[{"title":"B站美食区up主推荐","url":"/2020/10/02/fooder-collection/","content":"烘焙专长姗胖胖Joyce第一次知道姗胖还是通过她的空气巧克力一期视频。那个时候还在日本自己生活，从超市买了36%脂肪含量的淡奶油以及Vivani的99%的黑巧克力制作了巧克力甘纳许，然后打发它将它变成了空气巧克力。当时刚入嘴那种轻盈感与幸福感爆棚。\n姗胖个人感觉视频风格比较讨喜大众。视频风格方向上，语速适中，声音柔和，节奏恰好，风格俏皮。制作内容方向上，适合烘焙新手，步骤简单，配料常见。\n指路：姗胖胖Joyce\nFennel的铲子Fennel中式甜点和西式甜点都有涉及。我跟着Fennel做过牛奶鸡蛋醪糟、北非蛋、椰蓉麦芬、古早蛋糕。\nFennel早期发布的视频偏中式甜点，而且一些东西都挺有民族特色的，比如蒙古奶茶、美玲粥。后期发布的视频偏西式甜点，不过都是属于西点中较为简单的蛋糕。\nFennel给的配方个人感觉偏甜，如果要跟着配方一起做建议不怎么吃甜的适量减糖。\n指路：Fennel的铲子\nYannieFoodieYannie简直是我心目中的裱花之神。主打做整个蛋糕，侧重点不在如何做蛋糕体，而在如何优雅地玩弄奶油。跟着Yannie做过红茶香缇奶油蛋糕作为自己21岁的生日蛋糕，十分yummy。\n记得第一次知道复古蛋糕还是通过BennyCake的视频，据我长期混迹B站美食烘焙区的经验来看，Yannie是把复古蛋糕做的最好的一位了，没有之一。\n蛋糕都是偏复古的裱花，调色美丽。看着她抹面简直是一种享受。由于个人水平受限与锻炼不足，Yannie的视频对我来说主要是提升审美、放松心情的作用。\n指路：YannieFoodie\n我又把面包烤糊了关注的美食区up主里为数不多的男性烘焙爱好者了。视频特点就是狂放不羁。\n视频的拍摄和剪辑都比较不那么精致。一般up主都会提前把材料称重放入碗中准备好，拍摄时直接混合搅拌即可，这位哥不一样，直接铁碗放面粉，边称重边过筛，能少洗一个碗就少洗一个碗，搅拌的时候碗边留点面粉也不在意，十分像平常真实烘焙的我。\n还有值得一提的“又到了大家想吃吃不到的试吃环节”，一般就是糊糊拿着铁碗碗喝水配面包，最近又加入了玩偶嘉宾评测环节，当然是糊糊精分的表现。\n因为糊糊家里是开面包店的，经常也会直播做面包。日常做的都是大家在面包房里看得到的面包，配方也是经过自己实践改良的那种。\n指路：我又把面包烤糊了\nNoNo甜事手揉面包必推硬核up主。跟着NoNo做了不知道多少面包，眼看着NoNo涨粉，自己却还只能揉出六分膜。\n手揉御用面包粉为王后牌，御用酵母粉为燕子牌。NoNo的配方真的好，强烈建议跟着做。\n另外，看NoNo揉面特别解压，适合放松心情，我超喜欢咕叽咕叽的声音。当然和正统ASMR相比，底噪还是有点大的。\n指路：NoNo甜事\n硬菜复刻小高姐的魔法调料小高姐已经算是百万粉丝级别的大up主了，在我眼里她就是一个温柔的爱给孩子做饭的家庭主妇。\n既然说了名字有“魔法”，那是真的会有魔法在料理中。看着像魔法，其实是有科学原理的。我认为小高姐的特点在于不仅告诉你怎么做，而且告诉你为什么要这么做，这背后的原理是什么都会和你捋清楚。这是她与其他一般美食up主的区别。\n另外，小高姐还会做一些美食类科普视频。比如牛奶的种类及其衍生物，菜刀该如何选择，如何发面，烫面死面发面的区别等等。\n进入小高姐的视频，一起听取妈声一片。\n指路：小高姐的魔法调料\n绵羊料理大姨就不用多说了，直逼千万级元老级美食区up主，雅韵狂魔，硬菜屠戮者，绵羊A货工厂创始人。\n除了复刻硬菜，也有美食探店类，旅游探店类食品。专业！\n指路：绵羊料理\n淘米睡起床了继成功孵化出小鸡之后，淘米在研究孵化可达鸭。\n淘米的视频偏研究向，很干货很硬核。这位up主简直就是自底向上构建美食框架。怎么讲，活用电饭煲达人，废物利用顶级选手。看了学不会，看了绝不亏。\n指路：淘米睡起床了\n健康轻食享瘦厨房/好好吃瘦不得不吐槽这两个up主的名字真的很偏营销号风格。\n做的内容分量小，适合生酮人群。原材料主打杏仁粉、椰子面粉之类。没有跟着他们做过东西，但是可以为厨房烘焙提供一种新思路。\n指路：享瘦厨房/好好吃瘦\n芥末的小厨房一个主打健身食谱的up主，适合健身人群跟着一起做减脂餐。\n跟着芥末一起做过鹰嘴豆泥，了解到白生芝麻酱Tahini，真的好吃，但是热量是真的高，微微泛苦还很香。还做过全麦贝果，配方优秀，操作简单。\n指路：芥末的小厨房\n就是HannahHannah真的太宝藏了，温柔可爱，创意满满。\nHannah的作品颜值高而且还好做，基本原材料都是全麦面粉展开的，主打低糖低脂。\n在B站Hannah和粉丝互动也很多，会有不定期抽奖活动。\n指路：就是Hannah\n代阿悦啊创意早餐博主。有一阵子跟着阿悦做了好多营养健康的早餐，包括但不限于金枪鱼韩式拌饭、奶油蘑菇浓汤、南瓜派、西班牙蛋饼、各种蛋奶烤吐司。\n不过这些早餐内容都偏西式，一般都是用现成的切片面包或法棍面包为基础展开，配上一杯含水果的饮品。也有一些拌饭、意面、汤面之类。\n阿悦好像断更挺久了。是已婚上班族，好像老公经常出差，希望他们多在一起吧，祝福。\n指路：代阿悦啊\n猪侨魔芋与豆腐终极爱好者。魔芋代替面条，豆腐代替面粉。\n当年还是因为猪侨卷入了爱做饭的芋头SAMA抄袭风波，我才知道猪侨的。现在芋头已经凉透了，猪侨的粉丝量也逐渐上涨了。\n她的轻食堂系列真的十分简单易上手，料理残废的福音。马扎儿广播系列有点像朋友聊天，偏Podcast的内容，个人不太了解。\n指路：猪侨\n探店评测我叫大头雨不愁大头真的是我看着胖起来的。东北up主，口音可爱，段子层出不穷，粉丝聚合力极强。\n看大头的视频是真的能跟着笑出来的那种。头妃、隔壁王哥、妈见打、菜刀切牛排、腹肌除皱er等等，听一个笑一个，见一个笑一个。\n从大头那里知道了东北美食，比如麻辣拌、麻辣盆、锅包肉、溜肉段、叉烧肉、东北烧烤、各地特色薯片及饮品。\n指路：我叫大头雨不愁\n三联美食最近发现的新宝藏up主。偏各地特色美食测评向。\n梅姨笑起来真的太好看太治愈了，就像一个姐姐和你坐在一起边吃边聊的感觉，治愈你的心也治愈你的胃，看完梅姨的视频不会让你觉得饿，会让你对产出这个美食的地方有所了解有所向往。\n指路：三联美食\n燕子堡BBQ学徒Ray知名牛排西餐up主。\n从Ray这里学到了牛排熟成的各种方式，也看他开箱试吃试做各种品级的牛肉，反正就是馋人。吃肉多好！\n指路：燕子堡BBQ学徒Ray\n","categories":["食物猎人"],"tags":["Bilibili","烘焙","美食"]},{"title":"关于Hexo+NexT搭建个人博客的分享","url":"/2020/10/02/hexoandnext/","content":"踩坑与出坑Mac终端生成SSH key并添加到Github上参考这篇博客。\n比较实用的部分是如何检测SSH key是否有权限访问github这一部分，通过在终端输入ssh git@github.com。\n执行npm install出现的各种问题错误1：npm ERR! Unexpected end of JSON input while parsing near\n执行npm cache clean --force，再执行npm intsall。可能要多尝试几次。\n错误2：Missing write access to /usr/local/lib/node_modules\n执行sudo chown -R $USER /usr/local/lib/node_modules，具体解释在此处。\n错误3：Git Bash: remote error: You can’t push to git://github.com/\n需要使用HTTPS或SSH URL。\n区分._config.yml文件在hexo site root direcotory和theme directory under site root directory下分别有两个._config.yml文件，在阅读安装教程时请一定要看仔细每一步操作是针对哪一个配置文件进行的。\n学会熟练使用配置文件comment中给出的链接，阅读相关内容即可设置出想要的效果。在遇到问题时优先选择阅读最新官方文档！\nCNAME文件部署后消失直接在hexo/source目录下创建一个纯文件CNAME，里面存放的内容为从域名服务商处购买来的域名。\n对于创建纯文件CNAME，应当在终端目录hexo/source下执行命令行vi CNAME，进入vim文本编辑输入模式your-domain-name，退出保存即可。\n本地重新部署后浏览器没有显示网页变化由于学习使用的时候用的主要还是Chrome浏览器，他会自动缓存上一次的浏览记录，会让重新部署后的网页无法正确显示。在CNAME文件本地创建并上传多次后依然网页404，在设定favicon多次之后发现依然不出现小图标。\n可以尝试在Chrome浏览器中删除最近一小时的浏览记录，问题即可解决。也可以多尝试其他浏览器，比如Firefox、Safari。\n实用指南博客运作原理 彻底搞懂如何使用Hexo+GitHubPages搭建个人博客\n建议参考这篇文章前半部分，能够帮助理解Hexo和Github Pages之间的关系，Hexo在博客中扮演什么角色，Github Pages在博客中扮演什么角色。\n域名解析配置A Guide of Making Your Personal Blog - Part3\n这系列文章都为我部署我的个人博客提供了很大的帮助。这一篇为我理解域名解析提供了很大帮助，它不仅告诉你操作流程，还告诉你操作流程背后的原因。\n主要有三个部分：Namecheap购买域名，Cloudflare域名解析，Github响应解析。\nNamecheap购买完域名之后，我们需要告诉Namecheap我需要通过Cloudflare的服务器进行域名解析，而不是通过namecheap自带的服务器解析。所以，我们需要在购买的域名中选择Custom DNS，并将nameservers的值更改为Cloudflare的服务器的地址。\n为了获得Cloudflare的服务器地址，需要访问Cloudflare的网站。在这里为购买的域名添加记录，目的是将域名指向Github服务器的地址，添加记录的类型均为CNAME。\n我们在这个定位到的是Github服务器的地址，但是服务器却不知道该返回什么样的子资源。为了让属于我们的Github Pages被返回，我们需要将Github Pages的Settings中的Custom Domain设定为在Namecheap购买的域名。\n由此才可以建立起完整的域名解析。\nHexo官方文档这是Hexo官方文档\n此官方文档能够指导的内容有：Node.js的安装、Hexo的安装、Hexo生成文件中各个参数的作用、如何使用Hexo来产出博客内容。\nNexT官方文档这是NexT最新说明文档\n之前一直参考的是iissnan给出的说明文档，但是由于NexT更新，最新的指南应该根据最新的文档，否则会发现有hexo/themes/next/_config.yml配置文件内容的不同。\n另外，这个最新的文档似乎没有中文版。\n","categories":["个人博客搭建"],"tags":["踩坑记录"]},{"title":"命令行与npm包管理","url":"/2020/10/04/command-line/","content":"shell内置命令行CLI tools: command line interface tools\nChange directory: cd your-target-directory.\nListing directory contents: ls(short for list).\nCreate a new directory in current directory: mkdir your-new-directory.\n合并命令创建新的文件夹mkdir并进入该文件夹cd：组合起来就是take\nRemove the named directory: rmdir your-target-directory.\nCreate a new empty file inside the current directory: touch mdn-example.md.\nMove a file from the first specified location to the second specified location: mv first-specified-location second-specified-location. Technically moving a file, but practically renaming a file.\nCreate a copy of the file:  cp first-specified-location second-specified-location.\nRemove the specified file: rm your-target-file. Pernament delete and can not be undone via the recycle bin.\nRequest contents from URLs: curl you-target-URLs\nReturn all the lines that contain the word you want: grep the-word-you-want\n使用VS code打开当前所在文件夹中的所有内容code .\n使用工具Use tab key to auto complete，使用tab自动补全命令。\nLook at the manage page to find out what options each command has available: man your-target-command，使用man命令查询具体命令的使用手册。\nTo run a command with mutiple options at the same time, you can usually put them all in a single string after the dash character.用短横线连接命令的options。\nUse asterisks * as wild card characters meaning “any sequence of characters”, which allows you an operation concerning large number of files at once.使用star符号通配符查找满足条件的文件名。\nChian commands together using pipe symbol |. The pipe redirects the output of the former command to the input of the latter command.使用pipe输出重定向到吓一跳语句。\nCounts the number of words, characters, or bytes of whatever is inputted into it: wc the-thing-you-want-to-count\n开发工具链 Tool Chain包管理工具的npm解释npm: Node Package Management. Together with node.js. A package manager is a system taht will manage your project dependencies.\nPackage registries: a central place that a package is published to and thus can be installed from. e.g. The npm registry exists at npmjs.com.在国内一般使用淘宝源能够更快下载。\ndependency:  a third-party bit of software that was probably written by someone else and ideally solves a single problem for you.\nnpm命令集合Intialise a new project: npm init.\nGenerate it without having it ask any questions: npm init -y\ninstalling dependencies: npm install your-target-dependency.（这是局部安装，在当前文件夹下）另外还有其他选项如—save-dev/-D，—save-prod/-P。\nupdating dependencies: npm update. Version of dependencies are specified in package.json.\nAudit for vulnerabilities: npm audit.\nChecking on a dependency: npm ls your-target-dependency.\n（终端）查看已经全局安装的包：npm list -g --depth 0\n全局安装在npm install之后加上-g或者--global就能实现全局安装，默认是安装在Node所在安装目录下的node.js文件夹中。\n\n安装后的包，包名就是一个命令，例如创建vue/cli项目就可以使用vue create &lt;app-name&gt;来创建一个vue项目，例如通过npm -v就可以查看包的版本号。\n局部安装局部安装，以webpack为例，就是使用npm install webpack或者npm install webpack --save-dev来安装。\n在命令行的当前文件夹输入npm install sass会在当前路径的文件夹下面添加三个文件（当前目录中没有），分别是package.json、package-lock.json、node_modules，如下图所示。\n\n如果在以上操作之后再次执行一遍npm install babel，那么只会在当前的三个文件中添加依赖，而不会重新创建前面生成的三个文件。\n\n\n\n如果执行--save-dev option就是要求把安装信息写在当前路径下已经存在的package.json文件中的devDependencies field中，包安装在当前路径下的node_modules文件夹中。\n局部安装一般都是发生在一个具体的项目中，而这些包的的使用需要在文件全体根目录下的eslint.config.js文件（项目级配置）或者.eslintrc.js（文件级配置）。具体配置文件的区别参考StackOverflow的回答。\n局部安装更利于将各种依赖包以项目为单位集中管理、升级。\nnpm与npx的区别npm是管理node包的工具。npx是执行node包的工具。\n只有全局安装的包才能以包名去执行。\nnpx可以执行本地项目中的已经局部安装的命令，或者是执行没有安装的包的相关命令。例如npx create-react-app my-app会创建一个名为my-app的react脚手架，创建位置在当前文件夹所在位置。相当于替代了npm create-react-app以及create-react-app my-app这两个命令，且无需在全局安装react脚手架。\n项目开发工具Formattingprettier: an opinionated code formatter.\nFind the problems in the code format and fix it: prettier --wirte the-path-you-want-prettier-to-fix\nLintingLinting helps with code quality but also is a way to catch potential errors earlier during development.\neslint: a linting for JavaScript.\n","categories":["前端"],"tags":["命令行","npx","npm","全局安装","局部安装"]},{"title":"关于个人受益匪浅的生活好习惯","url":"/2020/10/04/myOctober-plan/","content":"规律作息早睡早起来形容作息还是过于狭隘，个人对于早的定义多少还是有不同的。此处的规律是个人摸索出来的一种可遵循的模式，例如对于我来说十二点前入睡，保证睡眠时间七小时，第二天就可以很精神地起床。\n晨起喝水不知道是不是最近成都降温了，早上醒来感觉鼻腔内干干的，这个时候一杯温水再好不过了。一般我会在前一天晚上在水杯里倒一半的开水间里的开水，第二天早上倒另一半，就可以获得温水啦。\n水给有准备的人喝的。要是等到想喝水了才去倒水，多少会因为开水烫嘴而放弃。夏天的时候我一般会直接从校园超市买成桶卖矿泉水，直接对嘴喝。等天气凉了，就常备凉水壶，常备凉开水，开源节流。\n一杯咖啡一杯醇香的咖啡真的可以开启美好的一天。加水或加奶都是我的最爱。\n当然也可以把咖啡放到运动前喝，真的会感觉提升运动表现，不会很容易就感到疲劳。有一次我下午五点左右喝了一杯黄金曼特宁，晚上做keep的K4级别燃脂运动，连着做了两套，以往都是一套下来就累了。\n按时早餐在九月底过了一周无早餐轻断食的生活。起因就是前一天晚餐吃得太多，第二天起来撑的慌，也没肚子去吃早餐了，就喝点水糊弄糊弄，到晚餐直接brunch。但是发现了一个问题，那就是我的晨间蹲坑时间开始不固定了。\n最近几天开始固定早餐之后，发现自己到晚上对于食物就没那么渴望了，第二天起来也能很正常地蹲坑，就十分安心的感觉。\n食物进入胃被消化到大肠直肠还是需要一定的时间的，据我粗浅的理解，大概就是吃得越早，食物被消化得越早，对于正常排泄就越有利。早餐没有吃的份总要在一天中的另外两餐中被补给，要是晚餐吃得多了，不仅容易发胖，还容易损害晚上夜跑的运动表现，更重要的是会让人睡的昏天黑地，第二天恶性循环。\n","categories":["好好生活"],"tags":["习惯"]},{"title":"JavaScript ES6 语法特征","url":"/2020/10/05/es6/","content":"变量类型一共三种变量类型：var let const。\n区别他们主要从\n\nscope: functional scope?block scope?\n\nhoisting or not?是否变量提升\n\ncan be redeclared? \n\ncan be reassigned?\n\n\n这四方面。\n箭头函数箭头函数(Arrow Functions)适用于需要使用匿名函数的地方。\n(multiple/singleParam) =&gt; &#123;statement&#125;(multiple/singleParam) =&gt; expression(multiple/singleParam) =&gt; &#123;return expression&#125;//当只有单一的return语句时可以直接输出expression，没有括号和return语句//括号既用在多个或单个参数传入//单个参数传入不适用括号singleParam =&gt; &#123;statement&#125;() =&gt; &#123;statement&#125;\n箭头函数的书写与花括号圆括号箭头左边才有可能出现()，这是参数的圆括号。\n依据箭头函数代码块语句是一句还是多句，可以分成以下两个情况：\n\n箭头的右边出现&#123;&#125;，这是函数体的花括号，代表函数体内部会有多条语句，且会出现return语句。\n\n箭头的右边没有花括号，代表函数体就一条语句，且这条语句自动会被作为箭头函数的return value。\n但如果返回的是一个对象，需要再对象的花括号外层嵌套一个小圆括号，例如() =&gt; (&#123;name: &#39;greg&#39;, id: 12345&#125;)。\n\n\n箭头函数与函数组件有的时候会使用匿名函数来创建函数组件，这种形式被称作arrow function component，并且把该匿名函数赋值给一个const变量，同时作为moudle被export出去。形式如下：\nexport const TryToLogin = () =&gt; &#123;    return (        // 返回的内容是大写的HTML标签构成的JSX对象        // 必须要有一个根节点包裹，不能同时多个并列标签直接返回    )&#125;\n一般函数组件的写法。当不给函数传递参数时，就代表该函数组件起一个组装UI或者路由的作用，比如下面这个顶层App组件。当为函数传递参数时，一般又是要进行数据传递的组件，会需要export。\nfunction App() &#123;  return (      &#x2F;&#x2F; HTML内置标签，定义react component后的标签      &#x2F;&#x2F; 全部大写      &#x2F;&#x2F; 路由标签  )&#125;\n\nclass组件与函数组件比较：\nclass Welcome extends React.Component &#123;  render() &#123;    return (        &#x2F;&#x2F; UI显示    );  &#125;&#125;\nrender()&#123; return( )&#125;这个模式在class组件中十分常见，代表的是UI渲染部分。\n\n在return语句内部本来应该返回的是类HTML语言，但是由于JSX语法的出现，只要我们把类JavaScript的语法放到花括号中，我们就可以在return语句内部写JavaScript。当然JavaScript语法的返回内容本质上还是类HTML语言。\nimport React from &#x27;react&#x27;;const App = () =&gt; &#123;  var users = [    &#123; name: &#x27;Robin&#x27; &#125;,    &#123; name: &#x27;Markus&#x27; &#125;,  ];  return (    &lt;ul&gt;      &#123;users.map(user =&gt; &lt;li&gt;&#123;user.name&#125;&lt;/li&gt;)&#125;      // 第一层花括号是因为return语句返回的应该是html语言，但是users.map显然是javascript语言，所以我们需要用上花括号。      // map语句内部表明用第一层花括号括起来的JavaScript语言返回的仍然是html语言/注意li标签。      // 但是li标签内部又用了一层花括号，因为user.name是javascript语言。    &lt;/ul&gt;  );export default App;\n单闭合标签调用与JSX语法引用无论组件时函数组件还是class组件，使用匿名函数定义的还是普通名称函数定义的，在调用组件的时候，都是将函数名称/组件名称/或者复制匿名函数到变量的名称（注意都需要大写）以HTML element的单闭合标签来使用。这个过程就好像是在调用函数，关注组件的return语句部分。\n&lt;TryToLogin &#x2F;&gt;&lt;Welcome &#x2F;&gt;&lt;App &#x2F;&gt;\n\n但是有的时候又很奇怪为什么不用花括号取包裹这些标签，比如说在把模块import到当前文件后，使用&#123;Welcome&#125;/&#123;App&#125;/&#123;TryToLogin&#125;这种语法，需要指出的是，这个花括号只是让我们在HTML中能用JavaScript，如果用花括号包裹着这些内容，那就好像是把函数声明放在了html文件中，不会有任何渲染。\n模版字面量模版字面量(Template Literals)通过在字符串中引入占位符$&#123;&#125;实现允许嵌入表达式的字符串字面量。\n功能包括但不限于：\n\n代码中直接换行就能实现字符串输出换行\n\n占位符中的表达式被直接计算输出\n\n\n展开语法展开语法(Spread Syntax)可以使可迭代对象在某一处被展开，例如\n\n在函数调用或数组构造时，将数组表达式在语法层面展开，当作函数参数或数组元素传入\n\nmyFunction(...iterableObj)：用于代替Function.prototype.apply(null, ...iterableObj)\n[...iterableObj, &#39;4&#39;, &#39;five&#39;, 6]：实现数组拷贝及连接\n\n在构造对象字面量时，将对象表达式按照key-value展开\n\nlet objClone = &#123;...obj&#125;：实现对象字面量的拷贝及连接\n剩余语法剩余语法(Rest Syntax)和展开语法进行的是相反的操作，展开语法将某一东西展开为许多元素，剩余语法将多个元素收集合并成一个东西。\n剩余语法允许我们将不被预期的、多余的（没有对应形参的实参）、不定量的参数收集成一个数组（是真正的Array实例）。\nfunction(a, b, ...theArgs)&#123; &#125;\n类 继承类语法本质是基于原型的继承的语法糖。关于一个类包括定义类和类体方法。\n定义类方法有两种：类声明和类表达式。\n\n类声明class class-name&#123;&#125;\n\n类表达式，可以分为具名类和匿名类\nlet var-name = class &#123;&#125;\nlet var-name = class class-name &#123;&#125;\n\n\n类体方法构造函数：constructor\n静态方法： static关键字，常用于为一个应用程序创建工具函数\n属性：\n\n实例属性定义在类的方法里\n静态的或原型的数据属性通过点访问形式定义在类的外面\n\nextends子类​    class sub-class-name extends super-class\nPromise对象通过创造Promise链来实现链式调用，将前一个函数的返回情况绑定在new Promise对象上，而后调用then()函数\n","categories":["JavaScript"],"tags":["ES6","Promise","Arrow Function","class","Rest Syntax","Spread Syntax"]},{"title":"React的条件渲染","url":"/2020/10/05/react-components/","content":"元素变量在组件的render()中引入一个元素变量。通过if-else条件语句判断表达式真假，将关于条件渲染的语句相关语速储存在这个条件变量中。\n在最后的return()语句中只需要输出这个元素变量即可。\n内联渲染适用于简单条件，对于过于复杂的条件应当选择提取组件。\n与运算符 &amp;&amp;&#123;条件判断语句 &amp;&amp; 条件渲染语句&#125;\n如果条件判断语句为true，则总返回右侧条件渲染语句；否则，直接忽略右侧语句总返回false。\n三目运算符condition ? true : false\n阻止组件渲染组件直接返回null，对于函数组件，直接if判断后return null；对于class组件，在render()中return null。\n","categories":["React"],"tags":["条件渲染"]},{"title":"React的元素、组件与事件处理","url":"/2020/10/05/react-learning/","content":"HTML DOM结点与React DOM一个HTML DOM结点对于React来说是“根”DOM结点，关于该节点的所有内容都由React DOM管理。\n在.js文件中利用React语法生成各种元素、组件，而后通过ReactDOM.render(待渲染的元素或组件, 利用普通DOM获得HTML中的节点)渲染到HTML中对应的根DOM节点中。\n利用React DOM的优点是它只将元素和它的子元素与它们之前的状态比较，只进行必要的更新来达到预期状态。\n元素React元素既可以是原HTML文件中的DOM标签及其组合，也可以是用户自定义的组件。\nconst element = DOM-tag-or-self-defined-component\n组件组件名称必须大写字母开头。\n一般组件函数组件：本质是编写JavaScript函数。function Toppercase(props)&#123;  return React-element;&#125;\nclass组件class Toppercase extends React.Component&#123;  render()&#123;    return React-element;  &#125;&#125;\n组合组件（更高一层级/更偏向用户层的）组件可以在其输出中引用其他（更低一层级/实现功能更单一的）组件。\n一般来说，每个新的React应用程序的顶层组件都是App组件。\n如何抽取组件元素的声明可以包含不止一个HTML结点（当然这是被允许的JSX写法），将元素抽取出来利用组件重新声明。\n在被抽取出来的部分需要利用props对象在组件内部访问组件本身的属性、子组件及其属性；在更高层次的组件内部使用较低层次的组件，使用大写的单闭合的标签来标明属性及其取值。\n这是属于外观的封装。\n组件内部属性访问props当React元素为用户自定义组件时，它会将JSX所接收的属性attributes以及子组件children转换为单个对象传递给组件，这个对象被称为props。\n要在更高层级更抽象的组件层次访问更低层次更具体的组件层次，需要使用点访问，props.children.child-attribute或props.attribute。\nprops具有只读性，组件不能修改自身的props。因为这是静态的，不可更改的，后面需要在组件中引入state来实现组件自我更新。\nstate1、只能在构造函数中对this.state=使用赋值语句。\n2、为了达成更改state且重新渲染组件的目的，需要使用setState()。\n3、this.state与this.props的更新可能是异步的，不要利用这两个值来更新下一个状态。应当将他们作为函数的参数传入，在函数体内更新。\n4、 当state包含多个属性时，单独更新其中某一个属性的值时，setState()会自动将更新的state合并到当前没有更改的state。\nstate与props的关系自上而下的单项数据流决定了：\n任何state只属于拥有并设置了它的组件，是局部的、封装的。\n某一组件可以将state作为props乡下传递给它的子组件。\n将函数组件转换成class组件为什么需要从函数组件转换到class组件每次组件更新时都有实例中的render()被调用。\n让ReactDOM渲染DOM节点的时候，只有一个此组件的实例被创建，关于这个实例可以使用state或生命周期方法。\n步骤1、同名class且继承与React.Component\n2、类体添加render()方法并将函数体放入其中\n3、函数体中的this.props替换props\n4、删除剩余的空函数声明\n在class组件中添加并使用state1、将需要做出变化的属性从props的点访问转移到state的点访问。\n2、添加class构造函数，为this.state赋初始值，且通过super(props)传递到父类的构造函数中。\n在class组件中添加并使用生命周期方法目的是在组件被销毁时释放资源。\n当组件第一次被渲染到DOM的时候，设置一个“挂载”(mount)。componentDidMount()&#123;&#125;。\n当组件被删除的时候，设置一个“卸载”(unmount)。componentWillUnmount()&#123;&#125;。\nclass组件关于state和生命周期的调用顺序组件被传递给ReactDOM.render()，对应到匹配的根节点DOM，进入组件。\nReact会调用该组件的构造函数，对象初始化。\nReact会调用该组件的render()方法，确定在html页面上要展示什么，更新根节点DOM来匹配组件输出。\n一旦组件的初始输出被插入到根节点DOM中后，React调用组件中挂载的生命周期方法。\n生命周期方法或其调用的其他方法会涉及setstate()方法，由此React知道了state已经改变，重新调用render()确定页面显示内容，从而渲染更新根节点DOM。\n一旦组件从DOM中被移除，React调用卸载的生命周期方法。\n列表组件与key在一个组件中渲染列表，通常可以对数组进行调用arr.map( arrow-function)。箭头函数执行将数组转化为列表元素(list item)的功能。\n当我们创建一个列表元素(list item)时，我们必须给每一个列表元素指定一个key属性，即&lt;li key=&#123;&#125;&gt; &#123;JS-expression&#125; &lt;/li&gt;。\nkeykey 帮助 React 识别哪些元素改变了，比如被添加或删除。\nkey是传递给React的，而不是传递给组件的，即不能用props.key来获取key属性的值。可以另外引入一个别名属性如id，其属性值与key属性值相同，可以被组件利用props.id读出。\n一般使用数据中的id(data.id)来作为元素的key，不到万不得已使用元素索引。\nkey不一定要全局唯一，但是在其兄弟节点之间独一无二。\n当把单个列表元素作为函数组件提取出来的时候，应该在哪里设置key？经验总是：在map()方法中的元素设置key。\n受控组件与表单为什么需要受控组件HTML表单元素的工作方式与其他DOM元素不一样。表单元素如&lt;input&gt;，&lt;textarea&gt;，&lt;select&gt;通常会维护一个属于自己的“state”，根据用户输入自动进行UI上的更新。\nReact中，组件的state属性控制着可变状态(mutable state)，并且只能通过setState()来更新。\n需要让这两个state建立依赖关系统一起来——让React组件的state称为唯一的数据源，并让组件能够控制用户输入过程中表单发生的操作。\n被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。\n受控组件的建立分为两个步骤\n1、 将React里的state属性和表单元素的值建立依赖关系。\n也就是让组件获得对表单元素输入框内容的控制权。输入框的内容取决于元素的value属性，将表单元素的value属性赋值为this.state.value-of-element。\n此时，表单元素内容是只读的，用户输入新的内容并不会让组件的state有所变化。此时运行会给出警告：\n\nWarning: Failed prop type: You provided a value prop to a form field without an onChange handler. This will render a read-only field. If the field should be mutable use defaultValue. Otherwise, set either onChange or readOnly.\n\n2、 通过onChange事件与setState()结合更新state属性\n用一个事件来监听输入内容的改变，在回调函数中利用this.setState更新表单元素的value属性。\n组件间的数据共享多个组件需要反应相同的数据变化时，需要把共享状态提升到共同父组件中去，让父组件中共享的state称为多个子组件的唯一的数据源。实现自上而下的数据流。\n一般在一个组件内部变化的数据通过state来访问或控制，多个组件在个字内部的state中相互独立地保存着各自的数据。\n操作步骤第一步，需要夺取子组件对共享数据的控制权，包括初始赋值与变化赋值。其思想与受控组件相同。\n将想要共享的数据从由子组件内部state访问变成由父组件props传入，即由this.state.shared-data变为this.props.shared-data。\n当我们需要子组件相应来自父组件的数据改变时，不再使用this.setState()，而是调用this.props.shared-data-change-function，获取父组件中具体的值，这个值就是一个事件处理函数。\n第二步，相应改变父组件。\n需要在父组件中构造函数中把this.state设置为想要共享的数据。\n在父组件中提供子组件相应数据更改的函数，并作为属性值传入子组件中。\n组合空元素空元素(empty element)是在HTML中不能存在子节点（例如内嵌的元素或者元素内的文本）的element。\n一般的HTML元素的名称是在尖括号中使用的小写名称。例如，&lt;p&gt;&lt;\\p&gt;带有一个斜杠开始的结束标记。\n在一个空元素上结束标记既不需要也不允许，使用闭合标签是无效的。&lt;input&gt;&lt;\\input&gt;是无效的写法，应该使用&lt;input \\&gt;。\n组件使用的约定在组件使用中我们需要注意两点：\n1、 必须大写字母开头。这是为了和一般的HTML元素的小写名称加以区别\n2、 在使用时没有闭合标签。这样的组件就与之前提到的空元素类似。\n第二个注意点不一定是完全成立。当我在组件中包含/嵌套子组件，可以通过带闭合标签的尖括号将子组件传递给组合组件。由此引入组合、props.children的概念。\n组合与props方式1:\n在组件定义中引入&#123;props.children&#125;。\n在组件使用时传入&lt;Component&gt;your-children-Component&lt;\\Component&gt;。\n方式2:\n在组件定义中引入&#123;props.self-defined-attribute&#125;。\n在组件使用时传入&lt;Component self-defiend-attribute=&#123;sub-Component&#125;\\&gt;。\n","categories":["React"],"tags":["React","组件","props","state","生命周期","受控组件","列表组件"]},{"title":"JavaScript中的回调函数","url":"/2020/10/06/callback-function/","content":"回调函数回调函数本质是一个在特定时刻特定事件下执行的函数，意思就是这个函数他和某个时间或事件相关联了，到达那个时间点或关注的事件被触发了，回调函数将被执行。\n回调函数的作用是实现异步操作。程序不需要一直等待某个事件的发生才去执行回调函数，而是等事件发生后再去执行。\n一个比较好理解的回答：\n回调函数（callback）是什么？ - 朱栩的回答 - 知乎\n回调函数与JavaScript事件处理机制参考资料JavaScript运行机制:事件驱动编程详解\n深入浅出JavaScript事件循环机制(下)\n深入浅出Javascript事件循环机制(上)\nPhilip Roberts: Help, I’m stuck in an event loop.\nevent loop &amp; callback queue主线程与工作线程提高CPU吞吐量的几种方式：多线程+同步I/O，单线程事件循环+异步I/O。\n由于“JavaScript是一门单线程的语言”，因而采用异步IO+事件循环。这里的单线程，是指JavaScript引擎（如chrome的v8引擎）中负责解释和执行js代码的线程只有一个，称它为主线程。\n但还存在其他由其他API提供的线程，如处理AJAX请求的线程，处理DOM事件的线程，读写文件的线程，这些被称作工作线程。\n同步任务、异步任务与事件循环在主线程上挨个排队等待执行的任务，被称作同步任务。这些同步任务构成了执行栈（execution context stack），执行栈中的任务必须等前面一个执行完了，才能执行后面一个。\n\n执行上下文栈（execution context stack）：当JavaScript代码执行的时候，会进入不同的执行上下文，这些执行上下文会构成了一个执行上下文栈（Execution context stack，ECS）。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。\n每一个执行上下文都可以抽象为一个拥有三个属性的对象。\nexecutionContextObj = &#123;    scopeChain: &#123; /* 变量对象（variableObject）+ 所有父执行上下文的变量对象*/ &#125;,     variableObject: &#123; /*函数 arguments/参数，内部变量和函数声明 */ &#125;,     this: &#123;&#125; &#125;\n每一次JavaScript解释器调用执行上下文，每次调用都会创建，激活两个阶段。\n创建阶段会依据传入参数、函数声明和变量声明设置执行上下文的上面三个属性，但不涉及具体的值，只把所有声明归纳。创建阶段依次处理顺序为：函数参数arguments，扫描上下文的函数声明，扫描上下文的变量声明并初始化为undefined。因此，就可以理解JavaScript提升了。\n可以看出函数提升优先于变量提升；函数提升是把整个函数的定义与声明提升到最前面，变量只单单提升声明；但是函数表达式的声明是遵循变量提升规则的。因此，也就可以理解函数提升、变量提升的关系了。\n激活阶段会在创建完成后随着代码内部一行行只派变量的值或者函数的引用。\n\n被交由工作线程处理的任务，就是异步任务。异步任务在工作线程上被运行/处理得出结果后，被放到消息队列callback queue中。不管现在主线程怎么样了，工作线程把异步任务运行出了结果，就会转交这个异步任务到消息队列。\ncallback的内容就是告诉主线程：我这边工作线程上的结果出来了哈，作为参数传到了callback function中了，你在执行栈上执行一下回调函数就知道该怎么做了哈。\n主线程上的所有同步任务都被执行完，也就是执行栈为空，执行栈才会去读消息队列，把消息队列中的回调函数放到执行栈中开始执行。主线程从消息队列中去读消息，这个过程是循环不断的。主线程把一个消息队列上的消息取出来放到执行栈上执行完毕，才去继续取下一个消息队列上的消息，取一个消息并执行的过程就叫做一次事件循环。\n对异步任务的再度划分macro0task/micro-task要等到执行栈上的同步任务清空，才去消息队列中取异步任务放到执行栈执行。但是有些异步任务要优先解决，等不及被取出后再次被放到消息队列中去，这种情况下该怎么办？细分一下异步任务，可以分为macro-task与micro-task。\n上面提到的同步任务称为task，多个同步任务组成一个task queue。异步任务即macro-task，多个异步任务组成macro-task queue，运行机制为take one item and one item only。而micro-task，是需要在本轮事件循环结束前、本轮事件循环所有task结束后执行的任务，多个micro-task组成micro-task queue，运行机制为运行直到清空队列（inluding any additional queued items），这种情况下event loop cannot continue until that queue has completely emptied and that is why it blocks rendering。\n用下面的例子解释micro-task queue的运作方式。\n(function test() &#123;    setTimeout(function() &#123;console.log(4)&#125;, 0);    new Promise(function executor(resolve) &#123;        console.log(1);        for( var i=0 ; i&lt;10000 ; i++ ) &#123;            i == 9999 &amp;&amp; resolve();        &#125;        console.log(2);    &#125;).then(function() &#123;        console.log(5);    &#125;);    console.log(3);&#125;)()// 1 2 3 5 4\n123的输出属于正常执行栈中同步任务task的执行流程。\n那为什么接下来是5？因为promise.then属于micro-task，他会在本次事件循环结束之前，也就是访问macro-task消息队列之前，被执行。而setTimeout就在macro-task消息队列中等着下一次事件循环被取用。\n常见的task/micro-task/macro-task分类\n每一个同步语句都是task，例如console.log()\nmacro-task一般都是异步任务，包括setTimeout、setInterval、setImmediate、I/O, UI rendering等\nmicro-task一般都是能够阻止下一次事件循环，从而阻止浏览器渲染的方法，包括process.nextTick、Promises.then、Object.observe等\n\n回调函数与thisReact官方文档事件处理一章节给出了一个例子，提到需要谨慎使用JSX回调中的this。\nthis.handleClick = this.handleClick.bind(this);\n一旦删除构造函数中的这句语句：\n\n一开始会正常显示初始页面(这是因为构造函数中初始化了属性)。\n\n一旦进行点击操作，也就是通过“点击”事件触发回调函数handleClick()，就会导致TypeError: Cannot read property ‘setState’ of undefined——也就是handleClick()中的this是未定义的。\n\n\n对于事件处理器/事件处理函数handleClick()：\n\n为什么需要添加语句？\n从它被定义的外围环境来看，该函数被作为一个类的方法在class组件中，而类的方法的this默认是取决于他们如何被调用的，是不会绑定指向这个类的实例的。通过改写这个行为，让类中this的值指向这个类实例，也就是开头提到的bind()语句。\n\n为什么删除语句会报错？\n从它是一个函数内部环境来看：在非严格模式下`this的值默认指向全局对象，在浏览器中就是window；在严格模式下，进入执行环境却没有设置this的值，this会保持undefined。\n\n\n参考：MDN Web Docs关于this的说明\n","categories":["JavaScript"],"tags":["回调函数","事件循环","macro-task","micro-task","this","执行上下文栈"]},{"title":"JSX语法","url":"/2020/10/06/jsx-syntax/","content":"JSX是一种允许在JavaScript中编写类XML语言的语法，它需要通过babel编译器转换成标准的JS语言。\n使用JSX语法的必要准备\n凡是使用JSX的.js文件都需要声明&lt;script type=&quot;text/babel&quot;&gt;。\n\n三个库\n\n\n&lt;script src=&quot;vendor-js/react.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;vendor-js/react-dom.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;vendor-js/babel-core/browser.min.js&quot;&gt;&lt;/script&gt;\nJSX的几个表现形式HTML与JavaScript混写HTML语言直接不带引号地写在JS语言中。如&lt;h1&gt;Hello world&lt;\\h1&gt;。\nReact组件可被使用（约定都是大写）可以在被定义之后像普通的HTML标签一样&lt;React-component /&gt;被使用。\n\nReact的JSX约定：开头大写代表自定义本地组件，小写开头代表HTML标签。\n\nJavaScript表达式注意这里的JavaScript表达式可以是：\n\n包括常量、关键字、变量的原始表达式\n\n对象和数组的初始化表达式\n\n函数定义表达式\n\n基于运算符的算术表达式\n\n\n作为结点属性值在大花括号内放置任何有效的JavaScript表达式并进行为节点属性进行赋值操作，这里的结点既可以是HTML自带的标签，也可以是自定义的元素或组件。\nattribute = &#123;JavaScript-expression&#125;。\n作为子节点表达式在大花括号内放置任何有效的子节点表达式，两边用父节点包括起来。\nreturn(            &lt;div&gt;                &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;                &#123;button&#125;//这里的button就是子节点表达式            &lt;/div&gt;        )\n","categories":["JavaScript"],"tags":["JSX"]},{"title":"React设计理念","url":"/2020/10/08/react-way-of-thinking/","content":"将设计好的UI划分为组件层级依据单一功能原则判断组件范围。\nUI与数据模型数据同构，一一对应。\n用React创建静态版本将渲染UI与添加交互这两个过程分开。静态版本就是一个不包含交互功能的UI，需要编写较多代码而无需考虑组件间的交互细节。\n建议：\n\n自下而上地构建应用，从最基本的组件开始编写。\n\n只需要用到porps而不应该使用state。\n\n只需要提供render()方法用于渲染。\n\n\n确定UI state的最小且完整表示设计理念： DRY(Don’t Repeat Yourself)\n考虑每个组件中的所有数据，逐个检查数据是否属于state：\n\n\n该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。\n该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。\n你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。\n\n\n确定state的放置位置对于应用中的每一个state：\n\n\n找到根据这个 state 进行渲染的所有组件。\n找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。\n该共同所有者组件或者比它层级更高的组件应该拥有该 state。\n如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。\n\n\n至此，完成了从上而下的数据流，此时state的值有顶层组件控制，用户对底层组件的操作无法改变其值。\n添加反向数据流因为用户的操作是对于底层的组件进行的，我们需要让数据反向传递：处于较低层级的表单组件更新较高层级组件的state。\n这里涉及到onChange事件、回调函数、setState()。\n","categories":["React"],"tags":["设计模式"]},{"title":"十月观影总结","url":"/2020/10/09/my-Oct-films/","content":"姜子牙和哪吒之魔童降世应该是同一世界观的影片。男友告诉我导演是在暴雪和梦工厂呆过的，此片预算充足，国外工业漫画的味道略重。\n个人观影比较注重画面与效果，姜子牙在这方面呈现得很不错。\n故事铺垫过长，背景交代在整部影片中占据了较大的部分，导致后面高潮呈现较为局促。虽然能看出是要把狐族的线和姜子牙的线交织在一起，但是紧密程度不高。\n大护法男友听说我对姜子牙观感甚好，就强烈建议我去看大护法和妙先生。\n构思巧妙，隐喻到位，不愧是走的国产成人动漫的风格。我实在是太喜欢花生人的隐喻了，后面婆婆带着小姜参观工厂的画面把我震惊到了。不过后面为了圆大护法和太子的线，花生人的内部革命以及统治猪猡的那群人的部分感觉收尾潦草。应该会有第二部，期待构建整个世界观。\n台词一般，配音一般。不知道编剧怎么想的，能把台词写的这么故作高深。也不知道是过于一般的台词导致了过于一般的配音，还是二者并无关系，这个配音真的有点蹩脚，国产漫画的配音还有很多路要走啊。\n太子的人物角色担当了整部剧的笑点，就是画风实在是……一言难尽。\n妙先生如果说大护法是给了你隐喻，妙先生可以说就是把东西都掰开了揉碎了告诉你了，矛盾与纠纷的点都融合在人物的台词里了，经典的电车问题。可能就是太直白了，反而没什么意思，包装一下藏一下可能还让观众觉得有猜头。\n画面精美度比大护法高多了，不过大护法的预算摆在那里呢，也不好比。\n故事完成度较高，前因后果解释得很清楚，每一条线也都串了起来。\n燃烧女子的肖像久闻大名的姬片，百闻不如一见，果真名副其实。\n服化道精美。篝火与阿卡贝拉、着火的裙子、被流产的女佣和她耳边的孩子、砧板壁炉与蔬菜、烤火的油画、赤裸女子的身躯、白色床单上唾液交缠的湿吻、深色岩石下迟到的初吻、读书少女红红的眼角、女画家的回眸、两个女孩坐在钢琴前的曲子。\n台词氛围渲染极致。每一句台词都有深意，特别喜欢两位女主势均力敌说出对方的小习惯的那一段，莫名有种打情骂俏的感觉，哈哈。\n最后两个演员真漂亮啊。小姐一开始真的满脸颓态，到最后和女画家相爱后那种富足的神态，真是太让人喜欢了，实打实的爱情啊。\n楚门的世界太残酷了。\n当我们在玻璃罩子外面看里面的楚门，觉得他可怜。可是当玻璃罩子里面的楚门挣脱出来，一直呆在外面的我们，依然觉得他可怜。精神高潮只在他毅然决然走出那个出口的时刻。\n福尔摩斯小姐：失踪的侯爵在私人影院看的，网飞无脑剧系列。看之前搜了一下豆瓣，发现评分一般，所以也没有报很大的期望去看。\n值得的看点有：贵族少爷的三次剪发，怎么说，越变越好看，有种一步步颜值提升的感觉。女主的卷发和裙裙，不过不得不吐槽一下姑娘跑大城市去身怀巨资竟然只想被害命没被谋财。福尔摩斯庄园的家庭陈列，那些装饰品被打碎的时刻我竟然不是觉得怜惜而是觉得痛快。\n侦探、推理元素涉及的太少了，看得出来导演想掺合一些女权、政治、家庭伦理在里面，但是掺合得稀烂。\nEmily In Paris快餐剧。幸亏女主颜值在线能看看，但是造型师简直是把演员的脸和身材用造型糟蹋了明明白白地给你看。\n本质上是披着职场生活外衣的玛丽苏后宫言情剧。\n","categories":["好好生活"],"tags":["观影","审美"]},{"title":"九月观影总结","url":"/2020/10/09/my-Sep-films/","content":"信条去影院看了两遍，不愧是诺兰，烧脑啊。但是依然还是有很多点不太懂，比如到底是平行世界还是因果世界。\n饥饿站台B站有一阵子每个影视区UP主都搞这个影视解说。感觉就是图一个猎奇血腥。\n八佰电影亮度本来就低，导致我这个脸盲直接全程认错了演员匹配错了人。\n","categories":["好好生活"],"tags":["观影","审美"]},{"title":"MAMP本地服务器","url":"/2020/10/10/local-server-environment/","content":"MAMP = Macintosh + Apache + MySQl + PHP\n教程分享还是Tania Rascia的教程\n安装MAMP并配置本地服务器\n多个虚拟主机的实现\n踩坑与出坑不经过代理连接的主机设置系统代理是ClashX，出站规则是规则判断。不影响访问。\n但是问题在于浏览器扩展中的SwitchyOmega，虽然模式是auto switch，但是一定要从选项中把不经过代理的主机列表添加进去，并且应用选项。\n浏览器问题（未出坑）Chrome浏览器是默认浏览器，在设置完不代理的主机之后能够成功访问虚拟主机。但是在Firefox中无法访问，显示链接被重置。\nAllow SymLink Override设定方式教程中给出的是在路径为/Applications/MAMP/conf/apache/httpd.conf的http.conf文件中修改None为All。\n&lt;Directory &#x2F;&gt;    Options Indexes FollowSymLinks    AllowOverride None&lt;&#x2F;Directory&gt;\n后来自己没有修改这部分，而是直接在添加的虚拟主机配置中设定，删除示例的两个虚拟主机，并在文件尾部添加如下内容：\n&lt;VirtualHost *:80&gt;    DocumentRoot &quot;&#x2F;Applications&#x2F;MAMP&#x2F;htdocs&quot;    ServerName myphpdev.test    ServerAlias myphpdev.test    &lt;Directory &quot;&#x2F;Applications&#x2F;MAMP&#x2F;htdocs&quot;&gt;        Options Indexes FollowSymLinks           AllowOverride All        Order deny,allow        Allow from all    &lt;&#x2F;Directory&gt;&lt;&#x2F;VirtualHost&gt;\n虚拟主机名的设定谷歌浏览器不再支持.dev结尾的域名，自定义的虚拟主机名不要完全按照教程中来。\n端口更改端口更改需要在两个地方确认，一个是配置文件，一个是MAMP图形界面中的偏好设置。\n配置文件/Applications/MAMP/conf/apache/httpd.conf的http.conf文件中修改两处\nListen 80以及ServerName localhost:8888，这两个语句不在同一处。\nMAMP的偏好设置在MAMP的图形界面中打开Preferences &gt; Ports并修改端口分别为：\nApache Port: 80Ngix Port: 8888MySQL Port: 3306\n","categories":["前端"],"tags":["踩坑记录","前端","虚拟主机","本地服务器","MAMP"]},{"title":"PHP入门","url":"/2020/10/10/my-php-tutorial/","content":"PHP介绍PHP = Hypertext Preprocessor，超文本预处理器。\nPHP脚本是在服务器上运行的。\nPHP &amp; JSON使用PHP语言来编码和解码JSON对象\njson_encode用于对PHP语言中的变量进行JSON编码，执行成功返回JSON数据，否则返回false。\njson_decode用于对JSON格式的字符串进行解码，并转换为PHP变量。\njson_last_error","categories":["PHP"],"tags":["PHP","JSON"]},{"title":"前端技术栈的区别与联系","url":"/2020/10/10/what-we-have-to-learn-in-frontend/","content":"逐个解释HTML是最基本的浏览器能够阅读的语言，是网页标记语言，是静态的。\nCSS是层叠样式表，用于规定HTML元素的形态，被嵌套在网页中。\nJavaScript是利用HTML标记代号内嵌于HTML中的JavaScript代码段。让静态的HTML网页有互动能力。\nHTML/CSS/JavaScript都是基于浏览器端的解释运行，可以完全独立于服务器。以上三者创造出的是静态页面。\n如果要让网页对外部数据请求产生大规模相应，就需要用到动态页面(Dynamic Webpage)，为此引入动态编程语言之一PHP。\nPHP不能被浏览器(也就是不能在客户端执行)执行，但是可以被安装了PHP解释插件的Web服务器(比如Apache)运行。在服务器端运行PHP程序，但发送到客户端只有HTML，服务器有选择地向客户端呈现内容。\n还需要搭配数据库完成动态网页的构建，也就要用到数据库系统MySQL。对于客户端发送过来的请求，PHP服务器向MySQL服务器请求查询并获得MySQL的返回结果，以动态的方式生成静态资源(HTML/CSS/JavaScript)发送到客户端，完成页面的呈现。\n关系总结许多静态资源(包括HTML、CSS、JavaScript、Images、datas)被存放在Web服务器(如Apache)上。\n动态编程语言(如PHP)依据客户端请求的具体资源，选择组合这些静态资源并将它们以动态文件(如PHP文件)的形式再投放到Web服务器上。\nWeb服务器上搭载的动态编程语言解释器将动态网页解释成静态资源，并返回给客户端，客户端收到的资源依然是静态资源。\n参考资料HTML、CSS、JavaScript、PHP、 MySQL 的学习顺序是什么？ - 知乎用户的回答 - 知乎 \n怎样通俗的讲解 PHP 和 Apache 的关系？ - 知乎用户的回答 - 知乎\n","categories":["前端"],"tags":["前端","PHP","Apache"]},{"title":"JSON入门","url":"/2020/10/10/working-with-json/","content":"JSON介绍JavaScript Object Notation(JSON/.json): JavaScript对象表示法用于将结构化数据表示为JavaScript对象的标准格式，常用于网站上表示和传输数据。\nJSON对象基于JavaScript对象。将JS对象写入JSON数据从而构造一个对象树。将JSON文件保存为一个对象，加载它进入JS程序，通过.或[]访问JSON对象内的数据。\nJSON应用场景用于浏览器(browser)和服务器(server)之间数据的传输。\n注意：\nJSON是一种纯数据格式，只包含属性，没有方法。\nJSON要求在字符串和属性名周围使用双引号。\nJSON形式官方文档\n对象对象是一个无序的“名称/值”对的集合。他也可以被理解为struct/dictionary/hash table/associative array。\n因此访问对象可以利用-&gt;访问法以及[]访问法。\n对象总以左花括号开始，右花括号结束，“名称/值”对之间用逗号分隔。\n// object&#123;  key1: value1,  key2: value2&#125;\n数组数组是值的有序集合。\n数组总以左中括号开始，右中括号结束。值之间使用逗号分隔。\n// array[  value1,  value2,  value3]\n值值可以是双引号括起来的字符串、数值、布尔值、null、对象、或者数组。\n字符串字符串是由双引号包围的任意数量的Unicode字符的集合，使用反斜线转义。\n使用JSON设置XHR加载JSON格式数据\n将保存一个待访问的URL作为变量保存在var requestURL中。\n\n创建一个HTTP请求对象，利用new构造函数。\nvar request = new XMLHTTPRequest()\n\n使用HTTP请求对象的open()函数打开新的请求\nrequest.open(&quot;GET&quot;, requestURL)\n\n设定HHTTP请求对象的参数并发送请求\nrequest.responseType = &#x27;json&#x27;;request.send()\n\n相应来自服务器的返回数据，并自定义处理\nrequest.onload = function() &#123;\tvar data = request.response;\t// function-with-data-as-params&#125;\n\n\nJSON传输中数据和字符串的转换\n接收一些字符串作为JSON数据，需要将它转换为对象。\nrequest.open(&quot;GET&quot;, requestURL);request.responseType = &#x27;text&#x27;;request.send()request.onload = function()&#123;\tvar textObj = request.response;\tvar jsonObj = JSON.parse(textObj);&#125;\n\n\n\n发送JSON数据作为信息，需要将它转换为字符串。\nvar myJson = &#123;&#125;;var myString = JSON.stringify(myJSON);\n\n\n","categories":["JavaScript"],"tags":["前端","JSON"]},{"title":"初始化后的create-my-react的文件解释","url":"/2020/10/11/create-my-react-explanation/","content":"文件树如下：\nmy-react-tutorial├── README.md├── node_modules├── package.json├── package-lock.json├── .gitignore├── public│   ├── favicon.ico│   ├── index.html│   └── manifest.json└── src    ├── App.css    ├── App.js    ├── App.test.js    ├── index.css    ├── index.js    ├── logo.svg    └── serviceWorker.js\n极为重要的两个文件\nPage templatepublic/index.html\n\nJavaScript entry pointsrc/index.js\n\n\n以上两个文件必须以此命名并存放在该路径，其余文件可以自由命名。\nREADME.md从命令行角度来说明如何整体操作项目，包括启动项目、初始化项目、构建项目、部署项目。\npackage.json这是所有的npm包在项目根目录都有的一个文件。\n该文件包含了Node.js/npm为了建立起具体项目的元数据(metadata)，包括依赖包(dependencies)、项目版本(version of the project)、许可证信息(license information)、配置信息(configuration data)。\nnode_modules如果有人使用了npm下载了你的项目，所有列出在package.json中的依赖包都会被下载并放到./node_modules目录下。\n如果自己在本地项目的根目录下运行命令行npm install，那么下载的依赖包就会被放到./node_modules目录下。\n因此，我们通过在命令行中运行npm create-react-app my-react-tutorial，就是下载了React官方发布的项目，且列出在package.json中的所有依赖包都被我们下载并放到了./node_modules目录下。\npublic只有在public目录中的文件才可以被public/index.html使用。一般来说除了修改title元素的内容来更改应用程序的名字，其他index.html中的内容都不应当被编辑，除非你清楚自己在进行什么样的操作。\npublic目录只有在build和deploy的时候会被更新。\nsrc该目录存放该项目的JS以及CSS文件，只有src目录下的文件才会被Webpack静态模块打包器处理。可以在src目录中新建子目录。\nReact将src目录中的代码嵌入到HTML文件的DOM树中，从而让浏览器能够解析出index.html文件。\n关于index.js的解读顶部import语句import React from &#39;react&#39;;import logo from &#39;.&#x2F;logo.svg&#39;;import &#39;.&#x2F;App.css&#39;;\n第一句导入React库，这一步的目的是允许React库将JS文件中的JSX语句转换成React.createElement()。所有与React相关的部分都需要包括这个React库。\n这里值得注意的是，我们没有给import React指定路径，是因为React是作为一个依赖库存在于package.json中的。\n第二句导入一个当前文件夹下的普通文件，需要指明路径。\n第三句是导入CSS文件，这里直接就是就是路径，没有变量名也没有from导入。\n中间class/函数组件组件名称遵循pascal-case variable，一定要大写。\n对于JSX写法的元素(element)设定属性(attribute)，和HTML中写法大致一致。区别在于HTML中元素的class attribute到JSX中变成了className attribute，这是因为class作为关键字被使用了。\n底部export语句一个.js文件底部的export default this-js-name.js使该文件能够在其他的.js文件的顶部利用import导入并使用。\n参阅create-my-react document: folder structure\nMDN web docs: React getting started\nWhat is the file package json\n前端基础配置详解\nwebpack配置解释\n","categories":["React"],"tags":["React","create-react-app"]},{"title":"JavaScript调用API","url":"/2020/10/11/js-with-api/","content":"API定义\nAPI stands for Application Program Interface, which can be defined as a set of methods of communication between various software components. In other words, an API allows software to communicate with another software.\n\nMDN web docs的Web API简介\nAPI抽象了该应用中复杂的代码，提供一些简单的接口规则供使用其他应用使用。相当于应用之间互相借用功能的一个渠道。\n访问第三方API的方式首先，需要明确访问第三方API的主体是谁。\n我们把网页的资源（包括静态资源和动态资源）放在网页服务器(Web Server)上。当客户端浏览器对服务器进行请求的时候，网页服务器依据这些资源作出回应。返回这些资源之前需要访问第三方API，因此是网页服务器在访问第三方API。\nHTTP Requests\nUse HTTP requests to communicate to a publicly available URL endpoint containing JSON data. \n\n常用HTTP方法\n\n\n\n动作\n方法\n操作\n\n\n\n\nCreate\nPOST\n创建新的资源\n\n\nRead\nGET\n获取资源\n\n\nUpdate\nPUT/PATCH\n更新已有资源\n\n\nCreate\nDELETE\n删除资源\n\n\n\n\n操作步骤var request = new XMLHttpRequest();request.open(&#x27;GET&#x27;, &#x27;https://ghibliapi.herokuapp.com/films&#x27;, true);request.onload = function() &#123;  var data = JSON.parse(this.response)  if(request.status &gt;= 200 &amp;&amp; request.status &lt; 400)&#123;  // 对数据的操作  &#125; else &#123;  // 链接不存在的情况  &#125;&#125;request.send();  \n一些技巧\n在获取到JSON数据后，先不着急把数据放入到已存在的或者已创建的DOM元素中，先使用console.log()在控制台输出数据，并用浏览器的检查元素Inspect查看一下。\n需要考虑链接失效的情况，对于每一个HMLHttpRequest对象，都会在请求结束资源后返回一个状态码status，用它来判断是否成功获取了资源。\n一般需要查询第三方API的官方说明文档，里面会有获取资源的说明，以及会返回什么样的状态码。\n\nFetch APIFetch API用于取代XHR，是HTML 5的内置API。\n\n fetch() 必须接受一个参数——资源的路径。无论请求成功与否，它都返回一个 Promise 对象，resolve 对应请求的 Response。你也可以传一个可选的第二个参数 init（参见 Request）。\n一旦 Response 被返回，就可以使用一些方法来定义内容的形式，以及应当如何处理内容（参见 Body）。\n\n// replace url with your JSON feedfetch(&#x27;url&#x27;)\t.then((response) =&gt; &#123;\t\treturn response.json();&#125;)\t.then((data) =&gt; &#123;  \t// work with JSON data here  \tconsole.log(data);&#125;)\t.catch((error) =&gt;&#123;  \t// do something for an error here&#125;)\n简单DemoHow to Connect to an API with JavaScript\n","categories":["JavaScript"],"tags":["API","JavaScript","Fetch","HTTPRequest","endpoint"]},{"title":"用于React学习的demo","url":"/2020/10/11/react-demo-lists/","content":"React安装MDN web docs对执行create-react-app初始化项目的操作步骤，完成初始化之后的文件树结构进行了十分详细的介绍，有助于理解文件之间的关系。\nMDN web docs关于create-react-app的解释\nReact学习React官方学习指南，主要阅读并实现核心概念的部分即可。\n逐步学习指南\nReact实践Tania Rascia的React教程主要涉及对src目录中JS代码的编写。\nReact Tutorial: An Overview and Walkthrough\n网页端简书项目原项目时间较久，三年前了，但是胜在解读清晰。\n地址：huyaocode react-app\n\n后来找到了其他人的复刻项目，有踩雷与语法更新，值得参考学习。\n地址：JuFengGuo react。\n腾讯云有他的博客： xing.org1^ Blog\n","categories":["React"],"tags":["React","JavaScript","demo"]},{"title":"Endpoint解释","url":"/2020/10/11/what-is-endpoint/","content":"What is an API Endpoint?\nSimply put, an endpoint is one end of a communication channel. When an API interacts with another system, the touchpoints of this communication are considered endpoints. For APIs, an endpoint can include a URL of a server or service. Each endpoint is the location from which APIs can access the resources they need to carry out their function.\nAPIs work using ‘requests’ and ‘responses.’ When an API requests information from a web application or web server, it will receive a response. The place that APIs send requests and where the resource lives, is called an endpoint.\n\nReferences: API Endpoints\n","categories":["前端"],"tags":["API","JavaScript","endpoint"]},{"title":"Github使用操作以及问题","url":"/2020/10/20/github-up-down/","content":"项目建立与关联登陆个人github创建新的远程仓库创建结束代码库之后会跳出指示操作界面，分两种情况：\n\nor create a new repositoory on the command line\n\ngit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin SSH-KEYgit push -u origin BRANCH-NAME\n\nor push an existing repository from the command line\n\ngit remote add origin SSH-KEYgit push -u origin BRANCH-NAME\n二者区别主要在于我们的本地电脑上是否有初始化git仓库，即含有代码的文件夹有没有在命令行中被git化。\ngit化之后的文件夹当中应当有一个隐藏的.git文件，在mac下直接cmd+shift+.可以显示。\nSSH-KEY和BRANCH-NAME就是下图所示的内容。\n\n第一次上传代码第一步：在终端下分别进入目标文件夹并初始化gitcd target-dirgit init\n第二步：关联本地库与远程库从本地工作区(working directory)到暂缓区/提交区(staging srea)；从暂缓区/提交区到git目录/版本库(git directory)。\ngit add -Agit commit -m &quot;description-for-this-commit&quot;\n关联远程github库并设置分支\ngit remote add origin SSH-KEYgit branch -M main\n第三步：上传到githubgit push -u origin main\n第二次更新代码首先查看仓库状态\ngit status\n之后的操作和关联本地库与远程库相同。\n添加项目更新总结先在Github上创建一个repository，并复制SSH。\n在本地终端进入目的文件夹，并用命令git init初始化，git add .或者git add -A把所有该文件夹下的文件放到本地暂缓区，在利用命令git commit -m &quot;&quot;把本地暂缓区的内容放到本地版本库。\n利用命令git remote set-URL origin SSH先把本地url设置为ssh的地址，并转到具体分支git branch -M BRANCH_NAME。\n利用命令git push -u origin BRACH_NAME把文件提交到BRACH_NAME的分支中，默认repository创建只有一个main brach。\n查看历史版本跟随做项目的时候为了看懂别人的代码，需要用到查看历史Commits。一般git clone出来的总是最新更新的版本，通过版本退回可以看到别人实现项目的思路演变。\n操作参考\n\n正常git clone项目到目的文件夹\n点击Commits进入历史版本，获取你想要查看的那个版本的SHA\n在目的文件夹下使用git checkout SHA\n\n可能遇到的问题集合Repository not found可能遇到的问题如下：\nremote: Repository not found.fatal: repository &#x27;https://github.com/MyRepo/project.git/&#x27; not found\n\n解决办法1: \n尝试从钥匙串中删除所有与GitHub有关的内容\n\n解决办法2: \n检查是否正确地设置了远程仓库地址\n\n\ngit remote -v\n如果发现不对就重新设置\ngit remote set-url origin https://username@github.com/MyRepo/project.git\n无法打开github文件夹很有可能是因为子文件夹下面已经有了一个隐藏的.git文件夹，导致无法解析，github把这个文件夹默认为untracked content。只需要删除.git文件夹即可。\n对于一个repository中的所有文件夹，必须只能 only one root.git folder，否则无法解析。\n参考StackOverflow的回答为什么无法打开github文件夹。\n","categories":["必备技能"],"tags":["踩坑记录","Github"]},{"title":"PyTorch+Anaconda+JupyterNotebook环境搭建","url":"/2020/10/22/ml-env-setup/","content":"常见conda指令\nconda -V\nconda list\nconda install PACKAGE_NAME=MAJOR.MINOR.PATCH\nconda create --name ENVIRONMENT\nconda activate ENVIRONMENT\nconda deactivate \nconda info --env\n\n正确配置步骤应当在命令行base环境中新建环境pytorch；进入该环境后；再执行conda install安装JupyterNotebook；再执行conda install pytorch torchvision -c pytorch安装pytorch的包。\n新的环境中是不会有JupyterNotebook的，所以打开在该环境下执行jupyter notebook是报错的。\n新的环境中也不会有pytorch的包，所以就算打开了JupyterNotebook执行python语句，涉及到pytorch的语法，也会报错。\n","categories":["DeepLearning"],"tags":["ML","DL"]},{"title":"Pytorch入门","url":"/2020/10/22/start-with-pytorch/","content":"深度学习机器学习研究如何使计算机系统利用经验改善性能。它是人工智能领域的分支，也是实现人工智能的一种手段，人工智能是最终目的。\n在机器学习的众多研究方向中，表征学习关注如何自动找出表示数据的合适方式，以便更好地将输入变换为正确的输出。\n深度学习是具有多级表示的表征学习方法。在每一级（从原始数据开始），深度学习通过简单的函数将该级的表示变换为更高级的表示。因此，深度学习模型也可以看作是由许多简单函数复合而成的函数。当这些复合的函数足够多时，深度学习模型就可以表达非常复杂的变换。\n深度学习可以逐级表示越来越抽象的概念或模式。\n深度学习的一个外在特点是端到端的训练。也就是说，并不是将单独调试的部分拼凑起来组成一个系统，而是将整个系统组建好之后一起训练。\n除端到端的训练以外，我们也正在经历从含参数统计模型转向完全无参数的模型。\n任务可以分为三种：回归Regression(线性模型)，分类classification(非线性模型，包括深度学习、SVM等)，结构化学习structured learning。\n实现的手段可以有：监督学习、半监督学习、无监督学习、强化学习。相同点是统一都有输入，区别在于是否有输入的匹配输出。从前往后输入输出正确匹配对以此减少。\nTensor与Numpy导入包from __future__ import print_functionimport torch\nPyTorch操作inplace版本都有后缀_, 例如x.copy_(y), x.t_()\n判断操作是否开辟新内存，使用Python自带的id函数：如果两个实例的ID一致，那么它们所对应的内存地址相同；反之则不同。\n基本操作torch.tensor()与np.array()用法类似，创建方法类似，二者可以转换，可接受基本运算法。\n四种形式的加法(+, add(), add_(), +=)\n\n\n\n\n操作\nTorch\nNumpy\n备注\n\n\n\n\n创建\ntorch.tensor([0.1, 0.2, 0.3])\nnp.array([0.1, 0.2, 0.3])\n\n\n\n转换\ntorch.from_numpy(x_numpy)\nx_torch.numpy()\n这两个函数所产生的Tensor和NumPy中的数组共享相同的内存（所以他们之间的转换很快）。\n\n\n四则运算\nx_torch + y_torch\nx_numpy + y_numpy\n\n\n\n范数\ntorch.norm(x_torch)\nnp.linalg.norm(x_numpy)\n\n\n\n正则化\ntorch.mean(x_torch, dim=0)\nnp.mean(x_numpy, axis=0)\n\n\n\n索引\n\n\n我们还可以使用类似NumPy的索引操作(:)来访问Tensor的一部分，不会开辟内存。需要注意的是：索引出来的结果与原数据共享内存。\n\n\n\n\n将NumPy中的array转换成Tensor的另一个方法就是torch.tensor(), 需要注意的是，此方法总是会进行数据拷贝（就会消耗更多的时间和空间），所以返回的Tensor和原来的数据不再共享内存。\n函数item()可以将一个标量Tensor转换成一个Python number。\nReshape\n\n\n\nTensor\nNumpy\n备注\n\n\n\n\nTensor.view()\nnp.shape()\nTorch.view() can also automatically calculate the correct dimension if a -1 is passed in. This is useful if we are working with batches, but the batch size is unknown. Torch.view()返回的torch.Size其实就是一个tuple, 支持所有tuple的操作。\n\n\n\n\n注意view()返回的新Tensor与源Tensor虽然可能有不同的size，但是是共享data的，也即更改其中的一个，另外一个也会跟着改变。(顾名思义，view仅仅是改变了对这个张量的观察角度，内部数据并未改变)。\n虽然view返回的Tensor与源Tensor是共享data的，但是依然是一个新的Tensor（因为Tensor除了包含data外还有一些其他属性），二者id（内存地址）并不一致。\n想返回一个真正新的副本（即不共享data内存）该用clone创造一个副本然后再使用view。view和copy存在区别。\nBroadcasting遵循以下两个原则：\n\nEach tensor has at least one dimension.\nWhen iterating over the dimension sizes, starting at the trailing dimension, the dimension sizes must either be equal, one of them is 1, or one of them does not exist.\n\n对应dimension要么相同，要么一个是1另一个是更大的数字。\n计算图为什么需要用到计算图？参考\n计算图将函数表达式用树状结构表示。求偏导，联系链式法则，因子路径。\n对于某一个结点往根结点去就是forward propagation，可以求该节点对它上面的所有节点的影响。对于某一个节点往叶子结点去就是backpropagation，可以求该节点受它下面的那些节点的影响。\n记录了计算图，就能追踪每一次微分。\n 硬件支持用方法to()可以将Tensor在CPU和GPU（需要硬件支持）之间相互移动。\ngpu = torch.device(&quot;cuda:0&quot;)x.to(gpu)\n批量数据主要涉及两个工具\nfrom torch.utils.data import Dataset, DataLoader\ncustom datasetYour custom dataset should inherit Dataset and override the following methods:\n\n__len__ so that len(dataset) returns the size of the dataset.\n__getitem__ to support the indexing such that dataset[i] can be used to get 𝑖\\ th sample\n\nclass FakeDataset(Dataset):    def __init__(self, x, y):        self.x = x        self.y = y    def __len__(self):        return len(self.x)    def __getitem__(self, idx):        return self.x[idx], self.y[idx]\ndata loader实现数据批量处理：batch/shuffling/parallel loading。\ndataset = FakeDataset(x, y)dataloader = DataLoader(dataset, batch_size=4,                        shuffle=True, num_workers=4)\n反向传播与自动求梯度追踪梯度的步骤\n对input tensor x的定义.requires_grad属性设置为True\n\n调用反向传播y.backward()，来完成所有梯度计算。此input的Tensor的梯度将累积到Tensor类的.grad属性中。\n\n随后用gradient descent更新x\n\n然后需要把每一次反向传播后的梯度清零，因为.grad的数据不会被覆盖只会在前一个基础之上累加。\nWe need to zero the grad variable since the backward call accumulates the gradients in .grad instead of overwriting.\n为了方便操作先调用调用.detach()将其从追踪记录中分离出来；再调用x.grad.zero_()清零梯度。\n\n\n其他自动求梯度的设置by using .detach() to get a new Tensor with the same content but that does not require gradients:\n stop autograd from tracking history on Tensors with .requires_grad=True either by wrapping the code block in with torch.no_grad():\n构造复杂模块Many times, we want to compose Modules together. torch.nn.Sequential provides a good interface for composing simple modules.\nmodel = torch.nn.Sequential(                            nn.Linear(d_in, d_hidden),                            nn.Tanh(),                            nn.Linear(d_hidden, d_out),                            nn.Sigmoid()                           )\n定义损失函数两种常见的loss function。\nmse_loss_fn = nn.MSELoss()loss = nn.CrossEntropyLoss()\n训练模型训练模型需要用到求梯度的几种方法，比如SGD之类的。torch.optim提供了求梯度的一些方法，至少要传入模型参数和学习率。\nPyTorch implements a number of gradient-based optimization methods in torch.optim, including Gradient Descent. At the minimum, it takes in the model parameters and a learning rate.\n在一个关于data_size/batch_size的循环，或者data_size的循环中，首先计算y_hat，其次计算loss，接下来求梯度(Optimizers do not compute the gradients for you, so you must call backward() yourself. )，要注意先清空梯度。\nstep_size = 0.01linear_module = nn.Linear(d, 1)loss_func = nn.MSELoss()optim = torch.optim.SGD(linear_module.parameters(), lr=step_size)for i in range(20):    # shuffling data    rand_idx = np.random.choice(n) # take a random point from the dataset    x = X[rand_idx]     y_hat = linear_module(x)    loss = loss_func(y_hat, y)    # You also must call the optim.zero_grad() function before calling backward() since by default PyTorch does and inplace add to the .grad member variable rather than overwriting it.    optim.zero_grad()    loss.backward()    optim.step()\n在初始化参数的时候可以定一个momentum的初始值，之后当作参数传入torch.optim。\n参考台大李宏毅机器学习助教补充课\nPytorch官方文档\n","categories":["DeepLearning"],"tags":["ML","DL"]},{"title":"线性回归","url":"/2020/10/23/dl-math-bacis/","content":"掌握术语Model training\nTraining data set/training set = input/output of target function,\nSample\nLabel = function output\nFeature = variant函数变量，输入个数也叫特征数或特征向量维度\nLoss function\n误差最小化问题的解可以分为解析解(Analytical Solution)和数值解(Numerical Solution)。\nHyperparameter = 超参数是人为设定的参数，并非通过模型训练学出的。\n输出层中的神经元和输入层中各个输入完全连接。因此，这里的输出层又叫全连接层（fully-connected layer）或稠密层（dense layer）。\n步骤模型假设选择框架\n模型评估，损失函数Loss function —  Input: function, output: how bad it is\nLoss  function with one parameter对该函数在某一初始点(given an initial value)求微分(didderentaite)；判断此点的微分正负，决定向哪一个方向更新能够让Loss function更小；决定往那个方向变化，结合一个Learning rate —  来决定步长；更新参数直到微分成为0。\n存在一个问题？Local Optinal VS Global Optimal\n存在多个参数的情况对各个参数分别求偏微分，再更新。\n模型优化梯度下降 — Gradient Descent\n要求loss function是convex(no local optimal) \n存在限制 — very slow at plateau/ stuck at saddle point/ stuck at local minima\n过拟合 overfitting复杂的模型再training data上表现良好，但是再testing data上表现很差。\n\nOverfitting is a phenomenon that occurs when a machine learning or statistics model is tailored to a particular dataset and is unable to generalise to other datasets.\n\n优化如何选择优化方式需要考虑loss function的误差有哪些来源，依据情况进行选择。以下是针对线性回归的每个步骤可以参考的问题优化思路。\n\n对数据分类，引入0-1函数参数。\n\n引入更多参数/特征/input。\n\n正则化Regularization，目的是为了让函数更加平滑，相对于训练数据输入相近的测试输入，在进入函数之后引起的输出变化会比较小。并不是越平滑越好，bias对于平滑度没有影响。\n\n误差来源在统计学中涉及到评估随机变量的偏差和方差。涉及到无偏估计.\nBiasAverage/ Expectations描述准确性\n简单模型 — high bias，复杂模型 — low bias。\n模型本质就是一个function set。简单模型的function space较小，难以涵盖target；而复杂模型的function space较大，有更大几率包括target，因此bias更小。\nError from bias越大代表Underfitting，说明模型连最基本训练数据都没有办法适用。解决办法：选择更复杂的模型，增加更多的特征变量。\nVariance描述确定性。\n简单模型 — low variance ，复杂模型 — high variance。\n因为简单模型更少受样本数据的影响。\nError from variance越大代表Overfitting，说明过于关注某些样本训练数据而忽略了整体，当测试数据输入的时候，会得到较大的误差。解决办法：更多数据，正则化。\n模型选择本质A trade-off between bias and variance. \nSelect a modle that balances two kinds of error to minimize total error.\n模型选择的误区假设现在有三个数据集合：Training set — Testing set(public) — Testing set(private)\nwhat NOT do\n不应该用训练集训练不同的模型，然后在测试集上比较错误。意思就是不应该用Testing set来选择模型。模型的选择应该在Training set内部进行决定。\n不应该在public测试集上得到较大的误差之后再返回训练集调试参数，更应当选择调整模型。\n\nDO cross validation交叉验证就是将Trainging set分成两组，一部分作为Training set，另一部分作为Validation set。用验证集选出合适模型，再用Public测试集合进行测试。\nN-fold cross validation: 将数据集分成N份，每一份都有机会成为训练集/验证集，以此对目前正在考虑的模型进行验证。\nGradient Descent梯度下降是一种在用损失函数评估模型时，确定特征的参数系数来让损失函数最小的方法。它的目的就是求特征的参数系数。\n\nGradient descent is a standard tool for optimizing complex functions iteratively within a computer program. \nIts goal is: given some arbitrary function, find a minumum. For some small subset of functions - those that are convex - there’s just a single minumum which also happens to be global. For most realistic functions, there may be many minima, so most minima are local. \nThe main premise of gradient descent is: given some current location x in the search space (the domain of the optimized function) we ought to update x for the next step in the direction opposite to the gradient of the function computed at x. \nWhere  is what we call a “learning rate“, and is constant for each given update. It’s the reason why we don’t care much about the magnitude of the derivative at , only its direction. \nReference: 理解梯度下降\n\n数学理论对于损失函数的一个初始点，需要在其邻域(表现在这里就是在等高图上着一个平面圆圈)找一个新的值使得损失函数更小，该怎么找？\n\ncontour graph和gradient是什么关系？如果把等高线图画出来，且标出所有的梯度方向，可以发现等高线和梯度垂直。\n\n对该损失函数在该初始点使用泰勒展开式化简，我们要求的损失函数就从一个很复杂的难以表现的式子变成了线性函数。损失函数本身可以表示成梯度向量和目前待求解的下一次更新的点的点积，表现在图像上就是两个向量方向相反。\n\n为什么可以这么说？梯度向量有什什么？下一次更新的点又是什么？\n首先需要明白偏导数，全微分，方向导数与梯度的概念。\n偏导数偏导数是改变坐标系基向量的某一个维度的值，固定其他维度的值，衡量函数值变化的情况。\nGraphical Explanation表现在二元函数的图像上就是用x/y平面切空间上的图像，切出来的那个函数是一个平面函数，求的偏导数就是在固定维度的值的那个点，该平面函数的导数/切线。\n梯度向量梯度向量就是对多元函数的基向量的所有维度求偏微分之后获得的每一个维度都是一个带有所有原变量的函数的向量。\n方向导数方向导数是偏导数的推广，衡量在某个特定的方向上函数值的变化情况。\nGraphical Explanation偏导数中用基向量的平面取切，如果我们要所有方向的平面都能切该怎么做？\n首先基向量可以用来表示其他任何向量，由自然基向量构成的一个向量表示在三维空间就是一个平面。求方向导数就是把偏导数投影到该向量所在的平面上，联系到内积。\n该任意向量可以有任意长度，但是把它scale到模为1就可以表示用这个向量平面去切空间里的函数，在那个点的切线斜率。\n方向导数与偏微分/梯度向量由内积的定义可知，梯度向量是方向导数最大的地方，就是曲面最陡峭的方向。\n全微分全微分就是改变坐标系基向量的所有维度的值，衡量函数值变化的情况。\n参考知乎专栏\nKhan Acadamy Multivariable Calculus\n\n注意这里化简的前提，是基于泰勒展开式对于损失函数在该点的模拟的精确度，因此我们适用的邻域就要足够小，这个邻域的大小表现在数据上就是我们选择的学习率。\n如何实现小心地调整Learning Rate\n直接画出损失函数关于要调整的参数的曲线，但是这个可视化只能在参数一维或者二维时进行。\n\n将Learning Rate学习率的改变对损失函数的影响的图像可视化。\n\n自适应学习率，通过添加一些因子来随着次数增加降低学习率。刚开始的时候用大一些的学习率；更新多次参数之后较为高进最低点，减少学习率。\n\n不同的参数需要不同的学习率。\n\n\n常规梯度下降法 Vanilla Gradient Descent\n\\omega^{t+1} \\larr \\omega^{t} - \\eta^tg^t \\\\\n\\eta^t = \\frac{\\eta^t}{\\sqrt{t+1}}Adagrad算法\n\\omega^{t+1} \\larr \\omega^{t} - \\frac{\\eta^t}{\\sigma^t}g^t \\\\\ng^t = \\frac{\\partial{L(\\theta^t)}}{\\partial{\\omega}}\\\\是之前该参数的所有微分的均方根，对于每个参数都是不一样的。\n代入化简可得\n\n\\omega^{t+1} \\larr \\omega^{t} - \\frac{\\eta}{\\sqrt{\\sum_{i=0}^t(g^i)^2}}g^t这个式子中的分式是为了显示how suprise this step is，要求步长前后反差大。\n对于单参数问题，梯度越大就代表和最低点的距离越远。对于多参数问题，前面的结论不成立。\n不仅要和一次微分成正比，还要和二次微分成反比。但是求二次微分带来的代价过于巨大，所以尝试使用一次微分来estimate二次微分，也就是分式中的分母。\n随机梯度下降法 Stochastic Gradient Descent常规梯度下降法走一步要处理所有数据。而随机梯度下降法的损失函数每次只选取一个数据，对其进行梯度更新，因此速度更快。\n特征缩放由于输入的分布范围很不一样，单位也不一样，一个变量的实际数据很大会导致它对特征参数的变化影响很大。因此要适当选择缩放，make different features having the same scaling。\n其中一种常见的缩放方法就是将输入的数据先0-1正规化。make the means of all dimensions 0 and variances 1.\n","categories":["DeepLearning"],"tags":["DL","LinearRegression"]},{"title":"概率分类与Logistic回归","url":"/2020/10/26/classification-basics/","content":"分类定义找一个function，输入对象x的特征，输出该对象是属于n个类别中的哪一个。\n生成模型盒子抽球问题\n两个盒子，每个盒子中各有XX的概率抽出红球或者蓝球，问抽出一个球，抽到x号盒子中蓝色球的概率。\n\n需要的已知信息将一个盒子映射成一个类别，抽一个球是某个盒子中的球的概率分别是 ；对于一个盒子，抽出球的概率分别是。\n利用已知信息推测回答对于给定的一个，就可以计算出它属于每一个盒子的概率是多少\n\nP(C_i|x)=\\frac{P(x|C_i)*P(C_i)}{\\sum{P(x|C_i)*P(C_i)}}(贝叶斯公式)=\\frac{P(x|C_i)*P(C_i)}{P(x)(全概率公式)}依据哪个盒子的概率大，我们就判断这个球属于哪个盒子。\n如何获得等式右边的各种数据？我们需要从训练集中估测需要的已知信息。这个想法叫做生成模型(Generative Model)。\n贝叶斯公式先验概率先验概率是通过我们的训练集，也就是已知分类的对象来获取的。\n对于某个特定分类的对象的数据，可以把它当作某个随机变量的抽样。如果我们有了这个随机变量的分布函数或概率密度函数，就可以推测其他我们未知取值的概率。\n每一个真实世界中的待分类或者已分类的对象需要在数学上被抽象成一个vector，该vector的每个分量都是这个对象的attribute，我们称之为feature。\n定义损失函数如何确定这个训练集数据的分布函数或概率密度函数呢？\n首先要确定这个分布的形式。是高斯分布、伯努利分布或者其他，这需要自己选择。例如对于二元分类来说，可以假设是符合Bernoulli distribution。\n其次将分布函数/概率密度函数看作一个function，输入的就是向量，输出是选中的概率。如果选高斯分布，那就是求期望和协方差矩阵，分别决定了最高点和离散度。\n根据已有sample求解概率密度函数的estimate，采用最大似然估计Maximum Likelihood。任意的期望和协方差都能构成高斯分布，都可以生成我们训练集中的数据，但是问题是对我们已有数据的命中率的高低。\n寻找最好的函数/求参数如何衡量一个确定estimate为的高斯函数对我们已有数据的命中率？引入样本的似然函数的概念。\n对于高斯分布的样本，我们假设高斯分布的期望为，协方差矩阵为，用这些样本的概率值——也就是样本作为输入传入高斯函数后的输出——的乘积，作为样本的似然函数。\n\nL(\\mu,\\sum) = f_{\\mu,\\sum}(x_1)*f_{\\mu,\\sum}(x_2)*f_{\\mu,\\sum}(x_1) * \\dots * f_{\\mu,\\sum}(x_n)能让最大的就是所有的最大似然估计。\n用数学来求解就是对两个estimate分别求偏微分为0的点。直观的来看，期望就是样本平均，协方差就是样本方差。\n抽球模型和分类问题的联系回到盒子抽球问题中的贝叶斯公式，等式中的就是通过概率密度函数求得的。\n我们需要定义计算出来的在什么样的情况下我们会把对象归为。可能概率大于某一个数值？\n为什么令每个类别的高斯分布的协方差矩阵相同后，高斯分布获得的最大似然函数是线性的？\n\n\\begin{split}\nP(C_1|x) &= \\frac{1}{1+\\frac{P(x|C_2)P(C_2)}{P(x|C_1)P(C_1)}}\\\\&=\\frac{1}{1+exp(-z)} \\\\&= \\sigma(z)[Sigmoid \\, function] \\\\\n\\end{split}\n\\\\\nz = ln\\frac{P(x|C_1)P(C_1)}{P(x|C_2)P(C_2)}拆分，用概率密度函数替换掉表达式的中的，展开项合并，并对表达式进行关于的整理，可以得到一个一次函数。\n详细推导见GoodNotes。\n\nP_{\\omega, b}(C_1|x) = \\sigma(z) [Sigmoid Function]\\\\\nz = \\omega  x + b\n之前学的多变量分析中的判别分析，为了降低输入数据的维度，将数据投影到了组间直线的分界线上discriminant score。输入为，输出经过一个一次方程式。\n\n\n\n整理出来得到的是一个一次函数，回顾之前的推导过程，我们需要estimate很多参数包括，并且我们做了假设样本数据服从于某个分布。\n步骤优化\n描述类别的高斯分布的协方差矩阵强制相同。此时分类的边界线，也就是最大似然函数（？）是线性的，所以也叫linear model。\n理由有二。\n第一，因为协方差矩阵和输入feature的大小的平方成正比，因此feature较大时，协方差矩阵增长会过快。\n第二，因为模型参数过多容易过拟合，应当有效减少参数。\n\n如果数据的feature是一个vector，每一个维度的概率分布相互独立，可以将多维的高斯分布通过每一维度的概率密度函数相乘，转化成一维高斯分布(Naive Bayes Classifier朴素贝叶斯分类器)。\n\n\n从获得的结果来看，最终只与有关，是否可以尝试直接求解这两个参数？由此引入Logistic Regression。\nLogistic Regression逻辑回归的函数集定义Logistic Regression的函数集为。我们需要假设训练数据集从此密度函数上获得，即任意一对都能让我们的训练数据集的input通过此函数获得一个output，即在该input下，分类正确的几率作为output。\n对于用于训练的数据集通过某个function，可以获得input，output。要将所有的数据都转换成实际的数据，用分类结果肯定不行。对于二元分类问题直接映射分类结果到0和1；对于多元分类问题该怎么办？后面解决。\n定义损失函数如何从function set中选出令衡量效果最好的那一个function？直观来说就是能够正确分类，输出概率最大的那个function是最好的。确定最优化函数function也就是查找一个特定的$\\omega^,b^$。\n\nL(\\omega, b) = f_{\\omega,b}(x_1) f_{\\omega,b}(x_2) (1-f_{\\omega,b}(x_3)) \\dots f_{\\omega,b}(x_n)  \\\\\n\\omega^*, b^* = {arg \\, \\max\\limits_{\\omega^*,b^*}} \\, {L(\\omega, b)} \\iff \n{arg \\, \\min\\limits_{\\omega^*,b^*}} \\,{ -\\ln{L(\\omega, b)}}注意到有两种形式的分式在相乘，不可能展开求解，需要改写函数集来同时能够匹配分类正确/属于Class0和分类错误/属于Class1两种情况。\n\n\\begin{split}\n-\\ln{L(\\omega, b)} \n&= -\\ln{f_{\\omega,b}(x_1)}\\ln{f_{\\omega,b}(x_2)} \\ln{(1-f_{\\omega,b}{(x_3)})} \\dots  \\\\\n&= \\sum_\\limits{n} -[\\hat{y}^n \\ln{f_{\\omega,b}(x_n)} + (1-\\hat{y}^n) \\ln{(1-f_{\\omega,b}(x_n))}] \\, \\\\\n\n\\end{split}上式可以看作两个0-1分布的交叉熵。\n求导结果\n\nMLE &amp;&amp; Cross-Entrpy Explanation什么是Cross Entropy？为什么作为衡量goodness of function的标准？\nReference\n熵的定义熵用于衡量随机变量的不确定性。\nEntropy is a measure of the uncertainty of a random variable. If we have a random variable X, and we have probability mass function p(x) = Pr[X=x], we define the Entropy H(X) of the random variable X with\n\nH(X) = -\\sum\\limits_{x}{p(x)\\log{p(x)}}由于形式和随机变量的数学期望十分相像，所以将它改写为\n\n\\begin{split}\nH(X) &= -\\sum\\limits_{x}{p(x)\\log{p(x)}} \\\\\n&= \\sum\\limits_{x}{p(x)\\log{\\frac{1}{p(x)}}}\\\\\n&= \\mathbb{E}_{X \\sim p(x)}[\\log{\\frac{1}{p(x)}}]\n\\end{split}So the entropy of a random variable is the expected value of the random variable log(1/p(x)) where X is drawn from p(x). \n\n交叉熵假设对于我们的数据集，有两个分布，一个是unkown but true的distribution，一个是modeled approximate的distribution。为了衡量这两个分布之间的差异性，我们引入the Kullback–Leibler divergence (also called relative entropy)的概念。如果两个分布一摸一样的话，交叉熵就是熵。\n\n\\begin{split}\nD_{KL}(p||q) &= \\sum\\limits_{x}{p(x)\\log{\\frac{q(x)}{p(x)}}}\n\\\\&= \\mathbb{E}_{X \\sim p(x)}[\\log{\\frac{q(x)}{p(x)}}] \\\\ &=\n\\mathbb{E}_{X \\sim p(x)}[\\log{\\frac{1}{p(x)}}] - \\mathbb{E}_{X \\sim p(x)}[\\log{\\frac{1}{p(x)}}]\n\\end{split}第一项是Cross-Entropy，第二项是分布p(x)的熵。\n将Cross-Entropy为，用真实分布的熵和Relative-Entropy表示Cross-Entropy，为。\n\nCross-Entropy &amp;&amp; MLE Relationship如何将Cross Entropy和Maximum Likelihood Estimation联系起来？需要理解的是，极大似然估计是用来估计一个概率模型的参数的一种方法。\nSuppose that for a problem, we have a set of examples X_example = {x_1, x_2, …, x_m} that drawn independently from a true but unknown distribution p_data(x). \nThen we try to model the true distribution by parametric model p_model(x;𝜃) with 𝜃 as the parameter. \nWe can say that p_model(x,𝜃) maps x to estimate the true but unknown p_data(x) given the same data.\nTo get the best model, we need to find such 𝜃 that yields the most similar outcome of p_model(x,𝜃) to p_data(x). We can use MLE principle to find such 𝜃, that is by using maximum likelihood estimator for 𝜃.\n\nSimlification1. i.i.d.\n\n\\begin{split}\n\\theta_{ML} &= arg\\max \\limits_{\\theta} p_{model}(X_{example};\\theta) \\\\ & \\stackrel{i.i.d}{\\longrightarrow} arg\\max \\limits_{\\theta}\\prod_{i=1}^{m}p_{model}(x_{i};\\theta)\n\\end{split}\nSimplification2. prodction to summation\n算数下溢the underflow problem\nThe product of p_model(x_i;𝜃) is going to be very close to 0 when the example set size m is large since the probability will be in the range of 0≤p_model(x_i;𝜃)≤1. This could cause a serious underflow to the computer, resulting in a less precise estimation of the model.\n数据量很大的时候会导致每一个数据的出现概率很小，乘积就会无限趋近于零，在计算机中处理浮点数会带来很大的误差。一个解决办法就是取对数，将相成转换为相加。\n改写式子，并scale一个，让他变成数学期望的形式。\n\n\\begin{split}\n\\theta_{ML} &= arg\\max \\limits_{\\theta}\\sum_{i=1}^{m}p_{model}(x_{i};\\theta) \\\\&= arg\\max \\limits_{\\theta} {\\frac{1}{m} \\cdot \\sum_{i=1}^{m}\\log {p_{model}(x_{i};\\theta) }} \\\\\n&= arg\\max \\limits_{\\theta} \\mathbb{E}_{X\\sim p_{example(x)}}{[\\log{p_{model}(x; \\theta)}]}\n\\end{split}最后的形式和Cross-Entropy一样。\n\n过程总结This shows that we can see the problem of getting the best parameter 𝜃_ML using maximum likelihood estimation as minimizing the cross-entropy between our parametric model p_model(x;𝜃) and the empirical example distribution p_example(x).\nTrain our model by minimizing the cross-entropy loss since it can lead us to the maximum likelihood estimator of the parameter 𝜃_ML that yields the best model according to the training example.\n\n寻找最好的函数用梯度下降法求解。对进行微分，运用链式法则在两个偏微分上下分别引入偏微分，获得结果\n\n\\frac{\\partial{(-\\ln{L(\\omega, b)} )}}{\\partial{w}} = \\sum_{n} -(\\hat{y}^n-f_{w,b}(x_n))x_i^n\nw_i \\leftarrow w_i - \\eta  \\sum_{n} -(\\hat{y}^n-f_{w,b}(x_n))x_i^n如何理解括号中的相减的两个式子？代表着Larger Difference, Larger Update。\n逻辑回归与线性回归的区别从两方面考虑。\n第一，实际数据的输出target。对于逻辑回归，限定在0～1之间。对于线性回归，可以是任何实数。\n第二，定义的损失函数的输出output。对于逻辑回归，由于Sigmoid Function的性质，限定在0～1之间。对于线性回归，可以是任何值。\n为什么不像线性函数中一样使用Square Error代表Loss Function？从两方面解释。\n一方面，output of loss function无论是close to target还是far from target，loss function梯度下降后的偏微分都可以是零。\n另一方面，交叉熵距离target越远，微分值越大，更新参数越大。但是平方误差在离target很远的时候，微分值特别小，更新参数会特别慢，效果很差。\nDiscriminative Model V.S. Generative Model用逻辑回归和生成模型找出来的是不一样的。因为两个模型所做的assumpition都不同，逻辑回归并没有做任何假设；但是生成模型预先假设了样本符合某个分布，给予了更多的信息。\n生成方法的优势在于训练数据集很小的情况下，结果受数据量的影响很小，基于分布假设，对噪声数据有更好的鲁棒性。\n判别方法的优势在于看训练数据集计算，训练数据量越大，error越小。\n多类别分类 n-class\ninput \\stackrel{\\omega_i ,b_i}{\\longrightarrow} z_i \n\\stackrel{exponential}{\\longrightarrow} e^{z_i} \\stackrel{normalize}{\\longrightarrow} output=\\frac{e^{z_i}}{\\sum_{j=1}^{n}{e^{z_i}}}exponential和normalize的过程都可以被一个叫softmax的方程来完成，这个步骤的工作就是对最大值进行强化。\ntarget该如何定义？如果用连续的0-1-2-3-4存在类别之间有距离大小的问题，而每个类别应当同等看待地位相同。用一个列向量来表示target。\n逻辑回归的限制逻辑回归就是区分类别，如果raw data并不能让逻辑回归做区别的？比如在平面上，一个正方形的四个顶点，对角同类别，无论怎么拉线都不能分类。这种时候该怎么办？\n利用特征转换Feature Transfomation。但是如何衡量一个特征转换的优劣又是需要考虑的。\n逻辑回归可以用来做特征转换，也可以用来做分类。把这些逻辑回归级联在一起就得到级联逻辑回归模型。\n一个逻辑回归的输入可以来源于其他逻辑回归的输出，这个逻辑回归的输出也可以是其他逻辑回归的输入。把每个逻辑回归称为一个 Neuron（神经元），把这些神经元连接起来的网络，就叫做 Neural Network（神经网络）。\n","categories":["DeepLearning"],"tags":["DL","LogisticRegression"]},{"title":"从Github上下载单一文件夹资源","url":"/2020/10/27/github-one-file-download/","content":"使用SVN\n在网页中打开想要下载的文件夹并复制的URL。\n\n将URL中/tree/master/转换成/trunk/。\n如果不是master分支，是另一个branchname分支，只需要将上文中的/trunk/替换成/branches/branchname/即可。\n\n在终端进入目的文件夹，输入svn checkout Changed-URL即可。\n\n\n\n升级到MacOS BigSur之后发现无法使用svn，因为XCode的Command Line Tools工具包里面没有svn了。解决办法是使用homebrew包管理工具。\n之前下载过homebrew，但是报错version value must be a string。解决办法是brew update-reset，之后正常安装即可。\n\n使用页面Raw在Raw上右键菜单点击链接另存为即可。\n但是可能存在文件格式转换。例如下载.csv到电脑就会变成.txt。\nRaw+Wget把单个文件点击Raw格式，跳出的页面中会有一个新的URL，形式大概为https://raw.githubusercontent.com/datawhalechina/leeml-notes/master/docs/Homework/HW_1/Dataset/result.csv。\n在命令行中输入wget Raw-URL，就可以下载内容，且不存在文件格式的转换。\n可能会出现的问题raw.githubusercontent.com的443端口无法连接的问题\n修改主机地址，添加github相关地址，具体参考解决GitHub的raw.githubusercontent.com无法连接问题\n","categories":["必备技能"],"tags":["资源获取"]},{"title":"使用LaTeX编辑数学公式","url":"/2020/10/27/latex-and-typora/","content":"区别常用函数表示 &amp;&amp; 左边单纯输入ln两个字母，右边加了斜杠，代表是一个函数。\n同样适用于min max sin cos等。\n函数中的圆括号和花括号区别一下两种在函数中加入表达式的方法。\n函数后面只用了花括号：\\ln{1-f_{\\omega,b}(x_n)}\n\n\\ln{1-f_{\\omega,b}(x_n)}花括号中另外加了一层圆括号把减号前后包括起来。\\ln{(1-f_{\\omega,b}(x_n))}\n\n\\ln{(1-f_{\\omega,b}(x_n))}下标置于正下方使用\\limits_{}，需要注意! Limit controls must follow a math operator.\n如果是非数学符号，结合\\mathhop{}将式子转换成数学符号。\n\n\\sum\\limits_{i=0}^n {x_i} \\\\\n\\mathop{argmin}\\limits_{x=0}空格\n相当于Tab的空格\\quad\n\n大空格a\\ b\n\n中等空格a\\;b\n\n小空格a\\,b\n\n\n波浪号常用语随机变量分布\\sim。\n带文字的箭头\\stackrel{exponential}{\\longrightarrow} \n期望\\mathbb{E}  \nproduct &amp; summation\\prod \n \\sum \n多行公式左对齐\n\\begin{split}\n\\theta_{ML} &= arg\\max \\limits_{\\theta}\\sum_{i=1}^{m}p_{model}(x_{i};\\theta) \\\\&= arg\\max \\limits_{\\theta} {\\frac{1}{m} \\cdot \\sum_{i=1}^{m}\\log {p_{model}(x_{i};\\theta) }} \\\\\n\\end{split}\\begin{split}x &amp;= a \\\\&amp;= b \\\\&amp;= c\\end{split}\\begin{array}{ll}\\end{array}\n","categories":["必备技能"],"tags":["LaTeX"]},{"title":"CSS布局","url":"/2020/10/28/css-layout/","content":"正常布局流Normal Flow是指在不对页面进行任何布局控制室，浏览器默认的HTML布局方式。\n主要涉及块元素/内联元素。\n当你使用css创建一个布局时，你正在离开正常布局流，但是对于页面上的多数元素，正常布局流将完全可以创建你所需要的布局。\n以下布局技术会覆盖默认的布局行为：display/ float / position/ display: table表格布局/ Multi-column layout多列布局。\ndisplay正常布局流下盒子类型分为inline/block两种，这个属性是根据HTML标签元素是块元素还是内联元素而自带的。\n\n一个块级元素的内容宽度是其父元素的100%，其高度与其内容高度一致。\n内联元素的height width与内容一致。你无法设置内联元素的height width —- 它们就那样置于块级元素的内容里。 如果你想控制内联元素的尺寸，你需要为元素设置display: block; （或者，display: inline-block; inline-block 混合了inline 和 block的特性。)\n\ndisplay还有另外两个取值为flex和grid。\n弹性盒子Flexbox弹性盒子被用于创建横向或者纵向的一维页面布局。要使用Flexbox，需要在想要进行flex布局的父亲元素上应用display: flex  ，子元素(flex item)的表现行为就是依据副元素上设置的flex-direction/align-items等属性（默认初始值是row/stretch，以为着子元素排成一行并被拉伸到和作为flex容器的父亲元素一样的高度）。\n模型说明\n\nflex conatiner/flex容器\n\nmain axis主轴 — cross axis交叉轴 互相垂直\nmain start — main end\ncross start — cross end\n\n\nflex item/flex项\n\nmain size — cross size\n\n\n\n指定主轴方向flex-direction默认值为row。可取值column/column-reverse/row-reverse。\nflex容器定宽定高时flex项过多溢出添加声明到flex容器(父元素)中添加声明flex-wrap: wrap，意味着任何溢出的元素将被移到下一行。\n同时，把flex: 200px添加到flex项(子元素)中，意味着每个子元素的宽度至少是200px。\n变换浏览器视窗还可以发现，最后一行上的最后几个项每个都变得更宽，以便把整个行填满。\nflex-flow缩写存在着 flex-direction 和 flex-wrap — 的缩写 flex-flow。\n控制flex项占用flex容器的空间比例在flex项中添加元素article:nth-of-type(f(n)) &#123;flex : 1&#125;，数字是一个无单位的比例值，代表每个flex项沿着主轴占用空间的份额。\n总的份额是所有子元素的份额相加，单个子元素的份额默认为1。\n对于某一个特定的子元素，为了计算它占用flex容器的空间，用给定它的份额除以总份额即可。\n可以配合尝试指定flex最小宽度。\n控制flex项的水平和垂直对齐从flex容器中使用属性去控制其下flex项的水平和垂直对齐\n\nalign-items 控制 flex 项在交叉轴上的位置。\n默认 stretch，其会使所有 flex 项沿着交叉轴的方向拉伸以填充父容器。如果父容器在交叉轴方向上没有固定宽度（即高度），则所有 flex 项将变得与最长的 flex 项一样长（即高度保持一致）。\ncenter 值会使这些项保持其原有的高度，但是会在交叉轴居中。\nflex-start 或 flex-end 这样使 flex 项在交叉轴的开始或结束处对齐所有的值。\n\n\njustify-content 控制 flex 项在主轴上的位置。\n默认值是 flex-start，这会使所有 flex 项都位于主轴的开始处。flex-end为结尾处。 \nspace-around 使所有 flex 项沿着主轴均匀地分布，在任意一端都会留有一点空间。\nspace-between和 space-around 非常相似，只是它不会在两端留下任何空间。\n\n\n\n如果想在flex项中单独去控制某个或者某类子元素，可以使用align-self属性覆盖align-items的行为。（在子元素中再一次声明align-items会没有效果）。\n控制flex项排序在flex项的规则集中添加order属性。改变子元素的顺序的同时，不影响DOM树种元素的顺序。\nsub-element:first-child &#123;  order: 1;&#125;\n\n默认所有flex项order为0。\n接受的值可负可0可正。\n排序顺序依据order值从小到大依次显示，当order值相同时，按照DOM树中的源顺序。\n\nGrid布局Grid布局用于同时在两个维度上把元素按照行和列排列整齐。一般都描述一个容器和若干子元素。\n模型说明\n分为行和列，行与行以及列与列之间的间隙被称为沟槽。\n定义网格将容器的display属性设置为grid。与弹性盒子相同，将赴容器改为网格布局后，它的直接子项会变成网格项。\n仅有该声明并不会造成网页布局的马上变化，因为display: grid的声明只创建了一个只有一列的网格，所以你的子项还是会像正常布局流那样从上而下一个接一个的排布。\nfather-element&#123;    display: grid;\tgrid-template-colums: 1fr 1fr 1fr;    /* 1fr = 1 fraction相对单位，代表了经过计算后的该子项会使用的份额。如果一个声明中全是fr，那么子元素的排列就是父亲元素宽度分之几。一般配合px等绝对单位使用，fr会根据除去绝对单位后的可用空间按比例分配。*/\tgrid-template-rows: 10px 10px;\tgrid-gap: 10px;&#125;\n定义网格间隙使用grid-column-gap属性来定义列间隙；使用grid-row-gap来定义行间隙；使用grid-gap 可以同时设定两者。\n不能使用fr单位。\n重复构建行/列repeat(time, unit)\n第一个参数值是表明后续要重复多少参数的行/列；第二个参数表示需要把每个行/列设置成多少，可以传入多个参数当作一套参数。\n隐式网格V.S.显式网格显式网格是我们用grid-template-columns 或 grid-template-rows 属性创建的。隐式网格则是当有内容被放到网格外时才会生成的。\n隐式网格中生成的行/列大小是参数默认是auto，大小会根据放入的内容自动调整。也可以使用grid-auto-rows和grid-auto-columns属性手动设定隐式网格的大小。\n解决固定行/列高不够用的情况minmanx()函数为一个行/列的尺寸设置了取值范围。\n\nset a minimum and maximum size for a track, for example minmax(100px, auto). The minimum size is 100 pixels, but the maximum is auto, which will expand to fit the content. \n\n自动使用多列填充将repeat函数和minmax函数结合起来设定行列属性。\nrepeat函数的第一个参数传入关键字auto-fill来替代确定的重复次数；第二个参数传入minmax函数，minmax函数参数传入一个最小的固定值，以及最大的值1fr。\n网格项放置如果不对子元素指定排列位置，默认自动排列。\n基于分割线放置可以利用grid-column和grid-row两个属性来制定每一个子元素从哪一个行/列开始，哪一个行列结束（有两个用斜杠分开的数字：开始列/结束列，使子元素在多个行列上展开；如果只有一个数字：只占单列/单行）。\n基于grid-template-areas属性放置父亲元素操作在父亲元素中使用grid-template-areas属性，一行内容用双引号，行与行之间直接换行，结束后使用分号。\n使用规则如下：\n\n你需要填满网格的每个格子\n对于某个横跨多个格子的元素，重复写上那个元素grid-area属性定义的区域名字\n所有名字只能出现在一个连续的区域，不能在不同的位置出现\n一个连续的区域必须是一个矩形\n使用.符号，让一个格子留空\n\n对于第一条，填满网格的格子，说明至少在父亲元素的规则集中grid-template-columns这个属性上有的列数要和该属性中的列数一样。他们两个是协同工作的。\n子元素操作子元素中声明grid-area，代表了这个区域的功能别名，用于在父亲元素中使用。不需要引号，冒号后面直接跟别名。\n浮动让元素浮动起来，改变元素本身和在正常布局流中跟随它的其他元素的行为。也就是说一个元素的浮动设置，会影响之后的元素的行为。\n通过将某一元素设置左/右浮动，并给出一个元素的margin，实现文字环绕该元素的效果。\nfloat的取值left — 左侧\nright — 右侧\nnone — 默认不浮动\n结合width的百分比取值和float以及margin-left/right的百分比取值，实现多列布局。\nfloat存在的问题就是只要是float过后的元素之后的内容，都会以围绕的方式包裹着浮动元素。由此需要一个”停止浮动”的属性clear。\n停止浮动clear可以取值both/left/right。之后所有的元素都不在浮动，回归正常文档流。除非另外设置了浮动。 \n如果没有可用元素来清除浮动（比如页脚），可以在想要清除浮动的元素之前，应用浮动的元素之后添加一个看不见的块元素div，对这个元素应用clear规则。\n\n浮动元素后超出父元素边框如何解决？:link:Float Three\n将父亲元素改为inline-block包裹浮动元素即可。\n\n定位定位能让我们把一个元素从它原本在正常布局流中应该在的位置移动到另一个位置，用于微调页面中的特殊项目。\nstatic每个元素自带的默认定位，放在文档流的默认位置。即使有了top right bottom left也忽略设定。\nrelative相对定位，允许我们相对元素在正常的文档流中的位置移动它。\n单纯设定该属性值表现得和static一样，除非设定top right bottom left。\n理解相对定位工作的方式——你需要考虑一个看不见的力，推动定位的盒子的一侧，移动它的相反方向。 所以例如，如果你指定 top: 30px;一个力推动框的顶部，使它向下移动30px。\nabsolute绝对定位。\n脱离文档流用了绝对定位的元素在正常文档流中相当于不存在。将元素完全从页面的正常布局流中溢出，类似于单独开设一个图层。\n可以利用磁特性创建一个不干扰页面上其他元素的位置的隔离的UI功能。\n位置变化相对于另外一个元素定位。这里的top right bottom left属性工作方式和relative中不一样，它们指定元素应距离每个包含元素的边的距离，而不是指定元素应该移入的方向。\n可以将元素相对于页面的 &lt;html&gt; 元素边缘固定，或者相对于该元素的最近被定位祖先元素(nearest positioned ancestor element)。\n\n哪个元素是绝对定位元素的“包含元素“？这取决于绝对定位元素的父元素的position属性。分两种情况。\n\n所有父元素没有更改默认static\n\n所有的父亲元素都没有更改默认的position属性，即所有的父元素默认情况下position属性都是static。结果，绝对定位元素会被包含在初始块容器中。\n这个初始块容器有着和浏览器视口一样的尺寸，并且元素也被包含在这个容器里面。简单来说，绝对定位元素会被放在元素的外面，并且根据浏览器视口来定位。\n\n所有父元素更改了默认属性static\n\n此时包含元素就是那个更改了默认属性static的父亲元素。\n\n堆叠顺序z-index “z-index”是对z轴的参考。我们使用水平（x轴）和垂直（y轴）坐标来讨论网页，以确定像背景图像和阴影偏移之类的东西的位置。 (0,0)位于页面（或元素）的左上角，x和y轴跨页面向右和向下。\n网页也有一个z轴：一条从屏幕表面到你的脸（或者在屏幕前面你喜欢的任何其他东西）的虚线。z-index的值影响定位元素位于该轴上的位置，也就是定位元素堆叠顺序。\n默认情况下，定位的元素都具有z-index为auto，实际上为0。\nfixed固定定位，与绝对定位非常类似，相对于浏览器视口来定位，即便网页滚动也会停留在相同位置。可以用来创建在整个页面滚动过程中总是处于屏幕的某个位置的导航菜单时使用。\nsticky结合static和fixed两个属性。优先保持static，当该元素相对于视口位置到达某一个预设置时，切换fixed定位。\n当一个元素被指定了position: sticky时，它会在正常布局流中滚动，直到它出现在了我们给它设定的相对于容器的位置，这时候它就会停止随滚动移动，就像它被应用了position: fixed。\n多列布局要把一个块转变成多列容器(multicol container)。\n使用 column-count属性来告诉浏览器我们需要多少列。\n使用column-width使浏览器将按照你指定的宽度尽可能多的创建列；任何剩余的空间之后会被现有的列平分。 这意味着你可能无法期望得到你指定宽度，除非容器的宽度刚好可以被你指定的宽度除尽。\n使用 column-gap改变列间间隙。\n用 column-rule 在列间加入一条分割线。和border属性类似，接受相同的单位。\n如果多列布局的一个列被拆成了很多碎块，尤其是在你添加了内容背景颜色和边框的情况下会特别明显。对文本容器盒子添加属性break-inside: avoid。\n媒体查询基础@media media-type and (media-feature-rule) &#123;  /* CSS rules go here */&#125;\nmedia-type媒体类型可取值all/print/screen/speech\nmedia-feature-rule媒体特征规则宽和高使用min-width、max-width和width等媒体特征，在视口宽度大于或者小于某个大小——或者是恰好处于某个大小——的时候，应用CSS。\n朝向orientation，我们可以用它测得竖放（portrait mode）和横放（landscape mode）模式。\n构成逻辑表达式媒体类型与媒体特征规则之间利用逻辑符号可以构成更复杂的媒体查询。\n\n与逻辑 and\n或逻辑 ,\n非逻辑 not\n\n","categories":["CSS"],"tags":["CSSLayout"]},{"title":"机器学习中的矩阵基础","url":"/2020/10/28/matrix-calculus-tips/","content":"数学原理正态分布的参数估计中的Matrix Calculus\n矩阵维度与运算的理解在多维（三维四维）矩阵向量运算-超强可视化这篇文章中，提到了张量运算的可视化方法，现做一些总结。\n在Keras框架中，生成一个矩阵/张量，可以采用以下方式。\n二维，输出一个两行三列的矩阵。\nimport keras.backend as Kimport numpy as npa = K.constant(np.arange(1, 7), shape=[2,3])print(K.eval(a))\n输出为：\n[[1. 2. 3.] [4. 5. 6.]]\n三维，同样的代码，只是shape有所改变。\na = K.constant(np.arange(1, 13), shape=[2,2,3])print(K.eval(a))\n输出为：\n[ [ [ 1.  2.  3.]    [ 4.  5.  6.] ]  [ [ 7.  8.  9.]    [ 10. 11. 12.] ] ]\n四维，同样的代码，只是shape有所改变。\na = K.constant(np.arange(1, 37), shape=[3,2,2,3])print(K.eval(a))\n输出为：\n[ [ [ [ 1.  2.  3.]      [ 4.  5.  6.] ]       [ [ 7.  8.  9.]      [ 10. 11. 12.] ] ]     [ [ [ 13. 14. 15.]      [ 16. 17. 18.] ]      [ [ 19. 20. 21.]      [ 22. 23. 24.] ] ]   [ [ [ 25. 26. 27.]      [ 28. 29. 30.] ]    [ [ 31. 32. 33.]      [ 34. 35. 36.] ] ] ]\n仔细观察输出，可以发现如下现象：\nshape的长度决定了输出的向量前面几个[开头，后面有几个]结尾。\n二维的输出结果作为一部分出现在了三维的输出结果中，三维的输出结果作为一部分出现在了四维的输出结果中。由此，可以看出上面例子中的三维结果是由2个二维结果拼接在一起的，这里2个是由shape=[2,2,3]中的第一个2决定的，而[2,3]决定的是二维矩阵是几行几列的。同样的道理，上面例子中的四维结果是由3个三维结果拼接在一起的，这里的3个是由shape=[3,2,2,3]中的第一个3决定的。可以看出，shape的第一个数字只是当前维度n的上一个纬度n-1维度的排列个数。\n这里有一种递归的思想在里面，n维的矩阵，无论怎么排，最终都会递归到2维，因为2维是构成矩阵的最小维度。\n既然如此，高维矩阵的运算，归根结底是2维矩阵的运算。两个高维矩阵中对应到2维矩阵的部分现做矩阵运算，结果再度拼为高维矩阵即可。而2维矩阵总是由shape中的最后两个维度决定的，只要最后两维度满足匹配原则，就可以正常运算。\nshape=[2,2,3]与shape=[2,3,4]的两个矩阵进行矩阵乘法运算。\na = [ [ [ 1.  2.  3.]    [ 4.  5.  6.] ]  [ [ 7.  8.  9.]    [ 10. 11. 12.] ] ]b = [ [ [ 1.  2.  3.  4.]    [ 5.  6.  7.  8.]    [ 9. 10. 11. 12.] ]  [ [13. 14. 15. 16.]    [17. 18. 19. 20.]    [21. 22. 23. 24.] ] ]\n执行如下语句进行矩阵乘法。\nc = K.batch_dot(b, a)\n结果为如下。\n[[[ 38.  44.  50.  56.]  [ 83.  98. 113. 128.]] [[416. 440. 464. 488.]  [569. 602. 635. 668.]]]\n可以看出\n[[ 38.  44.  50.  56.]  [ 83.  98. 113. 128.]] =   [ [ 1.  2.  3.]    [ 4.  5.  6.] ]  *  [ [ 1.  2.  3.  4.]    [ 5.  6.  7.  8.]    [ 9. 10. 11. 12.] ]\n其中，38就是第一个矩阵的第一行与第二个矩阵的第一列对应位置相乘并相加的结果。\n从Keras提供的矩阵想成的方法也可以看出，这是二维矩阵的批量运算batch_dot。二维矩阵使用K.dot(a, b)即可；对于高维矩阵，引入batch matrix multiplication的方法，使用K.batch_dot(a, b)进行运算。\n\nData is considered as (B1,…,Bn,C,H,W) format. Spatial dimension of tensor is in the last two indices. \nThe multiplication has been performed considering (2) as the batch size or non-spatial dimension, and spatial dimension of tensor a is (2,3) and b is (3,4).\n这里的解释来自A brief talk through Matrix Multiplication in Keras with Tensorflow as Backend。\n\n","categories":["DeepLearning"],"tags":["DL","Math","MatrixCalculus"]},{"title":"Lee-ML-Homework1","url":"/2020/10/29/MLHW1-tips/","content":"加载数据使用pandas库，import pandas as pd。\ndata = pd.read_csv(&#39;path&#39;);\n在加载数据的时候默认第一行就是列号，但是出现第一行就是数据的情况需要添加pd.read_csv(&#39;./Dataset/test.csv&#39;, header=None)。\n数据预处理无关行/列处理如果存在不是数据，只是辅助信息的多余的列，需要剔除。\n\n使用iloc，即data.iloc[:, 3:]表示保留所有行，列从第三列开始保留。\n\n\n与python中slice的区别\nNote that contrary to usual python slices, both the start and the stop are included.\n\n\n使用drop，train_data.drop([&#39;Date&#39;, &#39;stations&#39;, &#39;observation&#39;], axis=1, inplace=True)。需要确定的源数据中的行列名称(labels)，以及行还是列(axis=0 — index/ axis=1 — column)\n\n非数据项转换存在一些文字表示的数据项，如果取值为二元就可以转换成0或1的布尔值。\ndata[data == &#39;NR&#39;] = 0\n矩阵操作reshape &amp;&amp; -1StackOverflow的解答 \n-1意味着未知的维度，需要numpy依据传入的另外一个参数值进行自行计算。计算遵循的原则是前后数据不能有损失，即‘The new shape should be compatible with the original shape’。\nreshape(1, -1)转换成一个行向量；reshape(-1, 1)转换成一个列向量。\nnp.concatenate在线性回归中有一个bias项要添加到x中去，使用np.concatenate((np.ones([row, column]), x), axis=1)\n声明/更改数组数据类型一般在声明一个空数组，全1数组的时候会使用dtype=float之类的命令。\n如：test_y = np.empty([240, 1], dtype=float)\n在对已有的数组进行拼接/截取操作，或从某个文件读取数据到CSV，会使用.astye(float)之类的命令强制类型转换。\n如test_x = np.concatenate((np.ones([240, 1]), test_x),axis=1).astype(float)\n模型训练模型训练是在定义并初始化相关参数以及学习率之后，执行for循环。\n主要内容for循环的次数是iter_time。for循环内部需要有output_value y，每次迭代得到的loss function的结果，对loss function求gradient的结果，最后更新参数即可。\n参数更新如果使用adagrad用到了前面求的梯度，还要专门开设一个变量存放中间结果。\n如果参数更新的表达式，后面的负的gradient的式子中存在分式且分母有可能为0，需要在分母上添加一个eps极小值，目的是保证分式子有意义。\n模型评估参数传递在train的.py文件中保存好模型参数，并输出到当前路径。np.save(&#39;weight.npy&#39;, w)\n在test的.py文件中读入权重。w = np.load(&#39;weight.npy&#39;)\n结果输出把test的结果输出到CSV文件，前两行通用写法，然后开始定义header并写header；之后开始用for循环写数据，写一次数据就调用一次csv_writer.writerow(content-you-want-write) 。\nwith open(&#x27;predict.csv&#x27;, mode = &#x27;w&#x27;, newline=&#x27;&#x27;) as file:    csv_writer = csv.writer(file)    header = [&#x27;id&#x27;, &#x27;PM2.5&#x27;]    csv_writer.writerow(header)    for i in range(240):        if int(test_y[i][0]) &gt; 0:            row = [&#x27;id_&#x27;+str(i), str(int(test_y[i][0]))]        else:            row = [&#x27;id_&#x27;+str(i), &#x27;0&#x27;]        csv_writer.writerow(row)\n参考MrSun Blog\nCSDN 意疏\n","categories":["DeepLearning"],"tags":["ML-Tips"]},{"title":"Hexo渲染数学公式","url":"/2020/10/30/mathjax-on/","content":"解决办法参考\n更改渲染引擎；对渲染引擎文件的转义做修改；在NexT主题的配置中打开MathJax开关。\n使用MathJax参考\n仍然存在的问题L(\\mu^*)在行内$L(\\mu^)是无法正确渲染的，尤其是test^多个的test^*$的情况下。\n\\larr, \\lrarr, \\rarr在本地可以行内渲染，但是部署后会高亮呈红色无法渲染。 的解决办法是使用同等的替代品 \\leftarrow, \\rightarrow，呈现效果如下。\n","categories":["个人博客搭建"],"tags":["踩坑记录"]},{"title":"使用sketch设计商城app原型的流程","url":"/2020/10/30/sketch-app-design-workflow/","content":"前锋UI视频教程：2018sketch课程\n前期准备\n把各个页面上的元素做成思维导图以供后续参考\n查阅基本模型查看需要多少种字体，设定完成并模版化，构成创建该app所需要的所有字体库。\n查阅所有图标，单独开一个icon的page，复制出所有需要的在@1x情况下图标尺寸为44*44的rectangle，组成一个group。\n\n\nTIPS on shortcut\ncmd++g = group\ncmd+shift+l = lock\n\n图标绘制选中一个对象，按下option可以查看对象之间的间距。\n在设定一个元素的宽和高的时候，需要注意是2的倍数。一方面图标尺寸默认44*44，另一方面2的倍数比较方便居中对齐。\n在图标绘制的时候考虑图标的两种状态，一种是选中，一种是未选中，（当然也可以根据hover/clicked等状态自行定义一个图标的多个状态），绘制出一个图标的多种状态。\n页面绘制一套APP中所有的border和border-radius尽量都保持一致。\n中文字体一般用双数，才能让文字显示更完整。\n内阴影和外阴影的设置可以让某个物件凸起或者凹陷，但一般不会去做内阴影。\n在sketch中@1x的情况下去画线，粗细用0.5px，而不是1px，目的是在@2x的情况下呈现1px的效果。\n如何确定两边间距？在一倍率下的间距数值乘以倍率要是一个整数。比如说@0.75x和@1.5X的情况下，选择8的倍数做间距。\n一个单个的icon可以做很小，但是考虑到用户交互，一定要大于44X44才适用于用户点击。这种情况下对单个icon创建组件，组件的大小至少为44X44，然后在组件内部点击对象可以做任意大小。\nicon的种类可以分两种，一种是用于装饰的，一种是用于交互的。装饰的无需在artboard上生成组件，直接按照合适的大小调整；交互的需要现在artboard中生成组件，在组件页面编辑完成所有需要的元素（可能在组件中还有小组件生成）。\n对于组件中的文字，一定要说清楚可以容纳的最大字数是多少，作为备注指示之后的程序员。\n文字区域尽量给出提示最多可以容纳最多多少个字符。\n蒙板中的MASK是作为最上面的那一个图层出现的，会用MASK的轮廓呈现出底下多个图片的样子。比如最多的应用就是刘海屏。\n","categories":["UI"],"tags":["UI","SKETCH"]},{"title":"深度学习总介绍","url":"/2020/11/03/back-propagation/","content":"深度学习三个步骤Neural Network前馈feedforward，输入进入网络后流动是单向的。两层之间的连接并没有反馈feedback。\n全链接fully connect，每一层之间两两都有链接。\nInput Layer输入层 1层— Hidden Layer 隐藏层 N层 — Output Layer输出层 1层。\nDeep = many hidden layers\nGoodness of function单个训练样本采用损失函数Loss function来反映模型的好差，利用交叉熵函数对$y$和$\\hat{y}$的损失进行计算。\n\nx_i \\stackrel{\\omega_i}{\\longrightarrow} \\dots\\stackrel{Activation\\,Function}{\\longrightarrow} y_i \\stackrel{Cross\\,Entropy}{\\longleftrightarrow} \\hat{y}_i注意损失函数是定义在单个训练样本上的（在表达式上使用下标，且使用小写的$l$）也就是一个样本的误差。\n所有训练样本\nx^i \\stackrel{Neuron\\, Network}{\\longrightarrow} y^i \\stackrel{Cross\\,Entropy\\, C^i}{\\longrightarrow} \\hat{y}^i总体损失函数Total loss function是所有样本的误差的总和。也是反向传播需要最小化的值。\n\nL = \\sum_{n=1}^{n}{l_n}注意这里的$x^i$不是一维的数据，是用来表示一个对象的多维度向量，$x^i$和$x_i$表示的对象不相同，注意区分上下标。\n注意是吧所有训练数据的损失都加起来得到的总体损失L。为了最小化这个损失L，也就是要在function set里面找一个最优函数，也是酒找神经网络中的参数$\\omega$。\nPick best function使用梯度下降。\nBack Propagation: an efficient way to compute $\\partial{L}/\\partial{\\omega}$ in neuron network.\n\n反向传播反向传播是在使用梯度下降计算参数变化量的时候，让求梯度更方便的一种方法。\n反向传播背后的数学原理就是链式法则。\n因为单个样本的loss function是关于系统输出$y$的函数，输入$x$通过系统一层层传递才到输出$y$，所以链式法则拆分的时候也是拆阶段性结果做微分。\n单个训练样本分析\n输入先进入一个由权重weight和偏移b组成的线性系统获得线性函数输出z。\n线性输出z进入一个激励函数non-linear activation function获得一个非线性输出，该输出作为下一层神经网络的输入。最常用的非线性激励函数就是Sigmoid Function。\n\n为什么需要激励函数？用于加入非线性因素。因为有些数据线性可分，但是某些数据线性不可分。\n神经网络激励函数的作用是什么？有没有形象的解释？ - 颜沁睿的回答 - 知乎\n\n\n\\frac{\\partial l}{\\partial \\omega} = \\frac{\\partial l}{\\partial z} \\frac{\\partial z}{\\partial \\omega}计算$\\frac{\\partial z}{\\partial \\omega} $就是Forward Pass的过程，结果就是the value of the input connected by the weight，该层神经网络的输入。此处需要注意z已经在forward pass中被确定了。\n计算$\\frac{\\partial l}{\\partial z}$就是Backward Pass的过程。运用链式法则的时候需要注意，最终结果$\\partial l$是和$\\partial y$结合在一起的，而$\\partial y$是作为non-linear activation function的输出存在的，而该非线性激励函数的输入又是$z$，即该层神经网络的输入经过线性变换之后得到值。\nMini-Batch相关参数batch_size和nb_epoch。\n实际操作并不总是对所有样本最小化总的损失函数，而是将数据随机分成几个mini-batch，每个batch的batch_size指定之后，可以根据有多少样本算出有多少个batch。\n初始化神经网络参数后，随机选择第一个bacth的样本，对它计算total loss，然后更新神经网络参数；第二个batch..……直到选了batch_size个batch的样本，也就是对神经网络的参数更新了(总样本数/batch_size)次，才能称做遍历了一次nb_epoch。\nbatch_size代表一个batch有多大(就是把100个example，放到一个batch里)；nb_epoch等于20表示对每个batch重复20次。\nTips for Deep Learning在完成深度学习的三个步骤，得到神经网络之后，需要首先考虑是否能在训练集上获得好的表现。\n如果在训练集上不能获得好的表现，需要从Adapative Learning Rate和New Activation Function两方面考虑。\n如果在训练集上表现良好，但是在测试集上表现差，说明是overfitting，从Early Stopping和Regularization以及Dropout三方面考虑。\n训练集表现不好Vanishing Gradient Problem梯度消失是在使用Sigmoid Function作为激励函数时存在的问题。\n依据Sigmoid Function的图像来看，它将输入输出都限定在0～1范围内，随着输入增大靠近一条渐近线。\n当网络比较深，Sigmoid Function的输入值比较大的情况下，每一次对输入值做的变动delta，都会在输出上表现为很小的变动delta，从而靠后的hidden layer对loss的影响非常小。\n\n如何解决梯度消失的问题？\n有两个方式，一是动态调整学习率，二是直接更改激励函数。\n\n更改激励函数ReLU激励函数input&gt;0, output=input; input&lt;=0, output=0.\n对于input&gt;0的范围，在input比较大且变化比较的地方，梯度下降比较快，可以处理梯度下降问题。\n对于input&lt;=0的范围，那些output=0的部分直接可以从整个网络中拿走。最后整个网络就变成了thinner linear network。\n改进1: Leaky ReLu改进2: Parametric ReLU以上改进都是在input&lt;=0的情况下通过乘以一个比较小的参数让output有一点值。\n改进3: Maxout/Learnable Activation Function应该是先对每一层的neuron进行group，每一个group后的结果z都是max{group member result z}，对于所有input的可能取值，就相当于线性规划出了一个linear convex function。group的数量越多，那么convex的角就越多，激励函数也就越复杂，更直观地变成了非线性。\n该如何训练该网络？一方面，max过后，该网络就相当于剪枝了，另外一个线性变化后的z就不需要考虑了，最终还是得到thinner linear function。另一方面，对于较全的训练集input，应当max函数中的每一个weight和bias过后的z都会成为max过后有效网络的一部分。\n动态调整学习率PMSProp/Root Mean Square Prop\nAdagrad中也提出了动态调整学习率，Use first drivative to estimate second derivative。用固定的learning rate除以这个参数过去所有GD值的平方和开根号。\n\n\\omega^{t+1} \\larr \\omega^{t} - \\frac{\\eta}{\\sqrt{\\sum_{i=0}^t(g^i)^2}}g^t\nRoot Mean Square of the gradients with previous gradients being decayed.\n\n\\omega^{t+1} \\larr \\omega^{t} - \\frac{\\eta}{\\sigma^t}g^t \\\\\n\\sigma^t = \\sqrt{\\alpha(\\sigma^{t-1})^2+(1-\\alpha)(g^t)^2}$\\alpha$值调的小一点，说明倾向于相信新的gradient指示的error surface的平滑程度/陡峭程度。\nlocal minima的解决当神经网络很大，参数越多，出现local minima的几率越低。\n联系物理中的惯性，每次移动的方向，不仅考虑某一点的gradient，还考虑前一个时间点移动的方向movement of last step，将这两者求矢量和。\n对于某一个点$\\theta^i$，此处有movement为$v^i$，对该点计算gradient得到$\\nabla{L(\\theta^i)}$，那么下一次移动的方向movement为$v^{i+1} = \\lambda v^i - \\eta \\nabla{L(\\theta^i)} $。如果递推下去，可以有\n\nv^{i+1} = \\lambda{v^i} - \\eta \\nabla{L(\\theta^i)}  \\\\\n\\begin{split}\nv^{i+2} &= \\lambda{v^{i+1}} - \\eta \\nabla{L(\\theta^{i+1})} \\\\ \n&= \\lambda{(\\lambda{v^i} - \\eta \\nabla{L(\\theta^i)})}- \\eta \\nabla{L(\\theta^{i+1})} \\\\\n&= \\lambda^2 v_i -\\lambda\\eta\\nabla{L(\\theta_i)} - \\eta \\nabla{L(\\theta^{i+1})} \n\n\\end{split}$v^i$ is actually the weighted sum of all the previous gradient.越之前的gradient，对此刻的movement影响越小，越多考虑目前的gradient的影响。\nAdam = RMSProp + Momentum\n测试集表现不好注意这个是在训练集表现良好的基础之上进行的。\n此处的测试集是cross validation中从原训练集中抽取出来的validation set。\nEarly stopping虽然训练集在loss降低，但测试集上有可能loss降低后又升高了。需要让epoch停留在测试集的最低点。\nRegulariazation通过给原损失函数添加一个Regularization Term，构成一个新的需要最小化的损失函数。目的是weight decay，closer to zero。\nL2 RegularizationRegularization Term = $\\lambda \\frac{1}{2}  \\left|\\theta\\right|_2$\n$\\left|\\theta\\right|_2 = (\\omega_1)^2 + (\\omega_2)^2 + \\cdots$\n对新的损失函数求微分且合并同类项后可以发现，对已有weight$\\omega^t$总是乘上总小于1的$(1-\\eta\\lambda)$，相比于之前的乘以1，目的是让weight更接近0。是基于已有weight的。\nL1 RegularizationRegularization Term = $\\lambda \\frac{1}{2}  \\left|\\theta\\right|_1$\n$\\left|\\theta\\right|_1 = |\\omega_1| + |\\omega_2| + \\cdots$\n对新的损失函数求微分后发现不可合并同类项，只是减了一个$\\eta\\lambda sgn(\\omega^t)$，每次减的都是固定值。\nDropout训练时，每次在更新参数之前，让每个neuron都有p%的几率dropout，然后使用new thinner network去训练。for each mini-batch, resample the dropout neurons。在加上dropout之后，training set上的测试结果会变差。\n测试时，不做dropout，训练时的dropout rate是p%，则测试时所有的weight都乘以(1-p)%。\n\n为什么dropout会有用？\nDropout is a kind of ensemble. 就相当于把训练集分成了好多个子集，每个子集都生成一个network。当把testing data都分别放入这些网络的时候，每个网络都会给出一个结果，最终给这些结果去一个平均值。\nwhy deep深度学习其实就是模组化。\n每一层neural可以被看做是一个basic classifier，第一层的neural就是最基分类器；第二层的neural是比较复杂的classifier，把第一层basic classifier 的output当做第二层的input(把第一层的classifier当做module)，第三层把第二层当做module，以此类推。\n例子：语音辨识/逻辑电路\nsimilar input — different output / different output — similar output\n","categories":["DeepLearning"],"tags":["ML"]},{"title":"马尔可夫链","url":"/2020/11/03/markov-chain/","content":"State is simply the category.\nMarkov Chains are a combination of probabilities and matrix calculus. \nMarkove Chains model a process that proceeds in steps(time, sequence, trials, etc.); like a series of probability trees.\nTransition diagram 等价于 Transition Matrix，same information represented in different way。\nTransition Matrix的行代表to which state，列代表from which state。每一行的概率相加起来等于1。\n对于一个特定的initial state vector，在经过许多次state的转移后，转移结果会和initial state vector一样\n\nvP=v如果已知Transition Matrix，可以计算出steady state vectors，使用单位矩阵计算。\n\nv(P-I)=0","categories":["Statistics"],"tags":["MarkoveCahin"]},{"title":"图像识别与卷积神经网络","url":"/2020/11/04/cnn-intro/","content":"图像识别的特征Property1： 图像的pattern模式是远小于整张图片的，因此生成一个pattern只需要注意图像的一小部分；\nProperty2：一张图片中不同的区域可能存在相同的pattern；\n因此可以使用Convolution卷积。\n\nProperty3：对图片采样过后不会改变图像所要表达的东西，因此可以对图像做subsampling减小大小；\n因此可以使用Max Pooling。\n\n根据以上三个特性设计出的CNN架构：\n(Convolution — Max Pooling) X N times — Faltten — fully connected feedforward network\n卷积层(nn.Conv2d卷积层 — nn.BatchNorm2d归一化 — nn.ReLU激活层 — nn.MaxPool2d最大池化层)，可叠加很多层，作用是提取出特征。\n全链接层(nn.Linear — nn.ReLU — nn.Linear)，作用是对提取出的特征进行分类。\nAlphaGo能够使用CNN是因为它和图像有相似的特性。\n具体实现图片的表示方式对于黑白图片，每一个pixel就只有0，1两个取值，是一个二维矩阵。\n对于彩色图片，用RGB表示，每个pixel用0～255范围内的三个值表示，是三个二维矩阵。（因此我们的一张图片除了长和宽还拥有了高）\nConvolution依据Property1，为了生成一个pattern，需要使用filter。filter也是一个矩阵，维度需要自己选择。一个filter对应到图片中的某一个子矩阵做内积（对应元素相乘后整体再相加），然后向右移动stride=n个单位元素，从左至右从上至下一次移动。\n\nfilter移动的方向，要有具体意义。\n比如在文本识别中使用CNN，每一个单词都有一个vector，filter移动的方向一定是多个完整单词的vector的组合的方向，把一个vector拆分多次移动是没有具体语义的。\n\n当一个filter对一张图片完成一次移动之后，会生成一个新的矩阵。当新的矩阵中有相同的元素时，就代表有相同的pattern在这张图中，对应到Property2。\n以上过程对每一个滤波器都来一边就得到了对这张图像的Feature Map。\n全链接网络和卷积的关系卷积就是内积之和，相当于两个向量做inner product。\n全链接网络中给每个input一个weight然后把它们相加添一个bias得到输出，这个形式和卷积相似。可以把图像的二维矩阵转换成一维向量，按照index/row方向拼接成一个向量。\n对应起来就是，filter的作用对象就是这个向量中的某些分量，filter就是全链接网络每一个neuron的weight，内积之后的结果就是该neuron的输出。\n重要的是对于每一个filter，他们的weight都是相同的，通过实现shared weights可以实现神经网络较少的参数。\nMax PoolingFeature Map中是每一个filter作用于原图像后得到的Matrix。把该Matrix中的数据均分成几组，每组内进行基础的数学运算（如取平均，取最大），每组的多个数据变成一个数据。目的是为了让图像缩小。\nFlattenflatten就是把Feature Map中多层Matrix拉直成一个vector，每个matrix从左至右从上至下拉直成一个vector，多个matrix前后拼接在一起。\n作为输入连接到全连接网络中去。\n如何训练for each filter定义degree of the activation of the k-th filter为\n\na^k = \\sum_{i=1}^{n}\\sum_{j=1}^n a_{ij}^k意思是把图像通过该滤波器之后得到matrix的所有元素的和当作这个滤波器对这张图片响应的大小。\n想知道第k个filter的作用是什么，就需要照一张图片作为输入，能够让第k个filter被激活的程度最大。也就是找最大值的问题，可以用gradient descent来求。和之前不知道weight，需要依据输入用梯度下降把参数weightupdate出来不同，现在是把输入的图像当作需要找的参数用gradient descent做update，因为作为weight的filter的是已经固定的。\n因此对于每个filter，都可以训练出一个能让该filter的degree of the activation最大化的pattern。注意结果不是一个完整的图片，而可能是某一种纹理，重复出现的pattern。\nfor fully connected NN在全连接层的每一个neuron的作用是什么呢？\n当找一个图像作为input输入，每一个neuron对这张图片都有不同的输出$a_i$，我们需要找出能够让该neuron输出最大结果的input图像。注意此处的input图像已经开始处理整张图了，而不是图的一小部分。\n当找一个图像作为input输入，最终的输出$y_i$要被最大化，确定能够让该output layer输出最大结果的input图像。但是输出的结果可能和人类辨识图像的方式不同；所以需要添加一些constraint（例如L1 Regularization），让输出更容易被人类理解。\n","categories":["DeepLearning"],"tags":["CNN"]},{"title":"半监督学习","url":"/2020/11/05/semi-supervised-learning/","content":"介绍半监督学习就是除了有input和label一一对应的数据之外，还有一笔数据只有input没有label。\n虽然unlabeled data没有对应的output，但是unlabeled data的分布可以告诉我们一些事，从而影响我们的决定。因而在使用半监督学习的时候往往需要有一些分布假设。\n分类有两个：\n\ntransductive learning(unlabled data is the testing data)\n\ninductive learning(unlabeled data is not the testing data )\n\n\n半监督生成模型监督生成模型在「概率分类与Logistic回归」中有详细说明。首先是先验部分，通过训练集的数据做每个类服从高斯分布的假设，获得每个类的期望和方差。其次是后验部分，通过给的一个新的input data做分类，决定decision boundary在哪里。\n在半监督生成模型中，unlabeled data能对estimate parameters的结果有影响，对于每个类的期望和方差有影响，从而影响decision boundary。\n具体操作Initialize estimatorsgiven initial estimators\n这组初始化参数是通过已有的labeled data估测出来的。\nE-Step/Compute the posterior probability of unlabeled data这个几率算出来是怎么样的取决于modell值，是基于步骤一中的modell算出来的后验概率。\n感觉这个过程就像在测试model，给它一个input，看他的output。与testing data的不同在于，这个output不是用来衡量学习的优劣的，而是作为一笔数据更新model的参数。\nM-Step/Update model依据步骤二算出来的unlabeled data属于model下的Class 1的概率，更新模型参数。\n\n如何更新\n\nP(C_1) = \\frac{N_1+ \\sum_{x^u}{P(C_1|x^u)}}{N}分子中代表labeled data中属于Class 1的个数，分母中就是所有labeled data的个数。\n如果不考虑unlabeled data，结果就是这两个数据的分式子。\n如果考虑unlabeled data，需要把所有unlabeled data中属于Class 1的后验概率的和考虑进去。\n\n如何更新\n原本不考虑unlabeled data的时候，Class1的期望就是把所有属于Class 1的input做平均。加上unlabeled data之后就是把每一笔unlabeled data的数据和他的相对应的概率想成之后再除以总的概率和。\n\n\\mu^1 = \\frac{\\sum_{x^r\\in C_1}x^r}{N_1} + \\frac{1}{\\sum_{x^u}P(C_1|x^u)} \\sum_{x^u}{P(C_1|x^u)}x^u\nE-M算法：更新完所有的参数之后又返回步骤二，一直循环到步骤三结束，最终是收敛的结果。\n假设一：Low-density Seperation表示“非黑即白”，在类间交界处，数据的密度较低，可以勾画一个十分明显的界限。\nSelf-trainingself-training是最简单的一种实现low-density seperation的方式。\n如何实现有unlabeled data set和labeled data set。从labeled data set中训练出一个model，然后将这个model应用到unlabeled data set上获得预测出的pseudo-label。然后从unlabeled data set中移除（how to choose data？）一部分数据并添加到labeled data set中，更新模型。\n需要注意调整概率阈值threshold，或是多次取样来获得比较可信的数据。例如设置pos_threshold = 0.8，只有 prediction &gt; 0.8 的 data 会被标上1。\n类比GenerativeModel可以看出来过程和半监督生成模型类似。主要区别在于对unlabeled data set的output处理。\nself-training使用hard label，即unlabeled data就一定会属于某一个class；generative model使用soft label，即unlabeled data有多大概率属于Class 1，有多大概率属于Class 2。\n显然，生成模型和Self-traning所要求的“Low-density Seperation”/非黑即白相矛盾，因而生成模型不会在neuron network起作用。\nEntropy-based Regularization既然需要unlabeled data能够促进“非黑即白”，联系信息熵，就要求这个unlabeled data通过这个model之后的输出output信息熵越小越好。\n对unlabeled data output求信息熵\n\nE(y^u) = -\\sum_{m=1}^{N^u}y_m^u\\ln{y_m^u}可以重新定义model的Loss Function为\n\nL = \\sum_{x^r}{C(y^r, \\hat{y}^r)} + \\lambda E(y^u)\\\\第一个式子是在用交叉熵衡量labeled data上model的output和real data output的距离，希望越小越好；第二个式子是在用熵衡量unlabeled data上model的output的混乱度，自然是越小越好。参数带表了你倾向于偏向unlabeled data多一点还是少一点。\nSemi-supervised SVMSupport Vector Machines穷举所有的unlabeled data。\n假设二：Smoothness Assumptionsimilar x has the same y hat.\n因为x的分布不是平均的，它在某些地方十分集中，某些地方又十分分散，如果x1和x2在a high density region中十分相近，那么他们的输出label可以很相近。（x1和x2可以看作相近相似的中间状态，不相似的data可以看作是跳跃状态？）\nCluster and then labelCluster and then label是最简单的实现Smoothness assumption的方法，但是要求聚类很强。一般都是用一个很好的方法来描述image，提取特征后再进行聚类。\nGraph-based Approach用high density path连接起来的一个区域就是a high density region，相当于在结点之间画边。\n画边方式与相似度有两种方式：\n\nK nearest Neighbour\n\ne-neighbour\n\n\n同样考虑到图论中边和边权。可以给相连的边一些权重，让edge和他两端的points的相似度是成正比的。定义相似度选择Gussian Radial Basis Function:\n\ns(x^i, x^j) = exp(-\\gamma||x^i-x^j||^2)算出两个point的距离之后乘以一个参数取负号在exponential。\n定量描述the smoothness of the labels on the graph\nS = \\frac{1}{2}\\sum_{i,j}{\\omega_{i,j}(y^i-y^j)^2} = \\boldsymbol{y}^TL\\boldsymbol{y}第一个表达式中，是为了后续做微分方便而添加的；是两个data point之间的权重，即边权；就是两个data point之间的距离。注意这个式子是对连成图之后的所有data point而言的。这个式子越小代表越光滑。\n第二个表达式中，是一个(R+U)维度的向量，是一个(R+U)x(R+U)的矩阵，叫做Graph Matrix。\n\n\\boldsymbol{y} = [\\cdots y^i \\cdots y^j \\cdots]^T \\\\\n\\boldsymbol{L} = \\boldsymbol{D} - \\boldsymbol{W}其中代表图的邻接矩阵，是邻接矩阵每一行的和放在对角线上。\n由smoothness到loss function在原来的loss function中，有labelled data训练之后的cross entropy，此外添加带的smoothness of the labels on the graph项。因为平滑度是取决于nueron network的，而要找的nueron network就是一组参数。\n其实smoothness of the labels on the graph项不一定要放在output layer，可以放在某些hidden layer中。\n","categories":["DeepLearning"],"tags":["ML","半监督学习"]},{"title":"无监督学习","url":"/2020/11/06/unsupervised-learning/","content":"聚类聚类的几种常用方法：K-means，Hierarchical Agglomerative Clustering(HAC)。\nK-means需要事先决定有K个cluster，每个cluster初始的center也要从training data中随机找k个出来。\nHierarchical Agglomerative Clustering(HAC)就是建树，对每个data两两计算相似度，挑出最相似的一对data，merge成一个新的data vector。一直从下至上构建出root。要分类就是在每一层切一刀获得一种聚类方式。\nDimension Reduction降维降维的本质就是需要找一个function，当我们input一个vector x的时候，output是另外一个vector z，且output dimension小于input dimension。\n特征选择把data的分布拿出来看一下，发现都集中在某个特定的dimension，那么就拿掉其他dimension就可以。但问题是很多时候任何一个dimension都不能拿掉。\nPrincipal Component Analysis 主成分分析一维需要reduce to 1-D，就是要矩阵中的每一行的data points 投影到，然后就可以得到对应的，不同的 投影过后都是相同的。这里的就是的第一行。\n该如和确定这个？我们希望投影后所有点之间的奇异度越高越好，对应到数学上就是的方差越大越好。\n\nVar(z_1) = \\sum_{z_1}(z_1-\\bar{z}_1)^2 \\quad \\left\\|w^1\\right\\|_2=1高维现在想要投影到一个二位平面，除了把矩阵中的每一行的data points 投影到，还要把矩阵中的每一行的data points 投影到，这里的是的第一行和第二行。\n除了基向量的模为1的约束条件，还需要基向量之间是垂直的，代表基向量之间正交。因而可以说是一个正交矩阵orthogonal matrix。\n如何寻找正交基的寻找\n\\begin{split}\nVar(z_1) &= \\frac{1}{N}\\sum_{z_1}(z_1-\\bar{z}_1)^2 \\\\\n&= \\frac{1}{N}\\sum_{x}(w^1\\cdot x-w^1\\cdot\\bar{x})^2 \\\\\n&= \\frac{1}{N}\\sum_{x}(w^1\\cdot(x-\\bar{x}))^2\n\\end{split}向量内积可以和矩阵乘法转换（第一个等式），scalar做Transpose之后仍然是一个scalar（最后一个等式），获得如下式子：\n\n(a\\cdot b)^2 = (a^Tb)^2 = a^Tba^Tb=a^Tb(a^Tb)^T=a^Tbb^Ta带入原方程得到\n\n\\begin{split}\nVar(z_1) &= \\frac{1}{N}\\sum_{x}(w^1\\cdot(x-\\bar{x}))^2\\\\\n&= \\frac{1}{N}\\sum_{x} (w^1)^T(x-\\bar{x})(x-\\bar{x})^Tw^1 \\\\\n&= (w^1)^T \\frac{1}{N}\\sum_{x}(x-\\bar{x})(x-\\bar{x})^T w^1 \\\\\n&= (w^1)^T Cov(x) w^1 \\quad S = Cov(x)\n\\end{split}也就是说我们需要找的就是能够让最大，且满足约束条件的向量。约束条件是为了保证解出来的vector存在有限个。\n运用Lagrange Multiplier拉格朗日数乘法\n\ng(w^1) = (w^1)^T S w^1 - \\alpha((w^1)^Tw^1-1)对这个式子求偏导数，得到\n\nSw^1 = \\alpha w^1 \\\\\n(w^1)^TSw^1 = \\alpha (w^1)^Tw^1 = \\alpha意思就是是协方差矩阵的特征向量，且它是对应到最大的特征值的那个特征向量。\n的寻找有两个约束条件，因而拉格朗日数乘法的对象如下\n\ng(w^2) = (w^2)^T S w^2 - \\alpha((w^2)^Tw^2-1) - \\beta((w^2)^Tw^1-0)对这个式子求偏导数，再同时乘以，得到\n\n\\begin{aligned}\nS w^2 - \\alpha w^2 - \\beta w^1 = 0 \\\\\n(w^1)^T  S w^2 -  (w^1)^T  \\alpha w^2 - (w^1)^T \\beta w^1 = 0 \\\\\n((w^1)^T  S w^2)^T -\\alpha \\cdot 0 - \\beta  \\cdot 1 = 0 \\\\\n\\beta = ((w^1)^T  S w^2)^T = (w^2)^TSw^1= (w^2)^T \\lambda_1 w^1 = 0\n\\end{aligned}上面的推导表明，那么最初的式子就可以写成\n\nSw^2=\\alpha w^2意思就是是协方差矩阵的第二大的特征向量，且它是对应到最第二大的特征值的那个特征向量。\n投影后数据的特征投影和的数据在新的坐标的各个维度之间是不相关的，在数学上的表示就是投影后的的协方差矩阵是一个对角矩阵diagonal matrix。好处是实现模型的时候可以减少参数。\n从另一个角度理解PCA一个输入input可以看作是有限个component的线性叠加加上所有input的平均值。\n\n\\begin{array}{ll}\nx = \\bar{x} + \\hat{x} \\\\\n\\hat{x} = c_1u^1+c_2u^2+ \\cdots+c_Ku^K\n\\end{array}Reconstruction error: \nFind  minimizing the error\n\nL = min_{\\{u^1, u^2 \\cdots, u^k\\}}\\sum\\left\\|(x-\\bar{x}) -(\\sum_{k=1}^K{c_ku^k})\\right\\|_2这里要找的就是对应前面PCA中的。但是这两者有有不同，因为前面PCA要求必须垂直（线性情况较快），但此处用gradient descent求解出来的对象不一定保证垂直（但是可以deep）。\nPCA looks like a neuron network with one hidden layer(linear activation function).\nPCA involves adding up and substracting some components, and then the componets may not be part of the input. 也就说是用PCA解得得结果不一定是直观上我们可以理解的东西，为了让eigen vector直观化，需要使用Non-negative matrix factorization（NMF），要么让线性叠加的系数为正，要们让线性叠加的子部component为正。\n弱点有可能把两个class都放到一个vector上去。需要用到Linear Discriminant Analysis。\n只适用于线性。\n矩阵分解 Matrix Factorization推荐系统中，通常我们只会得到一个作为评分结果的矩阵MXN，这个矩阵是两个矩阵（用户-特性矩阵和特性-物品矩阵）通过某些factor作用的结果。如果这个MXN的矩阵中有缺省内容，如何通过已有信息预测空缺项？\n用户维度为M，物品维度为N，特性维度就是latent factor的数目假设为是K。我们希望找到MXK，和KXN的矩阵，让他们相乘之后的结果与评分矩阵MXN最接近，需要minimize error。\n对于损失函数的定义如下：Minimizing\n\nL = \\sum_{(i,j)}{(r^i\\cdot r^j-n_{ij})^2}Only considering the defined value and find by gradient descent.\n当然也可以在loss function中添加偏置项，更多其他与i有关的scale和与j有关的scale。\nWord-embedding词嵌入为什么需要词嵌入？\n传统的表示一个文字的方法就是1-of-N encoding，每一个word用一个vector来表示，这个vector的dimension就是这个世界上可能有的word的数目，很显然这过于大了。但是词汇之间是有联系的，可以组成word class，因此可以把同样性质但是不同的word用所属的class来表示。\n词嵌入就是把每一个词都project到high dimension space上去，在这个高维空间中每一个word embedding都有一个feature vector。\n如何找到适合该词的词嵌入？了解一个词汇的含义需要看该词的contex。\ncount-based基于计数的词嵌入原则是单词的word vector是，单词的word vector是，计算出这两个word vector的inner product后我们希望该值和两个词在该文章中同时出现的次数越近越好。其实这个思想和matrix factorization类似。\nprediction-based预测结构最朴素的就是拿前一个词汇去预测后一个词汇，也可以用前后词汇预测中间词汇，也可以用中间词汇预测前后词汇。\n输入输出定义希望同class的多个先后连续的词作输入的时候，输出是预测的下一个词汇。为了实现这个效果，中间hidden layer需要通过weight对输入进行转化，让他们对应到相同的空间\ninput是1-of-N encoding of the word （需要把这两个列向量接在一起变成一个很长的vector放到neuron network中去，有点像CNN中的Flatten）。\noutput是the probability for each word as the next word 。\n需要注意的是，两个vector对应的维度上对应到neuron network中的同一个neuron的weight是一样的（sharing parameters）。\n如何训练为了让和最终迭代结果相同，一开始就需要赋予相同的初始值，且在更新参数的时候，二者的更新表达式相同，除了Cross Entropy对自己的微分，还要算上Cross Entropy对另外一个权重的微分。\n多语言与多领域需要事先知道某几对英文单词和中文单词的对应关系，把这个当作输入放到model中去learn，这个训练好的model的功能就是如何把未知的新的中文和英文对应的词汇放到一起，并投射到空间上的同一个点。\n同样的英文和中文单词的对应可以转换成单词和图像的对应关系。\nNeighbour Embeddingdata point可能是在高维空间中的一个manifold，实际上这笔数据完全可以放到低维空间来描述。高维空间中的问题在于如何描述两个数据的距离/相似度，用欧氏距离没有意义。\n因而需要manifold learning把高维空间里的数据摊平到低维空间（属于非线性降维），再计算点和点之间的欧氏距离，结合后续的监督学习。\nLLE 局部线性嵌入 Locally Linear Embedding原来的空间里面的点之间的关系用weight来表示，假设某一个点可以通过它的邻居的线性组合而成，因此我们需要让线性组合后的结果和原点的距离越近越好，也就是最小化所有的点的距离之和。总结：已知高维空间中的数据，求出数据之间的关系weight。\n假设从高维空间到低维空间，描述空间里点之间关系的weight是不变的，因此可以用上面求出来的weight用同样的方式定义一个相似的函数。总结：已知的是数据间的关系weight，求的是低维空间中的数据。\nLE 拉普拉斯特征映射 Laplacian Eigenmap在semi-supervised learning中提出过graph-based approach以及定量描述smoothness相类似，最重要的区别在于有带label的数据项去约束smoothness的表达式。\n我们希望close in high density region中的数据投射到低维空间之后数据还是很相近，但是要对投射后的结果加一点constraint，如果一开始的维度是M，那么找出来的那些在低维空间的点做span之后还会恢复成原来数据的M维度（可逆？）。\nT-SNET分布随机领域 T-distributed stochastic neighbour embedding\nwhy以上都假设相近的点非线性降维之后都相近，但是却没有说不相近的点非线性降维之后都不相近（有可能不相近的点线性降维之后反而相近了）。\n之前都是针对某一个数据locally的相近，如果从整体上看呢？我们要求投影前后的数据的分布distribution相近。\nhow如何计算？\n分别计算出所有投影前数据x之间的similarity（已知），并写出投影后数据z之间的similarity（未知），让这两个值之间的KL distance越小越好，从而可以求出未知的投影后的数据z。\n如何定义和选择similarity？\n分投影前数据的similarity和投影后数据的similarity考虑。\n投影前数据的similarity用负的欧氏距离去exponent，因为距离一大，similarity就会非常小，确保了只有非常相近的点才有值。\n投影后数据的similarity有两种方式。可以选择和投影前数据相同的衡量方式，这样总的方法就是SNE；但更好的是选择T-dirtribution中的一种用欧氏距离加上一，整体取个倒数作为similarity，这样总的方法就是T-SNE。\n自编码器 auto encoder想找一个编码器，input是一个比较复杂的东西，encoder就是一个neuron network，它的output就是code，维度远比输入要小实现了类似压缩的效果。\n结构如下：input layer — layer1 — layer2 — … bottle… — layer2’  — layer1’  — output layer\ninput layer到bottle是属于encoder，bottle到output layer属于decoder，bottle的结果就是code。也就是dimension reduction的过程和reconstruct的过程。\nTIPS on auto-encoderAdd Noisede-noising auto-encoder，input加上noise之后再去encode，output要和加noise之前的原来的input越近越好。Neuron Network不仅学到了encode这件事，还学到了过滤噪音。\nPre-training一般用于参数的initialization，pre-training就能让你找到一组好的初始化参数。\n注意一般做auto-encoder的时候，希望coder的dimension要比input dimension小，如果coder的dimensionbiinput dimension大的话，需要加一个很强的regularization，避免auto-encoder直接把input并起来再输出（也就是learn不起来）。每一个步骤得到的weight都fix住，然后再输出结果之后再backpropagation微调fine-tune一下这些weight。\n适合于大量unlabeled data存在，少量labeled data的情况。大量unlabeled data用于得出最初的weight，少量labeled data用于fine-tune。\n应用文本检索 Text Retrieval把一篇文章压缩成一个code，利用降维将它表示成空间中的一个vector，现在有一个词汇用于查询，把查询的词汇也变成空间中的一个点，计算该查询次和每个document之间的内积，越大的内积代表相似程度最高。\n如何把一个document表示成一个vector？\n可以使用bag-of-word，vector的size就是所有lexical单词的个数，可以乘上weight代表每个单词的重要性。缺点在于缺失语义，词汇之间没有相关性。\n可以使用auto-encoder使语义考虑进来。\n类似图像搜索 Similar Image Search如果单纯比较query image和database中image的pixel的相似度的话，结果会很不好。\n需要用一个auto-encoder把image变革一个code，再在code上面去搜寻。\nCNN auto-encoderunpooling无池化，记录pooling的位置，把pooling后的值放在这个记录的位置上，其他都放0。或者也不用记录pooling位置，直接全部复制。\ndeconvolution反卷积，本质也是convolution，只不过weight相反。\n","categories":["DeepLearning"],"tags":["ML","无监督学习"]},{"title":"深度生成模型","url":"/2020/11/07/generative-model/","content":"PixelRNN图像由pixel构成，在随机给了初始的pixel之后，当作输入放到model中去，output是什么样的pixel，那么就在初始pixel之后补上该输出，然后目前有的pixel都又当作输入进入model，直到完成绘图。\n描述一个pixel可以采用RGB表示，每一个pixel就是三维的vector，但是按照上面的描述我们的input pixel是可变的，他把上一次的输出当作了输入，因而需要用到RNN。\nVAE Variational Auto-encoder如果把auto-encoder中的NN decoder单独拿出来，通过随机生成一个向量当作该decoder的input code，看能不能输出图像？但是结果不太好。\n此时需要VAE，沿用auto-encoder中encoder和decoder两个部分，但是在中间结果中对encoder的输出/decoder的输入做一些变更，训练的目的就是minimize reconstruction error。\n\n做那些变更？通过引入一个normal distribution和$\\sigma$方差来增加noise。增加noise的目的是让稍微变化了之后的code进入decoder之后还能够还原变化之前的code，有容错能力。\n如何minimize reconstruction error？其实就是通过这个loss function找对应的$\\sigma$的值。本质上这些变更还是在train一个NN。\n为什么loss function是这样的形式？可以看到当$\\sigma$取0的时候，前面两项直接就是0，让error最小，相当于什么也没有学到，所以需要一个L2 regularization term，让结果不会overfitting。\n局限在于只能模仿，不能创造。\n\nVAE是gaussion mixture model distributed representation的版本。\n我们从一个normal distribution（这个normal distribution是一大堆gussian distribution的表示）中sample出一个z，这个z接下来会决定某个特定的gaussion distribution的expectation和variance。\n如何决定z？相当于z作为input通过了两个function（也就是通过一个NN训练出来），得到了expectation和variance。通过这个特定的高斯分布，就可以获得最终的x的分布。求x的分布就是条件概率分布求解。\nGAN Generative Adversarial NetworkGenerator和Discriminator协同更新。\n第一代generator不知道real data是什么样的，根据随机的输入生成一大堆不是很好的东西。\n第一代discriminator在看过real data后，判断generator的生成物是0或1，0判断为这个是假的是生成的，1判断为这个是real的。\ngenrator为了骗过discriminator根据generator的评判结果不停地优化参数，discriminatior也不不停地优化。\nGeneratorrandomly sample a vector — NN generator  — image — discriminator — score on the image\n以上的流程和一个完整的NN是很类似的，只不过在调整generator的参数的时候要fix住discriminator的参数，且要做到让generator的评判结果越来越靠近1。\nDiscriminator辨别器适用于判断生成器的结果是否是真的。生成器会根据辨别器的判断结果去重新调整自己的参数。\n整个流程的生成结果是基于discriminator的，问题在于discriminator如果很弱就没有办法达到预期目的。\n","categories":["DeepLearning"],"tags":["ML","无监督学习"]},{"title":"支持向量机","url":"/2020/11/07/svm/","content":"Linear SVM modelStep1: Function Model\nf(x) = \\sum_{i}{w_ix_i+b} = \\begin{bmatrix}w \\\\ b\\end{bmatrix}\\cdot \\begin{bmatrix}x \\\\ 1\\end{bmatrix}=w^TxStep2: Loss Function\nL(f) = \\sum_n{l(f(x^n, \\hat{y}^n))+\\lambda\\left\\|w\\right\\|_2} \\\\\nl(f(x^n, \\hat{y}^n)) = max(0, 1-\\hat{y}^nf(x))Loss function的第一项是一个凸函数，第二项也是个凸函数，因此loss function整体也是凸函数。有不可微分的地方，但是可以用梯度下降做优化器。第一项的定义涉及了loss function，也就是Hinge Loss的方法。\n第一项中的是代表属于哪一个class的label，是预测后的分类结果。\nStep3: Gradient Descent第一种理解做微分，先不考虑第二项。\n\n\\begin{array}{ll}\n\\frac{\\partial{l(f(x^n, \\hat{y}^n))}}{\\partial w_i} &= \\frac{\\partial{l(f(x^n, \\hat{y}^n))}}{\\partial{f(x^n)}}\\cdot\\frac{\\partial{f(x^n)}}{\\partial w_i}\\\\\n&=\\frac{\\partial{l(f(x^n, \\hat{y}^n))}}{\\partial{f(x^n)}}\\cdot x_i^n \\\\\n&= c^n(w) \\cdot x_i^n\n\\end{array}\n第二种理解用一个极小项取代损失函数L中的，我们叫这个极小项是一个slack variable。\n\nKernel MethodDual Representation\n如果对于之前求出的迭代更新的式子，把初始化为0，式子变成所有数据的线性组合。\n线性参数可能是0，因为结合前面在定义Loss function的时候选择了Hinge Loss。也就是有可能就是取0（在fit很好的情况下），有可能不是0（在fit不好的情况下），到最后模型越fit，线性参数线性参数取0越多，越sparse。\nsupport vectors就是那些线性参数不为0的。\n这样结合的好处是：不是支持向量的数据点（有可能是outlier），去掉（线性参数是0）也不会有多大影响。如果用了Cross Entropy定义loss function，每一笔data对模型参数的迭代结果都有影响。\nKernel Trick改写函数集为Kernel Function重新表示模型参数为\n\n重新表示模型函数集为\n\nf(x) = w^Tx = \\boldsymbol{\\alpha}^TX^Tx=\\sum_na_n(x^n\\cdot x)\n把内积写成核方法就是核函数，称为核技巧。写成这样的好处就是，不用具体的知道每一个data的向量表示求出内积，我们只需要知道Kernel Function的输出就可以了。\n接下来最小化损失函数，也就是训练目的：找一组，是loss function最小。好处是只需要知道input data vector之间的内积。\n\n什么时候用Kernel Trick？\n不止用在SVM中。当我们对data的表示比较困难，或者说需要对input data用好几个hidden layer做feature transform，这时候Kernel trick is useful when we transform all x to 。\n我们需要把feature transform后的多个data vector做inner product，因为做feature transform之后维度变大了，所以运算量很大。\n而Kernel Trick告诉我们，你直接算原来的data vector，做inner product再平方就可以了，和上面的过程得出的结果是一样的。\n\n依据核函数的定义方式有很多变化。\nRadial Basis Function Kernel在一个无穷多维的空间做inner product。推导涉及exp函数的泰勒展开。\nSigmoid Kernel\nK(x,z) = tanh(x \\cdot z)\\\\\nf(x) = \\sum{\\alpha_nK(x^n,x)} = \\sum{\\alpha_n tanh(x^n \\cdot z)}每一个函数都可以看作一个Neuron Network。原始数据到第一层neuron的weight就是每一个data point，neuron的数目就是support vectors的数目。\n\n更多的启发直接设计Kernel Function，不用理会x和z的的feature。Kernel Function有点类似于把x和z放到高维之后的相似度。\n核函数做了什么？我们要找的这个Kernel Function，把x和z放进去，会得出一个value，这个value代表了x和z在高维上的inner product。\n什么样的data适合核方法？When x is structured object like sequence, hard to design its feature transformation function 。（没有办法直接用以vector来描述）\n","categories":["DeepLearning"],"tags":["ML","SVM"]},{"title":"transfer-learning","url":"/2020/11/07/transfer-learning/","content":"数据Source Data(Not directly related to the task)\nTarget Data(directly related to the task)\n每种data分为labeled和unlabeled。一共有四种情况。Target data量少才需要迁移学习。\none-shot learning: only a few examples in the target domain.\nLabeled Taregt Data + Labeled Source DataFine-Tune用source data训练一个模型，然后用少量的target data去fine tune这个模型，主要是训练出来的模型侧重于target domain做的是否好。\n问题是如果source data很少，本来做出来的模型就很烂根本不能在target domain有很好的表现怎么办？提供以下两个技巧。保守训练和层迁移。\n保守训练 Consevative Training大量的source data训练出一个NN1。\n用少量的target data去训练一个NN2。\n这两个model需要比较类似，但又要有不同。通过加一些regularization让NN2和NN1在面对相同的data的时候输出的结果不同。\n层迁移 Layer Transfer用source data训练出一个NN1。\n把这个训练好的NN1种的几个Layer拿出来copy到新的用target data训练的NN2里面去，在训练NN2的时候只需要训练剩下的没有收到copy Layer的那些参数。\n如何选择那些layer被transfer？依据不同的task而定。在语音辨识中需要用到最后几层，因为前几层是在判断发音方式（因人而异），后几层就是从发音方式到判断结果了（统一）。在图像中一般选择前几层，因为前几层是在找出最细节的简单图形或纹理，越到后面越复杂。\nMultitask Learning多任务学习中我们同时要求模型在target domain和source domain中表现良好。\n有一种情况是taskA和B之间存在共通性并且可以直接表示出来，model的前面几个layer共享参数，后来衍生出分支。\n另外一种情况是taskA和B之间共通的input feature没有办法确定，所以一开始model有多个分支的input，通过最初的几层独立的layer把input转移到同一个domain上去（先抽取feature），获得共通性表示之后中间layer共享参数，最后再重新分流。\nUnlabeled Taregt Data + Labeled Source DataDomain Adversarial Training结构feature extractor — label predictor + domain classifier\nfeature extractor的任务是把domain的特性去除掉，为了衡量feature extractor做得好不好，要在feature extractor的后面接一个domain classfier，它需要判断这个feature 来自哪一个domain，到最后训练效果很好的话domain classfier肯定不知道feature来自哪一个domain，也就是说最后它一定fail。\n但是只有这样的结构就学不起来，因为只要feature总output0，dimain classfier怎么也分不出来。因此要增加featur extractor的任务难度，在它后面接一个label predictor，意思就是要feature extractor在消除domain特性的同时，尽可能保留原来数据feature的特性。\n训练在做back propagation的时候在feature extractor和domain classifier之间天一个gradient reversal layer，实现负反馈；feature extractor和label predictor之间就是正常的gradient decscent。\nZero-shot learning零样本学习database中储存所有不同的可能的class和它的特性。\nNN的input是数据，output是该数据的特性。然后根据特性查找database对应到具体的class。\nattribute embedding如果attribute非常复杂，考虑attribute embedding。也就是对input和attribute做降维。\n有一个embedding space，每一个original input$x^n$和attribute of original input$y^n$都通过NN投射到同一个点或者相近的点$f(x^n), g(y^n)$上。训练这个模型不应该是最小化$f(x^n), g(y^n)$的距离（因为直接就把所有data都投射到同一个点上去了），应该让目$f(x^n), g(y^n)$的距离比所有$f(x^n), g(y^m)$的距离都近，设定一个defined margin k。\n当有一个未知的original input，把它投射到embedding space上去，找和哪一个attribute在embedding space上的投影最接近。\nattribute embedding+word embedding适用于没有database的情况。\nconvex combination of semantic embeddingoutput不决定是哪一个class，只输出可能的class的概率，把这些概率和class vector做线性相加得到一个新的混合后的vector，再看哪一个人class vector和这个新的vector最接近。\nLabeled Taregt Data + Unlabeled Source DataSelf-taught learning\nUnlabeled Taregt Data + Unlabeled Source DataSelf-taught clustering\n","categories":["DeepLearning"],"tags":["ML","迁移学习"]},{"title":"MLHW2-tips","url":"/2020/11/08/MLHW2-tips/","content":"文件类型原始数据给的是CSV格式，但是经过助教整理，解压缩后是不带后缀名的UNIX可执行文件。\n如何确定一个文件的类型？在终端使用file &lt;path&gt;命令就可以获得文件类型。终端显示助教给的文件是ASCII text，是用ASCII编码的纯文本文件，可以用任何文本编辑器打开。\n同时打开txt文本编辑器，把文件拖动到其中就可以获得文件路径。\n从文件提取数据首先保存数据路径，再从用with open(Path-for-XY) as f读取数据。\n保存数据路径，可以给定路径，也可以用&#123;&#125;表示不定路径，在使用不定路径的时候一定要format语句with open(output_path.format(&#39;logistic&#39;), &#39;w&#39;) as f:。\nX_test_fpath = &#x27;./Dataset2/X_test&#x27;output_path = &#x27;./output_&#123;&#125;.scv&#x27;\n读取数据要对数据的换行符和分隔符做处理，才能把数据放到numpy array中。strip在每一笔数据之间删除换行符；split函数在每一笔数据中删除每一个维度/feature上的分隔符。\n在读取数据的时候要注意是否存在head，next(f)就是跳过头部。\nwith open(X_train_fpath) as f:    next(f)    # 跳过第一行的列说明    X_train = np.array([line.strip(&#x27;\\n&#x27;).split(&#x27;,&#x27;)[1:] for line in f], dtype=float)    # strip用于忽略换行之类的，split用于根据标记分离单独的数据\n训练TIPS交叉验证集利用矩阵的slice实现验证集和交叉集的分割，从dev_ratio获得train_size。\n在完成分割后检查一下X_train/Y_train/X_dev/Y_dev的size和dim，调用shape函数，该函数返回一个list。\ntest_size = X_test.shape[0]data_dim = X_train.shape[1]print(&#x27;Size of testing set: &#123;&#125;&#x27;.format(test_size))print(&#x27;Dimension of data: &#123;&#125;&#x27;.format(data_dim))\nShuffling目的是把每笔数据的顺序打乱，标签还是对应原来数据的。\n最后return的是用一个索引去索引另一个索引。 numpy-array[numpy-array] or numpy-array[list]是可行的，但list[numpy-array]就会报错，索引时尽可能使用numpy数组。\n参考TypeError: only integer scalar arrays can be converted to a scalar index的处理方法\ndef _shuffle(X, Y):    randomize = np.arange(len(X))    np.random.shuffle(randomize)    return (X[randomize], Y[randomize])# 如果X和Y都是List，即我们在test它的性能时使用np.array(list-item)作为输入就不会报错# print(_shuffle(np.array([1,2,3,4]), np.array([1,1,0,4])))# 用numpy数组去索引List会报错Only integer scalar arrays can be converted to a scalar index# numpy.random.shuffle会改变传入原来传入的numpy数组# 一般讲要索引的target转换成numpy数组进行操作，尽可能将数据类型转换为numpy数组处理\n截断防溢出np.clip(1 / (1.0 + np.exp(-z)), 1e-8, 1 - (1e-8))\n对有逼近/渐近线的函数做截断。\n预测输出的转换在求解交叉熵的时候用的是最原始的预测输出（也就是通过sigmoid function后的01范围内的概率），但是在计算预测准确度的时候，要把预测输出用round转换为布尔值。\ny_dev_pred = _f(X_dev, w, b)Y_dev_pred = np.round(y_dev_pred)dev_acc.append(_accuracy(Y_dev_pred, Y_dev))dev_loss.append(_cross_entropy_loss(y_dev_pred, Y_dev) / dev_size)\n数组操作转置\n使用X.T属性，适用于一维和二维数组\n使用X.transpose()方法，对于高维数组需要由轴编号组成的元组才能依据轴转置。\n\n相乘np.dot(X1, X2)或者X1.dot(X2)\n参考李宏毅2020机器学习作业2-Classification：年收入二分类\n课程助教上传的Colab文件\n","categories":["DeepLearning"],"tags":["ML-Tips"]},{"title":"利用梯度下降法最优化损失函数","url":"/2020/11/08/summary-for-loss-function-optimization/","content":"参数说明: model parameters at the time step t.\n or : gradient of loss function at , for updating .\n: momentum accumulated for time step 0 to time step t, for updating .\n\n参数迭代方式on-line：一次用一对input&amp;label算损失函数更新参数\noff-line：一次用所有input&amp;label算损失函数更新参数\nSGD我们要Minimize Loss Function，梯度代表了增加的方向，往梯度的反方向走，就可以走向最小值。\n\nSGDM定义了一个momentum，初始值为0。本次参数的更新是momentum和上一次迭代参数的矢量和。注意momentum的求解也用到了gradient，并且用lambda考虑了上一次迭代的momentum。\n\nAdagradAdagrad就是把SGD的学习率加上了一个分母。如果前几次迭代中gradient值很大的时候，一开始就会一步跨很大，有了分母的约束之后，如果过去的gradient很大的话（代表比较崎岖的地方），就能让每一步走小一点。\n问题在于，分母会越来越大，之后每一步的参数更新会越来越小。要是一开始的gradient就很大，那么没几步就不走了。\n\nRMSProp和Adagrad的分母的算法有所不同，同时借用了SGDM的思想。既考虑了gradient，有考虑了momentum，这两者的结合就是下面式子中的v，且用一个参数去权衡这两个的比重，解决了Adagrad的短板。\n但是它还是没有办法解决local minima的问题。\n\nAdamAdam就是SGDM+RMSProp。\n就是SGDM中的momentum除以了一个，目的是让整个式子不会随着时间变化越来越大。要注意到的取值是比较接近1但又小于的，在一开始的time step中，的值主要是由来决定的，本次更新的会比上一次的来的小。通过处以一个来让momentum不要那么小。\n类似的，就是SGDM中的v除以了一个。\n一个很小的是为了在一开始v为0的时候分母不为0，否则就要无意义且学习率会无穷大。\n\n选择算法Adapative Learning Rate/Adam： fast training/unstable/larger generalization gap虽然能自适应学习率但是在训练后期表现不是很好。\nSDGM：stable but slow/better convergence/smaller generalization gap虽然训练起来很慢但是总是很稳定，因为每一步走的都一样长。\nAdam优化SWATS总的思想：first Adam + After SDGM，结合了Adam和SDGM的长处，追求更好的收敛。\nRAdam总的思想：apply warm-up to the first learning-rate\n为什么需要Warm-up？刚开始你去初始化参数的时候并不能知道这个初始化参数是否好，所以一开始做梯度下降，很有可能参数在乱更新，分布的方差很大，更新的大小很乱且方向也很乱 —— distorted gradient。所以一开始就要让走的步\n最简单的warm-up就是给参数更新定一个曲线，直线增加4000个update之后曲线下降。\nLookaheadK step forward，1 step back.\nNadam数学中的Nesterov acclerated gradient/NAG应用到Adam中。\n协助优化的技巧L2 Regularization在定义loss function的时候一般会添加一个L2 Regularization，他也是关于目标参数的一个函数。在做gradient的时候是否要把L2 Regularization当作gradient的一部分放在momentum和gradient中去？\nAdamW&amp;SGDW的方法说做微分求momentum和gradient的时候只考虑没有L2 Regularization的loss function，只在最后更新参数的时候把L2 Regularization的微分结果当作一个weight decay项放在learning rate后面。\n增加数据随机性Shuffling数据更换顺序，让每一次的gradient都有变化。\nDropout在训练的时候某一些neuron的输出会被丢掉。\nGradient noise在算完gradient之后加上一个gaussian noise。\n","categories":["DeepLearning"],"tags":["ML-Tips"]},{"title":"循环神经网络","url":"/2020/11/09/rnn/","content":"文本预测系统设计希望设计一个系统，输入一段词汇，希望他预测接下来的内容。\ninput via word embedding如何用一个向量vector表示一个字词word的意思（word embedding）？以下是获得vector的几种方法。\n\n理论上可行的办法有以下几种。\n\n1-of-N encoding/one-hot encoding\n假设一个有N个字的字典，那么每一个字vector长度都是N。一个word出现就占用对应dimension为1。缺点在于需要预先知道所有的字，很占用内存空间。缺少字与字之间的语义关联性。\n可以为未知词汇添加一个dimension’other’，于是上面的1-of-N encoding就可以变成1-of-(N+1) encoding。\n\n用word-hashing。a-a-a/a-a-b等原子，用每一个原子去对应word，可以表示所有英文单词。\n\nBag of Words(BOW)\n\n\n将句子里的文字变成一个袋子装这些词，不考虑词的次数和顺序/文法。\n\n具体训练时可以用skip-gram/CBOW等方法获得word embedding，这些层的参数是否要跟着模型一起训练可以通过fix_embedding的T/F来更改。\n\noutput as probability distribution输出我们希望得到一个probability distribution，代表了预测下一个单词出现在系统给定的每一个slot的概率。\ninput &amp; output are both sequences with the same length.\n\nslot就是一句话的语境意义。某个单词属于某个slot就代表这个单词意味着这句话的有效信息。\n例如，Taipei是一个destination slot， November 2nd 是一个time of arrival slot。\n并不是每一个单词都会属于某个slot，一句话需要提取出有效信息。\n\nRNN的特殊之处在于，hidden layer中的output都会被存放到memory parameters中去。下一次有input的时候，neuron既会考虑x1/x2，也会考虑memory中存放的数据。因此就算每一次输入相同，输出结果也会不同。\nRNN类别Elman Network当前输入的每一个hidden layer的输出，都用作下一个输入的对应hidden layer的输入。\nJordan Network当前输入的最终output保存在memory中，在下一个timestep的下一个输入作为输入考虑。\nBidirectional RNN同时训练正向和逆向的model，也就是向前看也向后看。\n把两个模型中某个timestep的对应输入的hidden layer参数都考虑，然后决定输出。\n如何Memory基本原理Long short-term Memory(LSTM): 4 input, 1 output.\n\n蓝色箭头的四个输入都是vector，这四个输入都是不一样的，从同一个原始x做了不同的线性变换（乘以了不同的权重）后得到的，所以x的维度和四个输入的维度都是一样的，等于memory cell的数目。参数量是4倍。\n输入中有三个都是signal control，包括input gate/output gate/forget gate。这三个gate都是由activation function组成的，一般选择sigmoid function，因为它形似0-1开关函数，但是有一个平滑的上升。\n输入中有一个是network中的产生memory内容的neuron的输出。\n黑色箭头的一个输出都是vector：代表了LSTM这个小nueron的输出。\n\n实际输入但实际在做的时候并不是只有和memory cell中存放的值（在这里就是粉色圆圈加号的输出，叫做peephole）放到下一个LSTM中做输入，还会把当前LSTM的输出当作下一个LSTM的输入。\n如何训练如何定义损失函数？如何表示NN的输出？如何表示实际的输出？\nNN的输出会和一个reference vector做cross entropy。reference vector的维度就是预先定义的slot的长度，该单词本来属于哪一个slot那么该reference对应的slot取值就是1。NN的输出就是input通过NN之后关于slot的vector。\n但是问题是当前时间点的一个单词的cross entropy代表的损失函数和最终整个句子的error关系不大（cost &amp; error not always related）。\n\n定义好损失函数之后如何最小化损失函数？\nBackpropagation throught time\nRNN训练的困难之处在于参数很小的变化可能引起gradient巨大的变化，也可能参数很小的变化对gradient影响根本没有。有点类似于函数中那种跳跃型间断点，在不间断的时候特别平缓，间断的时候又是特别剧烈。\n\n如何解决损失函数崎岖不平，梯度忽大忽小Gradient Vanishing coexist with Gradient Explode的问题？\nLong Short-term Memory can handle gradient vanishing(not gradient explode)\n理由：Memory and input are added，受input gate和forget gate同时控制，除非forget gate关掉了，那么前一次的memory cell中的内容不会消失，因此就没有梯度消失的问题。\n更多应用\nSlot Feeding：引入中的例子\n\nSentiment Analysis：input是sequence的分类问题，所以要用到RNN\n\nKey Term Extraction：input是document sequence\n\nSpeech Recognition\ninput和output都是sequence，但是最终input和output vector的长度不一致。\n可能input的好多词都值对应同一个character，那么output需要trimming变成更短的去掉重复内容的character sequence\n\nMachine Translation：input和output都是长度不同的sequences。\n\nSyntactic Parsing：看一个句子得出语义的树状结构，以前要用structure learning。\n\nSequence-to-sequence auto-encoder — text\n\n\ninput是word sequence，通过RNN变成一个vector — encoder的部分。\n把这个vector当作后续decoder的输入，找回一模一样的句子。\n如果可以成功做到两个步骤，Encoding的vector就代表这个input sequence的重要的信息，在训练模型的时候就不需要label data了，只需要大量input。\n\nSequence-to-sequence auto-encoder — speech\n\n有包含了许多内容的一段语音，你先对他做segmentation切成一段一段，然后用audio segmentation to vector的技术（这里需要用到RNN）把segment变成fixed length vector，这些vector之间的距离代表了他们的相似程度。\n","categories":["DeepLearning"],"tags":["ML","RNN"]},{"title":"从谷歌硬盘获取文件","url":"/2020/11/10/google-download/","content":"参考教学台大李宏毅机器学习助教分享\n素人技术博主分享\n使用gdown从谷歌分享链接中获取file_id，利用file_id下载。\n比如目前有这个链接https://drive.google.com/u/0/uc?id=19CzXudqN58R3D-1G8KeFWk8UDQwlb8is&amp;export=download，提取出id就是id=19CzXudqN58R3D-1G8KeFWk8UDQwlb8is。\n如果当前链接里没有id显示怎么办？在当前链接中点击下载图标看新跳出来的网址。\n在Colab下输入\n!gdown --id &#x27;19CzXudqN58R3D-1G8KeFWk8UDQwlb8is&#x27; --output foodpack.zip!ls!unzip food-11.zip\n在Python中输入\nimport gdownurl = &quot;https://drive.google.com/u/0/uc?id=19CzXudqN58R3D-1G8KeFWk8UDQwlb8is&amp;export=download&quot;output = &quot;foodpack.zip&quot;gdown.download(url, output)\n使用wgetwget比较容易在处理大容量档案时卡住不动或报错。\n在终端输入\nwget &quot;https://drive.google.com/u/0/uc?id=19CzXudqN58R3D-1G8KeFWk8UDQwlb8is&amp;export=download&quot; -O &quot;foodpack.zip&quot;\n","categories":["必备技能"],"tags":["资源获取"]},{"title":"MLHW3-tips","url":"/2020/11/11/MLHW3-tips/","content":"Colab使用Colab工作于Google Drive，创建完成colab notebook后可以根据修改-笔记本设置-硬件加速来选择GPU加速。\n在shell指令前添加!就可以在Ipython中运行任何命令行指令。\n可以把colab挂载到google drive从而就可以从云端硬盘中读取文件加载到Colab运行，但是每一次新建笔记本后都要配置挂载。\nfrom google.colab import drivedrive.mount(&#x27;/content/drive/&#x27;)\n更多参考\nPython OS 文件/目录方法读取某一个路径下的文件夹目录image_dir = sorted(os.listdir(path)) 。\n文件夹中的文件数目用(len(image_dir)表示。\n遍历该文件夹下的每一个文件for i, file in enumerate(image_dir): img = cv2.imread(os.path.join(path, file))\n合并路径os.path.join\n定义数据预处理函数数据预处理分训练集和测试集。使用包import torchvision.transforms as transforms。\n数据增强是为了防止过拟合的现象，用于数据较少的训练集。通常transforms.Compose将transforms组合在一起构成多次图形变化。\n基本步骤\n\n将Tensor类转换为PILImage类transforms.ToPILImage(),\n开始多个图片的翻转、旋转等操作。此步骤对训练集不需要\n将PILImage类转换回Tensor类transforms.ToTensor()。\n\n自定义数据集先用重写Dataset类对数据封装，重写初始化、长度和索引的函数，结合数据预处理的transform。再读入数据，用DataLoader类。\nDataset一个自定义Datasets的基本框架，初始化放在__init__()中，其中__getitem__()和__len__()两个方法是必须重写的。\n基本结构如下\nclass CustomDataset(data.Dataset):#需要继承data.Dataset    def __init__(self):        # TODO        # 1. Initialize file path or list of file names.        pass    def __getitem__(self, index):        # TODO        # 1. Read one data from file (e.g. using numpy.fromfile, PIL.Image.open).        # 2. Preprocess the data (e.g. torchvision.Transform).        # 3. Return a data pair (e.g. image and label).        #这里需要注意的是，第一步：read one data，是一个data        pass    def __len__(self):        # You should change 0 to the total size of your dataset.        return 0\nDataLoader实现分批次读取数据、随机读取数据、并行加载数据。\n常用操作有：batch_size(每个batch的大小), shuffle(是否进行shuffle操作), num_workers(加载数据的时候使用几个子进程)。\nDataloader这个类并不需要我们自己设计代码，我们只需要利用DataLoader类读取我们设计好的Dataset子类即可：\nloader = DataLoader(train_dataset, batch_size=16, num_workers=4, shuffle=True)# 按照batch_size来返回特定数量的训练数据的tensor\n自定义神经网络Torch.nn是专门为神经网络设计的模块化接口，需要重新实现构造函数__init__构造函数和forward这两个方法。\n自定义神经网络的模版class Classifier(nn.Module): # 自定义神经网络需要继承nn.Module类    def __init__(self): # 一般把网络中具有可学习参数的层放在构造函数__init__()中        super(Classifier, self).__init__()                self.cnn = nn.Sequential(        # 这里用nn.Sequential将提供的各类函数包装起来，注意每次输入输出的维度        # 形成一个大的CNN模块        )        self.fullyconnected = nn.sequential(        # 这里是另外一个大的全链接层模块        )        \tdef forward(self, x):        # 在forward中没有必要把细枝末节拼起来        # 只需要把每个大的模块拼接起来        # 同时也要注意输入输出        out = self.cnn(x)        out = out.view(out.size()[0], -1)        return self.fc(out)\n技巧一般把网络中具有可学习参数的层（如全连接层、卷积层等）放在构造函数init()中，当然也可以把不具有参数的层也放在里面。\n一般把不具有可学习参数的层(如ReLU、dropout、BatchNormanation层)可放在构造函数中，也可不放在构造函数中，如果不放在构造函数init里面，则在forward方法里面可以使用nn.functional来代替。\nforward方法是必须要重写的，它是实现模型的功能，实现各个层之间的连接关系的核心。\n训练模型定义参数如模型、损失函数、梯度下降的方法、epoch的次数。\nmodel = Classifier().cuda()loss = nn.CrossEntropyLoss() optimizer = torch.optim.Adam(model.parameters(), lr=0.001) num_epoch = 30\nfor循环每一个epoch，记录每一个epoch的时间，损失，正确率等都要清零。\n训练每一笔data的for循环之前一定要开启model.train() 保证自动backpropagation且参数更新。\nfor epoch in range(num_epoch):    epoch_start_time = time.time()    train_acc = 0.0    train_loss = 0.0    val_acc = 0.0    val_loss = 0.0    model.train()     for i, data in enumerate(train_loader):        optimizer.zero_grad() #         train_pred = model(data[0].cuda())         batch_loss = loss(train_pred, data[1].cuda())         batch_loss.backward()         optimizer.step()        train_acc += np.sum(np.argmax(train_pred.cpu().data.numpy(), axis=1) == data[1].numpy())        train_loss += batch_loss.item()\n测试模型测试每一笔validation set或者testing set的data之前一定要开启model.eval() 保证不会自动backpropagation参数更新。\nfor epoch in range(num_epoch):  epoch_start_time = time.time()  train_acc = 0.0  train_loss = 0.0  model_best.train()  for i, data in enumerate(train_val_loader):    optimizer.zero_grad()    train_pred = model_best(data[0].cuda())    batch_loss = loss(train_pred, data[1].cuda())    batch_loss.backward()    optimizer.step()    train_acc += np.sum(np.argmax(train_pred.cpu().data.numpy(), axis=1) == data[1].numpy())    train_loss += batch_loss.item()\n参考MrSun Blog\npytorch教程之nn.Module类详解\n","categories":["DeepLearning"],"tags":["ML-Tips"]},{"title":"集成学习","url":"/2020/11/11/ensemble/","content":"Bagging流程有N笔Training Data，从中做sampling，建立多个有相同数据量的dataset。\n用一个复杂的模型对这些dataset做learning，可以得到四个训练好的模型。\n最后将这四个模型的结果做Average/Voting。\n适用于什么情况模型复杂，但是bias很小；主要担心overfitting，目的是为了降低variance，将这些用subset训练好（但是只做重采样效果也不一定很好）的子模型做平均/投票。\n比如decision tree这样的模型，Random Forest就是决策树做bagging的版本。传统的决策树很容易在训练集上0% error rate。\n传统的随机森林是通过之前的重采样的方法做，但是得到的结果是每棵树都差不多（效果并不好）。比较多的是随机的限制一些特征或者问题不能用，这样就能保证就算用同样的dataset，每次产生的决策树也会是不一样的，最后把所有的决策树的结果都集合起来，就会得到随机森林。\n如何验证Validate如果是用Bagging的方法的话，用out-of-bag可以做验证，不需要把label data划分成training set和validation set。\n对于一个function1，用dataset1和dataset2训练；对于function4，用dataset2和dataset4训练。function1和function4做bagging的结果可以用dataset3来做测试。对所有的function的组合做out-of-bag测试，最终的error是这些测试结果的平均。\nBoosting适用于什么情况适用于错误率很高的模型，没有办法fit。\nBoosting有一个很强的保证：如果你的机器学习算法能产生错误率小于50%的分类器，这个方法可以保证错误率达到0%。\n流程\n先找一个分类器f1(x)\n接下来找一个辅助f1(x)的分类器f2(x)，f2(x)不能和f1(x)很像，f2(x)要能够弥补f1(x)没办法做的事情\n之后再找辅助f2(x)分类器的f3(x)，一直到最后\n\n注意所有分类器都是按照顺序sequentially得到的。而bagging是没有顺序的，可并行训练。\n细节实现如何使classifers — fk(x)不相同？要让每个分类器的参数不同，可以让他们在不同的dataset上训练。\n为了获得不同的数据集，可以重采样原数据集Resampling，就像bagging做的那样；也可以重新给原数据集中的每一个数据重新分配权重，即Re-weighting。，在实际操作的时候并不要对dataset的封装有什么更改，只是更改cost function为。\nAdaboost总的想法就是先训练好一个分类器f1(x)，然后再找一组新的training data，让f1(x)在这组data上表现很差（怎么才算表现差？），然后让f2(x)在这组training data上训练。\n\n就是分类器f1(x)在训练数据上的的error rate，分子是所有训练样本的weight之和，分母是分类正确的训练样本的weight之和，要求error rate小于0.5。\n\n将分类器f1(x)中的训练数据的权重变更（要怎么变更？）后，我们要找分类器f2(x)在新权重的训练集上error rate等于0.5。\n\n\n如何确定？\n已知\n\n\\begin{split}\n\\varepsilon_1 &= \\frac{\\sum_n{u_1^n\\delta{(f_x(x^n)\\neq \\hat{y}^n)}}}{\\sum{u_1^n}} \\\\\n\\varepsilon_2 &= \\frac{\\sum_n{u_2^n\\delta{(f_x(x^n)\\neq \\hat{y}^n)}}}{\\sum{u_2^n}} \\\\\n&=\\frac{\\sum_{f_x(x^n)\\neq \\hat{y}^n}{u_2^n}}{\\sum_{f_x(x^n) = \\hat{y}^n}{u_2^n} + \\sum_{f_x(x^n)\\neq \\hat{y}^n}{u_2^n} } \\\\\n&= \\frac{\\sum_{f_x(x^n)\\neq \\hat{y}^n}{u_1^nd_1}}{\\sum_{f_x(x^n) = \\hat{y}^n}{u_1^n/d_1} + \\sum_{f_x(x^n)\\neq \\hat{y}^n}{u_1^nd_1} }\\\\\n&= 0.5\n\\end{split}变形获得\n\n\\begin{aligned}\n\\frac{\\sum_{f_x(x^n) = \\hat{y}^n}{u_1^n/d_1}}{\\sum_{f_x(x^n)\\neq \\hat{y}^n}{u_1^nd_1} } = 1 \n\\\\ \n\\frac{1}{d_1} \\sum_{f_x(x^n) = \\hat{y}^n}{u_1^n} = d_1 \\sum_{f_x(x^n) \\neq \\hat{y}^n}{u_1^n} \\\\\n\n\\frac{1}{d_1} Z_1(1-\\varepsilon_1) = d_1 Z_1\\varepsilon_1 \\\\\nd_1= \\sqrt{(1-\\varepsilon_1)/\\varepsilon_1} > 1\n\\end{aligned}算法总结\n\n多个模型的sequential训练\n\n\n\n将多个训练好的模型组装，两种方式Uniform Weight/Non-uniform Weight。\n\n正确性验证要保证最后组装起来的模型的error rate会越来越小。\n问题转换1最终的error rate是有上界的，蓝色的函数就是绿色函数的上界。\n\n要证明最终的函数的error rate会越来越小的问题就变成了证明蓝色的上界函数会越来越小。\n问题转换2对蓝色部分的上界函数做一些变形。\n用的和表示第T+1次训练数据集权重的和，运用递推关系式将转换成关于y_train/y_pred/alpha的exp相关的表达式。这个式子表明训练数据的权重和（也就是红色表达式）会和训练数据的错误率有关系。\n\n要证明蓝色的上界函数会越来越小就转化为要证明训练数据的权重和会越来越小。\n问题转换3对训练数据的权重和做一些变形。\n在用第T+1次训练数据集权重的和的两种情况分类结果表示第T+1次训练数据集权重的和\n\n最终经过三次转换证明成功。\nGradient BoostingGradient Boosting是Boosting更泛化的一个版本。\n\n给定initial function，在每个timestep更新上一个timestep的function，得到最终的output Function。\n从梯度的角度考虑loss function，是上面那个式子，更新就是learning rate和对g(x)微分的结果。\n从boosting的角度考虑就是要添一个新的函数。\n如果这两个同方向就可以最小化损失函数。要让他们同方向就要让这两个式子同符号，把这两个式子的乘积最大化。\n\nAdaboost中就自动分配了一个最好的，把的价值发挥到最大，很类似于learning rate。也可以把Adaboost看成是在做梯度下降，这个梯度就是一个函数，而且学习率可以通过计算得出最好的。\nGradient Boosting中我们可以自己决定学习率，从而更改目标函数。\nStacking在分类问题中直接对不同结果的模型做Voting并不一定是好的，有的系统比较差。\n当然可以采用bagging分配子系统在最终结果中的权重。\n提出另一种方法，把子系统的输出结果当作新的特征输入到最终的分类器，这个分类器比较简单。Training Data分成两份，一份用来训练子系统，另一份用来训练最终分类器。\n","categories":["DeepLearning"],"tags":["ML","集成学习"]},{"title":"强化学习","url":"/2020/11/11/reinforcement-learning/","content":"interact with environment两种方式\n强化学习，机器在和环境互动的过程中，从环境获得reward，学习如何获得更高的reard。\nlearning by demostration/imitation learning，其中inverse reinforcement learning就是其中一种。\nwhole ideaAction =&gt; Observation/Reward\n参数更新要Maximize the expected cumulative reward per episode。\n训练难点在于Reward delay（如何知道某个action会在将来某个时间点获得正向Reward？），以及Agent’s actions effect the subsequent data it receives.\npolicy-based: learning an actor; value-based: learning a critic; actor+critic: A3C\nActor函数描述Actor/Policy就是一个function，定义为。\n神经网络的输入就是oberservation，可以被表示成一个vector或matrix。\n神经网络的输出就是action或probability of taking the action(stochastic)，可以对应到output layer的一个neuron。\nActor/Policy就是神经网络，也就是一个函数。\n函数好坏/Goodness of ActorAn episode is a series of state/action/reward, named as trajectories. 。\n\n这里的state其实就是前面的observation。\n\nReward就是这个episode中所有reward分量的和。。\n对于一个序列，Give an actor  with the network parameter  . 是total reward，但是这是一个随机变量，我们要让它的期望最大。\n现在要machine玩一个游戏，在一个episode结束之后，才能确定表示它的是什么样的。每一种排列组合的都有可能被sample，其概率由actor parameter决定。这里假设每一个episode被sample是等概率的，因此最终的期望要被最大化。\n最大化/Gradient Ascent在找最小值的时候用Gradient Descent；在找最大值的时候用Gradient Ascent。\n对期望做gradient ascent，每次变化都是加。\n具体过程\n\\begin{aligned}\n\\bar{R}_\\theta = \\sum_{\\tau}R(\\tau)P(\\tau|\\theta) \\\\\n\\nabla{\\bar{R}_\\theta} = \\sum_{\\tau}R(\\tau)\\nabla{P(\\tau|\\theta)}=\\sum_{\\tau}R(\\tau) P(\\tau|\\theta) \\frac{\\nabla{P(\\tau|\\theta)}}{P(\\tau|\\theta)}\n\n\\end{aligned}注意到是已经定义好的和无关的两，所以不需要对它做微分，can be a black box。\n且带入上式可得\n\n\\begin{aligned}\n\\nabla{\\bar{R}_\\theta} &= \\sum_{\\tau}R(\\tau) P(\\tau|\\theta) \\nabla{\\log{P(\\tau|\\theta)}} \\\\\n&=  \\frac{1}{N}\\sum_{n=1}^N{R(\\tau^n)} \\nabla{\\log{P(\\tau|\\theta)}}\n\n\\end{aligned}问题转换为求\n\n取log之后相乘变相加，做微分之后无关actor的项（黄色部分）都是没有的。\n最终更新表达式如下，要注意probability的log做微分之后乘以的是整个episode结束之后的reward，而不是某个action结束之后立马得到的reward。\n\n表达式解读为什么要做log？为什么不用p的微分直接除以p的几率？为什么要除以p的几率？\n即使reward并不大出现频率很高的action会被偏好；即使reward很大，出现频率却很低的action对目标的影响很小。\n相当于做了一个normalization。\n\n在某一个state我们可以sample到3个action，实际上没sample到的action在做完gradient ascent之后反而会越变越小，其他的action反而无条件的probability增加。\n不能让几率无条件增加，所以给增加一个baseline，只有当当前state的该action的reward比大的时候才increase probability。\nCriticA critic doesn’t determine the action. Given an actor pi, it evaluates how good the actor is.\nState Value Function When using actor , the accumulated reward expects to be obtained after seeing the observation/state s.\n\n只要有，这样的state的变化，就能计算并更新参数，不需要像actor一样等到episode完全结束。\n\nState-action value function When using actor , the accumulated reward expects to be obtained after seeing the observation/state s and action a.\nQ-Learning就是给定一个初始actor pi，让这个pi去和environment互动，用Q function找出一个表现比上一次actor pi更好的actor pi’ 。\n\n\\pi'(s) = arg \\max{Q^{\\pi}(s, a)}Actor+CriticA3C = Asynchronous Advantage Actor Critic\nInverse Reinforcement Learning只有action和environment，没有reward function，也就是规则不明确。目标是随着reward function的不断更新，让teache由弱变强，actor跟着teacher一起变强，但总是弱于teacher。\n","categories":["DeepLearning"],"tags":["ML","强化学习"]},{"title":"GAN-theory","url":"/2020/11/12/GAN-theory/","content":"MLE极大似然估计步骤\n就是要让真实数据分布中的每一笔data，通过给定参数的新的分布后，所得到的每一笔data概率之积要最大。\n最大化求解的转化\nMaximum Likelihood Esitimation = Minimize KL Divergence\nGenerative Model所定义的distribution PG要和真实数据的Pdata尽可能地相近似。\n为了计算PG，我们要做假设，比如分布服从Gaussian Mixture Model，但是一旦模型复杂了，我们就没办法计算PG。\nGAN拆解Gnerator在做什么\n在获得了PG和Pdata也就是两笔数据的分布之后，要最优化Generator。\n原始数据分布我们是没有办法完全获得的，这只在理论上现实，因而为了获得分布可以从PG和Pdata中sample一些样本获得样本分布。\n要让这两笔数据的差距变小，也就是要最小化这两笔data distribution的Divergence？\n从Generator到DiscriminatorDiscriminator可以告诉我们这些样本所代表的分布之间的Divergence。V(G,D)很小的时候，代表这两个sample data的distribution的divergence很小，很难分辨；V(G,D)很大的时候，代表这两个sample data的distribution的divergence很小，很容易分辨。\n\n证明可求最大值/模型可训练接下来要证明可以给Example Objective Function for D存在arg max，即可以找到Discriminator的function 使最大。\n对于给定的G，意味着generated data的distribution是确定的。这个时候需要找一个使得最大。\n转换1\n\\begin{array}{ll}\nV &=E_{X \\sim P_{data} }[\\log D(x)] + E_{X \\sim P_{G} }[\\log (1-D(x))] \\\\\n&= \\int_x P_{data}(x)\\log D(x) \\, dx + \\int_x P_{G}(x)\\log (1-D(x)) \\,dx \\\\\n&= \\int_x [P_{data}(x)\\log D(x) + P_{G}(x)\\log (1-D(x))] \\,dx \\\\\n\\end{array}也就是要最大化积分表达式中的那个函数。\n转换2用更简单的表达式来替换复杂的符号，\n\nP_{data}(x) = a \\quad P_{G}(x) = b  \\quad \\log D(x) = D \\\\也就是找一个使得最大。\n\n\\begin{array}{ll}\n\\frac{d f(D)}{d D} = a \\times \\frac{1}{D} - b \\times \\frac{1}{1-D} = 0 \\\\\nD^* = \\frac{a}{a+b} \\\\\nD^* = \\frac{P_{data}(x) }{ P_{data}(x) + P_{G}(x)} \\in (0, 1)\n\n\\end{array}\n至此已经找到了能让最大的function 。\nDiscriminator在做什么把得到的放进原式子中可以得到\n\n\\begin{array}{ll}\n\\max \\limits_D V(G, D) \\\\= V(G, D^*)  \\\\\n= E_{X \\sim P_{data} }[\\log \\frac{P_{data}(x) }{ P_{data}(x) + P_{G}(x)}] + E_{X \\sim P_{G} }[\\log \\frac{P_{G}(x) }{ P_{data}(x) + P_{G}(x)}] \\\\\n= E_{X \\sim P_{data} }[\\log \\frac{ 1/2 * P_{data}(x) }{ P_{data}(x) + P_{G}(x)  \\quad / 2}] + E_{X \\sim P_{G} }[\\log \\frac{ 1/2 * P_{G}(x) }{ P_{data}(x) + P_{G}(x) \\quad /2}] \\\\\n= 2 \\log \\frac{1}{2} + E_{X \\sim P_{data} }[\\log \\frac{ P_{data}(x) }{ P_{data}(x) + P_{G}(x)  \\quad / 2}] + E_{X \\sim P_{G} }[\\log \\frac{  P_{G}(x) }{ P_{data}(x) + P_{G}(x) \\quad /2}] \\\\\n= -2 \\log 2 + KL(P_{data} || \\frac{P_{data}+P_G}{2}) + KL(P_{G} || \\frac{P_{data}+P_G}{2}) \\\\\n= -2 \\log 2 + 2JSD(P_{data} || )P_G\n\\end{array}从上式我们可以看出：当我们在train一个discriminator，我们就是在衡量我们sample出来的Pdata和PG两个分布之间的Jensen-Shannon Divergence，也是一个binary classifier。\n\nGAN的算法本质上就是在解这个min max problem。\n\n最后Discriminator会怎么样。\n它到底是不是一个Evaluation Function，判断generator的output是好还是坏？Discriminator真的会fail掉变成一个水平线吗？这两个问题其实是矛盾的。\n（？）最后Discriminator会在有data分布的地方获得比较小的值，没有data分布的地方获得比较大的值。\nGAN算法Theoretically\nG ^ * = arg \\min\\limits_{G} \\max\\limits_{D}V(G, D)To find the best G as , we should minimizing the loss function . \n具体过程参考GAN Introduction文章。\n\n第一次迭代：\nTraining D\nFor Given , we have two distribution .\nBefore minimizing loss function, we should determine the best  D as $D^V(G^0, D_0^)$. \n\n这个过程也就是找一个discriinator能最大化的看到这两个distribution的差异，分辨能力较强，较为严格。\n实际上也可能找不到global maxima，可能停在一个local maxima就结束了关于本参数的多次迭代。Can only find lower bound of .\n\nWe use gradient asent several times to maximize the JS Divergence function and thus updating  for .\n\nTraining G\nAccording to the fixed loss function $L(G) = V(G^0, D_0^)$ at iteration 1, we *use gradient desent just once to minimize the loss function and thus updating  for .\n可以看出来，之前maximize和现在minimize的function的表达式都是一样的。但是由于固定了D，现在要优化的式子就没有了上面的第一项。\n\n在实际操作过程中objective function for generator是这个样子。\n\n\n问题是从$V(G_0, D_0^)到V(G_1, D_0^)$，我们希望第一代Generator能够Minimize前面第零代Discriminator计算出来的JS Divergence。\n但是当我们update 到， 整个原来用于衡量JS Divergence的function其实就已经变了，在处获得的最大值可能已经不是新函数的最大值了，也就是不再是衡量JS Divergence了。\n我们要假设在update 到的时候，参数变动很小，变动前后的function形状变化不大，因此我们只迭代generator一次。\n\n\n第二次迭代：\nFor Given , we have two distribution .\nPractically\n变动是求期望用Sampling来代替。\nDiscriminator要maximize的式子的过程就是在做一个binary classifier去minimize cross entropy。\n","categories":["GAN"],"tags":["ML","GAN"]},{"title":"GAN Introduction","url":"/2020/11/12/GAN-tutorial/","content":"GAN基础算法\nInitialize  for Generator and  for Discriminator\n\nIn each training iteration:\nLearning D Repeat K times\n\n\nSample m examples  from database \n\nSample m noise examples  from a distribution(Uniform Distribution or Guassion Distribution) \n\n\n这些example用多少维度的vector来表示是需要自己调的。\n\n\nObataining generated dara , \n\nUpdate discriminator parameters   to maximize\n\n\n\n利用gradient ascent求最大值，本质上和gradient descent一样，只不过function符号正负或者update的时候方向和梯度同向还是反向。\n这里用到的function并不是表现最好的，只是最早提出GAN的研究者当时采用的算法。\n解读第一项就是把从database中sample出来的real image vector经过Dsicriminator之后评分要越高越好。\n解读第二项就是把从某个分布随机生成的vector经过discriminator之后评分要越低越好。\n算出两个分布之间的JS Divergence，本质上就是一个binary classifier，can only find lower bound of 。\n\nLearning G Only Once\n\n\nSample another m noise samples   from a distribution\n\nUpdate generator parameters   to maximize\n\n最里层是random noise的vector，外面套了一个Generator就变成了一个image，利用Discriminator去评判这个Generator是否做得够好，希望评分越高越好。\n\n\n\n\n\nGAN as structured Learning结构化学习特征机器学习就是：input — function — output。\n当output不再是一个简单的scalar/class(one-hot vector)，而要求是sequence(MachineTranslation/Vhat-bot/SpeechRecognition)/tree/graph/matrix(ImageToImage/TextToImage)，那么就是结构化学习。\nStructured learning’s output is composed of components with dependency.\n结构化学习可以看作极端的one-shot/zero-shot learning，机器在学习如何输出在训练时完全没有见到过的东西。\nGAN与结构化学习GAN其实就是结构化学习的一种解决方案。\n传统的结构化学习方式有两种。一是Bootom-Up — Learn to generate the object at the component level，一个一个组件单独产生问题是没有大局观念；二是Top-Down — Evaluating the whole object, and find the best one，问题是很难做generation.\n以上两种方法结合在一起，bottom-up对应generator，top-down对应discriminator就是GAN。\nGenerator详解目标：vectors — NN Generator — image。\n要让Generator理解每一层output的component之间的关系，即pixel to pixel relationship，要让网络够深。\nNN Generator &amp; Auto-Decoder在supervised learning中，都给一对vectors/image，但是如何产生这么一对vectors/image，要求我们input vectors和output的特征有某些关系。\n由此联想到image — NN Encoder — low-dimension code，但是Encoder不能自己训练，必须要和coder — NN Decoder — image一起训练。可以看出Decoder其实就是Generator。\nAuto-Encoder &amp; VAE但是用decoder做的generator再遇到自己没有遇到的coder的时候产生的结果不可控，就算是vector a和vector b的线性组合通过decoder这个非线性系统之后产生的结果也是不可控的。\n如何解决这个问题？采用VAE — Variational Auto Encoder，给encoder的输出做一个偏移，让Auto-Encoder的输出更稳定一点。\n困难点Auto-Encoder没有办法考虑每一层input的每个component之间的关系，即pixel-to-pixel relationship，对应的就是structure learning中boottom-up approach的问题，没有全局观念。\nDiscriminator详解Discriminator = Evaluation function = Potential Function = Energy Function\nDiscriminator更容易去检查pixel-to-pixel relationship，因为它对应的就是structure learning中的top-down approach的优势。\n训练方法real image就是positive example，但是如何产生比较好的十分接近real image的negative example，让discriminator的评分更严格？\n采用iterative training。让discriminator的评分从松散到严格。\n第一个周期，由初始discriminator parameter决定了discirminator，该discriminator学习给real image distribution的区域高分，给generated image distribution的区域低分。也就是找到了第一个周期的Discriminator。\n第2-n的周期，先用第一个/前一个周期的Discriminator产生negative example（如何找，要解一个argmax problem，要做一些假设），重新学习real image distribution/positive example distribution的区域高分，给generated image distribution/generated image distribution的区域低分。\n直到discriminator自己产生的neagtive example distribution和实际的真是的positive example distribution重合，discriminator才会停止迭代。\n困难点如何让前一个周期的Discriminator产生negative example？如何找，要解一个argmax problem，要做一些假设，因此效果多少有些差。\n把Generator和Discriminator联合起来考虑，用generator来解argmax problem，解决了discriminator的痛点；用discriminator去给generator一个global view。\nAdvantage\nConditional GANWHY CGAN可操控输出结果。\n\n例如Text-to-Image，可以当成Traditional supervised learning来做。input data对应NN output要和input data label尽可能相近。\n问题在于input data/text和input data label/image很有可能是一对多的关系，从而导致模型产生的结果是多张input data label的平均，也就是多张image的平均，所以会特别模糊。\n\n同样Image-to-Image的问题，同样一张几何图形要转换成对应的房子，很有可能一张几何图形可以对应到多个房子。\nHOW CGAN\ngenerator的input是condtion和从normal distribution中sample出得z，output是image。\ndiscriminator的input是condition和generator的output image，要求判断output image真假的同时，还要判断这个image的内容和condition是否匹配，output是判断real pair or fake pair的scalar。\n\n为什么discriminator需要也有condition？\n假如没有condition作为输入，generator为了骗过discriminator，只要产生real image就行了，根本不用管input condition。\n\nTIPS CGANStack GAN\nPatch GAN\nUnsupervised Conditional GenerationTransfer an object from one domain to another without paired data(e.g. style transfer)\nDirect TransformDomain X — G{X-&gt;Y} — Domain Y\n要求1因为没有Domain X 和 Domain Y之间的link，需要用discriminator协助，让generator产生像是Y Domain的图像。\n\n要求2问题是如果generator直接产生和Domain X没有关系怎么办？我们必须要求generator的输入和输出必须配对。\n\n可以直接无视这个问题，当generator较简单shallow的时候，该generator倾向于不去更改input，那么就不需要做额外的constraint。\n\n或者使用一个pre-trained Encoder Network对generator的输入输出的embedding output越相近越好。\n\n\n使用CycleGAN。\nDomain X — G{X-&gt;Y} — Domain Y — G{Y -&gt; X} — Domain X，要让经过了两次generator转换前后的Domain X越相近越好，这就是Domain Consistency。\n同样可以做双向的CycleGAN。\n\n\nStarGAN\nProjection to Common SpaceDomain X — Encoder of domain X —Common Attribute at latent space— Decoder of domain Y — Domian Y\nTarget\nTraining基本方法\n训练Encoder和Decoder就是要Minimizing Reconstruction Error，可以在Decoder的output之后接一个Discriminator of X domain/ Y domain，让Decoder的output不那么模糊。\nEncoderX — DecoderX — DiscriminatorX = VAE GAN1\nEncoderY — DecoderY — DiscriminatorY = VAE GAN2\n存在问题问题是红色的training和蓝色的training是两个没有交集的训练路径，完全独立的，训练完之后你发现images with the same attribute may not project to the same position in the latent space。\n\n\n解决办法1\nsharing the parameters of encoders and decoders. Encoder共享最后几层的参数，Decoder共享前面几层的参数。\n\n解决办法2\n给latent space加一个Domain Discriminator去判断这个code vector是来自EncoderX还是EncoderY。\n\n\n解决办法3\nCycle Consistency，类似于CycleGAN，算Image和Image之间的consistency。\n\n\n解决办法4\nSemantic Consistency考虑在latent space上的consistency。\n\n","categories":["GAN"],"tags":["ML","GAN"]},{"title":"kernel-density-estimation","url":"/2020/11/14/kernel-density-estimation/","content":"What is KDEKernel Density Estimation is a way of estimating an unkonwn probability density function given some data, similar to histogram.\nBasic idea is you define a kernel function and you center a kernel function $K$ on each sampledata point $x_i$, and then you sum these functions together, and then you have a kernel density estimate $\\hat{f}(x) = \\frac{1}{N}\\sum\\limits_{i=1}\\limits^{N} K(x-x_i)$.\nChoice of KernelAttribute of KernelThe kernel function $K$ istypically\n\nNon-negative: $K(x) \\geq 0$ for every $x$，因为描述的是概率\n\nSymmetric: $K(x) = K(-x)$ for every $x$\n\nDecreasing: $K’(x) \\leq 0 $ for every $x$，随着x的增大值靠近0\n\ncan be bounded support or not，例如高斯核函数就是渐进0但是不为0，而三角和函数就是直接为0。\n\n\nFour kinds of kernelGuassian/Box/Triangle/Triweight\n\nChoice of Kernel is not that important because as data grows large the final function estimation will look as same. Gaussian will be fine.\nChoice of BandwidthUse $h$ to control for the bandwidth of\n\n\\hat{f}(x) = \\frac{1}{Nh}\\sum\\limits_{i=1}\\limits^{N} K(\\frac{x-x_i}{h})感觉bandwidth就是决定了对于每一个数据的核函数的分布函数的分散程度$\\sigma$。\nSilverman’s rule of thumbcomputes an optimal $h$ by assuming that the data is normally distributed.\nImproved Sheater Jones(ISJ)Multimodel, seveal modes, such as two noraml distributions.\nTipsWeighting datait is possible to add weights $w_i$ to data points $x_i$ by writing\n\n\\hat{f}(x) = \\frac{1}{h}\\sum\\limits_{i=1}\\limits^{N}  w_iK(\\frac{x-x_i}{h}), \\, where \\, \\sum\\limits_{i=1}\\limits^{N}w_i=1Bounded domainsA simple trick to overcome bias at boundries is to mirror the data.\n在分界处间断点如何确定值？把一侧的数据镜像到另一侧，然后两个分布相加后获得的新的original+mirrored distribution在间断点处做切割，做了mirror的那个部分全为概率0，original的部分采用新的original+mirrored distribution。\nExtension to d dimensionsAn approach to $d$-dimensional estiamtes is to wirte\n\n\\begin{array}{ll}\n\\hat{f}(x) = \\frac{1}{h^d}\\sum\\limits_{i=1}\\limits^{N}  w_iK(\\frac{\\|x-x_i\\|_p}{h}), \\, where \\, \\sum\\limits_{i=1}\\limits^{N}w_i=1 \\\\\n\\|x\\|_p := (\\sum_{i=1}|x_i|^p)^{1/p}\n\\end{array}the choice of normThe shape of kernel functions in higher dimensions depend on the value of p​ in the p norm.\nAs the number of samples grow, the choice of both kernel K and norm p becomes unimportant. The bandwidth H is still important.\nReferenceIntro to Kernel Density Estimation\n","tags":["ML","Statistics"]},{"title":"十一月观影总结","url":"/2020/11/15/my-Nov-films/","content":"曼达洛人第二季来了！制作水平真的好高，有种媲美电影的质感了。\n和男朋友讨论剧情，我说“这部剧就是一个曼达洛人带着尤达宝宝一路打怪升级，就是他有任务在身，为了完成这个任务，要找人寻找信息，为了获得信息，要帮人家做事情……”，男朋友听完，直接就和我说你们女的谈剧情真是啰啰嗦嗦，哼。\n卡罗尔和燃烧女子的肖像一样讲的同性之爱，但是刻画都很粗暴，强行把男人的戏份让一个女的来演的感觉。\n卡罗尔的面部特征与身材特征都过于男性化，攻击的一方，连带着在性爱中也是。\n售货员小姑娘就像完全被牵着走，服从。\n对于两位的关系的进展也很俗套，粗糙。\n相比之下更喜欢燃烧女子的肖像中两位女主互相试探、互相牵制、互相吸引的那种感觉。\nThe Queen’s GambitNetflix出品，实属爽剧。Elizabeth真的眼睛超大，但是化浓妆好显老，具体请参考E06的末尾。\n看完没有学会任何下棋的招数，只知道什么反西西里、后翼弃兵这些神乎其神的招式。\n一个叫欧维的男人决定去死男朋友给推荐的电影，优酷可以免费观看。一直记成了穿条纹睡衣的男孩，还后还因为记错了和男朋友生了莫名其妙的气，女人啊。\n可以说电影就是欧维的一生，以老年丧妻后的生活为起点，回顾了他的少年和中年，少年时期的父亲，中年时期与妻子的爱情，未能降世的宝宝，前半生的所有光都是来自妻子。后来新邻居的到来给欧维的生活带来了一些改变，也让他赴死的决定有了变化。\n人生就是陪伴与理解。\n大黄蜂Bubblebee很美式、很爆米花、很院线的一部电影。我实在是太喜欢大黄蜂那水汪汪的大眼睛了，激起少女心简直不要太容易。\n新世纪福音战士在Netflix看完了修复版的E01～E24开始看剧场版Air以及真心为你，算是完整了一下故事线。\n和男友讨论了挺多隐喻与映射，模糊的呈现虽然能来多样化的解读，但另一方面却不能形成一个完成的体系。很多隐喻没有办法一一对应地从集合A到集合B，边界模糊，令人头疼。\n观看的过程也相当于是解读的过程，所以看起来很累，并没有多少娱乐度。\n播客最近开始听播客了，契机是ActNormal这位b站up主组合，但是他们已经一个月没更新啦，因为大雪回国了，希望Maymay和大雪能再次合体ActNormal。\n听播客感觉是接受信息的一个很好的渠道，尤其是在吃饭、运动、走路的时候。\n\n文化有限\n有男女主播一起，能够提供多性视角。观点性较强。\n\nActNormal来都来了\n我爱大雪和Maymay！与其说是评论，他们更多是在分享\n\n路人抓马\n和男友讨论了一期内容，是拒绝闲聊语境下其中一位女主播的相亲故事，男朋友还吐槽了该女主播的处事方式。\n\n喷嚏\n感觉更像两位女导演之间经历的分享，观点性较弱。\n\n\n","categories":["好好生活"],"tags":["观影","审美"]},{"title":"Feature Extraction with GAN","url":"/2020/11/17/GANwithfeatureextraction/","content":"InfoGANInfoGAN希望输入数据的每一个维度代表着输出图像的某个特定特征，改变输入数据的某个维度，输出图像会同时有某一特征的改变，即解决input feature对output影响不明显的问题。\n架构和普通的GAN主要由两个地方的不同。\n第一，input vector被分成了两个部分，第一个部分c代表了输出图像的特征的集合，z‘代表了纯粹随机的无法解释的部分。\n第二，generator的输出被添加到两个路径，一个是到discriminator，一个是到classifier。classifier的作用是能根据generator的output x反推获得generator的input中代表特征的那个部分。但是如果没有discriminator，generator可能就偷懒直接把input c的部分直接放到output x，然后让classifier很方便就读出来。discriminator要让generator去创造。\n\n总结input characteristic c must have a clear influence on x; The classifier can recover c from x.\nGAN + AutoEncoder应用在Interactive Photo Enditing中。\n第一步，对于给一张image，投射到image embedding space中，变成一个code。\n第二步，在这个code的向量空间内稍作移动就可以实现更改了某一特征（user给的constraint），但总体与原来的image相似的图片。\nimage back to vector有三种实现方式。\n\nEditing photos要找一个满足三个条件的图片。\n第一个是user constraint，即要改变图片的某个feature。\n第二个是要求计算两个图片的距离相近，即与原图片类似。\n第三个是用discriminator来判断图片是否足够real。\n\nVAE-GAN架构\nEncoder的任务就是Minimize reconstruction error，并且让output z close to normal(Variational Auto-Encoder)。\nGenerator as Decoder的任务也是Minimize reconstruction error，并且cheat discriminator。\nDiscriminator的任务是Discriminate real, generated and reconstructed images。\n\n注意这里有三种image，一个是real image，一个是generator as decoder的generated image，另一个是decoder as generator的reconstrcuted image。\n\nWHY VAE-GAN一方面，从VAE考虑。VAE希望reconstruction error越小越好，也就是希望input x of encoder和output x of decoder as generator越接近越好，但问题是VAE的output不一定会realistic，会很模糊，因为无法衡量loss。\n另一方面，从GAN考虑。原来在train GAN，Generator没有看过真正的image长什么样，需要很多时间去调参数。但是加上encoder，他知道真正的image长什么样。\nAlgorithm\nInitialize En, De, Dis\n\nIn each iteration:\n\nSample M images  from database\n\nGenerate M codes  from encoder \n此处是encoder从real image输出的code\n\nGenerate M images  from decoder \n此处是decoder从encoder的code输出的reconstructed image\n以上是auto-encoder的操作流程。\n\n\nSample M codes  from prior \n\nGenerate M images  from decoder/generator \n此处是用从normal distribution中sample出得随机的一个vector当作generator的输入。\n以上是GAN的generator部分的操作流程。\n\n\nUpdate En to decrease , decrease \n\nUpdate De to decrease , increase  and \n\nUpdate Dis to increase , decrease  and \n\n\n\n\nBiGANBiGAN也是VAE-GAN的一种变形，还是建立在Encoder/Decoder/Discriminator这三者之上。只不过这些基本单元的连接方式有所不同。\n架构\n和VAE-GAN不同，BiGAN的Encoder和Decoder不再有一个real image和generated image的比较。Encoder和Decoder互相独立。\n那如何训练这两者？这个任务在于Discriminator。对于每一对image x和code z的pair，discriminator要判断他来自encoder还是decoder。\n解读Encoder的输入和输出构成一个disribution，记做\nDecoder的输入和输出构成一个disribution，记做\nDiscriminator的作用是evaluate the difference between P and Q\n到最后P和Q会是一样的。\n\nAlogorithm\nInitialize En, De, Dis\n\nIn each iteration:\n\nSample M images  from database\n\nGenerate M codes  from encoder \nEncoder生成一个pair\n\n\nSample M codes  from prior \n\nGenerate M images  from decoder/generator \nDecoder/generater生成一个pair\n\n\nUpdate Dis to increase , decrease  \n\nUpdate En and De to decrease , increase  \n\n\n\n\n\n同样的还有Triple GAN\n\nDomain-adversarial trainingTesting data and training data are in different domains. How to extract feature of the same distribution via generator.\n\n架构\n主要由三个部分组成，generator的作用是domain extractor，discriminator的作用是domain classifier，判断feature来自哪个domain。同时需要另外一个class label classifier。\n这三个部分可以一起learn，也可以不一起learn。\n\nsimultaneous training还是iterative training？其实fGAN中提出了一种将GAN simultaneous training的方法，但是会不太稳；原始GAN中还是iterative training。\n\nFeature DisentangleWHY\n在encoder的时候单纯的把input segment输出成一个code，那么这个code可能包含了很多信息，例如phonetic information, speaker information.\n如果我们一开始就把code利用feature分开来，细化每一个encoder的任务，那么结果丢进encoder去test的时候reconstruct的效果会更好。\nHOW\n利用一个speaker classifier当作discriminator来训练前面两个不同“domain”的encoder。\n","categories":["GAN"],"tags":["ML","GAN"]},{"title":"fGAN+WGAN+EBGAN","url":"/2020/11/17/fGAN-WGAN-EBGAN/","content":"f-GAN不仅是KL Divergence，其实任何Divergence都可以放到GAN中去Optimize。\nDefinition of f-divergence\nD_f(P\\|Q) = \\int_x q(x)f(\\frac{p(x)}{q(x)})dxwhere  is convex and . This function evaluates the difference of P and Q. As to how to evaluates depends on the choice of .\n当你选择，其实就是KL Divergence。\n当你选择，其实就是Reverse KL。\nFenchel Conjugate因为f-divergence中的function 是convex，所以他有conjugate function(共轭函数)。\n\n上面的括号里，意思就是给定了p(x)/q(x)/f*()，我们要穷举所有的t，来让括号内的式子最大。\nConjugate f-divergence &amp; GAN现在由于我们有了Discriminator，我们就不需要去穷举t去解这个max-problem。\n虽然任意一个Discriminator不能和上式画等号。\n\n但是我们找到的那个最好的Discriminator就可以解决这个问题。\n\n我们在之前的GAN模型\n\nSolution to Mode DroppingMode Collapse：Gnerator产生的图看起来都一样。PG的分布与Pdata中的某一个距离过近。\nMode Dropping：Gnerator产生的图都是某一类图，也就是PG的分布与Pdata中的某一类距离过近。Generator switches mode during training。\n以上问题出现的一个猜测就是我们的KL divergence选得不够好，选择不同的divergence可能会减轻以上问题，所以这就是f-divergence的应用意义。\n或者直接Ensemble，每一个generator发生mode collapse产生一张图。\nWHY improving GAN在原始GAN里面，我们用JS divergence/binary classfier衡量两个distribution的相似度。\n一方面如果两个分布没有overlap，那么JS divergence总是log2。从直觉上来看，JS Divergence就是一个binary classifier，如果两个分布没有overlap，那么分类器总能把他们分辨开，即100% accuracy。\n另一方面，low-dim manifold in high-dim space，数据分布的overlap几乎是可以被忽略的的；就算他们有overlap，我们在对Pdata做sampling的时候如果做的不好PG和Pdata依然会没有overlap。\nLeast Square GAN(LSGAN)在Discriminator是一个Binary Classifier的时候，我们的output会经过一个Sigmoid Function，如下图所示。\n\n蓝色的数据点就代表PG，绿色的数据点就代表Pdata。我们的generator要让蓝色的数据点往右移动与绿色的数据点尽可能重合。问题是这个Sigmoid Function在一开始微分很小，难以移动。\n解决办法就是Replace Sigmoid with Linear(replace classification with regression)\n\nWasserstein GAN(WGAN)WGAN用Earth Mover‘s Distance/Wasserstein Distance来衡量PG和Pdata两个分布的距离。（但不是f-divergence的一种）\nW Distance现在有两堆土，你把一堆土铲倒目标位置去所走的平均距离就是W Distance。\n铲土的方法有很多种，哪一个才是最好的？穷举所有possible “moving plans”, Using the “moving plan” with the smallest average distance to define the earth mover’s distance.\n\nDefinitionEvaluate Wassertein distance between Pdata and PG\n\n下面有约束条件D必须是一个Lipschitz Function，这要求D足够的平滑smooth enough。\n\n1-Lipschitz constraint要求Discriminator这个函数输出的变化不能大于输入的变化。\n如何实现1-Lipschitz ConstraintWeight Clipping原始W-GAN中做法，用gradient asent去train。\n\nImproved WGAN(WGAN-GP)Approximation1将1-Lipschitz constraint等价成(if and only if)另一个不等式。这个不等式的意思是我们要D是一个满足1-Lipschitz的function，就相当于对于任何一个x，D对x的微分的norm都要小于等于1。\n在原来的V后面加一个penalize的项，如果gradient的norm大于1的话，积分出有结果有penalty，如果graident的norm小于1的话，被积分的那个式子就是0，结果没有penalty。\n\nApproximation2问题在于我们不可能对所有x做积分，因为我们是在做sampling。\n再做一次近似，假设x是从某一个事先定义好的distribution P-penalty里sample出来的，我们只保证1-Lipschitz constraint只在P-penalty这个distribution里面成立。\n\n\n那么如何确定P-penalty的distribution呢？\n从Pdata中sample一个点，从PG中sample一个点，在这两个点的连线上做一个random sample，这个sample出来的x就当作是从P-penalty中sample出来的。\n\n为什么只在蓝色部分给penalty可行？我们希望PG中的点慢慢往左移动到Pdata的位置，generator是看着discriminator给出的gradient的方向update参数的。Only give gradient constraint to the region between Pdata and PG because they influence how PG moves to Pdata 。\nApproximation3\nSpectrum NormKeep gradient norm smaller than 1 everywhere\nW-GAN Algorithm一共要更改四个地方。\n训练Discriminator的时候，目标函数改成从两个分布的期望相减。可增加penalty或者weight clipping来满足1-Lipschtz constraint。对于D的输出，没有sigmoid，用linear。\n训练Generator的时候，目标函数对应修改。\n\nEnergy-based GAN(EBGAN)Using an auto-encoder as discriminator D。\n\nAuto-encoder作为discriminator的一个想法就是丢一张image进去，它的reconstruction error可以通过autoencoder算出来。一张图片越容易被reconstruct就说明它是一张high quality image。\nWHY EBGANEBGAN的意义在于用auto-encoder实现的discriminator可以用positive examples被pre-train，一开始的discriminator就会很强。\n我们一开始用binary-classfier实现discriminator的问题在于要train好一个二元分类器，你要同时拥有好的negative example和positive example。在一开始generator生成的negative example很弱，得到的discriminator也很弱；discriminator要等generator慢慢变强后，才能够变强。\nTraining TIPsdiscriminator的output reconstruction error越靠近0说明图片质量越好，就是要让他们的output越大越好（注意结果经过了一个负号）。\n但是你要注意不能让generated example的output越小越好。对于那些output不靠近0的图片，难道图片质量很差，我们就要让他变成很大的negative的值吗？这些很大的negative的值会拖着靠近0的值往下走，因为要求discriminator平滑。我们的训练目的不是minimize reconstruction error。\n\n所以我们设定一个threshold，告诉discriminator当一张图片的reconstruction error小于这个therehold的时候，就可以了。\n","categories":["GAN"],"tags":["ML","GAN"]},{"title":"衡量Generator的好坏的方法","url":"/2020/11/19/outputGANevaluation/","content":"Likelihood传统衡量Generator的方法是用Likelihood。\n实现方法就是，目前有一大堆real data(not observed during training)，需要计算通过Generator产生这些指定的data的Log Likelihood。\n用Likelihood衡量Generator的问题Log Likelihood: 。但是问题是对于指定的，我们无法计算。我们只能说输入一个Prior Distribution from normal distribution z，让它通过generator产生一笔data。\n如果我们的Generator只是一个比较简单的Gaussian Mixture Model，那么对于给定data的产生机率是可以比较简单的计算出来的。但是我们又不希望Generator这么简单，我们的模型是十分复杂的。\nKernel Density Estimation先让Generator生成一堆data。假设Each sample is the mean of a Gaussian with the same covariance，然后用KDE去fit这些data，获得实际data分布的一个approximation，然后用每一个real data代入这个distribution获得likelihood。\nLikelihood v.s. Quality但是问题是likelihood和generator的quality没有必然联系。\n\nLow likelihood and high quality\n\n会发生在Generater产生十分清晰的图像（high quality），但都和做evaluation时用的数据无关，用likelihood来算的时候就是low likelihood。但是你并不能说generator做的不好。\n\nHigh likelihood, low quality\n\nG1估测出产生给定图片的likelihood很高，G2产生99%概率的noise，1%概率的好的图片，这些差异在经过Log Likelihood的计算后差距不会很大。\nUsing classifier用一个已经训练好的classfier来判断这个object的好坏。\nInception Score就是由以下两个部分组成的。\n\n每张图片的output distribution越集中越好\nGAN是在image领域的，那我们就拿一个已经训练好的off-the-shelf image classifier，他的输入是generator的输出的某一张图，他的输出是一个基于输入图像的分布。这个classifier要判断generator的输出属于哪一类图像。如果某一个class的分布越大，说明generator效果越好。\n对所有class做平均后的output distribution越平滑越好\n机器能产生很清晰的一类图，但是也只限于这一类图。依然需要衡量generator的diversity，要让机器能够产生多个class的图。\nNo memory GAN我们不希望generator的输出是从database中本来就有的东西。\nMode DroppingGenerator产生的东西多样性不够。\nMini-batch Discrimination让Discriminator一次性check一把image，那么这样discriminator不仅要关注每一张image各自是否是real的，还需要关注每一张image之间有没有类似。\n","categories":["GAN"],"tags":["ML","GAN"]},{"title":"Improve Sequence Generation by GAN","url":"/2020/11/19/sequence-generation/","content":"Improving Supervised Seq2Seq ModelReinforcement Learning利用Chat-bot Example来讲解Reinforcement Learning在Seq2Seq Model中的实际应用。\nMaximum Likelihood利用MLE来训练Seq2Seq的model存在问题。使用Maximum Likelihood本质就是在Minimize Cross Entropy。\nhow are you我们希望chat-bot回答I’m fine但是实际对话中如果一个chat-bot有可能回答not bad和I’m Jone，从人的感觉来看not bad是更好的，但从我们定义的MLE来看，第一个单词I’m和正确回答相匹配，那么I’m Jone这个概率会更好。\nReinforcement Learning那我们应该用什么方法来判断？Maximizing Expected Reward。Chat-bot是一个系统，和Chat-bot对话的人也是一个系统。Chat-bot依据人给出的Reward反馈update自己的参数，也就是Machine obtains feedback from user。\n\n整个系统重新连接一下，可以得到以下的形式。\n\n目标是去调整encoder和generator的参数（也就是Seq2Seq model的参数），使得Human的function R的output越大越好。分为两个步骤，如何定义R的output，以及如何去最大化这个output。\n定义Reward Function output如何计算Reward function R的output？对于给定的，我们计算reward的期望值。\n\n\\begin{array}{ll}\n\\bar{R}_{\\theta} &= \\sum\\limits_cP(c)\\sum\\limits_xR(c,x)P_{\\theta}(x|c)\\\\\n&= E_{c\\sim P(c)}[E_{x\\sim P_{\\theta}(x|c)}R(c,x)] \n\\end{array}summation over all input c，因为各种各样的input出现的几率各不相同。\nsummation over all feedback given certain output of chat-bot。由于每次给同样的input，对应的output不一定是一样的，对于给定的c，我们得到的x是不一样的，是一个x的probability，chatbot的output本质上就是一个distribution 。\n最大化Reward Function outputMaximizing expected reward就是找一组Seq2Seq模型的参数，使得上面定义的Reward Function output 最大。\n\n\\theta^{\\star} = arg \\max_{\\theta} \\bar{R}_{\\theta}改写上一步骤中的式子，写成分布的形式。\n\n\\begin{array}{ll}\n\\bar{R}_{\\theta} \n&= E_{c\\sim P(c)}[E_{x\\sim P_{\\theta}(x|c)}R(c,x)] \\\\\n&= E_{c\\sim P(c), x\\sim P_{\\theta}(x|c) }R(c,x) \\\\\n&\\approx \\frac{1}{N} \\sum\\limits_{i=1}^NR(c^i, x^i)\n\\end{array}虽然目标是要取期望值，但是我们没办法真正获得disribution来获得期望值。我们需要一次approximation，从database里做sample，sample出N笔data，即。\n等我们做完approximation之后，发现要去update参数theta，但是最后的式子中哪里有theta？theta的值会影响我们从database中sample的N笔data，没法算gradient。\n\n实际操作中先对原式子做gradient，再去做approximation，这样就能把theta保留在我们要去maximize的式子中。\n\n\\begin{array}{ll}\n\\nabla\\bar{R}_{\\theta}  &= \\sum\\limits_cP(c)\\sum\\limits_xR(c,x) \\nabla P_{\\theta}(x|c) \\\\\n&= \\sum\\limits_cP(c)\\sum\\limits_xR(c,x)P_{\\theta}(x|c) \\frac{\\nabla P_{\\theta}(x|c)}{P_{\\theta}(x|c)} \\\\\n&= \\sum\\limits_cP(c)\\sum\\limits_xR(c,x)P_{\\theta}(x|c) \\nabla \\log P_{\\theta}(x|c) \\\\\n&= E_{c\\sim P(c), x\\sim P_{\\theta}(x|c) } [R(c,x) \\nabla \\log P_{\\theta}(x|c)] \\\\\n&\\approx \\frac{1}{N} \\sum\\limits_{i=1}^NR(c^i, x^i)\\nabla \\log P_{\\theta}(x|c_i)\n\\end{array}更新参数的操作如下。\n\n每次update参数之后，需要和使用者互动N次获得N笔sampling data的reward之后，再去做policy gradient。\n两种比较\nTraning DataMaximum Likelihood中都是人为标注的label，是全部正确的。\nReinforcement Learning中的的数据都是机器自己产生的，有些答案可能是错的。\nGradientML中每一笔Traning Data的weight都是一样的。\nRL中每一个x和c的pair都乘以了一个Reward，意思就是每一笔Traning Data都有weight。如果data中machine的回答是正确的，那么给它一个positive weight；如果data中machine的回答是错误的，那么给它一个negative weight。\n\nweight有没有可能都是正的？我们希望reward有正有负，一般会对所有正的weight减去一个threshold。\n不可能sample到所有的x，对于在一次iteration中没有被sample到的data，他们被sample到的概率会在一次iteration结束后降低。因为总概率总是1，其他被sample到且reward比较大的，被选择的概率就变大了。\n\nGANReinforcement Learning中为了实现一个较好的machine，需要机器与人互动上万次。时间成本与人力成本过高。\n因此引入GAN，human中的feedback由Discriminator来给。类似于Conditional GAN。\n\n无法微分的三种解决办法由于有sampling process，无法将Seq2Seq Model和Discriminator接起来的时候对整个network进行微分。\nGumbel-softmaxContinuous Input for DiscriminatorUse the distribution as the input of discriminator to avoid sampling process.\nReinforcement LearningWhatConsider the output of discriminator as reward \n\nUpdate generator to increase discriminator = to get maximum reward\n\nUsing the formulation of policy gradient, replace reward R(c,x) with discriminator output D(c,x)\n\n\nDifferent from typical RL in that the discriminator would update\nHOW\n分为两个步骤，一个是训练generator g-step，与前面RL中的训练方法类似；另一个是训练discriminator d-step，要结合实际对话与机器产生的对话。\n但是在g-step中每个iteration的objective function在进行update参数之后，目标是要让log函数的概率变低，也就是说我们要让chat-bot对于某个输入x，不怎么好的输出c的概率降低。问题在于这个概率是对整个句子的概率的衡量，而整个句子的概率是通过每一个短语的条件概率相乘/log相加获得的。如果要decrease整个句子，那每个短语的概率也要decrease？\n\n我们希望在计算的时候machine知道整个句子虽然是不好的，但是实际increase或decrease的时候需要句子的某些部分。\n\n因而我们需要修改objective function，换成在每一个timestamp做evaluation，而不是对整个句子做evaluation。\n\nUnsupervised Conditional Sequence GenerationText Style Transfer之前看过Image和Voice之间style transfer的例子。对应到text中，可以把positive sentences对应transfer到negative transfer。\n用CycleGAN实现。但是还存在discrete无法gradient ascent的问题。需要把对word sequence做word embedding，就变成连续的了。\n用Projection to Common Space。\n以上都参考GAN Introduction中的内容。\nUnsupervised Absractive Summarizationsupervised的方法需要收集百万笔的labelled traning data（document1 — summary1），否则machine连产生自己的句子都不能实现（从文章中拿句子当作summary并不算一个好的summarizer）。\n所以我们需要unsupervised的方式。利用和CycleGAN差不多的架构。\n\n实际上看下面需要Minimize the reconstruction error的部分，本质上是a Seq2Seq2Seq auto-encoder。这个部分找到了document — word sequence — document的一个满足的映射。\n这个映射人类是否能读懂呢？需要Discriminator来做限制。\n\nsupervised learning是unsupervised learning的upper bound。\n我们采用unsupervised的方法的意义在只需要于supervised的方式的data数量的一半就可以达成和supervised的一样的效果。\n\nUnsupervised Translation利用CycleGAN可以把两种不同的语言间可以直接unsupervised做翻译。\n类似的也可以应用到语音辨识中。\n","categories":["GAN"],"tags":["ML","GAN"]},{"title":"简书项目复刻问题集合","url":"/2020/12/02/react-project-summary/","content":"iconfonticonfont也就是把icon当font来用，通过自定义font-face实现。线上有许多iconfont库可供使用。\n一般iconfont解压缩后的文件夹都会放在整个项目的静态资源文件夹中，即src文件夹下的statics中，这涉及到了webpack在生产环境下打包静态资源的问题，与其他图片字体的引用一致，具体参考李熠 从React脚手架工具学习React项目的最佳实践（上）：前端基础配置。\n阿里图标库\n在线链接引入\n下载项目到本地\n\n需要注意的是一次性最好把想要添加的图标全罗列进去，否则以后再添加还需要重新替换本地文件。\n使用由于历史因素使用i标签容纳无语义图标，但是自己在用的时候使用了span元素。\niconfont本意是将icon当作font来使用，所以也可以像字体一样设置颜色color，大小font-size。\n\n需要注意的是下载的icon的空白部分是透明的还是有背景白色的；也就是要注意边框与实体。\n\n\nicon+a当iconfont和超链接a href一起使用的时候，一定要先给a元素width和height，否则a元素就是个没有宽高的空元素，显示不出来。\n文字对齐这里的文字除了一般文字，还包括iconfont。\n以想要对齐的对象为基准。它的父元素，需要设置text-align；它本身，可能需要设置vertical-align。\n盒子性质由最基础的inline，block，flex，table衍生出了各种混合属性。这些基本盒子性质都是针对于盒子本身及其内容来说的。比如inline的性质就是内容决定盒子，padding和margin都不可以设置，通过设定内容的大小来决定盒子的大小；block的性质就是盒子就是一整行，通过设定盒子本身的大小以及盒子的margin和padding来决定盒子的大小。\n而混合属性，比如inline-block，这个属性inline性质代表的是这个元素在上下文中是inline的性质，他不会占据一整行，可以和其他元素一起排列在一行；block性质代表的是这个元素对于自己内部的内容是block性质，可以设置padding，margin等属性把盒子撑开来。\n从树的角度来理解，基础属性就只是从父节点出发去审视子节点，但是混合属性就设计了从该节点去向上看父节点，向下看子节点。我们在谈盒子性质，其实是在谈两个元素/标签之间的关系。\n定位方式此处视角以我们想要让它的位置从正常文档流中脱离的对象来看。应当涉及元素本身和元素的父元素。\nabsolute+float第一步： 在父元素上使用position: absolute，同时确定top bottom left right等值。明确盒子性质最基础的inline/block还是较为复杂的inline-block/flex，以及盒子的属性/box-sizing。\n第二步： 在元素上使用float属性。如果该元素和他的相邻的元素之间想要同在一行，那么他们之间是inline的关系；如果该元素和他的相邻元素不想在同一行，那么他们之间是block关系。\n第三步： 如有必要，清除该浮动元素对后续元素的影响，使用clear。\nflex布局第一步： 在父元素上使用display: flex，决定是flex-direction是row还是columnn，是wrap还是nowrap，对于给定width和height的子元素使用align-items和vertical-align进行对齐。\n第二步： 在每个子元素上使用flex: XX，这里的单位可以是百分比也可以是数字，用来说明子元素占用父元素的份额。子元素如果有内容的话（其是相对来说该内容也像子元素），还需要自己设置内容居中。\n\n关于flex布局中flex父元素的子元素定位的问题，好像align-items和vertical-align只支持头尾中这些方式，如果想要特定高度的话，依据百分比自动调节的话还是需要传统定位方式。参考react简书项目login页面的下载app这个flex子元素。\n\n0或负span的图标想放到block的元素内部去，可以先将span设置为inline/inline-block，然后把margin取负值，至于是左还是右看需要。\n\n\n\n\n\n\nbottom为0似乎也能实现底部效果。\n去除浏览器默认样式一般会在src下创建一个全局样式表，是为了消除浏览器客户端的user agent style。要将这个样式添加在APP组件中，然后在index.js中去渲染。\nstyled-component使用教程Reference#2: Why I prefer Styled components to build React apps\n官方文档\n中文文档\nstyled-components：一本通\nreact-router-dom的Link样式因为Link标签最终还是被解析为a标签，所以会自带下划线和点击过后的变蓝色，将Link样式化后变成StyledLink使用。\nimport &#123; Link &#125; from &#x27;react-router-dom&#x27;;import styled from &#x27;styled-components&#x27;;const StyledLink = styled(Link)`    text-decoration: none;    &amp;:focus, &amp;:hover, &amp;:visited, &amp;:link, &amp;:active &#123;        text-decoration: none;    &#125;`;\n需要记住a标签与Link标签本质上是行内元素，对他设置margin和padding都没有用，通过给a标签与Link标签添加display: block使它变成块级元素后才能实现padding和margin。\n待解决的问题代码优化与简洁。一开始创建主要是styled的基础使用与模版字符串，至于嵌套等高级性质还没有看，代码较为冗长。 \n数据流管理slice书写规范如果不使用createEntityAdapter来管理store中的数据，而选择手写数据的话，需要注意数据本身一定是数组而不是对象构成的，所以在对store中数据修改的时候才能用concat/push这一类的方法。由于数据本身可能还需要描述数据状态的元数据，所以就多了其他的field，从而构成了一个对象。\n使用createSlice API自动创建action以及action creators一定会有三个name: &#39;&#39;, initialState, reducers:&#123;&#125;这三个field，而extraReducers:&#123;&#125; 存在与否取决于slice本身以及slice负责的UI是否有异步数据管理的需求。\n\nreducer field中的数据一定要注意的是：\n\n这里的state是指这个slice所管理的state，而不是store全体。\nreducer对象中的每一个函数其实都是对应该action/action creator的回调函数，一定要弄明白是在原state的基础之上增删改，还是通过直接return语句覆盖原state。在initialState定义为{posts: ‘’, id: ‘’, desc: ‘’}对象的情况下,直接的赋值语句state.posts = action.payload会在state对象下重新生成一了posts field来访数据，而不会覆盖初始initialState（当时因为这个调试了好久！）\nreducer对象中的回调函数一定要export对应的slice.actions。\nreducer对象本身一定也要export default slice到store中去生成全体store。\n\n\n从数据store中随机选取数据对应到项目中就是推荐作者一栏的换一换，采用的是洗牌算法，对store中的所有数据进行洗牌操作，然后选取(0,5)即可，也可以生成一个随机数，然后加上5。\n采用Knuth-Durstenfeld Shuffle，每次从未处理的数组中随机取一个元素，然后把该元素放到数组的尾部，即数组的尾部放的就是已经处理过的元素。\n算法步骤：\n\n选取数组(长度n)中最后一个元素(arr[length-1])，将其与n个元素中的任意一个交换，此时最后一个元素已经确定\n选取倒数第二个元素(arr[length-2])，将其与n-1个元素中的任意一个交换\n重复第 1 2 步，直到剩下1个元素为止\n\nes6实现：\nfunction shuffle(arr)&#123;    let n = arr.length, random;    while(0!=n)&#123;        random =  (Math.random() * n--) &gt;&gt;&gt; 0; // 无符号右移位运算符向下取整        [arr[n], arr[random]] = [arr[random], arr[n]] // ES6的结构赋值实现变量互换    &#125;    return arr;&#125;\n异步数据管理本项目因为使用了Redux Toolkit，所以在操作异步数据的时候会使用createAsyncThunk API，结合axios一起使用的话流程如下：\n在slice中定义异步操作：\n&#x2F;&#x2F; productSlice.jsimport &#123; createSlice,createSelector,PayloadAction,createAsyncThunk,&#125; from &quot;@reduxjs&#x2F;toolkit&quot;;export const fetchProducts &#x3D; createAsyncThunk(  &quot;products&#x2F;fetchProducts&quot;, async (_, thunkAPI) &#x3D;&gt; &#123;     try &#123;        &#x2F;&#x2F;const response &#x3D; await fetch(&#96;url&#96;); &#x2F;&#x2F;where you want to fetch data        &#x2F;&#x2F;Your Axios code part.        const response &#x3D; await axios.get(&#96;url&#96;);&#x2F;&#x2F;where you want to fetch data        return await response.json();      &#125; catch (error) &#123;         return thunkAPI.rejectWithValue(&#123; error: error.message &#125;);      &#125;&#125;);const productsSlice &#x3D; createSlice(&#123;   name: &quot;products&quot;,   initialState: &#123;      products: [],      loading: &quot;idle&quot;,      error: &quot;&quot;,   &#125;,   reducers: &#123;&#125;,   extraReducers: (builder) &#x3D;&gt; &#123;      builder.addCase(fetchProducts.pending, (state) &#x3D;&gt; &#123;        state. products &#x3D; [];          state.loading &#x3D; &quot;loading&quot;;      &#125;);      builder.addCase(         fetchProducts.fulfilled, (state, &#123; payload &#125;) &#x3D;&gt; &#123;            state. products &#x3D; payload;            state.loading &#x3D; &quot;loaded&quot;;      &#125;);      builder.addCase(        fetchProducts.rejected,(state, action) &#x3D;&gt; &#123;            state.loading &#x3D; &quot;error&quot;;            state.error &#x3D; action.error.message;      &#125;);   &#125;&#125;);export const selectProducts &#x3D; createSelector(  (state) &#x3D;&gt; (&#123;     products: state.products,     loading: state.products.loading,  &#125;), (state) &#x3D;&gt;  state);export default productsSlice;\n在component中使用异步操作：\nimport &#123; useSelector, useDispatch &#125; from &quot;react-redux&quot;;import &#123;  fetchProducts,  selectProducts,&#125; from &quot;path&#x2F;productSlice.js&quot;;const dispatch &#x3D; useDispatch();const &#123; products &#125; &#x3D; useSelector(selectProducts);React.useEffect(() &#x3D;&gt; &#123;   dispatch(fetchProducts());&#125;, [dispatch]); \n这里的定义与使用分别在slice和component中是因为异步数据的产生是在server端的，也就是我们要从服务器，或者在本项目中是提前准备好的public文件下的mock数据。如果异步数据的产生是通过用于与UI交互生成的，那么createAsyncThunk的生成就应该在UI中进行。\n代码来源StackOverflow- redux toolkit and axios。\n路由管理两个基本模式路由管理采用react-router-dom，基本模式有两个。\n第一个模式就是在App顶层组件中使用BrowseRouter包裹Switch再包裹Router与Redirect。一般Router中会有参数传递。\nimport &#123;  BrowserRouter as Router,  Switch,  Route,  Redirect,&#125; from &#39;react-router-dom&#39;function App() &#123;  return (    &lt;Router&gt;        &lt;Switch&gt;          &lt;Route exact path&#x3D;&quot;&#x2F;&quot;            render&#x3D;&#123;() &#x3D;&gt; (              &lt;React.Fragment&gt;              &#x2F;&#x2F; 此处可以多个组件组合，但是不可传递参数              &lt;&#x2F;React.Fragment&gt;            )&#125;          &#x2F;&gt;          &lt;Route exact path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;&#125; &#x2F;&gt;          &lt;Redirect to&#x3D;&quot;&#x2F;&quot; &#x2F;&gt;        &lt;&#x2F;Switch&gt;   &lt;&#x2F;Router&gt;  )&#125;export default App\n第二个模式就是在组件内部要进行跳转，使用Link标签包括所有能够通过点击到达另一个页面的内容，记得传递参数。\n&#x2F;&#x2F; 某个UI的return部分&lt;Link to&#x3D;&#123;&#96;&#x2F;posts&#x2F;$&#123;post.id&#125;&#96;&#125; className&#x3D;&quot;button muted-button&quot;&gt; View Post&lt;&#x2F;Link&gt;\n参数的传递与获取Router的参数传递与Link的参数传递有所不同。\n&lt;Route exact path&#x3D;&quot;&#x2F;posts&#x2F;:postId&quot; component&#x3D;&#123;SinglePostPage&#125; &#x2F;&gt;&lt;Link to&#x3D;&#123;&#96;&#x2F;posts&#x2F;$&#123;post.id&#125;&#96;&#125; className&#x3D;&quot;button muted-button&quot;&gt; View Post&lt;&#x2F;Link&gt;\n但是对接受这些参数传递的页面的组件来说，处理方式为：\nexport const SinglePostPage &#x3D; ( &#123; match &#125;) &#x3D;&gt; &#123;    &#x2F;&#x2F;这里用花括号是因为match是一个对象，包含URL    const &#123; postId &#125; &#x3D; match.params&#125;\npath和to指向的连接整体会作为一个对象传入UI的函数组件中作为参数，为了提取其中的参数，使用url.params方法，注意这里返回的对象都是字符串类型的。\n一般得到链接里的参数后，就会将这个参数作为一个搜寻条件去匹配redux store中的所有数据。这里需要注意，如果redux中的数据id是number类型，而恰巧在useSelector中又使用了全等===符号，那么最后选择出来的结果绝对是undefined。所以一定要注意url参数和redux store的数据类型匹配。\n&#x2F;&#x2F; UI中选择id匹配的数据const post &#x3D; useSelector(state &#x3D;&gt; selectPostById(state,postId)&#x2F;&#x2F; slice文件export const selectPostById &#x3D; (state, postId) &#x3D;&gt; state.posts.posts.find(post &#x3D;&gt; post.id &#x3D;&#x3D;&#x3D; postId)&#x2F;&#x2F; 这写slector中作为参数的state是root redux object，因为这个函数最终是要传入useSelector的，而useSelector的作用对象是全体store。\n","categories":["React"],"tags":["iconfont","css布局","styled-component"]},{"title":"React数据管理之Hooks与Redux","url":"/2020/12/04/redux-hooks/","content":"React Component Reviewclass component在React的Class组件，主要由四个部分组成。\n第一部分是constructor(props){}，在这里声明这个类拥有的全部状态。这一部分属于data/state类别。\n第二部分是组件内部用于修改状态的函数，一般都被赋予一个变量，在其他地方被调用。\n第三部分是生命周期函数，用于控制该组件在渲染过程的不同阶段会执行什么样的动作，也是一个函数。这一部分属于actions类别。\n第四部分也就是render(){}部分，return部分使用JSX表达式，告诉浏览器要如何渲染上面定义的组件。这一部分属于view/UI类别。\nfunction component函数组件更像是只关心class组件的第四部分，也就是UI部分。不考虑数据与数据的变化。本质上就是DOM createElement的语法糖。\n我们在构建网页的时候，一开始只考虑UI，也就是把静态网页先搭建出来，这个时候我们只需要使用函数组件。但是随着功能的复杂化，一开始的函数组件可能需要开始拥有自己的状态与数据了，这个时候需要把函数组件包装到class组件中去，或者重构代码将函数组件重写成class组件；而class组件可能又要被包裹到更高级别的组件中去，这样子层层嵌套十分麻烦。虽然引入了单项数据流的概念，管理与检查错误还是十分麻烦。\n因此出现了用于增强函数组件的HOOKs。通过hooks在函数组件内部实现state和action，可能在函数组件之间实现共享state和action。这样一来，功能性上函数组件与HOOKs等同于class组件。\nHooks\nHooks are functions that let you “hook into” React state and lifecycle features from function components.\n\nuseStateuseState is a Hook that lets you add React state to function components.\n有了useState Hook之后，在一个函数组件被创建且你发现它需要添加状态时，就不需要再把它转换为class组件了。相当于替代了class组件中的第一部分constructor以及第二部分修改状态的函数。\n使用方法如下：\nimport React, &#123; useState &#125; from &#39;react&#39;;function Example() &#123;  &#x2F;&#x2F; Declare a new state variable, which we&#39;ll call &quot;count&quot;  const [count, setCount] &#x3D; useState(0);\n单看等号右边的useState()就相当于声明了一个状态变量，他接受一个初始状态值作为参数。\n看等号左边的一个数组，有两个值，第一个是当前状态，第二个是用于更新状态的函数。类比一下class组件，这就相当于this.sate.current_state1和this.setState{current_state1: }这两个语句。\n右边赋值给左边用到了array destructing语法，把useState的第一个返回值当前状态赋值给array索引为0的count，把用于更新状态的函数赋值给array索引为1的setCount。\nuseEffect\nBy using useEffect Hook, you tell React that your component needs to do something after render.\n\n有了useEffect Hook以后，在一个函数组件被创建且每一次的DOM渲染都有可能要执行一些其他动作的时候，就不需要把它转换为class组件并且在class组件内部多次调用生命周期函数了。相当于替代了class组件中第三部分生命周期函数。\n需要注意的是不同的业务逻辑的副作用可以用不同的useEffectHook来表现，而在生命周期函数中无论什么业务逻辑都按照生命周期的流程在区分。我们希望split the code based on what it is doing rather than a lifecycle method name.。\n使用方法如下：\nuseEffect函数会在每一次render渲染更新的时候运行。不像生命周期函数分为多个mounting和updating之类的多个阶段，他只是run after render。\nuseEffect(() &#x3D;&gt; &#123;    function handleStatusChange(status) &#123;      setIsOnline(status.isOnline);    &#125;    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);    return () &#x3D;&gt; &#123;      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);    &#125;;  &#125;);\neffects with cleanup如果在每次渲染并且施加effect之后还需要cleanup this effect，可以在useEffect函数中添加一个return语句，指明需要cleanup。类比到class组件就是ComponentDidMount与ComponentWillUnmount这两个生命周期。\n在每一次apply the effect之后都会在有一个cleanup this effect；否则不会在调用另一个apply the effect。（？存疑）\nuseEffect on Condition但是每一次重新渲染都cleaning up or applying the effect会导致性能问题，tell React to skip applying an effect if certain values haven’t changed between re-renders，因此给useEffect函数传入第二个参数，这个参数的形式是由函数内部变量组成的数组，告诉react只在这个内部变量变化时进行effect。在class组件中，通常是在ComponentDidUpdate中进行值的比较，如state或者props。\nmultiple effects to Separate  Concerns由于useEffect在函数组件内部被调用，这样useEffect函数就可以访问到函数组件内部的状态，也就是说每一次的after render effect都是不同的state变化引起的不同的effect。\nRules of Hooks\nDon’ t call Hooks inside loops, conditions, or nested functions. Only Call Hooks at the Top Level.不要在循环、条件、嵌套中使用。\n因为每一个hook都有他相关的数据管理域，react通过识别hook的调用顺序来匹配相关数据管理区域。如果有条件或者嵌套，这种顺序就会被打乱。\n\nAs long as the order of the Hook calls is the same between renders, React can associate some local state with each of them.\n\n\nDon’ t call Hooks from regular JavaScript functions.只在函数组件、自定义hook中调用hook。\n\n自定义hook的明明遵循useHook的书写规范。\n\n\nReduxRedux是基于React的一个数据/状态管理库。\nRedux is a pattern and library for managing and updating application state, using events called “actions”. \n状态/数据管理面临的挑战在React的组件中，有两种组件模式。第一种是传统的class组件，通过组件嵌套，state到props的抽象完成数据管理。第二种是函数组件，通过HOOKs API的useState()与useEffect()实现和传统class组件相同的功能。\n他们都被称作self-contained app。主要由三个部分组成：\n\nThe state, the source of truth that drives our app;\nThe view, a declarative description of the UI based on the current state\nThe actions, the events that occur in the app based on user input, and trigger updates in the state\n\n当我们需要在组件之间共享状态/数据时该怎么做？React核心概念中提出了lifting state up to parent components状态提升至父组件。那这又涉及到抽象与嵌套，state到props的转变，不停地在变换多种组件构成的树component tree，十分麻烦。\n一个方法就是把这些所有需要共享的数据/状态抽取出来集中管理，与component tree割裂开来。这也就是Redux的核心思想——This is the basic idea behind Redux: a single centralized place to contain the global state in your application, and specific patterns to follow when updating that state to make the code predictable.\n","categories":["React"],"tags":["React","Hooks","Redux"]},{"title":"React+Redux App同步数据流","url":"/2020/12/06/redux-react-app-example/","content":"feature-k Slice首先从某个feature的Slice定义开始。\nsrc下创建文件夹在src文件夹下新建一个features文件夹，然后再用具体的该特征feature1为名创建一个子文件夹，最后创建feature1slice.js。整个过程就是src =&gt; features =&gt; feature-k =&gt; feature-kSlice.js。\nAll of the code related to feature-k should go in the feature-k folder.\ninitialState与createSlice的export在feature-kSlice.js中，使用createSlice API创建reducer function。reducer function需要一些initial data 传入，因为在初次加载的时候store中的数据才有会值，才方便我们做UI component。\n\n用const和数组创建用来描述这部分数据的fake object，取名为initialState，并把它传入createSlice去。\n\n用createSlice创建feature-kSlice变量，主要是name，initialState，reducers。\nimport &#123; createSlice &#125; from &#39;@reduxjs&#x2F;toolkit&#39;const initialState &#x3D; [  &#123; id: &#39;1&#39;, title: &#39;First Post!&#39;, content: &#39;Hello!&#39; &#125;,  &#123; id: &#39;2&#39;, title: &#39;Second Post&#39;, content: &#39;More text&#39; &#125;]const postsSlice &#x3D; createSlice(&#123;  name: &#39;posts&#39;,  initialState,  reducers: &#123;&#125;&#125;)export default postsSlice.reducer\n\n\n\n在feature-kSlice.js中吧reducer function部分export出去export default postsSlice.reducer，从app/store.js中import这个文件import postsReducer from &#39;../features/posts/postsSlice&#39;，并在configureStore中添加该reducer。\n\n完成以上几个步骤之后，运行这个程序并用redux devtools检查工具是可以看到state标签中给出的初始化数据initialState的。\n\n\n\ncreateSlice的export分为两个部分，第一个是在定义createSlice的reducer时同步生成的action的export，第二个是整体reducer的export到App.js。因为这里最初还没有添加actions和reducers，所以没有export actions。\n\nfeature-k UI component因为我们在这个feature中已经有了一些initial state/fake object array，因此在该feature下开始考虑UI component。由于UI component本身也分层级，我们最最顶层的postList.js开始考虑。\n在import完了必要的API之后，export const UI1 = () =&gt; {}会跟一个箭头函数，这个函数内部会涉及store数据取用，html相关UI描述，最后return的内容就是整体UI模块。\n使用selector从redux store获取data为了从redux store获得data，需要使用useSelector Hook。useSelector Hook会使用Provider包裹起来的所有组件部分都能够访问到作为参数传入进去的全局数据store。在UI组件中调用他，只会返回被该组件需要的特定数据。\n The “selector functions” that you write will be called with the entire Redux state object as a parameter, and should return the specific data that this component needs from the store.\n写UI在获取了数据之后就可以使用map等循环语句开始制作html相关代码块。当最终需要的代码块由多个子模块组成的时候，可以先const定义多个子模块，最后在return()内部组装这些模块。\n在顶层APP添加UI在结束添加特定UI之后，需要在顶层App.js文件中import该UI，并且修改路由，这个部份涉及路由问题。\nimport &#123;  BrowserRouter as Router,  Switch,  Route,  Redirect&#125; from &#39;react-router-dom&#39;import &#123; PostsList &#125; from &#39;.&#x2F;features&#x2F;posts&#x2F;PostsList&#39;function App()&#123;    &lt;Router&gt;        &lt;div&gt;            &lt;Switch&gt;                &lt;Route                     exact            \t\tpath&#x3D;&quot;&#x2F;&quot;            \t\trender&#x3D;&#123;() &#x3D;&gt; (              \t\t&lt;React.Fragment&gt;               \t\t&lt;PostsList &#x2F;&gt;              \t\t&lt;&#x2F;React.Fragment&gt;)&#125;                &#x2F;&gt;            &lt;&#x2F;Switch&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;Router&gt;&#125;\n\n以上涉及的知识静态UI的创建，他的数据都是放在store里面的，并且目前为止reducer是空的。\n如果浏览器客户端产生了动态数据该如何处理？比如我们要在原来的postList的UI之上创建一个AddPostForm的UI，这个UI会因为用户的交互产生数据呢？如何做到UI compoennt一方的数据和store一方的数据保持一致呢？\nUI component内部数据管控这里所说的UI component内部数据管控是什么意思呢？这是因为当用户在客户端浏览器对UI进行输入，修改，点击等操作的时候，作用的对象都是UI component。UI component内部应当有管理这些数据的函数，这就需要用到React Hook中的useState API。在UI component中首先需要启用useState()产生data1和setdata1函数。\n每一次绑定了data1数据的UI发生变更的时候，放在UI component的onClick/onChange属性中的监听函数就会发现这个变更，调用回调函数ondata1Changed，而回调函数函数本身就是由useState hook的setdata1构成。这个监听函数就被放在。\n import React, &#123; useState &#125; from &#39;react&#39;export const AddPostForm &#x3D; () &#x3D;&gt; &#123;  const [title, setTitle] &#x3D; useState(&#39;&#39;)  const onTitleChanged &#x3D; e &#x3D;&gt; setTitle(e.target.value)  return (    &lt;section&gt;      &lt;h2&gt;Add a New Post&lt;&#x2F;h2&gt;      &lt;form&gt;        &lt;label htmlFor&#x3D;&quot;postTitle&quot;&gt;Post Title:&lt;&#x2F;label&gt;        &lt;input          type&#x3D;&quot;text&quot;          id&#x3D;&quot;postTitle&quot;          name&#x3D;&quot;postTitle&quot;          value&#x3D;&#123;title&#125;          onChange&#x3D;&#123;onTitleChanged&#125;        &#x2F;&gt;        &lt;button type&#x3D;&quot;button&quot;&gt;Save Post&lt;&#x2F;button&gt;      &lt;&#x2F;form&gt;    &lt;&#x2F;section&gt;  )&#125;\n过程概述为：\n用户对input UI进行输入\n=&gt; onChange事件监听函数检测到input change \n=&gt; 调用该事件监听函数的回调函数 \n=&gt; 回调函数内部通过e.target/event target对象读取UI的value，配合useState在函数UI组件内部调用setdata1，最终完成data1的更新。\nUI component与store通信在完成UI组件内部的数据用useState Hook更新储存之后，这些数据要传递到store。有可能UI组件内部储存的数据无条件的同步到store，也有可能用户的某个行为，如保存/确认/发送，出发了UI组件与store的同步。\n\n需要注意的是useState总是动态追踪变化，比如一个input的内容，在用户输入的过程中，useState也会更随着更新；而将数据同步到store的都是最终数据，global的数据，the latest values for the input fields。\n\nuseDispatch实现UI向store传递数据为了实现UI component和store的通信，首先在方法上需要添加useDispatch()方法，以及store中包含的某个reducer。该reducer作为参数传入useDispatch()方法，而该reducer的参数就是UI component需要传递到store的数据，至于传入是多个参数还是一个payload对象需要看creatSlice中reducer的定义方式。\nexport const AddPostForm &#x3D; () &#x3D;&gt; &#123;    const dispatch &#x3D; useDispatch()    const onSavePostClicked &#x3D; () &#x3D;&gt; &#123;    if (title &amp;&amp; content) &#123;      dispatch(        postAdded(&#123;          id: nanoid(),          title,          content        &#125;)      &#x2F;&#x2F; 这里传入的顺序就是createSLice方法中reducer的payload      )      setTitle(&#39;&#39;)      setContent(&#39;&#39;)    &#125;  &#125;  return (    &lt;section&gt;      &lt;h2&gt;Add a New Post&lt;&#x2F;h2&gt;      &lt;form&gt;        &#123;&#x2F;* omit form inputs *&#x2F;&#125;        &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;onSavePostClicked&#125;&gt;          Save Post        &lt;&#x2F;button&gt;      &lt;&#x2F;form&gt;    &lt;&#x2F;section&gt;    )&#125;\n调用createSlice中actionCreator的postAdded传入的是一个对象，这个对象中包含了UI component利用useState存放的数据。actionCreator内部把这个对象用action.payload来引用。\nconst postsSlice &#x3D; createSlice(&#123;  name: &#39;posts&#39;,  initialState,  reducers: &#123;    postAdded(state, action) &#123;      state.push(action.payload)    &#125;  &#125;&#125;)\naction payload的两种写法默认在reducer中使用action.payload以上两个代码块的定义与调用是基于默认的把reducer在UI中作为{}包裹的对象传递到slice中去，在slice的reducer中使用action.payload访问。操作的形式都是对象。\n手写action creator与payload自定义Right now, we’re generating the ID and creating the payload object in our React component, and passing the payload object into postAdded. \n\n手写actioncreators的一个好处就是可以自定义action的payload。需要注意的是这个id的生成不能在reducer中去生成，不然数据流都是不可预测的。在上面的例子中，id的随机生成是在UI component中完成的。在下面的例子中因为手写了action creator所以能够自定义payload。\n\nIf an action needs to contain a unique ID or some other random value, always generate that first and put it in the action object. Reducers should never calculate random values, because that makes the results unpredictable.\n\n&#x2F;&#x2F; hand-written action creatorfunction postAdded(title, content) &#123;  const id &#x3D; nanoid()  return &#123;    type: &#39;posts&#x2F;postAdded&#39;,    payload: &#123; id, title, content &#125;  &#125;&#125;\n虽然createSlice只要写了reducer就能自动生成action creator，但是我们如何在给自动生成的action creator定义我们想要的payload呢？玩意需要传递的数据十分复杂呢？\ncreateSlice中自定义payload的prepare callback functioncreateSlice允许我们在reducer对象的某个特定reducer中给该reducer和action creator定义payload，只需要在定义reducer的同时定义prepare callback function即可，即define a “prepare callback” function when we write a reducer。\nprepare函数的定义时传入的参数就和手写action creator传入的参数是一样的，都是从UI component处获得的。该函数返回一个payload filed对象，里面就是该reducer与action creator的payload。\n\nThe “prepare callback” function can take multiple arguments, generate random values like unique IDs, and run whatever other synchronous logic is needed to decide what values go into the action object. It should then return an object with the payload field inside. \n\n当我们在UI component中调用这个action creator的时候，传入reducer函数的参数就是多个组成payload的元素，而不再是一个对象。\n两种定义方式的比较默认action.payloadcreateSlice定义reducer\nconst postsSlice &#x3D; createSlice(&#123;  name: &#39;posts&#39;,  initialState,  reducers: &#123;    postAdded: &#123;      reducer(state, action) &#123;        state.push(action.payload)      &#125;,      prepare(title, content, userId) &#123;        return &#123;          payload: &#123;            id: nanoid(),            title,            content,            user: userId          &#125;        &#125;      &#125;    &#125;    &#x2F;&#x2F; other reducers  &#125;&#125;)\nUI组件调用reducer\nconst onSavePostClicked &#x3D; () &#x3D;&gt; &#123;    if (title &amp;&amp; content) &#123;      dispatch(postAdded(title, content, userId))      setTitle(&#39;&#39;)      setContent(&#39;&#39;)    &#125;  &#125;\nprepare callbackfunctioncreateSlice定义reducer\n&#x2F;&#x2F; 这部分内容包裹在postSlice中postUpdated(state, action)&#123;            const &#123; id, title, content &#125; &#x3D; action.payload            const existingPost &#x3D; state.find(post &#x3D;&gt; post.id &#x3D;&#x3D;&#x3D; id)            if(existingPost)&#123;                existingPost.title &#x3D; title                existingPost.content &#x3D; content            &#125;        &#125;,\nUI组件调用reducer\nconst onSavePostClicked &#x3D; () &#x3D;&gt; &#123;        if(title &amp;&amp; content)&#123;            dispatch(postUpdated(&#123;id: postId, title, content&#125;))            history.push(&#96;&#x2F;posts&#x2F;$&#123;postId&#125;&#96;)        &#125;    &#125;\n多个单页UI component与路由在完成了某个具备单独成页性质的UI component之后，需要在顶层文件App.js中将它import并使用Route API添加。\n其次需要查看页面间路由，比如从列表页到详情页，需要在列表页添加到详情页的Link API。感觉Link API就有点像href。\n","categories":["React"],"tags":["React","Redux"]},{"title":"Redux的同步数据流","url":"/2020/12/06/redux-sync-data-flow/","content":"Redux Store\nCreate a Redux store using the Redux Toolkit configureStore API\n\n在使用Redux管理React全体数据/状态的时候，可以将全体数据按该app功能function/特征features来划分成不同的Redux Slice，这些数据块被包裹在configureStore方法中，被保存在store.js中。通过顶层文件访问state.redux-slice-name来访问数据块。\n什么样的数据才需要放到store中Global state that is needed across the app should go in the Redux store. State that’s only needed in one place should be kept in component state.\nIn a React + Redux app, your global state should go in the Redux store, and your local state should stay in React components.\nredux slice\nA “slice” is a collection of Redux reducer logic and actions for a single feature in your app, typically defined together in a single file. \n\nconfigureStore实现redux slice在文件树中store.js和features/functions这个文件夹在同一层，features/functions文件夹中又是各种redux slices的子文件夹，这些子文件夹的命名就是configureStore中reducer对象的key。\nimport &#123; configureStore &#125; from &#39;@reduxjs&#x2F;toolkit&#39;import usersReducer from &#39;..&#x2F;features&#x2F;users&#x2F;usersSlice&#39;import postsReducer from &#39;..&#x2F;features&#x2F;posts&#x2F;postsSlice&#39;import commentsReducer from &#39;..&#x2F;features&#x2F;comments&#x2F;commentsSlice&#39;export default configureStore(&#123;  reducer: &#123;    users: usersReducer,    &#x2F;&#x2F;  Since usersReducer is responsible for updating the state.users slice, we refer to it as a &quot;slice reducer&quot; function.    &#x2F;&#x2F; reducer对象的key就是features文件夹中的子文件夹名    posts: postsReducer,    comments: commentsReducer  &#125;&#125;)\nconfigureStore手写\n以上调用了redux中的configureStore，这是一个封装好的函数。configureStore内部实现是怎样的呢？\n当我们把花括号包裹起来的{}reducer object传入给configureStore的reducer中去之后，他会把这个对象在传递给combineReducer函数用来生成一个RootReducer。\n\n如何实现手写configureStore？\nconfigureStore的本质就是把各个slice结合起来RootReducer，这个RootReducer的参数就是普通reducer所要求的state和action，只不过这个state是全体数据的state。\nfunction rootReducer(state &#x3D; &#123;&#125;, action) &#123;  return &#123;    users: usersReducer(state.users, action),    posts: postsReducer(state.posts, action),    comments: commentsReducer(state.comments, action)  &#125;&#125;\nRootReducer也可以通过调用combineReducers这个方法来写。他接受一个包含slice reducers的对象作为参数，返回的就是root reducer函数。\nconst rootReducer &#x3D; combineReducers(&#123;  users: usersReducer,  posts: postsReducer,  comments: commentsReducer&#125;)\n可以把这个RootReducer直接传入到configureStore中去。\nconst store &#x3D; configureStore(&#123;  reducer: rootReducer&#125;)\nActionsActions本质上就是对象object。这个对象中包括：值为字符串的type field，能够返回action的action creator functions。\n手写Actions定义各种Actions是复杂且无聊的，因为多个action可能就属于一个功能块。比如论坛中的post板块，可能有post/postUpdated，也可能有post/postDeleted等多个actions。\n因此Redux写了一个API把这些工作都集合了起来，这就是createSlice。\n使用createSlice写ActionsRedux Toolkit has a function called createSlice, which takes care of the work of generating action type strings, action creator functions, and action objects. \n在createSlice内部需要用字符串定义name，用reducer functions组成的对象定义reducers。同时定义initalstate，因为需要给createSlice传递一个初始状态值。\nimport &#123; createSlice &#125; from &#39;@reduxjs&#x2F;toolkit&#39;export const counterSlice &#x3D; createSlice(&#123;  name: &#39;  &#39;,  initialState: &#123; &#125;,  reducers: &#123;    action1: state &#x3D;&gt; &#123; &#125;,    action2: state &#x3D;&gt; &#123; &#125;,    action3: (state, action) &#x3D;&gt; &#123; &#125;  &#125;&#125;)export const &#123; action1, action2, action3 &#125; &#x3D; counterSlice.actionsexport default counterSlice.reducer\n调用createSlice就会自动生成对应的action code。在createSlice中生成的action code的type就从createSlice的name以及每个reducer function的key name而来。比如， &quot;counter&quot; name + the &quot;increment&quot; reducer function generated an action type of &#123;type: &quot;counter/increment&quot;&#125;. \nredux reducer规则\n必须是state+action=》state的形式\nThey should only calculate the new state value based on the state and action arguments\n\nimmutable updates/ No mutating states/ 不可以部分数据更新，必须全体更新\nThey are not allowed to modify the existing state. Instead, they must make immutable updates, by copying the existing state and making changes to the copied values.\n但是实现imuutable update每次都需要原来数据的copy，copy的更改，用copy替换原来的数据这三个步骤，十分麻烦。\ncreateSlice和createRedux通过使用Immer library实现了”mutable” update，Immer承担了copy&amp;return的工作，我们只需要关心update和change即可。\n\nImmer uses a special JS tool called a Proxy to wrap the data you provide, and lets you write code that “mutates” that wrapped data. But, Immer tracks all the changes you’ve tried to make, and then uses that list of changes to return a safely immutably updated value\n\n\n不含异步逻辑\nThey must not do any asynchronous logic or other “side effects”\n\n\n异步数据同步逻辑的操作流程如下：\n\nActions are dispatched\nthe store runs the reducers and calculates the new state\nthe dispatch function finishes. \n\n但是当我们需要从一个API获取数据的时候需要使用异步逻辑。\n使用thunk实现异步使用thunk需要把redux-thunk middleware添加到新建的redux store中。\n\n为什么需要middleware？因为reducer的设计规则不允许我们把异步逻辑放在里面，之所以要把异步逻辑放在reducer去是因为能够访问到store数据。那异步逻辑放在哪里呢？\n如果我们能访问到store，那么书写异步逻辑就不是问题。访问store，并且把disptach的逻辑放到异步函数promise/setTimeout之类的就行。那么这涉及到import store into other files，但这也是不可行的，因为redux的设计不允许这种import store的行为。\n解决办法就是用middleware去拓展redux store，让store拥有其他的功能。The Redux store can be extended with “middleware”, which are a kind of add-on or plugin that can add extra abilities.\n\nmiddleware的两个主要功能：\n让使用middleware的代码块有异步逻辑的同时也能访问全体store。\n修改普通的dispatch函数，让它可以接受functions or Promises，为不实普通的action objects。The Redux Thunk middleware modifies the store to let you pass functions into dispatch.\n\n\nthunk详解当使用configureStore创建redux store时，configureStore API会自动配置好thunk。\n\nA thunk is a specific kind of Redux function that can contain asynchronous logic. Thunks are written using two functions:\n\nAn inside thunk function, which gets dispatch and getState as arguments\n内部的thunkfunction本质上就是异步函数带有promise或者async之类\n\nThe outside creator function, which creates and returns the thunk function\n外部的creator function会传入一个从服务器获得的数据\n\n\n\nUI component访问storeThe React-Redux library has a set of custom hooks that allow your React component to interact with a Redux store.\n访问state最常见的就是用useSelector Hook从全体数据的store中获取你想要的那一部分数据（extract whatever pieces of data it needs from the Redux store state）。\n手写slector一个功能是允许从state中获取某个值的函数就叫selector。\nexport const selectCount &#x3D; state &#x3D;&gt; state.counter.value\n如果我们的UI component能够访问store中的数据，就可以在UI component中如下调用selector函数。\nconst count &#x3D; selectCount(store.getState())console.log(count)&#x2F;&#x2F; 0\n问题就在于Our components can’t talk to the Redux store directly, because we’re not allowed to import it into component files. 也就是store不能被import。因此就需要useSelector Hook作为中介与Redux store对话。\n使用useSelector Hook实现const posts &#x3D; useSelector( state &#x3D;&gt; state.posts)\nuseSelector总会在一个action被dispatched切redux store更新之后重新运行，并比较前后选择的值。如果前后值不相同，useSelector会让相关的组件用新的数据/状态重新渲染。\n访问action在UI component中，如果用户做了什么行为，会触发action store中的某个action creator，那么我们就能把它当作eventListener一样使用。\n但是问题是UI component本身是没有办法访问store的，这个时候需要使用useDispatch Hook。\nconst dispatch &#x3D; useDispatch()render(&#123;&lt;button  className&#x3D;&#123;styles.button&#125;  aria-label&#x3D;&quot;Increment value&quot;  onClick&#x3D;&#123;() &#x3D;&gt; dispatch(increment())&#125;&gt;  +&lt;&#x2F;button&gt;&#125;)\n\nHook如何定位store虽然UI子组件可以通过useSelector和useDispatch访问redux store，但是这些hook如何知道他们要访问的store是哪个store？\n方法就是在app的入口文件index.js中引入Provider，并把我们希望访问的store作为参数传入。\nimport React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;import &#39;.&#x2F;index.css&#39;import App from &#39;.&#x2F;App&#39;import store from &#39;.&#x2F;app&#x2F;store&#39;import &#123; Provider &#125; from &#39;react-redux&#39;ReactDOM.render(  &lt;Provider store&#x3D;&#123;store&#125;&gt;    &lt;App &#x2F;&gt;  &lt;&#x2F;Provider&gt;,  document.getElementById(&#39;root&#39;))\n","categories":["React"],"tags":["React","redux","slice","store","thunk"]},{"title":"十二月观影记录","url":"/2020/12/07/my-dec-films/","content":"杀马特我爱你中午刚听完文化有限关于美国工厂的一期播客，晚上就在男朋友的推荐下看了纪录片杀马特我爱你。感觉可以从以下几个角度看。\n\n工厂流水线与工人个性化\n\n工厂流水线要求人像机器一样不间歇工作，工资按照做多少零件，每个零件多少钱来算。为了多赚钱，只能多做，不停地做。好像你呆在这个工厂不要出去也没有关系，你所有的一切在这个工厂都可以完成。高强度高密集的工作是对人性的压榨，这种工作模式下人的个性是无法伸展的，没有生活，没有个性。\n杀马特的出路，就是用头发来宣誓自己，在极度缺乏安全感的情况下吸引别人的注意力。\n\n亚文化与主流文化的冲突\n\n杀马特群体本身是自爱的，而不是像网络上描述的那样是自黑和自嘲。我记得影片中戴眼镜穿的西装革履的小哥说，大概是12年还是13年开始，网络上开始出现对杀马特圈子的围剿，可是明明我们只是安守一隅，为什么不能有空间留给我们呢，就那么一片就好。\n主流文化的党同伐异，让亚文化在中国社会上存活地异常困难。\n\n工作与生活的关系\n\n一个刘海姑娘谈起自己妈妈对自己说的话：“哪里需要休假，我一天都在上班也没有关系。”杀马特不想像自己的父辈母辈一样只看着钱。但其实父辈母辈为了赚钱也只是养家糊口，供家庭生计和子女读书，为他人而工作。而在子女一代，他们更希望为自己做些什么。\n\n城市与农村的分化\n\n罗福兴说：“在城市我都不敢看高楼的，那和我没什么关系。”刚进城打工的时候，可能这个小朋友连自己租的房子都找不到。\n农民工与城市没有任何连接，甚至城市本身都是不欢迎不能作为廉价劳动力的农民工的。\n\n留守儿童与城市童工\n\n杀马特的主要群体都是农民工与农民工二代。刚进城市，心智尚未成熟，可能刚下车行李就被偷了，可能走在路上还要被人骗钱，他们走在城市的街上，面对隐藏在街道上的威胁，他们的内心其实是害怕的，因此他们用上冲的、五颜六色的头发来武装自己。\n进击的巨人最终季来了！但是时间线还是需要捋一捋。\n三和人才市场NHK拍的纪录片，反映了一些广东三和地区的社会问题。\n看了这么多之后听了这么多之后，发现现状就是在处理问题的时候，往往是解决提出问题的这个人，而不是去解决问题本身。\n阳光普照感觉节奏有点慢了，后面1.5倍速观看的。比较值得称赞的是配乐和场景。配乐很好听也很应景；很多场面都拍的很日式，看到片头跟焦好像是个日本人。\n还有，颜值担当许光汉的嘴为啥是歪的。\n十二公民男朋友推荐的，改编自十二怒汉的十二公民。3号陪审员也是绝了，演的太好了。\n新世纪福音战士剧场版1.11/2.22/3.33导演有钱了之后，拍出来的感觉果然也不一样了啊，使徒的形态与攻击方式都变化了很多。期待明年一月的4.44。\n窝头会馆北京人艺的话剧，在youtube上看的录像。这算是我第一次正儿八经看话剧吧，体验太不一样了。我对话剧的印象还停留在雷雨，就是高中课本上那阴沉沉凄惨惨的讲述家庭人伦的雷雨，就是没啥意思。但是窝头会馆是真的不太一样，台词十分有意思，演员也十分有意思。\n总的来说就是——老戏骨集会，一幕背景从头用到尾，台词蹦跶蹦跶隐喻意味还特别强。最喜欢耶稣、关老爷、释加牟尼三足鼎立那一段，笑岔气了；关公双手执刀拿钱和皇上的隐喻也有意思。\n钢的琴我实在是太喜欢这部片子了！配乐一流！构图一流！色彩一流！演员一流！看这部片子觉得自己就是精神东北人。\n看完这部片子的当天，就让男朋友唱了一首心恋给我听，好家伙，他原来是听过这首歌的，只不过到那时候才知道是叫心恋。\n白日焰火关于演员的演技，我没什么高深的简介。一个演员有多大的能耐让观众投入他的角色，这就是他的演技。我在看廖凡饰的主人公张自力，至少能被他带入那个角色。记得最清楚的是他在雪地里喝得烂醉被人摩托换单车；在摩天轮上桂纶镁和他的对手戏，光影之间的场面；酒桌上推杯换盏后的无奈与心酸。对于我来说记忆的点都是他演的出彩的点。\n桂纶镁确实越看越好看啊，一开始觉得不咋地，看到后来就有那清冷出挑的意思了。\nhello树先生男朋友称这是王宝强演技巅峰之作。怎么说呢，感觉王宝强演技有点流于形式了，就是说精神有问题就一个走路走不出个人样，感觉卡住了弯不过来一样。\n可以看出导演想拍很多东西，前半段过于缓慢了，铺垫过多了，反而后半段主人公精神出现了问题之后才显得有看头。\n让子弹飞绝了！绝了！绝了！台词一流，演技一流。\n活着色彩太可以了！巩俐太漂亮了！\n疯狂的石头感觉并不幽默。\n无人区还是宁浩的片子，个人觉得比疯狂的石头好看。\n我发现作为观众我并不讨厌好人坏人泾渭分明，而是讨厌被告诉这是好人坏人，通过自己感知演员演出的角色，从而体会出这是好人这是坏人的感觉并不赖，毕竟这部片子中卖隼的那个坏人是被演的彻彻底底、完完全全的坏。\n辩护人","categories":["好好生活"],"tags":["观影","审美"]},{"title":"redux-toolkit介绍","url":"/2020/12/10/redux-toolkit/","content":"在使用redux toolkit之前需要在项目中安装依赖包。\nnpm install @reduxjs/toolkit\n由于redux toolkit本身已经是依赖于redux/redux-thunk/reselect这些依赖包的抽象集合，所以可以不再使用这些基础依赖包。\nnpm uninstall redux redux-thunk reselect\n这些基础依赖包提供的API都能在redux-toolkit中找到。\nStore Setup手写store基础配置在redux fundamentals与redux essentials的教程中都涉及了最底层的创建redux store的流程。\n为了创建一个redux store，需要经历以下几个步骤：\n\nimport各个slices中的reducers到rootReducer文件中，combine形成rootReducer\n将rootReducer文件中的rootReducer添加到store file中\n在store file中import用于配置thunk middleware/applyMiddleware等方法\n将多个配置方法使用composeWithDevTools组合起来形成唯一的一个composed store enhancer\n调用createStore并传入root reducer和composed store enhancer\n\n使用configureStoreRedux Toolkit提供了configureStore API简化以上五个步骤。\nconfigureStore为我们直接提供了以下功能：\n\n默认combine slice reducers为rootReducer\n跳过rootReducer直接创建redux store\n自动添加thunk middleware\n自动添加其他一些能够检查mutating updates的middleware，如果我们在slice内部的reducer中进行了mutable updates就会报错\n自动将store连接到Redux DevTools Extension\n\nWriting Slicesredux store要求对state的变更必须是immutable的，因此在书写slices的时候，需要一遍一遍地先copy原来的obj，再修改原来的obj，再整体return obj。\n而且reducer的书写是以switch/case的形式书写的，每一次都需要传入action type进行匹配。\nRedux Toolkit提供了createSlice API简化reducer logic and actions。\ncreateSlice优点createSlice为我们直接提供了以下功能：\n\n直接在reducers对象内部以函数的形式书写case reducers，不需要使用switch/case\n\n\nWe write case reducer functions inside the reducers object, and give them readable names\n\n\n由于Immer Library的配置，可以在createSlice内部写”mutable update logic”\n\n\ncreateSlice allows us to safely “mutate” our state!\n\n\naction creator会因为reducer function的定义而自动生成\n\n\ncreateSlice will automatically generate action creators that correspond to each case reducer function we provide\n可以通过访问slice.actions.reducerFunctionName来访问自动生成的actioncreator。\naction creator的action type就是name filed + reducer field里的function name\n\n使用createSlicecreateSlice()参数接受一个含有三个主要fielde的对象：\n\nname field是自动生成的action creator的action type的前缀\ninitialState field是reducer的初始状态\nreducers field是一个key为string，value为case reducer functions的函数。\n\n\n每次一完成createSlice的定义后都有两行需要export的内容。\n第一行是需要被import到redux store的reducer整体：export default todosSlice.reducer。\n第二行是需要被import到UI component的、自动生成的reducer.actions：export const &#123; todoAdded, todoToggled &#125; = todosSlice.actions。\n\n如何为reducer field中的reducer function传递更多的参数？在UI component中调用dispatch的时候传递给dispatch的action的参数是和slice中定义的action.payload是形式上是一致的。\n&#x2F;&#x2F; slice file中定义在createSlice的reducer field里的reducer functionreactionAdded(state, action) &#123;const &#123; postId, reaction &#125; &#x3D; action.payload&#125;&#x2F;&#x2F; UI component&lt;button key&#x3D;&#123;name&#125;         type&#x3D;&quot;button&quot;         className&#x3D;&quot;muted-button reaction-button&quot;        onClick&#x3D;&#123;() &#x3D;&gt; dispatch(reactionAdded(&#123;postId: post.id, reaction: name&#125;))&#125;&gt;&#123;emoji&#125; &#123;post.reactions[name]&#125;&lt;&#x2F;button&gt;\n数据都是以对象的形式，按照key和value的形式一一对应传递的。\n\n如果遇到从UI component传入多个参数需要经过某些preparation logic（也就是UI传入的数据要做一些额外的变换）才能作为该action的payload传递到reducer function的情况下，该怎么办？\ncreateSlice提供了为该reducer function添加一个prepare callback function field，用于把UI传过来的数据处理一下，在作为action.payload传递到reducer function中去运行。\n在reducers field中将带有prepare callback的函数放在该reducer function名字的对象下，该对象有prepare field和reducer field。\n&#x2F;&#x2F; reducer中createSlice的reducers fieldtodoColorSelected: &#123;      reducer(state, action) &#123;        const &#123; color, todoId &#125; &#x3D; action.payload        state.entities[todoId].color &#x3D; color      &#125;,      prepare(todoId, color) &#123;        return &#123;          payload: &#123; todoId, color &#125;        &#125;      &#125;    &#125;,\n\nWhen we call the generated action creator, the prepare function will be called with whatever parameters were passed in. It should then create and return an object that has a payload field (or, optionally, meta and error fields)\n\nWriting ThunksRedux Toolkit has a createAsyncThunk API that will generate these thunks for us.\ncreateAsyncThunk定义与使用方法createAsyncThunk接受两个参数：\n\n第一个参数是string类型，作为自动生成的action的action type\n第二个参数是返回Promise对象的payload creator callback function。通常用async/await语法书写。\n\nexport const Thunk1 &#x3D; createAsyncThunk(&#39;feature&#x2F;Thunk1&#39;, async () &#x3D;&gt; &#123;&#125;)\ncreateAsyncThunk内部会自动生成：三个action creators以及对应的action types，一个在（该thunk function）被调用的时候自动dispatch这些actions的thunk function。\ncreateAsyncThunk.pending: feature&#x2F;createAsyncThunk&#x2F;pendingcreateAsyncThunk.fulfilled: feature&#x2F;createAsyncThunk&#x2F;fulfilledcreateAsyncThunk.rejected: feature&#x2F;createAsyncThunk&#x2F;rejected\nThunk generated action in extraReducers注意在我们的slice文件中thunk都是被书写在createSlice外部的，因此createSlice内部的状态是无法监听createSlice本身之外定义的action type的。\n为了监听其他地方定义的action type，createSlice提供了extraReducers field。\ncreateSlice also accepts an extraReducers option, where we can have the same slice reducer listen for other action types\n该field就是一个callback function with a buidler parameter。当我们需要createSlice去监听其他的action type的时候，只要在callback function内部调用builder.addCase(actionCreator, caseReducer)即可。\nNormalizing Statenormalizing state的好处就是可以用ID寻找任何一项数据本身，而不需要循环整个数组。与其用数组来储存数据本身，不如用对象想储存数据，以及数据相关的元数据，以及错误信息。\nRedux Toolkit includes a createEntityAdapter API that has prebuilt reducers for typical data update operations with normalized state. \ncreateEntityAdapter的内置方法Calling createEntityAdapter gives us an “adapter” object that contains several premade reducer functions, including:\n\naddOne / addMany: add new items to the state\nupsertOne / upsertMany: add new items or update existing ones\nupdateOne / updateMany: update existing items by supplying partial values\nremoveOne / removeMany: remove items based on IDs\nsetAll: replace all existing items\n\n\n以上都是和增删state value相关的操作。\n\ngetInitialState: returns an object that looks like &#123; ids: [], entities: &#123;&#125; &#125;, for storing a normalized state of items along with an array of all item IDs\n\n一般getInitialState可以作为createSlice的initialState field的参数传入。\n\ngetSelectors: generates a standard set of selector functions。\n\ngetSelectors默认自动生成两个selector：返回所有items的数组的selectAll；以及返回一个item的selectById。但是由于这个通用的名称是不具有语境的，我们可以把它换名字变成当前slice语境下的函数。使用array destructing为selector重命名。\n由于getSelector不知道应该在redux state tree中的那个分支找这个slice的数据，所以需要传递一个小小的selector来告诉getSelector，要找所有state中的当前slice的state。\n&#x2F;&#x2F; todos slice in whole redux storeexport const &#123;  selectAll: selectTodos,  selectById: selectTodoById&#125; &#x3D; todosAdapter.getSelectors(state &#x3D;&gt; state.todos)&#x2F;&#x2F; this slice\n","categories":["React"],"tags":["React","Redux"]},{"title":"JWT介绍","url":"/2020/12/14/JWT-explaination/","content":"JWT，JSON Web Token，是用户身份认证/authentication的一种方式。JWT通过将用户的登录状态和登陆数据用加密后JSON的格式储存在客户端，服务端依靠这个字符串认定用户身份。\n背景与两种认证方式介绍传统的认证方式是基于session的用户认证，即session-based authentication。\n下图是session认证过程，包括初次建立认证以及后续使用该认证。\n \n在初次建立认证的过程中，一个用户登录到一个网站，server就会为该用户生成session；在本地服务器的数据库中储存该session；返回一个SessionId给client/也就是浏览器，储存到浏览器的cookie中。\nserver上的session是有expiration time，因此在失效后用户必须重新登录并重新生成另一个session。\n在后续使用该认证的过程中，只要生成的session是有效的，每一次client为用户发送一个http请求，包含了SessionId的cookie总会被发送到server。server通过比较http请求中的SessionId和本地数据库中的session进行用户认证，然后返回相应的数据。\n基于session的认证存在问题是平台限制。cookie是客户端浏览器拥有的特性，当从手机端native app去访问服务器的时候是没有cookie的，而为了不同的平台去开发多个服务器显然是不划算的，因此就有了Token-based Authentication。\nJWT工作原理Token-based Authentication初次建立用户认证时，用户登录状态被server编译encoded为一个JSON Web Token，并返回到client去。JWT的储存从server端转移到了client端，server端不再需要去储存用户登录相关的信息。基于client端是手机端还是PC端有区别，基于手机系统也有区别，比如在浏览器当中就是Local Storage，在IOS中就是KeyChain，在Android中就是Shared Preferences。\n在后续使用该认证时，client只需要把储存在本地的JWT附送在http请求一并发送（一般都是在http报文的头部）。server会验证JWT并返回response。\n\nJWT本身并不是在Encrypt data，可以从下一节JWT的生成看出他只是在Encode data。JWT的目的是证明data是被一个可信任的源产生的。如果有攻击方拿到了JWT数据，照样可以获得用户信息，因此需要使用HTTPS encrpytion。\nJWT构成与生成JWT本质上就是JSON数据格式，也就是JavaScript对象，由Header，Payload，Signature三部分组成。\nHeaderHeader一般用于说明Token type是JWT，以及使用什么算法来产生后续的Signature，代表了Message authentication code。\n&#123;  &quot;typ&quot;: &quot;JWT&quot;,  &quot;alg&quot;: &quot;HS256&quot;&#125;\nPayloadPayload用于储存我们想要储存在JWT中用于用户验证的相关信息，如username，userId，email，以及一些standard fields（有点像说明数据meta data）。\n&#123;  &quot;userId&quot;: &quot;abcd12345ghijk&quot;,  &quot;username&quot;: &quot;bezkoder&quot;,  &quot;email&quot;: &quot;contact@bezkoder.com&quot;,  // standard fields  &quot;iss&quot;: &quot;zKoder, author of bezkoder.com&quot;,  &quot;iat&quot;: 1570238918,  &quot;exp&quot;: 1570238992&#125;\nSignatureSignature的生成是基于前面的payload和header的，分为三个步骤。\n\n首先，把header和payload两部分encode，并且用dot拼接起来。const data = Base64UrlEncode(header) + &#39;.&#39; + Base64UrlEncode(payload); \n其次，对拼接好的前两部分做hash运算，至于用什么加密算法，是在header中alg字段定义好的。const hashedData = Hash(data, secret);\n\n最后，对hashing result进行encode，得到Signature。const signature = Base64UrlEncode(hashedData);\n\n\nCombine three parts把上面生成的三个部分用JWT的标准格式拼接起来的到最终的结果header.payload.signature。\nconst encodedHeader = base64urlEncode(header);/* Result */&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&quot;const encodedPayload = base64urlEncode(payload);/* Result */&quot;eyJ1c2VySWQiOiJhYmNkMTIzNDVnaGlqayIsInVzZXJuYW1lIjoiYmV6a29kZXIiLCJlbWFpbCI6ImNvbnRhY3RAYmV6a29kZXIuY29tIn0&quot;const data = encodedHeader + &quot;.&quot; + encodedPayload;const hashedData = Hash(data, secret);const signature = base64urlEncode(hashedData);/* Result */&quot;crrCKWNGay10ZYbzNG3e0hfLKbL7ktolT7GqjUMwi3k&quot;// header.payload.signatureconst JWT = encodedHeader + &quot;.&quot; + encodedPayload + &quot;.&quot; + signature;/* Result */&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJhYmNkMTIzNDVnaGlqayIsInVzZXJuYW1lIjoiYmV6a29kZXIiLCJlbWFpbCI6ImNvbnRhY3RAYmV6a29kZXIuY29tIn0.5IN4qmZTS3LEaXCisfJQhrSyhSPXEgM1ux-qXsGKacQ&quot;\n参考Bezkoder.com\n","categories":["JavaScript"],"tags":["前端","JSON"]},{"title":"ES6导入导出声明","url":"/2020/12/15/import-export-es6/","content":"模块是自动运行在严格模式下且没有办法退出运行的JavaScript代码。\nimport和export都是静态关键字。模块的导入和导出有一个重要的限制/原则，必须在在其他语句和函数之外使用，不能动态的通过if语句之类的语法去进行导入导出。\n导出语法可以导出任何该js文件中的变量、函数、类。\n定义时导出声明这种导出方法要求导出的函数或者类声明有名称。\nexport var color = &quot;red&quot;;export function sum(num1, num2)&#123;    return num1+num2;&#125;export class Rectangle()&#123;&#125;\n文件底部导出引用这种导出方法要求导出的函数或者类有名称。这里导出的不是声明，而是引用。\nfunction multiply(num1, num2)&#123;    return num1*num2;&#125;export multiply;\n重命名导出使用as关键字来指定函数在模块外应该被称为什么名称。在导入的时候就需要使用as关键字后面跟着的名称来导入。\nfunction multiply(num1, num2)&#123;    return num1*num2;&#125;export &#123;multiply as mul&#125;;import &#123; mul &#125; from &#x27;./example.js&#x27;\n默认值导出模块的默认值是指通过default关键字指定的单个变量、函数、或者类，只能为每一个模块设置一个默认的导出值。在某一个模块中多次使用default关键字导出是语法错误。\n\n\n导出匿名函数或类\n\nexport default function(num1, num2)&#123;    return num1+num2;&#125;\n以上把function作为默认值导出了，且该函数没有名称，也就是说可以用匿名函数导出了。\n为什么可以不给函数命名？因为函数被模块所代表了，因此它需要一个名称。\n\n\n先定义函数或类，在导出为默认值\n\nfunction multiply(num1, num2)&#123;    return num1*num2;&#125;export default multiply;\n\n\n使用重命名语法结合as导出默认值\n\nfunction multiply(num1, num2)&#123;    return num1*num2;&#125;export &#123; multiply as default&#125;\n经常用于在一条导出语句中同时指定多个导出内容（包括默认导出）。\n导出一切导出该模块中的所有值（包括默认值和所有命名导出值/非默认值），使用*模式。有可能影响导出内容。\nexport * from &#x27;./example.js&#x27;\n导入语法在模块A中导出的功能通过import 关键字在模块B中访问，import语句主要由两部分组成：要导入的标识符，标识符要从哪个模块倒入。\n语法解释import &#123; identifier &#125; from &#39;./example.js&#39;\nimport语句有一个原则，不管在import语句中把一个模块写了多少次，该模块总是执行一次。也就是from &#39;./example.js&#39;总是只执行一次。\n原因在于每一条导入模块的代码执行后，实例化过的模块被保存在内存中。只要另一个import语句引用了该模块，就重复使用储存在内存中的实例化的模块。如果整个应用程序中有其他模块也使用了./example.js，那么这些模块都共同使用内存中的加载过的模块。\n需要导入的标识符 &#123; identifier &#125;关键字import后面的大括号表示从给定模块导入的绑定(binding)。\n从哪个模块导入 &#39;./example.js&#39;关键字from表示要从哪个模块导入，其后的字符串指定了该导入模块的路径。\n指定路径的字符串需要文件扩展名。原因有二：第一，浏览器使用的路径格式与传给&lt;script&gt;元素的相同，在script元素中做引用的时候是跟着js扩展的；第二，Node.js基于文件系统前缀区分本地文件和包。例如，example是一个包，但./example.js就是一个本地文件。\n指定路径的字符串之前需要包含/,../, ./，目的是更好地兼容多个浏览器和Node.js环境。\n导入一或多个绑定普通的绑定都需要放在花括号中{}。\nimport &#123;sum&#125; from &#x27;./example.js&#x27;import &#123;sum, multiply&#125; from &#x27;./example.js&#x27;\n导入整个模块/命名空间导入import * as example from &#x27;./example.js&#x27;example.multiply(1, 2)\n可以把./example.js整个模块的模块A都导入进模块B作为单一对象example使用，整个模块的所有导出都可以作为对象的属性来使用。\n这个导入格式也被称为命名空间导入(namespace import)，因为./example.js文件中并不存在example对象，故而example是作为example.js文件中所有导出成员的命名空间对象被创建的。\n重命名导入import &#123; mul as numti &#125; from &#x27;./example.js&#x27;multi(1, 2)\n默认值导入注意导入默认值是不需要添加花括号，import后面的不带花括号的名称是当前模块B的本地名称sum。\nimport sum, &#123; color &#125; from &#x27;./example.js&#x27;\n在同时导入默认值和非默认值的时候，需要用逗号将默认的本地名称与大括号包裹的非默认值隔开；且import语句中，默认值必须排在非默认值之前。\n","categories":["JavaScript"],"tags":["ES6","import","export"]},{"title":"数据分析中的数据预处理","url":"/2020/12/17/data-preprocessing/","content":"数据预处理步骤数据清理主要通过填补缺失值、光滑噪声数据、平滑或删除离群点来解决数据的不一致性问题。\n缺失值的处理先用pandas.isnull.sum()检测出变量的缺失比例，考虑删除或者填充，若需要填充的变量是连续型，一般采用均值法和随机插值进行填充，若变量是离散型，通常采用中位数或哑变量进行填充。\n删除变量的缺失率较高大于80%、覆盖率较低、重要性较低，删除。\n填充定值填充： 用-9999替代。\n统计量填充： 缺失率较低且重要性较低，根据数据的分布情况填充——均匀分布就使用均值填补缺失，倾斜分布就使用中位数进行填补。\n插值法填充：包括随机插值，多重差补法，热平台插补，拉格朗日插值，牛顿插值等。\n模型填充：使用回归、贝叶斯、随机森林、决策树等模型对缺失数据进行预测。\n哑变量填充：变量是离散的、不同值类型较少，可以换成哑变量，例如性别SEX变量，存在male,fameal,NA三个不同的值，可将该列转换成 IS_SEX_MALE, IS_SEX_FEMALE, IS_SEX_NA。三列，用0/1真假值替代。如果某个变量存在几十个不同的值，根据每个值的频数，将较小频数的数据都归类为other，降低维度。\n离群点的处理将离群点看作影响数据质量的异常点。\n检测离群点简单统计分析：根据箱线图、各分位点判断是否存在异常，例如pandas的describe函数可以快速发现异常值。\n正态分布的数据应用3-sigma原则\n基于绝对离差中位数MAD\n处理离群点\n根据异常点的数量和影响，考虑是否删除这条记录\n\n如果数据做了log-scale对数变换之后消除了异常值，就应用变换后的值\n\n用平均值或中位数代替异常点\n\n\n噪声处理噪声是变量的随机误差和方差，是观测点和真实点之间的误差。\n第一种处理办法：对数据进行分箱操作，等频或等宽分箱，然后用每个箱的平均数，中位数或者边界值（不同数据分布，处理方法不同）代替箱中所有的数，起到平滑数据的作用。\n第二张处理办法：建立该变量和预测变量的回归模型，根据回归系数和预测变量，反解出自变量的近似值。\n数据集成数据集成将多个数据源中的数据结合成、存放在一个一致的数据存储，如数据仓库中。这些源可能包括多个数据库、数据方或一般文件。\n\n实体识别问题：\n数据分析者或计算机如何才能确信一个数 据库中的 customer_id 和另一个数据库中的cust_number 指的是同一实体？利用元数据，也就是描述数据的数据来比避免冗余。\n\n数据冗余问题：\n数据库中表的范式相关，第二范式。 用相关性检测冗余：数值型变量可计算相关系数矩阵，标称型变量可计算卡方检验。\n\n数据值的冲突处理：规范化去重。\n\n\n数据规约数据归约技术可以用来得到数据集的归约表示，它小得多，但仍接近地保持原数据的完整性。 这样，在归约后的数据集上挖掘将更有效，并产生相同(或几乎相同)的分析结果。\n","categories":["DataScience"],"tags":["数据分析","数据预处理"]},{"title":"终端从bash到zsh与终端代理","url":"/2020/12/19/bash-to-zsh/","content":"一个冷知识，zsh该怎么读，我一直读z-s-h三个字母，后来发现应该读z-shell。\n从bash到zsh参考macos上的zsh配置。\nshell脚本切换chsh -s /bin/zshchsh -s /bin/bash\n查看当前系统默认shellecho $SHELL\n默认zsh安装/升级zsh --versionbrew install zsh zsh-completions\n保留bash脚本命令行输入\necho &quot;source ~/.bash_profile&quot; &gt;&gt; ~/.zshrc\n但是会出现\\和[和]和英文字母数字掺杂的情况，待解决。\n\n类unix文件命名规则：\n\n在类unix系统中常用缩略语rc是runcom/run command的简写。rc一般会跟在任何类脚本文件名的最后，这些脚本通常在程序的启动阶段被调用。例如，.bashrc是在bash shell启动后运行的脚本，/etc/rc是linux启动的主角本。\n~波浪号代表当前用户的home目录，在OS X下位于/Users/用户名/\n.点是类unix下的隐藏文件，在GUI文件管理器和ls的默认设置下不会显示出来，但ls -a命令可以显示英藏文件\n\n\n安装oh my zsh官方推荐的curl方式以及wget方式在终端输入的时候会一直显示443拒绝连接！一开始以为是hosts的问题，需要像以前那样修改主机地址sudo vim /etc/hosts并添加github相关ip，但是发现依然没用！\n后来发现需要设置终端代理，分两种情况，针对当前终端窗口的代理设置；针对当前shell配置文件的永久设置。\n终端代理以使用Clash X代理客户端为例，对Clash X客户端进行“复制终端代理命令”的操作。\n\n然后Copy到终端为\nexport https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890\n之后执行oh my zsh的命令就没有443问题了。这种方法只在当前终端有效，关闭或者新建终端窗口将失效。\n\n如果希望长期有效，将命令添加在shell配置文件.bash_profile或者.zshrc中。\n\n终端进入配置文件\n\nsudo vi ~/.zshrc # 进入配置文件，输入密码\n\n添加shell配置文件\n\n如果没有vim使用经验需要查看一下vim操作，按下i从默认的正常模式变为编辑模式。\n在文件末尾添加以下命令，注意host：127.0.0.1和port：7890需要匹配Clash X客户端复制终端代理命令的相关数据。\nalias setproxy=&quot;export https_proxy=http://127.0.0.1:7890;export http_proxy=http://127.0.0.1:7890;export all_proxy=socks5://127.0.0.1:7890;echo \\&quot;Set proxy successfully\\&quot; &quot;alias unsetproxy=&quot;unset http_proxy;unset https_proxy;unset all_proxy;echo \\&quot;Unset proxy successfully\\&quot; &quot; \n继续vim操作，esc变为正常模式，按下冒号:并输入wq会保存并退出，由此回到终端。\n\n应用shell配置文件\n\n在终端执行以下命令让配置生效。\nsource ~/.bash_profilesource ~/.zshrc\n\n应用代理命令\n\n直接在终端输入setproxy即可。\n\n参考\nmacOS终端使用代理网络\n\n关于终端代理\n\n\n无法PING在设置完代理之后，使用ping方法依然无法成功。因为ping方法是基于网络层的ICMP协议，而代理协议socks和http分别基于OSI模型的会话层和应用层。详细解释看这里如何在命令行里设代理。可以使用curl方法访问外网网站。\ncurl ip依然显示实际地理位置在设置完代理之后，使用curl方法获得地理位置信息curl cip.cc，可能依然显示实际地理位置，注意查看参考1中给出的前提条件是Clash X代理客户端开启全局模式，如果是规则判断依然会出现实际地理位置。\nnpm/yarn设置代理为npm和yarn设置包管理工具的初衷是出现network error。一般情况下，会建议切换国内源，但是国内源切换了也还是没办法的话就试试设置代理。\n参考如何为git,npm,yarn设置代理。\n查看代理命令npm config listyarn config list\n设置代理命令npm config set proxy  http://127.0.0.1:7890npm config set https-proxy http://127.0.0.1:7890yarn config set https-proxy http://127.0.0.1:7890yarn config set proxy http://127.0.0.1:7890\n\n如果走了代理，就可以把源设置为国外默认源了。\n\n查看国外源\n\nnpm config get registryyarn config get registry\n\n设置国外源\n\nnpm config set registry=http://registry.npmjs.orgyarn config set registry https://registry.yarnpkg.com\n\n取消代理命令npm config delete proxynpm config delete https-proxyyarn config delete proxyyarn config delete https-proxy\n","categories":["必备技能"],"tags":["踩坑记录","shell","终端"]},{"title":"Sass学习","url":"/2020/12/19/learn-sass/","content":"预处理器Sass的功能Variable用$variable语法表示一个变量，一般在文件顶部定义并存放一个数值或颜色值。\nNesting通过indent/tab嵌套多种选择器实现父子样式继承。\nPartialsPartials就是文件名以下划线开头的SCSS文件，类似_patrial.css。Partials一般不直接被预处理器编译为css，而是被import到主要的scss文件后，与主文件一同被编译。\nImport使用@import语法把所有Partials文件导入主文件。\nMixins使用@mixin语法包裹可多次重复利用的代码块，一般结合Varibales一起使用，实现一个基本的传参函数。\nExtend使用@extend语法实现样式的继承与自定义，适用情况类似于要设计一组颜色各异的button，extend来的是通用button样式，而extend语法本身的样式明确各个颜色。\nOperators在scss文件中使用基本数学运算。\n终端使用sass命令compile文件基本步骤与命令新建一个.scss文件，例如名为style.scss，编辑内容并储存。\n在终端先进入该.scss文件所在文件夹，然后执行sass style.scss:style.css。冒号后面的内容就是输出文件名。\n执行完成后当前列表新增除了.scss文件以外的三个文件，分别是a source map(.css.map)，a regular .css file，a sass.cache directory.\n修饰命令如果需要实时对.scss文件的修改同步编译到.css文件，可以使用sass —watch命令。\n压缩.css文件，使输出的css文件能够更快加载。--style compressed命令。\n如何组织一个SCSS项目sass主文件夹下有：\n\nbase文件夹，用于存放全局varibales以及mixins，文件名都是以下划线开头的Partials。\ncomponents文件夹，用于存放依据组件需求生成的样式表，文件名都是以下划线开头的Partials。\nmain.scss文件，用于将所有子文件夹中的partials都import\n\n最后sass命令编译的对象是整个main.scss文件。输出到与sass文件夹同层级的css文件夹下的.css文件即可。\n","categories":["css"],"tags":["css","sass"]},{"title":"利用Vue3做一些demo的总结","url":"/2020/12/23/vue-demo-conclusion/","content":"使用Vue CLI创建项目在命令行输入，接着会提示进入一个设置Vue的preset的界面，依据需要选择默认的活着手动设置。\nvue create Vue3-demo1\n在完成创建后进入项目所在文件夹，并运行npm run server启动项目。\n我使用VS code的时候装插件装了一个名为Sass/Less/Stylus/Typescript/Javascript/Jade/Pug Compile Hero的插件，每次修改保存文件以后都会在当前目录自动打包一个 dist/[name].dev.js ，只需要禁用该文件就可以了。\nvue文件架构一般有vue脚手架自动生成的使用默认配置vue+babel+eslint的文件一般有public文件夹，src文件夹，其他单个配置文件组成。\n","categories":["Vue"],"tags":["Vue3"]},{"title":"Vuex学习","url":"/2020/12/24/vuex-summary/","content":"Vuex is a state management pattern + library for Vue.js application.\nvuex提供一个中心化的store全体供所有的components使用。\n\nIt serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion.\n\n为什么要用vuex/想法与redux类似对于一个self-contained app来说，state/view/actions的很容易维持（one-way data flow），但是当许多组件components需要共享一个state的时候这个三角关系就很容易被打破：有很多view依赖于同一块state，有很多view发出的actions可以变更同一块state。\n当然可以通过passing props来解决父子组件间的这个问题，但是当components的层级关系越来越深，这个变更就很不好操作；但是兄弟组件sibling components如果要共享同一块数据，passing props的方法并不能解决问题。\n因此vuex的出现就是extract the shared state out of the components, and manage it in a global singleton。数据/state/data应当成为单独管理的一棵树，view/UI/components应当也是单独的一棵树。\n\nvuex store任何store有两个约定：\nvuex store是响应式reactive的，当有vue组件向他拿state来用时，如果store state有所变动，vue组件中这些引用都会自动更新\nvue组件不能直接变更store state，唯一的mutate store state的方法就是by explictly committing mutations（为了保证留下track-able record）.\n\n创建storestore本质上就是一个object，使用createStore()方法，向里面传入一个包含state field/mutation object/actions obejct等其他field的object。\nconst store = createStore(&#123;  \tstate: &#123;&#125;,    mutations: &#123;&#125;,    actions: &#123;&#125;,    modules: &#123;&#125;&#125;)\n使用store在main.js中createApp()调用完成之后以.user(store) plugin的形式注册vuex store实例。\n这个操作inject store into all child components from the root component through Vue’s plugin system，因此在组件内部可以通过this.$store访问global store的所有field。\nstate field在createStore的state field中储存的data，本质上和vue实例中的data property function是一样的作用。\n从store中取出最直接/不经加工的数据在ui/components中使用有以下几个方法：\n使用state computed field+store.state在组件内部的computed field通过引用store.state.访问store中state field的里某个对象，并返回该对象。\ncomputed: &#123;    count () &#123;      return this.$store.state.count    &#125;  &#125;\n该方法只能在一个app中的所有组件都依赖于gloabal state的情况下适用。\n使用state computed field+mapState当有多个store state需要在computed field中被使用的时候，可以使用mapState helper which generates computed getter functions for us.\ncomputed: mapState(&#123;// 感觉mapState像是提供了一个前往store的通道    // 有点useSelector的意思了，但是是在component中适用的useSlector    count: state =&gt; state.count,    // passing the string value &#x27;count&#x27; is same as `state =&gt; state.count`    countAlias: &#x27;count&#x27;,    // to access local state with `this`, a normal function must be used    countPlusLocalState (state) &#123;      return state.count + this.localCount    &#125;,        // map this.count to store.state.count    // 这种方法只在mapped computed property is the same as a state sub tree name时使用    &#x27;count&#x27;  &#125;)\n如果要和组件自己的local state融合，还需要用到spread syntax。\ngetters field前面提到state和view有一对多的关系，如果有多个component要用到这个state，总不能在每个view的computed field里面都走一遍mapState或者this.$store吧？因此就有了getters函数，这个函数就像react里面定义在slice文件里面的Select函数，作为参数传递给component中的useSelector hook。\n定义getters一般函数定义与参数传递 property-style accessconst store = createStore(&#123;  state: &#123;    todos: [      &#123; id: 1, text: &#x27;...&#x27;, done: true &#125;,      &#123; id: 2, text: &#x27;...&#x27;, done: false &#125;    ]  &#125;,  getters: &#123;    doneTodos (state) &#123;      return state.todos.filter(todo =&gt; todo.done)    &#125;  &#125;&#125;)\n在定义getters函数的时候，不仅仅可以用当前store的state作为第一个参数；还可以利用当前store的getters作为第二个参数，通过点访问法访问同一个getters field中的其他getters。\ngetters: &#123;  // ...  doneTodosCount (state, getters) &#123;    return getters.doneTodos.length  &#125;&#125;\n箭头函数定义 method-style access以上都是依据一般函数来定义getters的，当然也可以用arrow function来定义getters，这样可以实现在不同的地方按需求传递参数。\ngetters: &#123;  // ...  getTodoById: (state) =&gt; (id) =&gt; &#123;    return state.todos.find(todo =&gt; todo.id === id)  &#125;&#125;\n从store中取出经过加工/选择的数据在ui/components中使用有以下几个方法：\n使用getterscomputed field + store.getters在component/ui/view中利用getters提取数据可以通过引用store.getters，并点访问对应的getter函数。\ncomputed field + mapGetters需要使用spread syntax与原组件的自有computed融合。\ncomputed: &#123;    // mix the getters into computed with object spread operator    ...mapGetters([      &#x27;doneTodosCount&#x27;,      &#x27;anotherGetter&#x27;,      // ...    // map `this.doneCount` to `this.$store.getters.doneTodosCount`  \t   doneCount: &#x27;doneTodosCount&#x27;    ])  &#125;\nmutations field\nThe only way to actually change state in a Vuex store is by committing a mutation. \n\nmutation field中不能包含异步操作，因为在使用devtool debug需要跟踪before&amp;after snapshots of the state，一个mutation被commit了但是异步操作的callback function还没有被调用，这样子state就完全是不可预测的了。\n不带payload的mutation定义与调用vuex mutation和events十分相似，每一个mutation都需要一个string type和一个handler。\n在mutations field内部的每一个函数都是一个mutation handler。mutation handler内部是实现actual state modifications的地方，它接收state作为第一个参数。那么string type是什么？就是这个函数的名字。\nmutations: &#123;   increment (state) &#123;     // mutate state     state.count++   &#125; &#125;\n但是mutation handler不能被直接调用，需要走一遍事件注册的流程。我们希望有以下流程：”When a mutation with type increment is triggered, call this handler.” 我们通过调用store.commit函数并传入handler function的string type来实现这个流程。\nstore.commit(&#x27;increment&#x27;)\n如果需要在component中commit mutations，需要使用this.$store.commit()，或者mapMutations helper。\n带payload的mutation定义与调用mutation handler function除了接受state作为第一个参数，也可以把当前mutation的payload作为第二个参数传入，只需要在commit函数中同步传入第二个参数即可。如果payload是多个数据，直接用对象表示payload，并用点访问法访问。\nstore.commit(&#x27;increment&#x27;, &#123;  amount: 10&#125;)\nobject-style commit with type field既然都用到对象了，为什么不把mutation type一起放到payload的对象中去呢？这就是obejct-style commit，也就是commit a mutation is by directly using an object that has a type property。\nstore.commit(&#123;  type: &#x27;increment&#x27;,  amount: 10&#125;)\n为mutation type定义constants在flux中，一般会把当前store所有mutation都放到同一个mutation-type.js文件中export const，然后再当前store中import {}，使用computed property name作为function name。\n// mutation-types.jsexport const SOME_MUTATION = &#x27;SOME_MUTATION&#x27;\n// store.jsimport &#123; createStore &#125; from &#x27;vuex&#x27;import &#123; SOME_MUTATION &#125; from &#x27;./mutation-types&#x27;const store = createStore(&#123;  state: &#123; ... &#125;,  mutations: &#123;    // we can use the ES2015 computed property name feature    // to use a constant as the function name    [SOME_MUTATION] (state) &#123;      // mutate state    &#125;  &#125;&#125;)\nactions fieldactions和mutations其实类似，区别在于\n\naction一般不直接变更state，因为有mutation field存在，因此action可以通过commit mutation或dispatch action来实现state field的变更。\naction可以包含任何异步逻辑。\n\n定义action handler与destructing语法通常action handlers会接受一个context obejct，该context obejct把同样的store instance都暴露给（但context object本身不是the store instance itself，感觉更向copy）当前action handlers，因此可以在action handler function内部访问到当前store的state/getters等field。\nactions: &#123;    increment (context) &#123;      context.commit(&#x27;increment&#x27;)    &#125;&#125;\n因为conetxt本来就是copy当前store instance的object，但是我们又不需要用到这个object里面所有的内容，因此可以用ES6的数组结构获取需要的内容。\nactions: &#123;  increment (&#123; commit &#125;) &#123;    commit(&#x27;increment&#x27;)  &#125;&#125;\n使用action handler使用方法与mutations类似，通过store.dispatch()方法，不带payload、带payload、objecy-style dispatch都可以。\n在组件内部通过this.$store.dispatch()或者mapActions helper实现调用。在传递给mapActions() 参数的时候可以是一个对象，也可以是一个数组，内部的action type都是string类型。\n模块 modules把全体store分成不同的模块，每个模块管理自己的state/mutations/actions/getters field。这有点类似redux中的每个slice。\n当前模块state与rootStateconst moduleA = &#123;  state: () =&gt; (&#123; ... &#125;),  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  getters: &#123; ... &#125;&#125;const store = createStore(&#123;  modules: &#123;    a: moduleA  &#125;&#125;)store.state.a // -&gt; `moduleA`&#x27;s state\n在每一个模块内部，muations filed和getters field接受的第一个参数state就变成了当前模块的local state（也就是只属于这个slice的state）。\nmutations: &#123;    increment (state) &#123;        // `state` is the local module state    &#125;  &#125;,getters: &#123;    doubleCount (state) &#123;&#125;  &#125;\naction field接受的第一个参数context，这个context.state暴露的是当前local store实例，而全体global store的实例要通过context.rootState来实现。\nactions: &#123;    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;      if ((state.count + rootState.count) % 2 === 1) &#123;        commit(&#x27;increment&#x27;)      &#125;    &#125;&#125;\n在getters field中，rootState也被作为第三个参数使用\ngetters: &#123;    sumWithRootCount (state, getters, rootState) &#123;      return state.count + rootState.count    &#125;  &#125;\nnamespacing 命名空间默认所有的actions和mutations都是在global namespace下被注册的。但是当modules变多了，很难保证两个modules中的函数命名没有冲突，因此就需要把当前模块的所有方法都放在固定的命名空间。通过在创建module的时候添加namespaced: true来实现命名空间化。\nconst store = createStore(&#123;  modules: &#123;    account: &#123;      namespaced: true,      // module assets      state: () =&gt; (&#123; ... &#125;), // module state is already nested and not affected by namespace option      getters: &#123;        isAdmin () &#123; ... &#125; // -&gt; getters[&#x27;account/isAdmin&#x27;]      &#125;          // nested modules      modules: &#123;        // inherits the namespace from parent module        myPage: &#123;          state: () =&gt; (&#123; ... &#125;),          getters: &#123;            profile () &#123; ... &#125; // -&gt; getters[&#x27;account/profile&#x27;]          &#125;        &#125;,\n在子模块内部访问global assetsIf you want to use global state and getters, rootState and rootGetters are passed as the 3rd and 4th arguments to getter functions, and also exposed as properties on the context object passed to action functions.\n在getter field中，使用getters点访问当前模块的其他getters，使用rootGetters点访问root store中定义的getter或方括号访问其他模块中定义的getter。actions field同理。\nmodules: &#123;  foo: &#123;    namespaced: true,//该模块已经被namespaced了    getters: &#123;      // `getters` is localized to this module&#x27;s getters      // you can use rootGetters via 4th argument of getters      someGetter (state, getters, rootState, rootGetters) &#123;        getters.someOtherGetter // -&gt; &#x27;foo/someOtherGetter&#x27;        rootGetters.someOtherGetter // -&gt; &#x27;someOtherGetter&#x27;        rootGetters[&#x27;bar/someOtherGetter&#x27;] // -&gt; &#x27;bar/someOtherGetter&#x27;      &#125;,      someOtherGetter: state =&gt; &#123; ... &#125;    &#125;,    actions: &#123;      // dispatch and commit are also localized for this module      // they will accept `root` option for the root dispatch/commit      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;        getters.someGetter // -&gt; &#x27;foo/someGetter&#x27;        rootGetters.someGetter // -&gt; &#x27;someGetter&#x27;        rootGetters[&#x27;bar/someGetter&#x27;] // -&gt; &#x27;bar/someGetter&#x27;        dispatch(&#x27;someOtherAction&#x27;) // -&gt; &#x27;foo/someOtherAction&#x27;        dispatch(&#x27;someOtherAction&#x27;, null, &#123; root: true &#125;) // -&gt; &#x27;someOtherAction&#x27;        commit(&#x27;someMutation&#x27;) // -&gt; &#x27;foo/someMutation&#x27;        commit(&#x27;someMutation&#x27;, null, &#123; root: true &#125;) // -&gt; &#x27;someMutation&#x27;      &#125;,      someOtherAction (ctx, payload) &#123; ... &#125;    &#125;  &#125;&#125;\n在子模块内部添加global assetsIf you want to register global actions in namespaced modules, you can mark it with root: true and place the action definition to function handler. \nmodules: &#123;    foo: &#123;      namespaced: true,      actions: &#123;        someAction: &#123;          root: true,          // 在foo模块下定义的action handler是全局的          handler (namespacedContext, payload) &#123; ... &#125; // -&gt; &#x27;someAction&#x27;        &#125;      &#125;    &#125;  &#125;\n在component内部访问使用模块每次都得把模块说明白，如果有多层嵌套就得有很多斜杠和模块名。\n例如：\nmethods: &#123;  ...mapActions([    &#x27;some/nested/module/foo&#x27;, // -&gt; this[&#x27;some/nested/module/foo&#x27;]()    &#x27;some/nested/module/bar&#x27; // -&gt; this[&#x27;some/nested/module/bar&#x27;]()  ])&#125;// 下面这种写法还好些methods: &#123;  ...mapActions(&#x27;some/nested/module&#x27;, [    &#x27;foo&#x27;, // -&gt; this.foo()    &#x27;bar&#x27; // -&gt; this.bar()  ])&#125;\n可以通过createNamespacedHelpershelper将当前component绑定到特定的的模块去。\nimport &#123; createNamespacedHelpers &#125; from &#x27;vuex&#x27;const &#123; mapState, mapActions &#125; = createNamespacedHelpers(&#x27;some/nested/module&#x27;)export default &#123;  methods: &#123;    // look up in `some/nested/module`    ...mapActions([      &#x27;foo&#x27;,      &#x27;bar&#x27;    ])  &#125;&#125;\n","categories":["Vue"],"tags":["vue3","vuex"]},{"title":"数组相关知识点总结","url":"/2020/12/26/list-method-key/","content":"数组变更方法与替换方法总结变更并返回原数组。使用变更方法时在原数组上通过点访问法调用变更方法，如example1.items.push(&#123; message: &#39;Baz&#39; &#125;)\n\npush()\npop()\nshift()\nunshift()\nsplice()\nsort()\nreverse()\n\n\n不会变更原始数组，而总是返回一个新数组。在使用替换方法时使用赋值语句用新数组替换旧数组，如example1.items = example1.items.filter(item =&gt; item.message.match(/Foo/))\n\nfilter()\nconcat() \nslice()\n\nkey和index的区别index是数组的索引，标记从0到n-1的长度为n的数组中的每个元素。index的特点是不会不区别list item，只要元素出现在该数组的第i个索引，那么就确认它的位置。一个list item和一个list index不是强绑定的关系，当前list index上的list item被删除了，会有下一个list item被顶上来填充这个空了的list index。\nkey一般是一个用于唯一区别list item的标记，一般都是list item对象自己保有的一部分。一个list item和一个list item key是强绑定的关系，如果list item被删除了，那么用list item key去查找数组是不可能再找到这个list item的。\nkey和index是从两个方面去描述list item的方法。当list是固定不变的时候，也就是不会对这个list有任何增删改的操作的时候，也就是这个list只用于查找的时候，key和index是可以等价的，直接将index给予key。当list是有变动的时候，也就是可以增删改也可以查找的时候，key和index绝对不等价，增删改item会带走item key但不带走index。\n","categories":["JavaScript"],"tags":["JS数组方法","key和index"]},{"title":"防抖函数","url":"/2020/12/28/debouce-explaination/","content":"为什么需要防抖函数在浏览器中，触发频繁的事件，如window的onresize、鼠标的mousemove、滚轮的wheel、文本输入框的验证等，因为这些事件被频繁触发，有可能导致大量的计算或者服务器资源消耗极大的操作，event handler就没有必要每一次触发都执行。\n因此就有了函数防抖的概念，让事件触发的n秒内只执行一次，防止event handler多次调用，如果连续触发就重新计算事件。\nGithub上找到的关于防抖函数的讨论\nvue中的防抖的相关实现v-model与lazy修饰符vue提供了输入框数据的双向绑定v-model指令，该指令默认每一次用户的输入都让vue重新计算重新渲染，当用户输入很长一段内容的时候这是极大的渲染负担。因此引入了.lazy修饰符，但.lazy修饰符的局限在于只有当用户focus out才渲染，对于比较小的输入会比较方便，但是大的文本输入情况下不适用。\nv-bind:value与event handlerv-bind指令与v-model指令的区别在于，v-bind是实现用户输入流向vue的单向绑定（需要绑定在value上），如果要让vue的数据去流向用户（也就是渲染），需要用到事件处理函数，每一次用户的输入，我都利用事件去update一下，相当于手动实现了v-model的双向绑定。\n这样的实现方式与v-model相比，可以更细致化的去定义事件处理函数如何去处理如何去渲染。\n&lt;!-- 这里使用了tailwind css --&gt;&lt;textarea  class=&quot;w-full h-full&quot;   :value=&quot;text&quot;  @click=&quot;update&quot;&gt;&lt;/textarea&gt;\nexport default &#123;  data() &#123;    return &#123;      text: &quot;&quot;    &#125;;  &#125;,  methods: &#123;    update(e) &#123;      this.text = e.target.value;  &#125;,&#125;\nupdate延迟调用前面提到我们不希望每一次用户的输入都导致一次渲染，因此需要对update函数进行一个延迟调用。\nupdate(e) &#123;  setTimeout(() =&gt; &#123;this.text = e.target.value;&#125;, 500);&#125;,\n以上函数表示，我们希望当用户停止输入经过500ms，vue要去依据输入框中的value值更新vue的data中储存的数据。但是具体去输入的时候，又会发现所有的更新都好像是即时的、instant update，为什么会出现这种情况？因为只要每一次update，都会有一个setTimeout被执行，多次的输入带来的就是多个setTimeout，本质上和上一段中的update函数没区别。\n为了解决这个问题，我们在每一次运行setTimeout的时候，都希望vue去check一下是否之前就已经存在了其他的setTimeout，在每一次update前都清理一下之前就有的setTimeout。因此我们需要在data field中定义一个string变量来存储已有的setTimeout。\nexport default &#123;  data() &#123;    return &#123;      text: &quot;&quot;,      timeput: &quot;&quot;,    &#125;;  &#125;,  methods: &#123;    update(e) &#123;      clearTimeout(this.timeout);      this.timeout = setTimeout(() =&gt; &#123;      this.text = e.target.value;    &#125;, 500);  &#125;,&#125;\n抽象出debounce函数抽象后的debounce函数是一个工具性质的函数。\nmethods: &#123;  update(e) &#123;    const task = () =&gt; &#123;      this.text = e.target.value;    &#125;;    this.debounce(task, 500);  &#125;,  debounce(func, wait = 1000) &#123;    clearTimeout(this.timeout);    this.timeout = setTimeout(func, wait);  &#125;,&#125;,\n使用mixins在page中导入工具函数vue实例有一个可选的mixins field，可以用于不同的vue实例之间融合merge他们共有的field。如果当前vue实例中已经存在了导入vue实例中的某个变量、方法，那么当前vue实例会覆盖导入vue实例的变量、方法。\nvue实例在使用融合后的其他vue实例的变量、方法的时候，直接使用this来调用，仿佛这就是本来定义在当前vue实例中的一样。\n详细实现参考vue3-demo3的src/pages/Markdown.vue文件以及src/utilities/mixins/debounce.js文件。\n","categories":["JavaScript"],"tags":["debounce","vue"]},{"title":"Vue虚拟DOM","url":"/2020/12/28/virtual-dom/","content":"参阅Vue3官方文档对此的解释\n官方文档中动画演示源代码，用于看解释\nBitfumes Vue3教程中的Vue Virtual DOM解释\n解释虚拟DOM是浏览器DOM的一份JavaScript复制。虚拟DOM是一个轻量级的JavaScript对象。\n当用JavaScript去update html DOM的时候，这个操作十分expensive，但是用JavaScript对JavaScript DOM去update相对cheap。\n找出每一个DOM节点并更新是一个十分缓慢的过程，因此不如在虚拟DOM中把所有要更新的DOM节点都找出来，然后vue去比较虚拟DOM和浏览器DOM之间的区别，然后batch calls to re-render/一次完成所有节点更新。\n","categories":["Vue"],"tags":["virtual-dom"]},{"title":"vue3新特性Composition API","url":"/2021/01/02/composition-api/","content":"在之前的vue学习过程中，主要是通过定义vue组件的各种field，例如data function，computed object， methods object等来组织vue组件的逻辑。但是当逻辑越来越复杂的时候，这种组织vue组件的方式就不太可行。\nsetup component option是一个在vue组件被创建之前就被执行的函数，因此在setup option内部是没有this的，该函数内部职能访问props，该组件的方法、计算属性、state等都不可以访问。\n那么setup函数就相当于替代了生命周期函数中的created和beforeCreate这两个周期函数。\n在setup内部需要定义数据，并返回一个对象，对象包括在vue组件的template中需要用到的数据的集合。\n响应式数据const+refconst数据的定义就相当于原来组件的data field，但是由于setup内部就是普通的JavaScript语句，不会实现reactive response，因此需要用到ref，常见的定义形式为const newHeroRef = ref(&quot;&quot;);。\n在使用ref包裹的const时，需要时调用newHeroRef.value获取引用本身，否则newHeroRef只是一个对象。\n什么时候使用ref？当我们需要在setup中时刻监听某一个数据的时候。\nconst state+reactiveconst+ref的替换就是const state = reactive(&#123;&#125;)，对象内部就是响应式数据。这么做的好处在于更新数据时只需要state.data更新，并且从setup function返回的时候只需要返回state全体对象。\n什么时候使用reactive？当我们需要在setup中时刻监听某一批数据的时候。\ncomputed+get+(set)const数据同样可以用来定义computed field。具体定义方式为const heroCount = computed(&#123; get: () =&gt; &#123;return dcHeros.value.length;&#125;, &#125;);，传入对象，对象内部有getter和setter（自定义）。\nfunctionfunction的定义就相当于原来组件的methods field中除了生命周期函数的部分。同样需要在setup return语句中返回该函数。\n","categories":["Vue"],"tags":["composition-api"]},{"title":"记录一下VSCode快捷键","url":"/2021/01/03/vscode-shortcut/","content":"option+鼠标点击：在鼠标点击的各个位置插入多个光标\ncmd+上下方向键：转到当前文件的最开始或者最结尾\ncmd+左右方向键：转到当前行的最开始或者最结尾\noption+左右方向键：向前或者向后移动一个单词为单位的光标\noption+上下方向键：移动当前行的所有内容到下一行或上一行\nshift+cmd/option+左右方向键：从当前光标开始以cmd行为单位/以option单词为单位选中内容；可以结合copy&amp;patse进行代码移动/复制/粘贴\noption+·打开终端\ncmd+shift+p转到vscode工具\ncmd+p转到当前文件夹的某个目标文件\ncmd+b打开或关闭侧边栏\n","categories":["必备技能"],"tags":["vscode"]},{"title":"使用Heroku部署网站","url":"/2021/01/04/heroku-app-deploy/","content":"本来想在Netlify上部署网站的，结果无论如何都没办法重定向到github，并且总是网页无法打开，就转用heroku了。\nVue-CLI项目部署参考链接VueCLI官方给出的部署教程\nBinarCode上的部署教程\nHeroku官方基于Heroku CLI的Node.js应用部署文档\nStackOverflow上比较好的回答1\nStackOverflow上比较好的回答2\n部署操作需要在heroku上创建账号，创建app。在进入app后有一排工具栏，可以查看对应的信息。\n\nDeploy一栏是初次部署的时候显示的页面，在这里关联github的特定项目。\nActivity一栏可以查看build log，如果部署不成功需要去查找错误。\nSettings一栏可以配置环境变量。在vue3-demo3中用到了.env配置环境变量，需要在部署的时候添加到heroku去。\n如果部署中出现报错npm ERR! missing script: start，意思是在package.json中没有找到start相关的script，因为vue-cli默认只有serve/build/lint。这时需要自定义start脚本的内容。\n\n这里涉及一些npm脚本的知识。掘金上关于npm的知识点汇总\nnpm脚本常用的几个缩写分别是：\n\nnpm start short for npm run start\n\nnpm test short for npm run test\n\nnpm stop short for npm run stop\n\n\n如下，当执行npm run start指令的时候，实际上执行的就是start在scripts中的脚本 node server.js。\n第一个指令缩写可以解释为什么create-react-app中运行指令是npm start了。\n\n在脚手架的package.json文件中添加&quot;start&quot;: &quot;node server.js&quot;,指令，如下：\n\n这个指令的意思是在node环境下执行server.js文件。server.js文件是需要在当前应用文件夹的最顶层，和package.json处于同一级的自建文件。\n// server.jsconst express = require(&quot;express&quot;);const history = require(&quot;connect-history-api-fallback&quot;);const serveStatic = require(&quot;serve-static&quot;);const enforce = require(&quot;express-sslify&quot;);// require()中涉及的字符串都是需要预先安装的npm包const app = express();//该app使用expressapp.use(enforce.HTTPS(&#123; trustProtoHeader: true &#125;)); // 要求使用http链接app.use(serveStatic(__dirname + &quot;/dist&quot;));// 要求部署的最终代码都放在heroku生成的__dirname下的dist文件夹中app.use(history());app.listen(process.env.PORT || 5000);\n","categories":["前端"],"tags":["踩坑记录","前端","部署"]},{"title":"babel基础","url":"/2021/01/10/babel/","content":"参考前端科普系列-Babel：把 ES6 送上天的通天塔\nBabel是Javascript编译器。可以针对不同类型/版本的浏览器对ECMAScript的支持程度，把原本不支持的代码转化为浏览器全部支持的代码；也就是Babel的转译基于浏览器环境。\n依赖包安装使用babel需要安装以下依赖包。\nnpm install --save-dev @babel/core @babel/cli @babel/preset-env\n@babel/preset-env是预置的常用的转换插件的集合，包含了大部分ES6语法转换常见，如果编译过程中遇到报错，也就是源码使用了不在@babel/preset-env的代码，需要在plugins中手动增加。\n定义脚本在npm scripts字段中加入babel脚本或者直接在命令行输入：babel src --out-dir dist。改名了会在工程根目录下的dist文件夹生成编译后的输出文件。\nbabel.config.js设置在项目根目录添加babel.config.js，主要由presets和plugins两个部分组成。presets是告诉babel以何种配置编译，比如debug输出的结果要有babel的工作日志，target转译环境是什么等；plugins是真正进行语法转换，完成编译的插件。\nconst presets = [  [    &#x27;@babel/env&#x27;,    &#123;      debug: true,      // 打印babel工作日志，方便查看转换了哪些语法      targets: &#123;        chrome: &#x27;58&#x27;        // targets参数让babel基于环境做转译，浏览器支持的ES6语法就不转译        // 如果没有target参数，会默认转译所有的ES6语法    &#125;    &#125;  ]]const plugins = []module.exports = &#123; presets, plugins &#125;\nsyntax &amp; built-in编译的过程经历parser解析源文件，transform转换，generator生成新文件大致三个步骤。babel通过babel.config.js中设置的plugins插件来决定如何进行转换，每一个语法都有一个对应的插件，插件命名格式为@babel/plugin-xxx。\nBabel将ES6标准分为Syntax以及built-in两种类型。\nSyntax就是语法，const，=&gt;，let，class，import等。对于 syntax 类型的语法在转译的过程会在当前模块中注入类似 _classCallCheck 和 _defineProperty 的 helper 函数来实现兼容。（通过查看dist下编译结果就可以知道）\nBuilt-in就是可以通过改写覆盖的语法（感觉更像是方法），例如includes，promise。对于 built-in 类型的语法通过 require(&quot;core-js/modules/xxxx&quot;) polyfill 的方式来兼容。（通过查看dist下编译结果就可以知道）\n使用core-js处理built-in默认babel值转译syntax类型，built-in类型的处理有两种方法：1. @babel/polyfill覆盖ES6中的built-in。2. 使用core-js。\nnpm install --save core-js注意要用—save方式安装，因为core-js中（需要被使用到的部分或全体，看配置是usage还是entry）是要被注入到源代码中去的，以提供执行环境。\n配置 useBuiltIns在@babel/preset-env中通过useBuiltIns参数来控制 built-in的注入。它可以设置为 ‘entry’、’usage’ 和 false 。默认值为 false，不注入垫片polyfill。在设置built-in为entry或usage的时候，还要制定corejs版本，否则日志会输出井盖\n设置为’entry’时，在整个项目入口import core-js即可。但是babel会把目标环境不支持的所有built-in都注入，无论是否用到，增加代码浪费空间。\n设置为’usage’时，无需在项目入口处导入，且按需注入源码。\n  const presets = [  [    &#x27;@babel/env&#x27;,    &#123;      debug: true,      useBuiltIns: &#x27;usage&#x27;,      corejs: 3,      targets: &#123;&#125;    &#125;  ]]\n@babel/plugin-transform-runtime优化syntax前面提到babel在编译过程中通过注入helper函数实现syntax语法转换。当项目中的每个模块都被注入重复的helper函数，代码量会增大。因此需要用@babel/plugin-transform-runtime复用helper函数，缩小代码体积；同时避免全局污染。\nnpm install --save-dev @babel/plugin-transform-runtimenpm install --save @babel/runtime\n接着在babel.config.js中配置：\nconst plugins = [&#x27;@babel/plugin-proposal-class-properties&#x27;,// 这个plugin支持的preset-env中没有的语法转换[&#x27;@babel/plugin-transform-runtime&#x27;// 开启@babel/plugin-transform-runtime优化syntax// 编译后之前的helper函数会变成require的形式]]\nbuilt-in全局污染的解决polyfill的运作方式是覆盖/修改原来require的模块，也就是对require的模块进行修改，直接修改原型，造成全局污染。\n为了避免这个问题，只需要配置 @babel/plugin-transform-runtime 的参数 corejs。该参数默认为 false，可以设置为 2 或者 3，分别对应 @babel/runtime-corejs2 和 @babel/runtime-corejs3。\n不再需要使用core-js，以及@babel/preset-env 的 useBuiltIns 和 corejs 的配置。\nnpm uninstall @babel/runtimenpm install --save @babel/runtime-corejs3\nBabel.config.js配置如下，\nconst plugins = [    &#x27;@babel/plugin-proposal-class-properties&#x27;,    [      &#x27;@babel/plugin-transform-runtime&#x27;,      &#123;        corejs: 3      &#125;    ]  ]\n但是不支持targets设置，也就是无法按需加载。\n\n截至目前为止，对于 built-in 类型的语法的 polyfill，一共有三种方式:\n\n使用 @babel/preset-env ，useBuiltIns 设置为 ‘entry’\n使用 @babel/preset-env ，useBuiltIns 设置为 ‘usage’\n使用 @babel/plugin-transform-runtime\n\n\n","categories":["babel"],"tags":["前端","babel"]},{"title":"eslint与prettier协同工作","url":"/2021/01/10/eslint/","content":"在讨论代码风格以及代码格式化之前，一定要注意查看编辑器的个性化配置是否会导致错误。例如，开启VS code中自动对Tab以及空格进行相互转化，这在ESLint与Prettier工作的情况下产生问题！需要区分Tab以及空格。参阅StackOverflow的回答\n注意文件格式的区别，配置文件既可以是json，也可以是js。\nESLintESLint提供的不仅是代码格式化，更有控制代码风格，检查代码错误的作用。\nESLint demo以所见即所得的可视化方式提供了rules configuration的各种选项。\nESLint安装在初始化一个npm项目后，—save-dev的形式安装。\nnpm install eslint --save-dev\n在项目目录下执行npx eslint --init，会有一个命令行问答面板，根据yes或no的选择，在自动生成的.eslintrc.js文件中给予初始配置。\nESLint可以对项目中的任何文件执行，只需要npx eslint yourfile.js。命令长指令还有-c/—config，—env，—global等。\nESLint 配置具体查看Table of Contents的链接。\n常用的配置字段有以下几种：\nenv\nAn enviroment defines global variables that are predefined.\n\n明确了env如browser/node/es6等，就能预先知道这些环境中有哪些保留字是自己编写代码的时候不能用的，就算用了ESLint也会报错。\nparser如果使用到了babel，需要明确parser: &quot;@babel/eslint-parser&quot;,(这里是js文件格式，而非json)。并且文件目录下要有babel配置文件存在。\nglobals为什么需要globals？因为ESLint的no-undef rule要求，当一个文件内某个变量defined but not used的时候会报错。在配置文件中利用globals字段说明所有全局变量，并给予writable/readonly的权限。\npluginsESLint通过plugins字段来支持第三方插件，在使用一个插件之前，需要通过npm下载。插件的名字都有eslint-plugin-xx的通用格式，在写入plugins字段的时候可以不需要前缀。\nplugins: [&quot;prettier&quot;],//npm install --save-dev eslint-plugin-prettier\n\nThe eslint-plugin- prefix can be omitted for non-scoped packages\n\nplugins本质上就是定义了一些功能的集合，在plugin字段中写入plugin并不会让这些功能生效。还需要在rules字段中启用特定的功能。\n启用和停止plugin中的规则都有相同的形式。\nTo configure a rule which is defined within a plugin you have to prefix the rule ID with the plugin name and a /. \nTo disable eslint-plugin-example‘s rule-name rule, combine the plugin’s name (example) and the rule’s name (rule-name) into example/rule-name\nrules: &#123;    &quot;prettier/prettier&quot;: &quot;error&quot;,    // 第一个是plugin插件    // 第二个是plugin插件中名为prettier的规则    indent: [&quot;error&quot;, 2],  &#125;,\nrules规则如下：\n\n&quot;off&quot; or 0 - turn the rule off\n&quot;warn&quot; or 1 - turn the rule on as a warning (doesn’t affect exit code)\n&quot;error&quot; or 2 - turn the rule on as an error (exit code is 1 when triggered)\n\n形式如&quot;plugin1/rule1&quot;: &quot;error&quot;，冒号后可以是数字或字符串，也可以是字符串或数字组成的数组。\nextendsextends就是继承的意思，这个字段旨在继承一些已有的，共享的，或者当前目录下的其他配置文件的ESLint配置（也就是一个opinionated rules），而后其他字段的如果另有说明，在这些导入配置的基础之上另作修改。\nrules字段可以对extends字段的base rule settings通过以下方式更改：\n\n添加其他base rules中没有的规则\n对继承的某条规则，更改规则选项值的先后顺序\n对继承的某条规则，override或disable。\n\n推荐的extend字段的value有：&quot;extends&quot;: &quot;eslint:recommended&quot;，extends: [&quot;standard&quot;, &quot;prettier&quot;],。另外，还可以使用配置文件路径来引用项目目录中已存在的配置文件。\n注意和plugin一样，这些sharable configuration package都是有eslint-config-前缀，使用时可以省略。standard的配置名就是eslint-config-standard。\noverrides有一些场景需要将eslint配置文件应用到指定文件，指定文件的方式就像在命令行中指定文件一样app/**/*.test.js。\nconfiguration based on glob patterns.\nESLint忽略特定文件\nignorePatterns字段\n.eslintignore文件\n\nPrettier文件目录下npm安装Prettier。\nnpm install --save-dev prettier\n手动创建配置文件并书写。\n// prettier.config.js or .prettierrc.jsmodule.exports = &#123;  trailingComma: &quot;es5&quot;,  tabWidth: 2,  semi: false,  singleQuote: true,&#125;;\n可配置的格式化PrintWidth决定一行最多可以输入多少个字，超出就换行，默认80。\nTabWidth明确多少个空格用作一级别的缩进，默认2。\nTabs使用tab还是space来进行缩进，默认false不使用tab缩进。\nsemicolons在每一行statement最后都加分好，默认true都加分号。\ntrainingComma尾后都好，意思就是数组或者对象的最后一个项目也要加一个都好，默认”es5”。但是在JSON中默认不允许，如果最后一项加了逗号就要报错。\nbracketSpacing默认true，花括号和变量之间有空格。\narrowParens默认”always”，总给箭头函数的输入加上括号，因为当只有一个参数的时候括号可以省略。\noverridePrettier borrows ESLint’s override format.override字段接受一个由对象组成的数组，每一个对象都是一个prettier配置，针对什么文件files，有哪些配置options。\nPrettier &amp; ESLintPrettier和ESLint在代码格式化方面有功能重合，但对于同一个问题又有不同的解决办法，因此同时安装二者会报错。通过在ESLint中使用适应Prettier的插件来协调。\n需要两个包来安装。第一个是能够把所有eslint中可能与prettier发生冲突的规则关闭的eslint-config-prettier，第二个是将写在Prettier中的rule当作ESLint规则并且输出ESLint警告的eslint-plugin-prettier。\n\neslint-plugin-prettier: Runs Prettier as an ESLint rule and reports differences as individual ESLint issues.\nAslant-config-prettier: Turns off all rules that are unnecessary or might conflict with Prettier.\n\n需要下载npm包有：\nnpm install --save-dev eslint-plugin-prettier eslint-config-prettier\n在.eslintrc.js文件的extends字段做以下配置：注意一定要把prettier的plugin放在最后。（这个extends是一些配置的集合，包括了extends字段，plugins字段，rules字段的设置。）\nextends: [&quot;standard&quot;,          &quot;plugin:prettier/recommended&quot;,          // 其他有可能与prettier发生冲突的插件排除          &quot;prettier/flowtype&quot;,          &quot;prettier/react&quot;],\n对于其他可能和prettier存在冲突的eslint plugin如eslint-plugin-react，在这之后将这些排除。\n完成后就可以在.prettierrc.js中书写prettier options了。\n","categories":["ESLint"],"tags":["前端","ESLint","Prettier"]},{"title":"JavaScript闭包","url":"/2021/01/12/js-closure/","content":"参考JavaScript经典基础知识点精讲之闭包\n我还是想谈谈JS里面的闭包\n对闭包的理解\n闭包就是绑定了上下文环境的函数\n闭包是一个函数和声明该函数的词法环境的组合\n闭包就是一个能够访问它被定义时所处的作用域环境的函数\n闭包将函数内部和函数外部连接起来的一座桥梁\n\n闭包是一个函数，这个函数能够暴露和他处在同一执行上下文execution context的其他任何内容，置于暴露给谁，暴露在哪，看闭包在哪里被调用。\n为什么闭包能够暴露？因为作用域链的向上搜寻的能力。如果在当前执行环境中搜寻不到某个变量名/函数名，作用域链会允许JavaScript解释器不停的向上回溯。\n闭包如何暴露？在 JS 里面，最常见的闭包形式是在一个函数里面嵌套另一个函数，另一个函数持有父作用域里面定义的变量；但产生闭包不一定非要函数内部return某个函数。return一个函数只是为了我们能在函数外部去访问到return的函数内部的变量。\n闭包有如何性质？每一次对闭包（函数）的调用都会创建不同的闭包环境。同一个调用函数生成同一个闭包环境，在里面声明的所有函数同时具有这个环境里面自由变量的引用。\n","categories":["JavaScript"],"tags":["执行上下文栈","闭包"]},{"title":"一月观影记录","url":"/2021/01/15/jan-films/","content":"犴达罕西瓜视频上看的。\n鄂温克文化的消亡。狩猎文化的消亡。以及人的死亡。\n婚姻故事进入爱情，享受爱情，结束爱情。进入婚姻，享受婚姻，忍受婚姻，结束婚姻。而为了结束婚姻，争吵在家里是家常便饭，诋毁在法庭上也屡见不鲜。人在失去情绪控制的时候真的什么话都说得出来，明知道不该这么说，说出来就是伤害人的，但是你就是想说出来，说出来之后又后悔。\nBEASTAR狗子好帅～\n约定的梦幻岛现在看女主真的有点白莲花！烂尾了！\n咒术回战感觉有股子火影忍者的古早味。\n","categories":["好好生活"],"tags":["观影","审美"]},{"title":"macOS上的Python解释器与执行环境","url":"/2021/01/25/python-envs/","content":"背景早年看廖雪峰老师的Python教程，说要安装python解释器，那个时候对命令行，虚拟环境之类的根本都没概念，并且当时并不知道Mac系统自带python解释器。所以，直接去官网安装了官方解释器。在命令行下执行python文件。\n之后用Pycharm的IDE，每次在新建项目选择python解释器的时候都一头雾水，选也选不到正确的路径，都是泪。\n后来为了学习数值计算的课程，安装了anaconda，有了很多anaconda的环境。\n有了brew之后，更乱了。\n因此下定决心捋一捋自己python解释器路径。\n系统中可能存在的Python环境、解释器路径参考macOS 上如何切换默认的 Python 版本？ - Steven Liu的回答 - 知乎\nInstall, Uninstall, and Manage Multiple Versions of Python on a Mac\n系统自带的/usr/bin/pythonMac系统自带的Python环境的具体依赖为/System/Library/Frameworks/Python.framework/Versions/2.7，对应的解释器就在该目录下的./bin/python2.7。但是Comand Line Tool会在/user/bin/python下去运行这个环境，前后着之间的关系应该是软连接symlink。\n不要删除！系统的功能实现依赖于这些框架。\n\n系统自带的/usr/bin/python3参考StackOverflow的回答：Python 3.7.3 Inadvertently Installed on Mac OS 10.15.1 - Included in Xcode Developer Tools 11.2 Now?\n可以看到/usr/bin/python3（此处是具体的依赖/可执行对象），不是映射或者替身。\n\n但是/usr/bin/python是一个symlink，指向的具体可执行文件的位置是/System/Library/Frameworks/Python.framework/Versions/2.7。\n注意区别这二者的关系。\n关于commandlinetools下的python文件同时在/Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework中可以找到替身，在/Applications/Xcode.app/Contents/Developer/us r/bin/python3可以找到python3以及python3.8指向python3.framework。\n\n这几个文件的最终指向都存在于/Applications/Xcode.app/Contents/Developer//Library/Frameworks/Python3.framework/Versions/3.8/Python3这个目录下。\n\nbrew安装的环境参考Mac 下 Python 环境总结 ( 非 Anaconda)\nhomebrew 安装python3\nhomebrew Cellar文件夹下安装的Python解释器\n如何查看brew所在目录？在终端输入brew -—prefix，会返回/usr/local，这也就解释了为什么以下的路径都是以此开头。\n\n通过homebrew安装python环境的安装路径为/usr/local/Cellar/，brew里install的brew里uninstall。\n可以在终端输入brew list来显示安装了哪些包，输入open /usr/local/Cellar/在finder中查看。一般来说在/usr/local/Cellar/中安装的包，brew都会自动地在/usr/local/bin/中添加symlink。\n但是我自己在查看/usr/local/bin/中有执行环境的时候并没有找到对应的可执行文件。于是尝试在终端执行brew install python@3.9，返回了一个warning：\nWarning: python@3.9 3.9.1_1 is already installed, it&#x27;s just not linked You can use `brew link python@3.9`  to link this version.\n在终端输入brew link python@3.9后，发现/usr/local/bin/中出现了python3.9的symlink。\n在此进入/usr/local/Cellar/python@3.9发现有两个文件夹，应该对应了不同的子版本。\n\n尝试进入其中某一个，查看bin文件夹下的二进制文件。\n\n可以看到bin文件夹下的替身都是最终指向/user/local/Cellar/Frameworks/Python.framework/Versions/3.9的文件夹下的可执行文件。\n对比系统自带的python路径/System/Library/Frameworks/Python.framework/Versions/2.7，就可以发现除了Prefix有所不同，从/Framework开始路径都是相同的。只是前缀不同，一个是/Systems/Library，另一个是/usr/local。\n接下来尝试进入/user/local可以得到如下结构，我们可以看到还有一个Framework文件夹，进入查看内容。\n\n可以发现进入这个目录之后还是Python.frameworks，继续深入又可以看见Versions版本号。\n\n最重要的是，这里的Python指向的还是homebrew的Cellar文件夹中安装的Python解释器。\nanaconda安装的环境用户安装anconda3后，anaconda自带默认的python环境base为/Users/drunk99/anaconda3，对应的解释器就在该目录下的./bin/python。\n如果用户建立了其他anaconda的环境，如名称为myenv，那么python环境为/Users/drunk99/anaconda3/envs/myenv，对应的解释器就是该目录下的./bin/python。\nanaconda会自动把路径配置到～/.zshrc文件中，无需手动添加路径。\n官网pkg安装环境通过官网pkg安装的环境，也就是用户安装的python环境为/Library/Frameworks/Python.framework/Versions/3.7。\n对应的解释器就在该目录下的./bin/python3.7\n参考CSDN上的卸载教程，以及知乎专栏的安装教程。\n分为三步骤。\n第一步：删除框架sudo rm -rf /Library/Frameworks/Python.framework/Versions/x.x\n第二步：删除目录应用sudo rm -rf &quot;/Applications/Python x.x&quot;\n第三步：删除指向Python的连接cd /usr/local/bin/\nls -l /usr/local/bin | grep &#39;../Library/Frameworks/Python.framework/Versions/x.x&#39; | awk &#39;&#123;print $9&#125;&#39; | tr -d @ | xargs rm\n第四步：在zshrc配置文件中删除python环境路径sudo vim ~/.zshrc进入配置文件，在命令模式下按下dd删除当前光标所在行。退出保存即可。\n总结\n不要随意变动或者使用/usr/bin下的可执行文件或者是软连接，包括该软连接指向的可执行文件。\n很多情况下并不需要自己再去python.org官网去下载解释器，使用包管理工具更方便。\n在有了anaconda以及homebrew的python包管理工具后，需要区别二者环境。在conda和brew的默认python环境之上，还有可能会有多个虚拟环境，注意区分。\n\n可能需要用到的终端语句查看symlink查看目标文件是否是替身、是否指向哪个具体的可执行文件：ls -l /usr/bin/python。\n这句话的意思是，hey终端，给我ls/list以下/usr/bin/python这个路径的文件指向哪个-l/link。\n从终端打开finder在finder中查看当前目录的文件：open .。这句话的意思是，hey终端，给我从finder中打开当前路径。\n如果想指定位置，可是输入绝对路径open /System/Library/Frameworks/Python.framework/Versions/2.7。\n查看/修改系统级环境变量列出系统内置的环境变量的文件：cat /etc/paths，如果要改动各种路径的默认顺序，使用sudo vim /etc/paths操作。注意，这是系统级环境变量，路径以/etc开始。\n查看/修改用户级环境变量查看当前用户级配置好的变量：echo $PATH。\n修改用户环境变量，只需要修改~/.zshrc或者~/.bashrc（看用哪个shell），sudo vim ~./zshrc进入修改界面。\n在文件最底端添加export PATH=&quot;/usr/local/bin:$PATH&quot;，每一个系统变量都是用:分隔开来的。这句话的意思是，hey终端，帮我把/usr/local/bin的添加到原来$PATH变量的前面，并且作为用户级的新$PATH，搜索路径的时候最先搜索它。\n详细请参考macOS/Linux 环境变量设置\n","categories":["Python"],"tags":["Python","解释器","虚拟环境"]},{"title":"关于python包的管理及查看","url":"/2021/01/26/python-packages-install/","content":"背景由于自己系统中存在多个python解释器，直接在终端pip install也不知道自己把包装到哪里去了，在PyCharm终端下载也不知道下载到了哪里去，因此下定决心弄明白。\n本文参考：\n\n你的Python包都装到哪了？\nPython Tutorial: How to Set the Path and Switch Between Different Versions/Executables (Mac &amp; Linux)\n\nPython如何找包想要弄明白Python解释器如何找包，首先要弄清楚Python解释器在哪个位置。\n以自己使用homebrew安装的python@3.9为例子，路径是/usr/local/bin/python3，这是python解释器所在的位置（注意这里都是替身，symlink，实际可执行文件的位置在/usr/local/Cellar下）。\n这里的/usr/local是可替换的path_prefix，根据操作系统不同或者安装方式不同会有所变化。如果是macOS自带的python，路径就是/usr/bin/python。\n当在python环境下用解释器执行脚本是，会寻找以下三个位置：\n\n&lt;path_prefix&gt;/lib（标准库路径）\n&lt;path_prefix&gt;/lib/pythonX.Y/site-packages（第三方库路径，X.Y 是对应 Python 的主次版本号，如 3.7, 2.6）\n当前工作目录（pwd命令的返回结果）\n\n需要注意的是，不同次版本好的Python的第三方库路径不同，如果你把 Python 从 3.6 升级到 3.7 那么之前装的三方库都没法用了。\nPyCharm中默认环境下包的安装通过图形界面安装\n在IDE终端使用pip install\n安装结果默认环境的包会安装到哪里去？当前环境解释器的路径是/usr/local/bin/python3，因此对应应当去寻找/usr/local/lib/python3.9/site-packages。\n\n可以看到我们在IDE的终端安装的pygments已经出现在了site-packages下。\n系统终端的默认环境下安装包在终端执行pip install pygments，发现提示已经安装到了目标位置。\n\n这是因为终端下的默认Python解释器优先级别最高的是homebrew安装的。下面给出的路径是可执行文件所在位置，不是/usr/local/python3的symlink。\n\n使用type/which查看当前python可执行环境的路径type会给出shell变量的性质，如python is a hash/python is an alias等提示，并在括号内附有完整路径。\nwhich会直接给出路径\n使用sys内置库查看当前python可执行环境的路径\nPyCharm中虚拟环境下包的安装创建该项目的虚拟环境打开Pregfrences，选中Project Interpreter，添加一个新的。\n\n创建虚拟环境，就是在当前项目下所在目录下创建一个venv文件夹，里面包含lib和bin。bin中存放指向python解释器的替身，lib中存放标准库和第三方库。这个venv文件夹下的各个项目对于该项目而言，就和/user/local/lib，/user/local/bin对于系统终端运行的python脚本是一样的。\n打开IDE终端下载库可以看到终端中出现了(venv)以及(base)，前者代表已经进入了virtualenv，后者代表目前在anaconda的base环境。\n\n\n系统终端的虚拟环境下安装包在进入虚拟环境之前，使用which pip/type pip查看一下当前pip绑定到那个路径下的解释器。\n\n可以看到当前的pip还是和which python匹配的路径。由此可以推断并验证，pip和python的解释器都是存在于同一个目录下的。\n在终端执行source ~/PycharmProjects/qa_system/venv/bin/activate，并在此使用pip install就会发现下载到了~/PycharmProjects/qa_system/venv/lib目录下。\n\n这个时候再来查看一次which pip，就能发现匹配到了项目的虚拟环境中。\n\n终端输入deactivate就能退出当前虚拟环境。\n\npip使用如果使用官方源下载包，会重复输入命令pip install，然后就会报错THESE PACKAGES DO NOT MATCH THE HASHES FROM THE REQUIREMENTS FILE。解决办法pip install package-name --no-cache-dir。当然，还是换源更快。\n下载慢换源和npm官方源一样，pip的官方源从国内链接也是特别慢，所以要换成国内源。\n终端输入pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple。\n\n查看包所在位置经常会遇到使用了pip install下载一个包，但是在脚本中使用import却报错找不到这个模块。这个时候需要使用pip show显示包安装的位置，包所在位置的上层lib文件夹和脚本编译器所在的bin文件夹属于同一层级。\n\n","categories":["Python"],"tags":["Python","虚拟环境","包安装"]},{"title":"Django基础","url":"/2021/02/11/django-basics/","content":"项目执行命令runserverpython manage.py runserver：在本地查看项目。\nsuperadminpython manage.py createsuperuser建立superuser，有权限访问所有后台数据。\nstartapppython manage.py startapp app-name：在当前总项目的项目文件夹新建一个application，django会自动生成一系列初始文件。如下所示。\n\n__init__.py为空。\nadmin.py用于注册models.py中的数据库的表，让数据库的操作不再依赖于shell中的代码，而是通过GUI操作。\napps.py说明一些和当前app相关的信息，比如在startapp后面跟着的app-name。\nmodels.py用于建立数据库表，一般形式是声明一个class代表一个表，所有数据的类型定义都来自于from django.db import models库。如下所示。\nfrom django.db import modelsfrom django.utils import timezonefrom django.contrib.auth.models import User# Create your models here.class Post(models.Model):    title = models.CharField(max_length=100)    content = models.TextField()    date_posted = models.DateTimeField(default=timezone.now)    author = models.ForeignKey(User, on_delete=models.CASCADE)    def __str__(self):        return self.title\nurls.py决定当前app的路由，和views.py的内容相关联。path(&#39;about/&#39;, views.about, name=&#39;blog-about&#39;)第一个参数是路由路径，第二个参数是views.py中定义的页面，第三个参数是赋予页面的唯一的名称，由这个页面名称可以反向获得页面路径。django中的路由解析是按照分级解析来运行的。在django_project的根目录的下一级同名子目录中可以发现另一个urls.py，这是路径搜索的开始，遇到匹配的就一级一级向其他app延伸。搜索结束django_project中的urls.py后，继续去掉已经搜索的url部分，匹配blog中的urls.py，直到匹配到特定的视图。\n\nviews.py中，每一个视图/页面/组件，都以class的形式被声明，并通过from django.shortcuts import render的render函数返回。需要为render函数传入templates文件夹中的html页面，以及models.py中的数据，如return render(request, &#39;blog/about.html&#39;, &#123;&#39;title&#39;: &#39;About&#39;&#125;)。\n\nmigration\n为什么需要database migration？\n这让我们在建立一个数据库之后，就算数据库中已经存在数据，我们依然能够修改数据库。如果django项目组没有database migration，而我们有需要对数据库的数据修改，我们需要使用一些sql code去update data structure。\n相当于用python的方式去update sql。\n\npython manage.py makemigrations基于项目中models.py的内容变化准备数据库同步，每一次执行makemigrations后migrations文件夹中都会生成XXXX_initial.py，这个文件只在makemigrations的时候生成。（这里的XXXX。是每一次migrations的数字，migration number）\n\npython manage.py migrate将已有的变化同步到数据库，主要就是执行makemigrations的时候生成的XXXX_initial.py文件。\n\npython manage.py sqlmigrate app-name migration-number会自动生成并显示每一次migration会生成的具体的sql代码。\n\nshellpython manage.py shell可以提供一个python prompt让我们用python的方式去查询数据库。\n首先需要导入数据库中的表。在这里通过from django.contrib.auth.models import User导入User Table。其次，为了查询User Table中的各个项目，使用点访问法找出其内容User.objects。需要注意查询返回的是一个单个的对象，还是包含对象的集合QuerySet。\n\n为已经导入的表新建一个元组/插入一条新的数据，直接把导入的Table当作函数调用，并传入参数。每一次新建的一个元组都要保存到表才可以查询并显示。\n\n如何探寻多个表之间的关系？比如上面就是一个User Table，一个Post Table。我们希望找到一个用户发布的所有帖子，该怎么做？这在数据库查询中十分常见。在python shell中，可以直接使用user.post_set，它会返回一个可查询对象，继续对该对象使用all/first/last/filter等查询语句即可返回具体的内容。另外，还可以对该查询对象进行create操作，意思是为该用户新建一条帖子。\n\n","categories":["Python"],"tags":["Python","django","Web"]},{"title":"二月观影记录","url":"/2021/03/08/feb-films/","content":"刺杀小说家同作为特效主打的国产电影，剧本与演员演技比流浪地球好了不知道多少个档次。\n误杀是翻拍的误杀瞒天记，中国版，演的很好，挺好看的！男朋友推荐滴～\n你好李焕英剧情很一般，贾玲很出戏。\n白日梦想家因为B站有个up叫白日梦想家，专门做影视剪辑的，就去搜了一下有没有名字叫这个的电影，然后就找到了。看了一下，挺老套的，很美国。\n复仇者联盟2：奥创纪元为了看明白旺达幻视才去看的，真的好烂一片子。\n被光抓走的人男朋友推荐的，立意挺好的，虽然标题是消失的人，但是讲的却是留下的人，但是很多东西都说不通。\n四重奏在医院里的时候看完了，没有特别喜欢的感觉，虽然是日剧必看吧。\n","categories":["好好生活"],"tags":["观影","审美"]},{"title":"三月观影记录","url":"/2021/03/08/mar-films/","content":"波斯语课还是纳粹军官演的好呀。几个配角存在的意义感觉很模糊，是想体现纳粹为人的一面吗？\n源代码男朋友推荐看的，并且保证我一定喜欢看。确实挺有意思的，前一个小时不如后面半个小时有意思，后面半个小时有很多反转。而且我这个脸盲竟然认出了这部片子里面的博士是西部世界里面造人的那个，哈哈哈。\n月球和源代码是同一个导演，讲述了克隆人用于太空站执行任务的故事。整个影片涉及的人物寥寥无几，不过很多影评所说的孤独感，我还是难以感受到。\n阿凡达经典果然是经典，潘多拉星球上的景色是真的美，这需要多少的想象力，才能用技术构建这么漂亮的景色啊。\n男友和我说，阿凡达刚上那一会儿，国内电影院IMAX还没几个，他那时候在保定，阿凡达的票一售而空，保定的赶着往北京去，就为了看阿凡达。\n夏洛特烦恼笑点很密集，狗血也挺足。才知道马冬梅的梗来自这里，算是比较经典的了。\n按照夏洛特烦恼、羞羞的铁拳、李茶的姑妈的顺序看下来，发现优秀程度是在递减的。发现开心麻花的剧都喜欢有豪车美女大奶，最终结局一般都是屌丝男抱得白富美，俗套啦。\n羞羞的铁拳反转还是有的，大结局也是好的，适合和朋友亲人一起看。\n李茶的姑妈剧情有点无厘头，笑点有点恶臭。如果自己一个人看肯定看不下去，有人陪着还好一些。\n一次别离严肃的家庭剧，牵扯到两个不同的家庭，重心偏在小中产阶级家庭，刻画爸爸女儿的关系、丈夫妻子的关系、父亲儿子的关系、儿媳公公的关系、丈母娘女婿的关系，都有涉及。印象最深的就是得了阿尔兹海默症的公公抓着要离开家的儿媳的手，不想让她走。看了这部影片，无法说谁对谁错，他只是在陈述事实，一种生活的常态，一种两难的境地。\n无依之地给我一种像对话纪录片的感觉。女主在房车旅行的路上，遇到了各种人，听他们的故事，也叙说自己的故事。导演很喜欢拍那种景大人小的画面，就差写着“主人公很孤独”六个大字在荧幕上了。拍摄人物也很喜欢怼脸拍，面部的皱纹、斑点、红晕，都能看的清清楚楚。配乐挺好听的。\n低俗小说竟然是一部黑帮电影！围绕几个人物写了几个故事，全都串联在了一起，挺有意思的。\n特别喜欢Mia和Vincent跳舞的桥段，Mia吸毒昏死过去扎针的场面也很荒诞，老大Marsellus被爆菊又被解救的场面也挺让人哭笑不得的，喜欢念圣经的Jules返璞归真也挺荒诞的。\n值得一看，台词特逗，翻译过来差了点味。\n","categories":["好好生活"],"tags":["观影","审美"]},{"title":"Transformer与Attention原理","url":"/2021/03/11/illustrated-transformer/","content":"什么是transformer？Transformer是一个使用了注意力机制Attention使训练速度提升的一个模型。Transformer在谷歌发布的Attention is All You Need一篇文章中被提出，并在TensorFlow的Tensor2Tensor库中实现。Transformer最大的特点就是对于一个输入句子，它可以做到并行处理句子中的每一个词。\n把Transformer看作一个黑盒子，他的输入是一句话，输出也是一句话；在这个黑盒子在拆分一下，黑盒内部有Encoders（由许多Encoder顺次连接而成）和Decoders（由许多Decoder顺次连接而成）两部分组成，Input-&gt;Encoders-&gt;Decoders-&gt;Output。\nEncoders中每一个Encoder都在架构上类似，但是权重上不同。每一个Encoder的输入首先进入Self-Attention，再进入Feed Forward Neural Network层。Self-Attention的帮助Encoder在encode某个词语的时候考虑这个句子中的其他词语。Feed Forward Neural Network前馈神经网络由一个输入层，一个浅层网络或多个隐藏层，以及一个输出层构成。每一层与下一层连接，可以有不连接的神经元，如果全部连接就是全连接网络了。例如卷积神经网络CNN就是典型的深度前馈神经网络。\nDecoders中每一个Decoder都在架构上类似，Decoder和Encoder的区别在于，在Decoder的self-Attention层与Feed Forward层之间有一个Encoder-Decoder Attention，这一层attention用于帮助decoder关注input中的相关部分。\n接下来对一个训练好的Transformer模型的工作流程进行讲解。\n准备工作：什么是word2vecword2vec又叫词嵌入，适用于把一个词word变成一个向量vector的算法。每一个词都会转变成一个维度为i的向量，i是一个可以设定的参数，通常来说我们会把i设定为训练数据集中最长的句子。\nword2vec会在什么时候派上用场呢？input不会直接就输入到encoder中去，在那之前会进行word2vec，第一个encoder的输入就是词嵌入后维度为i的向量，此后的每一个encoder都接受上一个encoder的输入。\ninput中每一个词不是一个一个的进入encoder的，而是一起进入的，虽然在self-attention的时候每一个词的处理是有依赖的，但在feed forward的时候词与词的依赖是不存在的，因此在前馈的部分可以体现transformer并行处理的特征。\nEncoders详解Encoder架构：什么是self-attention一个句子是会有上下文的，比如“狮子不会吃草，因为它是食肉动物”这里的它指代的是什么，对于人来说这个很好理解，对于代码来说这很难。我们希望模型在处理“它”的时候，将“它”和上文的“狮子”联系起来，这就是self-attention的作用，它会让模型在encoding一个词汇的时候更好的考虑语境。\n那么如何对input计算self-attention呢？运用的本质是还是矩阵运算。\n基础：word-level attention接下来以word level查看对于某一个词的self-attention如何计算。\n第一步，由input embedding vector与三个矩阵分别相乘获得a Query vector，a Key vector，a Value vector。三个矩阵是模型训练过程中训练获得的，用于将input embedding vector投影为其他的向量。新获得的三种vector维度比input embedding vector小很多，这样做是为了降低每一个attention的运算量，从而让所有attention的运算量不至于过于大。\n第二步，计算每一个词与其他词之间的score，所获的score是当模型在encode某一个词和句子中的其他词的点积，score的高低决定有多大的重要性要考虑。\n第三步，把获得的score都除以根号下key vectors的dimension，这样做是为了获得更稳定的梯度。\n第四步，将结果传入softmax，是结果全为正且所有结果相加为1。This softmax score determines how much each word will be expressed at this position.\n第五步，将value vector与softmax score的结果相乘，这一步是为了筛选出值得关注的单词并过滤掉没什么价值的单词。相当于每个value vector乘以某个权重。\n第六步，将第五步中的weighted value vectors相加，这个结果就是the output of the self-attention layer at this position(for this word)。这一结果会传递到feed-forward neural network中去。\n矩阵运算：matrix calculation attention我们在上一个word-level中以一个单词为基准去计算，如果多个单词的embedding被pack为一个矩阵，那么计算整个句子中的单词的self-attention就很方便。\n\nX \\times W^Q = Q \\\\\nX \\times W^K = K \\\\\nX \\times W^V = V \\\\\nAttention(Q, K, V) = softmax(\\frac{QK^T}{\\sqrt{d_k}})\\cdot V\\\\输入矩阵的每一行vector都对应输入句子中的每一个单词，将输入矩阵与权重矩阵分别相乘就可以获得。这就是Attention的数学公式中的几个量，本质上Attention的计算公式就是这三个矩阵相乘，讲一个的序列Q编码成的序列。\n\n所谓self attention\n改良：muti-headed attentionmuti-headed attention是self-attention的改良。在muti-headed的情况下，可以存在多个随机初始化的Query/Key/Value weight matrices，例如在Transformer中就是用了8个attention head。这些矩阵在训练后，可以用来把我们的embedding input vector用参数矩阵映射到多个子空间——project the input embeddings (or vectors from lower encoders/decoders) into a different representation subspace。\n\n具体来说就是将Q，K，V用h个不同的投影矩阵重复投影h次，分别做h次single-head attention，最后再把结果拼接起来。\n\nhead_i = Attention(QW_i^Q, KW_i^K, VW_i^V) \\\\\nW_i^Q \\in \\mathbb{R}^{d_k \\times \\tilde{d_k}}, W_i^K \\in \\mathbb{R}^{d_k \\times \\tilde{d_k}}, W_i^V \\in \\mathbb{R}^{d_v \\times \\tilde{d_v}}\\\\\nMultiHead(Q, K, V) = Concat(head_1, \\cdots, head_h)代码实现中的问题在具体的代码实现中，由于tensorflow不会自动并行，所以不能按照multihead的思路来写。需要讲multi-head的操作合并到一个张量来运算。\n在实际代码实现中，一般具有相同的特征维度，即hidden_size，一般选择12、16、24；确定之后，通常选择让投影矩阵，也就是说每一个Attention Head，将原始维投影到维；Attention计算之后输出也是维，称之为head_size；最后所有head的结果拼接就是个维拼接，就是维。\n但由于投射到低维后，总参数量下降，不能很好地去逼近投射前的参数量，于是就出现了低秩瓶颈（Low-Rank Bottleneck）。\n由于投射到低维后总参数量为，为了逼近原来的参数量，最直接的想法就是增加参数量。增大，运算量增加；减小，就相当于模型的multi-head被削弱了，都不太行。\n解决办法1是不一定要把都投射到同样的维度，只要保证做内积的维度相等就可以了，因此令维度为key_size，的维度为head_size。增加模型的key_size是解决低秩瓶颈的解决办法。\n解决办法2是Attention计算的内积之后softmax之前用一个参数矩阵叠加多个低秩分布的结果。\n直观理解multi-head对于”The animal didn’t cross the street because it was too tried”这句话，特定位置的某个单词如it，在每个字空间中，被认为应当focus on的单词都不一样。\n\nmulti-head attention后如何去往下一层按照这样的方式重复多次Q，K，V的计算，可以获得8个Attention head。每一个Z我们都要输入的前馈神经网络去，但是问题在于前馈神经网络只希望获得唯一一个矩阵来代表每一个词。因此我们需要尽可能利用这八个矩阵，并压缩为一个。\n\n怎么压缩？首先，把所有attention head按顺序拼接起来，注意每一行一个单词，总共就两行，所以拼接过程中总有第一个维度是不能变的。其次，把拼接后的attention heads与一个与模型一起训练的权重矩阵相乘就能获得能够输入到FFNN去的Z matrix。\n\n可以看到这里把muti-head的多个Z的维度又转变了一下。\n总结multi-headed attention过程\n细节1：如何确定语句序列 Postion Embedding由于一句话是一个单词的有序排列，我们知道transformer是把每个单词并行输入到FFNN去的，那怎么表示某个单词在句中的位置，或者说怎么判断两个单词在句子中的距离？方法是在输入的单词的embeddings的基础上再加上一个positional encoding。\n\nPosition Encoding又称Position Embedding，也就是位置向量。谷歌给出构造Position Embedding的公式，而非让这个位置向量训练出来。\n\n位置p映射为一个维的位置向量，这个向量的每个维度的计算由上面那个公式决定，位置向量中第个元素的计算就是，第个元素的计算就是。这样定义的位置向量表示的是绝对位置，但是正余弦的数学性质决定了可以提供相对位置的信息。\n词向量和位置向量的结合，既可以是拼接作为新向量；也可以把位置向量和词向量定义为一样的维度，然后二者相加。\n细节2：对每层结果归一化在Encoder中的每一个self-attention层与ffnn层之后都会有一个Add&amp;Normalize的过程，就是将X与Z相加后使用Layer Normalization归一化。\n\nDecoders详解encoders与decoders如何协同Encoders的最后一层输出的结果会被转化为一组attention vectors K and V，这些会在decoder的encoder-decoder attention layer中被用来帮助decoder关注序列中的正确位置。\ndecoder的encoder-decoder attention layer的运作机制就和muti-headed self-attention类似，只不过他的K和V从encoder来，而Q从它下面的layer获得。\n\n在最后一层Decoder输出了一个单词之后，这个单词又会作为输入进入到第一层Decoder。\n\nself-attention的区别与Encoder中的self-attention不同的是，decoder中的self-attention只允许检查到已经输出的previous output的位置，对于未来的输出的位置将他们设置为-inf进行mask。\n结束工作：Linear+softmaxdecoder的输出就是a vector of floats，如何将这些向量转变为word，是Linear Layer和Softmax Layer的工作。\nLinear Layer是一个简单的全连接网络fully connected neural network。它将decoder输出的vector投影到一个十分巨大的向量，名为logits vector。如果我们的模型经过训练有1w个不同的词汇量，那么logits vector就会是1w维度那么大，每一个维度的数值都对应了词汇量的每一个单词。\nSoftmax的工作就是把logits vector的数值转换成对应的概率(all positive, all add up to 1.0)，最大概率的维度会被选中。\n参考The Illustrated Transformer\n苏神的博客-《Attention is All You Need》浅读（简介+代码）\n苏神的博客- 突破瓶颈，打造更强大的Transformer\n","categories":["NLP"],"tags":["ML","DL","NLP"]},{"title":"Nginx安装与配置","url":"/2021/03/27/nginx-with-ssl/","content":"Nginx的安装、启动、验证安装可以参考这两篇教程：How to Intsall Nginx on CentOS以及How to install Nginx web server on CentOS 7 Linux。\n安装分为以下三个命令。\nsudo yum -y update # 更新sudo yum install -y epel-release # 安装epel repository，可以提供更多CentOS官方不提供下载的开源包sudo yum install nginx # 这里如果使用-y可能会没有反应，我自己弄的时候就存在这个问题\n启动与查看Nginx的状态。\nsudo systemctl start nginx # 按下Enter后不会获得返回值，但Nginx已经启动了sudo systemctl status nginx # 使用status查看，这会有返回值，看到active说明就在运行了\n其他一些配置。\nsudo systemctl enable nginx # 设置开机自动启动sudo systemctl disable nginx # 设置开机不自动启动sudo systemctl stop nginx # 停止nginxsudo systemctl restart nginx # 重新启动\n如果希望在浏览器中验证Nginx的可访问性，可以在浏览器中输入http://Ip-or-domain，返回一个CentOS相关的页面就没有问题。\n\n许多网页教程显示都是返回一个Welcome to nginx!的相关页面，之前我也一直以为自己配置错了。但是这个页面到底是服务器上存在的什么页面，是由/etc/nginx/nginx.conf中的server&gt;root选项决定的，如下：\n\n可以看到root的路径在/usr/share/nginx/html中，可以去查看一下该文件夹下的index.html文件。\n相关问题的解决连接附上关于nginx安装成功并启动后，登录网页不能进入欢迎页面的问题。\n\nNginx配置Nginx的安装目录为/etc/nginx。目录结构如下：\n\n使用yum安装的nginx的主要配置文件位于/etc/nginx/nginx.conf中。\nNginx默认配置文件位置到底在哪里关于Nginx的默认配置文件nginx.conf到底在哪里的回答。可以参考SegmentFault上的回答，StackOverflow的回答。\n不同的安装方式会导致nginx配置文件的目录不同。\n如果是yum以及epel安装的，配置文件在/etc/nginx下，/etc/nginx/nginx.conf的include语句include /etc/nginx/conf.d/*.conf;可以引入当前目录下conf.d下的所有*.conf的配置文件。\n如果是wget安装的，配置文件在`/usr/local/nginx/conf。\n如果在ubuntu系统下使用apt-get，文件目录中还会存在一个sites-available文件夹，其实他的作用就类似于conf.d文件夹。可以参考这个回答。\nNginx配置文件相关命令以下是关于查看nginx配置文件的命令。\n# 查看当前使用nginx配置文件的地址nginx -t# 查看所有的nginx.conflocate nginx.conf# 以-c命令指定配置文件启动nginxsudo nginx -c /etc/nginx/nginx.conf\nNginx启动后无法访问页面如果发现systemctl restart nginx之后访问ip或domain仍然提示报错或服务器拒绝访问，使用systemctl status nginx查看nginx当前的状态，如果出错会有红色高亮语句。\n命令行的return value类似于Job for nginx.service failed. See &quot;systemctl status nginx.service&quot; and &quot;journalctl -xe&quot; for details.，可以考虑检查Nginx配置文件中的syntax是否有错误。解决办法参考自这里。\n执行如下命令，这里指定了测试检查的Nginx配置文件的路径。\nnginx -t -c /etc/nginx/nginx.conf\n结果是这样的。\n\n第一个warn因为我生成的是自签名证书，后续再去申请有效的证书。\n第二个emerg就是出错所在，多了一个花括号，导致语法出错了！依据行提示101查找位置，修改保存。再次restart就可以了。\n加密、签名、证书相关概念digital signature数字签名查看数字签名是什么，这篇文章解释了数字签名与数字证书。下面是我的一些理解。\n在网络上传输信息的双方，双方各持有一把公钥、一把私钥。公钥和私钥是对偶的，如果破解了一把，另一把自然就被破解了；公钥是私钥的唯一持有者给他的通信对象发送的加密钥匙，公钥可以公开给所有人，私钥需要持有者保密。发送方用公钥加密内容，接收方只能用和发送方匹配的密钥解密内容。\n\n发送信息的双方，各自生成一对公钥和密钥，把公钥分享给对方，私钥自己持有。举个例子，A和B在通信，首先要A生成自己的公钥和密钥，并且B也生成自己的公钥和密钥，A把自己的公钥给B，B也把自己的公钥给A。因此A在通信中会用到：A自己的密钥，B发送过来的公钥。\n\n目前为止，发送方A想要给接收方B发送信息，只要用公钥加密即可。但是C、D、E都可以有公钥，B如何确定发送过来的信息是谁发过来的？因此发送方A采用“数字签名”的形式发送信息。\n数字签名就是发送方A将信息用Hash函数生成信件摘要digest，并用发送方A自己的私钥加密后生成的证明自己是自己的认证。数字签名会附在原信息内容后，通过接收方B的公钥加密后发送。接收方B在拿到这个信息后，首先用自己的私钥B解密，获得信件正文内容与签名，再将签名用发送方A的公钥解密，获得摘要digest。接收方B为了确认信件征文内容没有被篡改，对信件正文做哈希后与解密后获得的digest做对比，如果一致，说明内容对上了，发送人也对上了。\n「签名」的作用本身也不是用来保证数据的机密性，而是用于验证数据来源的防止数据被篡改的，也就是确认发送者的身份。\n\n为什么是哈希函数？\n\n如果没有哈希函数，同时原信息又很庞大，对原信息计算数字签名（非对称加密）的运算量十分庞大，耗时。\n哈希函数是不可逆的，无法从摘要反推出原文。\n\n\n数字证书digital certificate有了数字签名之后，A和B的对话就能加密进行了，但问题是接收方B持有的公钥怎么就一定是发送方A的？如果C用自己的公钥冒充A发送给B，且B保存下来，之后A反而会被当作冒充者。\n之前我们都在考虑消息是否会被篡改，但是公钥是否会被篡改呢？发送方A没有办法证明自己的公钥就是自己的公钥，因此需要第三方帮自己证明，就像公安局发身份证证明公民身份一样。\n换句话说，数字证书就是「公钥的数字签名」，是为了保证公钥不被篡改而引入的。\n由于我们不能自己证明自己，要找第三方公证，这个第三方就是CA（Certificate Authority），CA会将证书的颁布机构、有效期、公钥、持有者等信息用CA的私钥进行签名，在接收方B收到这个数字证书的时候，用CA的公钥进行验签。\n\n证书颁发的机构有层级关系，下级CA的证书由上级CA签发，根证书签发机构使用自签，自己给自己认证。\n操作系统和浏览器等厂商一般都会预装可靠的根证书。\n\n参考一文彻底搞懂加密、数字签名和数字证书\n数字签名是什么\n为Nginx配置TLSopenssl生成密钥与证书首先创建一个用于存放nginx的密钥、Diffie-Helman key、证书的文件目录，并设置权限。\nmkdir /etc/pki/nginx/chmod 700 /etc/pki/nginx/\n用以下命令生成RSA私钥和自签名证书到上一步创建的目录。其中req是证书请求的子命令，-newkey rsa:2048 -keyout /etc/pki/nginx/private.key表示生成私钥到制定位置/etc/pki/nginx/private.key，-nodes表示私钥不加密，-x509表示输出X509格式的证书，-days 365表示有效期为365天\nsudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/pki/nginx/private.key -out /etc/pki/nginx/certificate.crt\n接着会在命令行要求填写Country Name (2 letter code)至Email Address等证书拥有者信息，其中Common Name填写服务器IP地址或（已购买的）域名。\n用以下命令生成DH key到上一步创建的目录。\nopenssl dhparam -out /etc/pki/nginx/dhparam.pem 2048\n至此，/etc/pki/nginx下已有三个文件。（pki=public key infrastructure）\n\n\n也可以向证书与私钥供应商处获取密钥，有很多公司提供这个服务。申请成功后将证书和私钥都复制到特定目录下的.crt与.key后缀的文件中即可。\n另外在同一目录下生成DH密钥交换可以确保密钥交换过程中的安全性。\n图文可以看这篇教程。\n\n为Nginx应用生成的密钥与证书在/etc/nginx中包含了关于Nginx的所有配置。在conf.d子目录下创建一个ssl.conf的配置文件。\nvim /etc/nginx/conf.d/ssl.conf\n内容如下，一定要把server_IP_address改成自己的服务器ip。\nserver &#123;listen 443 http2 ssl;listen [::]:443 http2 ssl;server_name server_IP_address;ssl_certificate /etc/pki/nginx/certificate.crt;ssl_certificate_key /etc/pki/nginx/private.key;ssl_dhparam /etc/pki/nginx/dhparam.pem;ssl_protocols TLSv1 TLSv1.1 TLSv1.2;ssl_prefer_server_ciphers on;ssl_ciphers &quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&quot;;ssl_ecdh_curve secp384r1;ssl_session_cache shared:SSL:10m;ssl_session_tickets off;ssl_stapling on;ssl_stapling_verify on;resolver 8.8.8.8 8.8.4.4 valid=300s;resolver_timeout 5s;#add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains; preload&quot;;add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains&quot;;add_header X-Frame-Options DENY;add_header X-Content-Type-Options nosniff;root /usr/share/nginx/html;location / &#123;&#125;error_page 404 /404.html;location = /404.html &#123;&#125;error_page 500 502 503 504 /50x.html;location = /50x.html &#123;&#125;&#125;\n另外可以选择将http流量重定向为https流量。\nvim /etc/nginx/default.d/ssl-redirect.conf\n在这个ssl-redirect.conf文件中放入如下内容。\nreturn 301 https://$host$request_uri/;\n","categories":["必备技能"],"tags":["linux","NGINX","SSL","数字签名","数字证书"]},{"title":"利用Gunicorn和Nginx在服务器上部署一个Flask API","url":"/2021/03/29/gunicorn-nginx-flask-api/","content":"在过去，我们部署一个应用的时候，几乎总是要分布在多台机器的。比如，4台HTTP服务器把动态请求分发到两台Application服务器上，并且它们都访问一个数据库服务器。但是随着机器的能力在增强，而互联网应用的覆盖面从业务逻辑极其复杂的银行业电信业到了送盒饭选泡面的小行业，越来越多的Application服务器和Web服务器合体了（以django圈子举例，有httpd+mod_wsgi或者Nginx+mod_uwsgi）。而且很多时候这种小应用的数据库也host在同一台机器上。\nNginx是什么Nginx是一个处理用户请求、并返回响应的HTTP服务器。\n在网络不稳定的情况下，从客户端发来的请求可以被Nginx缓存，一并发送给Gunicorn。\n在存在多个应用服务器（就是具体处理业务、生成相应内容的服务器，比如Django框架、Flask框架）的情况下，Nginx的反向代理功能让用户客户端不必知道他们真正访问的是哪一个服务器。\nGunicorn是什么Gunicorn is a Python Web Server Gateway Interface(WSGI) HTTP server.\n\nWSGI是什么？它的主要工作是什么？WSGI简介。\nWSGI是一个规范，定义了Web服务器如何与Python应用程序进行交互，使得使用Python写的Web应用程序可以和Web服务器对接起来。\nWSGI的主要目的有两个：\n\n让Web服务器知道如何调用Python应用程序，并且把用户的请求告诉应用程序。\n让Python应用程序知道用户的具体请求是什么，以及如何返回结果给Web服务器。\n\n\nGunicorn不需要直接处理用户客户端发送过来的请求。Gunicorn首先接受来自Nginx的动态请求；Gunicorn调用应用服务器中的逻辑生成相应内容，返回给Nginx；Nginx把数据再返回给用户。\n三者关系借用一个简单又形象的回答。\nNginx面向来自外部的请求，并且Nginx持有当前服务器文件系统中的静态资源文件。然而，Nginx不会直接和Python应用程序有数据交互，此二者之间要有一个桥梁，这个桥梁就是Gunicorn。Gunicorn运行Python应用程序，将来自外部的请求交付Python应用程序处理，并返回数据。\n那么Gunicorn怎么完成这些任务呢？他会生成一个Unix Scoket，利用WSGI协议把Python应用程序得出的响应数据传递给Nginx。\nThe outside world &lt;-&gt; Nginx &lt;-&gt; The socket &lt;-&gt; Gunicorn\n部署步骤先确定服务器系统上安装了必要的依赖内容，比如合适版本的gcc/g++，最新的动态库，git，Nginx，Python版本管理工具与虚拟环境管理工具（如pyenv、pipenv、virtualenv等自行选择）。\n现在本地PyCharm的虚拟环境中完成代码开发，虚拟环境导出必要的库到requirements.txt，使用SFTP将代码部分上传到服务器，在服务器上创建虚拟环境并进入，安装requirements.txt下的依赖。\nGunicorn配置进入虚拟环境，在项目根目录下，安装gunicorn，pipenv install gunicorn。\n在整个项目的启动文件，也就是app = Flask(__name__)所在Python文件的同一目录下，创建一个名为gunicorn.conf.py的Gunicorn的配置文件。\n\n注意gunicorn.conf运行会报错，官网文档要求以.py结尾。\nThe third source of configuration information is an optional configuration file gunicorn.conf.py searched in the current working directory or specified using a command line argument.\n\nvim gunicorn.conf.py配置文件的内容如下：\n# 并行工作线程数workers = 4# 监听内网端口8080【按需要更改】bind = &#x27;127.0.0.1:8080&#x27;# 设置守护进程【关闭连接时，程序仍在运行】daemon = True# 设置超时时间120s，默认为30s。按自己的需求进行设置timeout = 120# 设置访问日志和错误信息日志路径，在项目启动文件夹下提前创建一个logs文件夹，否则后续运行可能会报错accesslog = &#x27;./logs/acess.log&#x27;errorlog = &#x27;./logs/error.log&#x27;\n\n关于workers配置的血与泪的教训。如果自己的服务子配置不咋地，像我一样1核2G内存，项目里还有预训练模型要调用的，强烈建议不要多线程……不然运行起来卡到ssh连接建立都要一分钟，无语！\n\n要让Gunicorn处理这个Python应用就在项目启动文件所在目录下执行下面的命令。\ngunicorn -c gunicorn.conf.py  flask_server:app\n\nGunicorn命令的参数解释：\n-c：按照指定的Gunicorn配置文件运行。\nflask_server:app：项目的启动文件，项目启动文件中flask app的名字（一般都默认叫app，也可以自己定义）。\n当然，配置文件中的参数也可以放在命令行中执行，只是每一次写一长串命令行会很麻烦。如gunicorn -D -w 3 -b 127.0.0.1:8080 main:app中-D 表示后台运行，-w 决定线程个数，-b指定ip和端口。\n\n查看运行的Gunicorn的进程号，并关闭。\n# 请求gunicorn相关的进程树pstree -ap|grep gunicorn# 返回的结果(myChatbot) [root@VM-4-13-centos api]# pstree -ap|grep gunicorn  |-gunicorn,21545 /root/.local/share/virtualenvs/myChatbot-Bk5svUYU/bin/gunicorn -cgunic  |   |-gunicorn,21548 /root/.local/share/virtualenvs/myChatbot-Bk5svUYU/bin/gunicorn -cgunic  |   |   |-&#123;gunicorn&#125;,21578  |   |   |-&#123;gunicorn&#125;,21579  |   |   |-&#123;gunicorn&#125;,21580  |   |   |-&#123;gunicorn&#125;,21589  |   |   |-&#123;gunicorn&#125;,21590  |   |   |-&#123;gunicorn&#125;,21591kill -9 21545\nNginx配置上一篇博客中，记录一些Nginx配置相关的内容。/etc/nginx/nginx.conf中对http模块中的server模块进行如下更改。因为我们在服务器上既放了web前端的代码（基于Vanilla JS），以及后端api，所以要有多个location分别给予前端和后端。\n经过多次尝试发现以下配置是可行的。\nserver &#123;        listen       80 default_server;        listen       [::]:80 default_server;        server_name  121.4.67.30;        # Load configuration files for the default server block.        include /etc/nginx/default.d/*.conf;                \t\t# 这是前端Web页面的路径，里面就css/js/html各一个，两张图        location / &#123;        root /home/myChatbotWebFrontend/QABotFrontend/;        index index.html index.htm;        &#125;                # 这是后端Flask API的路径，Nginx会把请求转发给Gunicorn        location /api/ &#123;        proxy_pass http://127.0.0.1:8080/;         proxy_set_header  X-Real-IP  $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        &#125;                # Web项目下静态资源的查找        location ~* ^.+\\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt)&#123;        root /home/myChatbotWebFrontend/QABotFrontend/;        &#125;                # 默认的错误页面，可要可不要        error_page 404 /404.html;        location = /404.html &#123;        &#125;        error_page 500 502 503 504 /50x.html;        location = /50x.html &#123;        &#125;    &#125;\n变化就是把root项给删除了，不然会一直显示Welcome to CentOS的欢迎页面。添加了三个location，分别用于指向Web代码，Python代码，以及静态资源（虽然不知道有没有用，但是不想再删了试了）。\n在location项中添加了一个代理配置，将访问server_name121.4.67.30的流量都代理到proxy_pass本机的8080端口，因为我们gunicorn的配置文件中决定了我们的Python应用程序在本机127.0.0.1的8080端口。\n做好这些工作后重启nginx即可。systemctl restart nginx。\n关于Nginx中location和proxy_pass中斜杠的问题这主要涉及Nginx匹配的路径与云服务器上多个项目存放路径的问题。\n首先是location的匹配规则，如下。Nginx中的一个location，可以被prefix string，或者被一个regular expression定义。\n为了匹配从用户客户端发来的一个请求地址，nginx首先会校验prefix string，选择最长匹配项目。其次，nginx进行正则匹配。regular expression的匹配是按照它们在配置文件中定义的先后顺序进行的；正则匹配方式一旦匹配到了路径，就不会再继续匹配下去。一边下来发现正则匹配没有匹配的项目，那么nginx就会返回prefix string匹配的项目。查看Nginx-Httpcore官方文档，与文档的中文解读。\nlocation [=|~|~*|^~] /uri/ &#123; ... &#125;\n\n~*代表使用正则匹配，不区分大小写匹配。\n~代表使用正则匹配区分大小写匹配。\n=代表使用精确匹配，一定情况下会加速匹配。\n^~代表如果符号后的字符是最佳匹配，就采用改方式，不再进行查找。\n\n对于 URL 中的尾部 / 则是，当有 / 时表示目录，没有时表示文件。当有 / 是服务器会自动去对应目录下找默认文件，而如果没有/ 则会优先去匹配文件，如果找不到文件才会重定向到目录，查默认文件。\nlocation中uri是否有斜杠与proxy_pass是否有斜杠，决定了能否正确匹配到路径。关于斜杠的提示，来自这篇配置教程。\nlocation /api/ &#123;    proxy_pass http://127.0.0.1:8080/;     proxy_set_header  X-Real-IP  $remote_addr;    proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;&#125;\n我的理解是，nginx首先会基于server_name  121.4.67.30;，把当前拥有的待匹配对象作为http://121.4.67.30/api/。我从浏览器中输入的请求地址类似于http://121.4.67.30/api/test?ques=你好，nginx会将这个请求uri与带匹配对象做比较，并用proxy_pass中的内容http://127.0.0.1:8080/替换为http://127.0.0.1:8080/test?ques=你好，这样就能顺利访问到本地执行的、由Gunicorn管理的Python Flask API了。\n我们希望Nginx把目标uri转变为实际上我们Python运行的flask api：http://127.0.0.1:8080/test?ques=你好。我们不希望本地访问的地址中有/api/。\n如果proxy_pass中的内容http://127.0.0.1:8080，且location /api/，那么nginx会保留location中路径的部分，替换成了http://127.0.0.1:8080/api/test?ques=你好。\n或有location /api与http://127.0.0.1:8080，替换成http://127.0.0.1:8080/api/test?ques=你好，无法成功搜索。\n\nproxy_pass中的内容http://127.0.0.1:8080被成为proxy_pass withput uri(i.e. without path after server:port)。就是单纯的ip地址和端口的组合。\n\n或者location /api，且proxy_pass http://127.0.0.1:8080/;，那么nginx会使用alias的替换方式对请求的url进行替换，如将请求地址http://121.4.67.30/api/test?ques=你好变为http://127.0.0.1:8080//test?ques=你好。\n关于Nginx中proxy_pass的斜杠问题，这篇文章中写的很清楚，可以参考。\n无法访问或报错遇到无法访问或者报错的情况，去gunicorn配置的logs目录下看日志！一般终端执行这些命令的时候不会有return value。\n比如一开始不知道gunicorn的main:app命令参数代表什么意思，自己和教程乱写，结果怎么也出不了页面，error.log中都记录了下来，才发现是根本没有main模块，别人的main模块在我这边的名称是flask_server。\n\n参考AI画家第四弹——利用Flask发布风格迁移API\nAI画家第五弹——从0到1部署你的RESTful API\nfalsk中gunicorn的使用\n使用Nginx和Gunicorn在服务器上部署Flask项目\n","categories":["必备技能"],"tags":["API","server","Gunicorn","Nginx","flask"]},{"title":"CSS基础知识","url":"/2020/10/16/css-tips/","content":"工作原理\n浏览器拉取到CSS之后会进行解析，根据选择器的不同类型（比如element、class、id等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id选择器等）应用在对应的DOM的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。\n如果一个浏览器在解析你所书写的CSS规则的过程中遇到了无法理解的属性或者值，在你书写了错误的CSS代码（或者误拼写），又或者当浏览器遇到对于它来说很新的还没有支持的CSS代码的时候，它会忽略这些并继续解析下面的CSS声明。\n基本规则浏览器的默认行为太丑就需要改变浏览器对于该元素的默认行为。可以具体的在该选择器下的元素，或者通过全局选择器*，应用属性值为none的样式。\n为了避免重复的 CSS，一种常见的做法是给基本元素定义通用样式，然后给不同的元素创建对应的类。\nCSS语言有规则来控制在发生碰撞时哪条规则将获胜 — 这些规则称为级联规则和专用规则。cascade, 和它密切相关的概念是 specificity，决定在发生冲突的时候应该使用哪条规则。\nCascade层叠\ncss规则的顺序很重要。\n当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。\n\n优先级衡量一个选择器的优先级的标准\n一个元素选择器不是很具体 — 会选择页面上该类型的所有元素 — 所以它的优先级就会低一些。\n一个类选择器稍微具体点 — 它会选择该页面中有特定 class 属性值的元素 — 所以它的优先级就要高一点。\n\n具体浏览器计算优先级本质上，不同类型的选择器有不同的分数值，把这些分数相加就得到特定选择器的权重，然后就可以进行匹配。注意不允许进位计算，例如无论多少个类选择器的权重叠加，都不会超过一个 ID 选择器。\n\n千位： 如果声明在 style 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。(一般很少用)\n百位： 选择器中包含ID选择器则该位得一分。\n十位： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。\n个位：选择器中包含元素、伪元素选择器则该位得一分。\n\n注: 通用选择器 (*)，组合符 (+, &gt;, ~, ‘ ‘)，和否定伪类 (:not) 不会影响优先级。\n继承一些设置在父元素上的css属性是可以被子元素继承的，有些则不能。\nCSS为了控制继承提供了四个特殊的通用属性值，每个CSS属性都能接收这些值。\n\ninherit\n\n设置该属性会使子元素属性和父元素相同。实际上，就是 “开启继承”.\n\ninitial\n\n设置属性值和浏览器默认样式相同。如果浏览器默认样式中未设置且该属性是自然继承的，那么会设置为 inherit 。\n\nunset\n\n将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial一样。\n\nrevert\n\n新属性，很少有浏览器支持。\nCSS 的 shorthand 属性 all 可以用于同时将这些继承值中的一个应用于在该选择器选中的元素的（几乎）所有属性。它的值可以是其中任意一个(inherit, initial, unset, or revert)。这是一种撤销对样式(选择unset属性)所做更改的简便方法，以便回到之前已知的起点。\n速记属性速记属性如 font, background, padding, border, and margin ，允许一行设定多个属性值。\n\n In 4-value shorthands like padding and margin, the values are applied in the order top, right, bottom, left (clockwise from the top). There are also other shorthand types, for example 2-value shorthands, which set padding/margin for top/bottom, then left/right.\n\n盒模型类型块级盒子 block box\n盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽\n每个盒子都会换行\nwidth 和 height 属性可以发挥作用\n内边距（padding）, 外边距（margin） 和 边框（border） 会将其他元素从当前盒子周围“推开”\n\n内联盒子 inline box\n盒子不会产生换行。\nwidth 和 height 属性将不起作用。\n垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。\n水平方向的内边距、外边距以及边框会被应用而且也会把其他处于 inline 状态的盒子推开。\n\ndisplay属性inline/block块盒子和内联盒子区别在于会在页面流page flow和元素之间的关系上表现出不同的行为，使用display属性设置为inline或者block来控制盒子的外部显示类型。\n\n外部显示类型 V.S. 内部显示类型\n注意这里的盒子模型是外部显示类型，用于决定盒子时块级还是内联。但是盒子模型本身还有一个内部显示类型，决定盒子内部元素如何布局。\n\nflex可以通过使用类似 flex 的 display 属性值来更改内部显示类型。 如果设置 display: flex，在一个元素上，外部显示类型是 block，但是内部显示类型修改为 flex。\ninline-blockdisplay属性有一个特殊值，用来表现内联盒块之间的一个中间状态，即inline-block。\n使用场景\n不希望一个项目切换到新行，但希望可是达成块盒子的部分效果。\n\n添加内边距来使连接具有更大的命中区域\n\n\n特点\n设置width和height属性会生效\npadding/margin/border会推开其他元素\n\n盒模型种类标准盒模型\nContent Box用于显示内容(width/height)\nPadding Box包围在内容外部的空白区域(padding)\nBorder Box包裹内边距和内容(border)\nMargin Box描述盒子与其他元素之间的空白区域，影响的还是盒子的外部空间。(margin)\n\n\n\n一个常见误区\n给盒子设置width和height实际设置的是content box，padding和border再加上设置的width和height才是整个盒子的大小。\n盒子的范围到border为止，不会延伸到margin。\n\n替代盒模型标准盒模型的盒子大小需要计算才能获得，十分麻烦。使用替代盒模型的好处在于所有宽度都是可见宽度，内容宽度是该关度减去边框和填充部分。\n浏览器默认使用标准盒模型，如果要使用替代盒模型，要设置 box-sizing 属性为 border-box。\n如果要使所有元素都使用替代模型，设置box-sizing在&lt;html&gt;元素上。\n属性margin/border/padding\n外边距margin\n\n可以使用margin属性一次控制一个元素的所有边距。顺序为top-right-bottom-left顺时针。\n无论使用标准模型还是替代模型，外边距总是在计算可见部分后额外添加。\n会把其他元素从盒子旁边推开。 外边距属性值可以为正也可以为负。设置负值会导致和其他内容重叠。\n外边距折叠margin collapsing是指有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小，而不是两个外边距的综合。\n\n边框border\n\n可以使用border属性一次设置所有四个边框的宽度width、颜色color和样式style（注意书写顺序）。\n圆角border-radius可使用长度或百分比作为值，第一个值定义水平半径，第二个值对应垂直半径。\n\n内边距padding\n\n内边距只能是0或正数。\n内边距用于将内容推离边框。\n\n 以上这些属性完全适用于块盒子。但是内联盒子不一定使用，有一些设定会直接被忽略。\n\n另一种方法是用em值设定字体大小。em 值的大小是动态的。当定义或继承font-size属性时，1em等于该元素的字体大小。如果你在网页中任何地方都没有设置文字大小的话，那它将等于浏览器默认文字大小，通常是16px。em = 希望得到的像素大小 / 父元素字体像素大小\ncolorCSS属性设置颜色值的前景色以及文本装饰，可以用name-coclor，hsla，rgba，global index。\ndisplay用于定义元素的默认显示方式。\n块级元素，默认填充满整个一行，如div p ul li ，自带display: block属性。\n行内元素，默认大小由内容撑开，如a span input，自带display: inline属性。\n选择器 selector将命中的样式应用到对应的元素上。选择器所选择的元素，叫做“选择器的对象”。\n如果你有多个使用相同样式的CSS选择器，那么这些单独的选择器可以被混编为一个“选择器列表” — 将选择器组合起来，在它们之间加上一个逗号并另起一行 — 这样，规则就可以应用到所有的单个选择器上了。\n当你使用选择器列表时，如果任何一个选择器无效 (存在语法错误)，那么整条规则都会被忽略。\n确定样式的几种情况根据元素在文档中的位置确定样式\n设置某一个标签元素的后代元素的样式，利用包含选择器，在两个选择器之间加空格。\n设置直接出现在某个标签元素后面并且与该标签元素具有相同层级的另一标签元素的样式，利用相邻选择符+。\n\n根据状态确定样式最直观的例子就是&lt;a&gt;标签，在标签后面直接跟上:status。\n选择器种类类型/类/ID选择器\n类选择器以.开头，会选择文档中应用了这个类的所有物件。\n\n\n指向特定元素的类：通过没有空格地附加类的欲选择元素的选择器h1.className。\n\n某个元素含有多个类：为了匹配带有所有这些类的元素，我们可以将这些类不加空格地连成一串。\n\n\n\nID选择器以#开头，由于在一篇文档中，一个id只能使用一次，将id选择器放在类选择之前缩小范围。\n\n标签属性选择器根据一个元素上的某个标签的属性的以下其中情况进行选择。\n\n[attr] Matches elements with an attr attribute (whose name is the value in square brackets).\n[attr=value] Matches elements with an attr attribute whose value is exactly value — the string inside the quotes.\n[attr~=value] Matches elements with an attr attribute whose value is exactly value, or contains value in its (space separated) list of values.\n[attr|=value] Matches elements with an attr attribute whose value is exactly value or begins with value immediately followed by a hyphen.\n[attr^=value]Matches elements with an attr attribute (whose name is the value in square brackets), whose value begins with value.(RegExp)\n[attr$=value]Matches elements with an attr attribute whose value ends with value.(RegExp)\n[attr*=value]Matches elements with an attr attribute whose value contains value anywhere within the string.\nCase Insentivity: Use the value i before the closing bracket. This flag tells the browser to match ASCII characters case-insensitively.\n\n伪类/伪元素伪类伪类用于样式化一个元素的特定状态，直接跟一个冒号。它们选中你的文档中处于某种状态的那部分，表现得就像是你已经向你的HTML加入类一样。\n参考\n位置决定样式:first-child :last-child nth-child nth-of-type\n:only-child\n:invalid\n用户行为伪类:hover :focus :checked等\n伪元素伪元素选择元素的某一个部分而不是元素自己，后面跟两个冒号。表现得是像你往标记文本中加入全新的HTML元素一样，而不是向现有的元素上应用类。\n生成带有伪类::before和::after的属性content//生成内容\n插入图标作为视觉提示，并且不希望屏幕阅读器读出它。\n\n插入空字符串，而后像页面上的其他元素一样被样式化。\n\n\n关系选择器Combinator关系选择器在选择器之间，或选择器与文档内容的位置之间，建立了一种有用的关系。\n后代选择器用单个空格（ ）字符组合两个选择器。\n子代关系选择器子代关系选择器是个大于号（&gt;），只会在选择器选中直接子元素的时候匹配。（父亲节点与孩子节点/注意容易误区以为只能）\n例如article &gt; p可以选择article元素的初代子元素。\n邻接选择器邻接兄弟选择器（+）用来选中恰好处于另一个在继承关系上同级的元素旁边的物件（紧跟/兄弟节点）。\n通用兄弟选择器选中一个元素的兄弟元素，即使它们不直接相邻，你还是可以使用通用兄弟关系选择器（~）。（任何/兄弟节点）\n全局选择器*，单用的话选中文档中的所有内容，如果和其他选择器组合的话放在后面就是选中父亲元素的所有内容。当组合选择器时，使用全局选择器会让选择器更加易读，更明显表明他们的作用。\n@ rules\nAt-rules are CSS statements that instructs CSS how to behave.\n\n最常见的就是@media，允许使用媒体查询来应用css。该查询将根据视口宽度更改样式。这符合响应式设计(Responsive Design)，能够让网站针对不同浏览器和设备呈现不同显示效果。\n背景样式\nbackground-color\n\nbackground-image\n可设置url()，多个图像用逗号分开\n可设置渐变背景\n\nbackground-attachment\n当有内容要滚动且想要设置页面滚动时，背景如何滚动\n有scroll/fixed/local\n\nbackground-repeat可设置no-repeat/repeat-x/repeat-y/repeat\n\nbackground-size可设置长度或百分比值，关键字cover/contain\n\nbackground-position\n选择背景图像显示在其应用到的盒子中的位置。\n可以使用(是background-position-x和background-position-y的缩写)水平坐标值紧跟垂直坐标值/关键字top、right、bottom、left、center/长度值/百分比。4-value语法可以指示到盒子的某些边的距离。\n\n\n书写模式和方向为什么需要谈到书写模式和方向？\n新的书写模式对盒模型的各个属性有何影响？之前介绍的属性是属于物理属性还是逻辑属性？\n如何让盒模型的各个属性适应任何书写模式？如何寻找一种通用的盒模型表示形式？\nwriting-mode属性可以指定文本的排列方向是横向还是纵向。有三个取值horizontal-tb/vertical-rl/vertical-lr。\n切换书写模式时，块和内联文本的方向也被改变了。此时，块维度指的总是块在页面书写模式下的显示方向。而内联维度指的总是文本方向。 \n\n这里存在一个问题，我们的内联和块的文本方向被改变了，也就是box的content布局改变了，但是content的width和height是横向模式下固定的。\n也就是说，尽管盒子的物理方向因为我们设置了writing-mode属性有了变化，盒子的物理属性仍然是默认书写模式的物理属性。\n因此需要把横向模式下的width和height对应到纵向模式下的XXX，或者任何书写模式下通用的XXX？\n\n解决不同书写方向的盒模型适应问题用逻辑logical和相对变化flow relative来代替width和height一样的物理属性。\nwidth映射成inline-size，表示内联维度的尺寸。\nheight映射成block-size，表示块级维度的尺寸。\n同样的，margin/border/padding都有对应的映射后的属性。\nmargin-top映射成margin-block-start，表示块级维度开始处的边距。\nborder-bottom映射成border-block-end，表示块级维度结尾处的边框。\npadding-left映射成padding-inline-start，表示内联开始方向上的内边距。\n调整大小固有尺寸元素的固有尺寸由其包含的内容决定。\n如果给一个块级元素如div不添加任何内容，设置border，会出现横跨页面一整行的一条线，那是边框被压缩后的效果，欣慰内部没有内容撑开它。表现出横跨一整行是因为这是一个块级元素。\n如果放置一个内联元素img，表现出来就会是一个正方形。也是压缩后的效果。\n设置尺寸给元素指定尺寸时，我们称之为外部尺寸，无论放什么内容进去，该尺寸恒定；如果内容超出了该指定尺寸的容纳空间，就发生内容溢出。\n使用具体的数值使用百分数要注意这个百分数是什么的百分数，一般都是指父级容器的百分数。百分数是以包含盒子的块为根据解析的。\n\nThis is because percentages resolve against the size of the containing block. With no percentage applied our &lt;div&gt; would take up 100% of the available space, as it is a block level element. If we give it a percentage width, this becomes a percentage of the space it would normally fill.\n\nwidth设置百分数参考父级元素。\nmargins和padding设置百分数，值以内联尺寸inline-size为依据进行计算(therefore the width when working in a horizontal language)，通过给他们设置相同的百分数可以让盒子周围的内外边距大小相同。\n使用min-和max-尺寸给定一个元素的最大或最小尺寸。\nMin-height的常见用法为：盒子中有变化容量的内容，想让它有一个确定的高度。盒子就会一直保持大于这个最小高度，但是如果有比这个盒子在最小高度状态下所能容纳的更多内容，那么盒子就会变大。\nmax-width的常见用法为：在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。（响应式设计）\n视口单位与视口尺寸相关的度量单位，即意为视口宽度的vw单位，以及意为视口高度的 vh单位。\n1vh等于视口高度的1%，1vw则为视口宽度的1%。你可以用这些单位约束盒子的大小，还有文字的大小，他们会一起变化。\n溢出 overflowOverflow happens when there is too much content to fit in a box. \n下面介绍几种处理CSS溢出的方法。\noverflow告诉浏览器如果发生了溢出，该怎么处理溢出的内容。\n\nThe overflow property is how you take control of an element’s overflow. It is the way you instruct the browser how it should behave.\n\n\nThe default value of overflow is visible. With this default, we can see content when it overflows.\n\nTo crop content when it overflows, you can set overflow: hidden. This does exactly what it says: it hides overflow. Beware that this can make some content invisible. \n\nAdd scrollbars when content overflows, Using overflow: scroll, browsers with visible scrollbars will always display them—even if there is not enough content to overflow. \n\n可以直接向属性传入两个以上列出的参数值，分别对应水平和垂直方向。\n\n\nscroll on the x axis using overflow-x.\nscroll on the y axis using  overflow-y.\n\nIf you only want scrollbars to appear when there is more content than can fit in the box, use overflow: auto\n\n当发生a small box with a long word（就是一句话中有很长一个单词直接超出了content范围）时，不适合用overflow。如果hidden会导致data loss，如果scroll不利于展示，建议使用word-break或overflow-wrap属性。这二者都是对一句话进行断句，区别在于利用空格考虑单词完整性断句。\n\n In contrast to word-break, overflow-wrap will only create a break if an entire word cannot be placed on its own line without overflowing.\n\nCSS的值\n\n\n\n数值类型\n描述\n\n\n\n\ninteger\n整数\n\n\nnumber\n小数，也可以是没有小数部分的整数\n\n\ndimension\n有附加单位的number，包括许多特定的类型，比如length\n\n\npercentage\n百分比值\n\n\n\n\n长度绝对长度与其他任何东西都没有关系，总是相同大小。cm/mm/px/pt，常用于打印。\n相对长度相对于其他一些东西，比如父亲元素的字体大小，或者视图端口的大小。\n例如em在 font-size 中的基准是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width。如果样式应用在某个标签上，这个标签中存在其他标签，那么这个样式会嵌套应用，逐级变大。\nrem单位的意思是以根元素的字体大小为基准。每一个连续的嵌套层都不会不断变大。\n百分比百分比是总相对于其他值设置的。\n在font-size中使用百分比，会让嵌套标签内容从父级继承并嵌套应用，逐级变小。\n数字不添加任何单位的数字。例如不透明度属性(opacity)，取值控制在0～1。\n位置position数据类型表示一组2D坐标，用于定位一个元素。\n字符串和标志符标志符就是被用作值的关键字。表示一个CSS可以理解的特殊值，不需要被引号扩起来，因为它们不被当作字符串。\n字符串一般在指定生成内容时使用content:&quot;&quot;。\n函数函数也易属性值的形式存在于CSS中，在颜色部分用到的rgb()/hsl()/url()/calc()都是函数。 \n颜色颜色取值\n十六进制RGB对应红色、绿色和蓝色。\nRGB和RGBA都是函数，接受0～255之间的十进制数字。A代表透明度。\n\n区别opacity和RGBA中的A的区别：使用不透明度会让元素和他里面的所有东西都不透明，但是RGBA只会让指定的颜色不透明。\n\nHSL和HSLA都是函数，接受色调、饱和度、亮度值作为参数。\n色调是颜色的底色，参考色轮0～360。\n饱和度范围为0～100%，0代表无颜色显示为灰色阴影，100%代表全色饱和度。\n亮度范围为0～100%，0代表没有光，显示全黑色，100%代表完全亮，显示为白色。\n图像和视频图像和视频被描述为替换元素(replaced element)。这些元素是一种外部对象，他们的内容不受当前文档的样式的影响。CSS只能影响可替换元素的位置，但不能影响它自身的内容。\n调整图像大小&amp;溢出问题max-width将max-width设置为100%，使图片尺寸上小于但不大于盒子。\nobject-fit目的是使替换元素以多种方式被调整到合乎盒子的大小。\n\ncover维持比例地缩小图像，可部分填充盒子，一部分会被剪裁。\ncontain维持比例缩放图像，必须整个填充盒子，会产生空白。\nfill不维持比例缩放图像，完全填充盒子。\n\n\n需要注意布局中的替换元素会有默认的不同的行为。例如在flex或grid布局中，其他元素会默认拉伸充满整个区域，但图像不会被拉伸，只会被对齐到网格区域或弹性容器起始处。\n\n表单样式化表单的预处理在一些浏览器中表单元素默认不会继承字体样式，为了确保表单填入区域中使用body或者父亲元素中定义的字体，需要添加规则font-family:inherit/font-size:100%。\n样式化表单时采用box-sizing属性中的border-box，且将所有元素的内外边距设置为0，在单独进行样式化控制式加回来。\n在textarea上设置overflow:auto可以避免IE在不需要滚动条的时候显示滚动条。\n button, input, select, textarea &#123;   font-family: inherit;   font-size: 100%;   box-sizing: border-box;   padding: 0; margin: 0; &#125; textarea &#123;   overflow: auto; &#125;\n\n现在有许多通用样式表确保你在开始自己的CSS作业之前跨浏览器的任何事情都会被设定成统一的样式。以上的操作也是一个简单的通用样式的设计。\n\nTIPS通过 table-layout: fixed，您可以根据列标题的宽度来规定列的宽度，然后适当地处理它们的内容。结合一个100%的width组合在一起，这意味着该表将填充它放入的任何容器，并且能很好的响应。\n使用 border-collapse: collapse; ，让表元素边框合为一条。\n在th和td元素上设置了一些padding使数据项有了一些空间，使表看起来更加清晰。设置letter-spacing，有助于提高可读性。text-align对其文本内容。\n文本样式化文本内容需要从字体样式和文本布局风格两方面考虑。\n\n网络字体使用\n// 由于字体要预先下载，把该文件放在CSS文件的最上面最初导入@font-face &#123;    font-family: &#x27;XXXX&#x27;;    // 之后在font-family属性中要用到该值    src: url(&#x27;fonts/....woff2&#x27;) format(&#x27;woff2&#x27;);    // 建议倒入多种格式以支持不同浏览器。&#125;\n\n字体样式\ncolor\nfont-family(using font stack)\nfont-size(px/em/rem)当调整你的文本大小时，预处理将文档(document)的基础 font-size 设置为10px，所需要的 (r)em 值就是想得到的像素的值除以 10，而不是 16。建议在样式表的指定区域列出所有font-size的规则集，这样它们就可以很容易被找到。\nfont-style斜体/font-weight粗体/text-tansform大小写/text-decoration上中下划线多取值\ntext-shadow可有多个阴影值，一个阴影值有四个值。\n\n文本布局风格\ntext-align\nline-height通常1.5～2\nletter-spacing/word-spacing\n\n列表列表间距考虑列表在文档上下文中的一致性，通过设定每个段落和列表之间的上下间距line-height和字体大小font-size。\n考虑列表内部的形式一致性，通过设定列表项的行高。\n列表项目符号list-style-type/position/image分别用于\n\n设置列表项目符号的类型(none)\n\n列表项目符号的位置是在列表项内还是列表项外inside/outside\n\n允许自定义图片为项目符号，图像的设置参考background-image，结合type为none。\n\n\n有序列表的编号控制\n\n从ol设定可以设定start=&quot;x&quot; reversed\n从li设定可以设定value=&quot;?&quot;\n\n链接链接状态:link\n:vistied\n:hover\n:focus\n:active\n对于链接样式的设置要从上面五个状态分别设置规则集进行考虑。\n链接 — 按钮通常使链接被样式化之后看起来效果和按钮差不多。例如网站菜单栏，标记为一个列表，列表中包含链接。\n","categories":["css"],"tags":["css"]},{"title":"HTML基础知识","url":"/2020/10/19/html-revision/","content":"头部元素&lt;head&gt;标签中包括了哪些内容？\n&lt;title&gt;\n与h1的区别在于&lt;title&gt;是为整个HTML文档添加标题，会在添加书签的时候建议用做书签名。h1主要是为&lt;body&gt;添加标题的。\n\n&lt;meta&gt;元数据就是描述数据的数据。\ncharset属性规定了文档中的字符编码。\nname指定了meta元素类型，可以去取author description 等值； content属性指定了实际的元数据内容。\n&lt;link&gt;rel href属性，用于添加页面自定义图标或样式表\nscript专门用于在HTML页面中应用JavaScript。\n文字处理\np段落\nh1标题\n有序列表&lt;ol&gt;/无序列表 &lt;ul&gt;/ 列表元素&lt;li&gt; /嵌套列表/描述列表(description list)&lt;dl&gt; — 描述术语 &lt;dt&gt; — 描述列表的描述部分 &lt;dd&gt; 会产生缩进。\n&lt;em&gt;表示强调/&lt;strong&gt;表示非常重要/可以被嵌套在其他标签中\n&lt;b&gt; &lt;i&gt; &lt;u&gt;仅仅影响表现且没有语义，是表象元素(presentational element)。\n\n二者区别在于语义。&lt;em&gt; &lt;strong&gt;会表现出斜体/加粗是因为这是浏览器默认行为，是可以被更改的，用这个标签不是为了获得斜体风格。&lt;b&gt; &lt;i&gt; &lt;u&gt;就是纯粹为了表现出特定的风格。\n\n引用 块引用&lt;blockquote cite=&quot;&quot;&gt;&lt;/blockquote&gt; — 行内引用&lt;q cite=&quot;&quot;&gt;&lt;/q&gt;。注意cite属性不会被显示，如果需要显示该引用来源，直接用&lt;cite&gt;标签包裹住内容，并在外层嵌套一个&lt;a href&gt;超链接。\n&lt;address&gt;标记联系方式。\n&lt;sup&gt; &lt;sub&gt;标记上下标。\n&lt;time datetime=&quot;&quot;&gt;&lt;/time&gt;提供机器可识别的时间和日期。\n\n布局元素有语义\n&lt;main&gt;一个页面上用一次，直接位于&lt;body&gt;中。\n&lt;article&gt; 存放与页面其他布局元素无关的文章。\n&lt;section&gt; 适用于组织页面使其按功能分块。\n&lt;aside&gt;侧边栏，补充信息。\n&lt;header&gt; 作body的子元素就是网站的全局页眉；如果是&lt;article&gt;或者&lt;section&gt;的子元素就是这部分特有的页眉。注意和&lt;head&gt;标题区分。\n&lt;nav&gt;页面主导航功能。\n&lt;footer&gt;包含了页面的页脚。\n\n无语义应用场景\n之前有语义的元素无法对应\n只想将一组元素作为一个单独的实体来修饰响应单一的CSS和JavaScript。\n\n分类内联无语义元素&lt;span&gt;\n块级无语义元素&lt;div&gt;\n多媒体元素有时被称为替换元素，因为这个元素的内容和尺寸由外部资源所定义，而不是元素自身。\n元素自身属于空元素，没有闭合标签，标签内容为空。\nimg\nsrc 想要引入的图片的绝对路径或相对路径\nalt 备选文本，值是对该图片的文字描述\nwidth height 设置图片大小\ntitle鼠标悬停在图片上会有提示信息\n\n&lt;figure&gt; &lt;figcaption&gt;为图片提供一个语义容器，在\nHTML图片是具有语义的，而用CSS构建的图片只是为了起装饰作用。\nvideo/audio\nsrc\ncontrols没有取值，是一个布尔变量，使其包含浏览器提供的控制界面。也可以使用JS API自定义控件界面。\nvideo标签的内容是后备内容，当浏览器不支持&lt;video&gt;标签时就会显示这段内容。\n在video标签内容中提供多个&lt;source&gt;播放源以提高兼容性。\n\n媒体文件的内容有多种形式，类似于MP3、MP4、WebM这些属于叫做容器格式，它们定义了生成媒体文件的音频轨道/视频轨道/文本轨道的储存结构，一些描述性的元数据，和编码译码器。\n因为浏览器支持的coder-decoder有所不同，为了兼容不同的浏览器，需要利用&lt;source&gt;标签提供不同格式的源文件。\n\nautoplay 自动播放，不建议。\nloop 循环播放，不建议。\nmuted播放时默认关闭声音。\nposter视频封面。\npreload缓冲较大文件。\n&lt;track&gt;标签的src属性是.vtt文件，kind属性可以取值subtitles/captions/descriptions，srclang属性高速浏览器你编写文件的语言。\n\niframe能够将其他Web文档嵌入到当前文档中，适用于将第三方内容嵌入网站，存在安全隐患。\n\nallowfullscreen 布尔变量。\n\nframeborder=&quot;&quot;\n\nsrc=&quot;&quot;\n\nwidth=&quot;&quot; height=&quot;&quot;\n\nsandbox 布尔变量，建议始终使用sandbox属性。\n沙盒定义：一个允许包含在其里的代码以适当的方式执行或者用于测试，但不能对其他代码库（意外或恶意）造成任何损害的容器。\n\n\nobject和embed嵌入各种形式的插件。\nsvg图片类型位图用像素网格定义，精确包含每个像素的位置和它的色彩信息。有.bitmap .png .jpg .gif。\n矢量图用算法定义，包含图形和路径的定义，电脑根据定义计算出该如何呈现。有SVG格式。\nSVGSVG是描述矢量图像的XML语言，用于标记图形。\n将矢量图添加到HTML利用&lt;img&gt;\n直接复制SVG代码，并内联到HTML文件中\n使用&lt;iframe&gt;\n响应式图片一种可以在不同的屏幕尺寸和分辨率设备上良好工作的图片。涉及到美术设计问题和分辨率切换问题。\n分辨率切换可以通过&lt;img&gt;元素的srcset和sizes两个属性来实现。\n美术设计可以通过&lt;pictures&gt;元素来实现。\n&lt;img&gt;适用于不同图片尺寸的方案srcset+sizessrcset定义允许选择的图像集，双引号内用逗号分隔。每一个可选项包括：文件名+空格+以w为单位的图像的固有宽度。\nsizes定义一组媒体条件，双引号内用逗号分隔。每一个可选媒体条件包括：带括号的媒体条件（不要忘了冒号）+空格+媒体条件为真时图像将填充的槽的宽度。最后一个逗号后面只有槽的宽度，是默认匹配。\n浏览器行为：查看设备宽度 — 查询sizes匹配合适的媒体条件 — 找到对应的媒体条件的槽的大小 — 依据已知槽的大小去选择最接近该槽大小的srcset列表中的图像。\n适用于相同图片尺寸不同分辨率的方案srcset+x语法srcset定义允许选择的图像集，可选项包括：文件名+空格+以x为单位的数据。\n浏览器行为：计算出当前显示器的分辨率 — 从 srcset中找出最合适的引用图片。\n&lt;picture&gt;为不同的布局提供不同裁剪的图片，不同的图片突出的细节不同。\n可以在&lt;picture&gt;标签中包含&lt;source&gt;标签以及必须有的带有src和alt属性的&lt;img&gt;标签。\nmedia该属性取值为一个媒体条件，注意媒体条件的写法。\nsrcset包含显示图片的路径。\n为什么需要在HTML中实现响应式图片浏览器最先加载的就是HTML文件中的内容，主解析器开始加载CSS和JavaScript之后。HTML中的响应式图片主要是为了应对不同设备对该网页的可访问性，我们不可能在页面上只放一张照片，等页面加载出来在用JavaScript去替换成合适的照片。\n表单HTML表单主要用于收集数据并将这些数据发送到服务器，需要有一个Web服务器来接收和处理数据。\n&lt;form&gt;定义了表单和确定表单属性的行为。是创建一切HTML表单的开始。\naction定义了提交表单的时候，这里收集到的键/值形式的数据送往那个URL，可以是一个PHP文件。\nmethod定义发送数据的HTTP方法时get还是post，无论使用哪一种方法，服务器接收到的都是一个字符串。\nenctype默认情况下该属性值为application/x-www-form-urlencoded，意思是已编码为URL参数的表单数据。\n如果要发送文件，需要将值设置为multipart/form-data。同时包含file picker小部件。\n&lt;fieldset&gt;用于创建具有相同目的的小部件组的方式，相当于功能相同一起打包，方便后续一起添加样式或者语义。\n在其开口标签之后添加&lt;legend&gt;&lt;/legend&gt;来描述这个小部件组的用途。\n具体应用\n包裹着一组单选按钮。\n对长表单进行分段，使之可以放在不同的页面上，提高可用性。\n\n小部件一般使用&lt;div&gt; &lt;fieldset&gt; &lt;section&gt; h标题 &lt;p&gt;标签同时包装标签和对应的的小部件，可以构造更复杂的表单。例如section&gt;h2+p的组合。\n通用属性autofocus布尔属性，加载时自动聚焦\ndisabled布尔属性，表示用户不能与元素交互。继承。\nname元素名称，和数据一起提交。\nvalue元素初始值。\n&lt;label&gt;&lt;label&gt;的for属性值和&lt;input&gt;的id属性值相匹配。\n&lt;label&gt;的内容就是该输入框的名字。\n完成绑定之后，可以将该输入框名字和该输入框相匹配，点击该输入框名字可以激活后面的输入框。\n&lt;input&gt;通用规范包括readonly disabled(输入值永远不会和表单数据的其余部分一起发送) size(框的物理尺寸) maxlength(可输入的最大字符数目) placeholder(文本库中出现的文本，用来粗略描述输入框目的)\ntype&lt;type&gt;是&lt;input&gt;最重要的属性，定义了接收数据的格式。注意&lt;input&gt;是一个空标签。\n\ntext是&lt;type&gt;的默认值和备用值，用于创建单行文本框。\n\npassword属性值用于创建密码框。\n\nemail属性值用于创建邮件地址框。\n\nsearch属性值用于创建搜索框，样式上会呈现出圆角以及‘x’清除。\n\ntel属性值用于创建电话号码栏。\n\n可选中项的创建基于： checked布尔属性+type=???取值\n发送数据时的行为与其他表单小部件不同。表单发送时，只有在选中该选项时，才会提交选中的value和name，不选择是不发送的。\n\ntype=&quot;checkbox&quot;属性值用于复选框\ntype=&quot;radio&quot;属性值用于创建单选按钮\n\n\n\nvalue因为input是空标签，所以定义它的的初始值要用value属性来实现。\nidid属性是为了和&lt;label&gt;的for属性值匹配。\nname用于告诉浏览器这个数据的名称是什么，从而通过HTTP报文发送过去后服务器端可以按照名称收集并处理数据块。\nlist该属性值和&lt;datalist&gt;元素的id值相同，绑定之后提供提供数据列表(datalist&gt;option*n)。\n&lt;textarea&gt;多行文本框，允许用户包含硬换行符(按回车)。\n有开始标签和结束标签，和&lt;input&gt;区别在于文本默认值的设定。\n&lt;select&gt;用于创建单选框下拉窗口，其中有一个或多个&lt;option&gt;元素作为子元素。\n多选选择框的创建就是将multiple属性添加到&lt;select&gt;中，直接显示的不是下拉窗口而是所有列表。\n&lt;option&gt;&lt;option&gt;元素还可以作为子元素嵌套在&lt;optgroup&gt;中。&lt;option&gt;的&lt;value&gt;规定了表单提交时应该发送的数据。\n&lt;button&gt;按钮，  type属性有三种取值。这三个取值也可以在&lt;input&gt;的type属性中设置，技术上同样可以实现按钮。\n\nsubmit取值会将表单数据发送到&lt;form&gt;里action属性定义的网页中。\n\nreset重置为默认值。\n\nbutton不会发生任何事，可以用JavaScript构建定制按钮。\n\n\n表单样式字体和文本为了让表单的字体外观和其他内容保持一致使用\nbutton, input, select, textarea &#123;  font-family : inherit;  font-size   : 100%;&#125;\n盒子模型每个小部件都有自己的边框，填充和边距的规则，如果统一所有小部件的风格，需要使用到box-sizing属性。\n\nThis is because each widget has their own rules for border, padding and margin. To give the same size to several different widgets, you can use the box-sizing property along with some consistent values for other properties\n\ninput, textarea, select, button &#123;  width : 150px;  margin: 0;  -webkit-box-sizing: border-box; /* For legacy WebKit based browsers */     -moz-box-sizing: border-box; /* For legacy (Firefox &lt;29) Gecko based browsers */          box-sizing: border-box;&#125;\n定位&lt;legend&gt;元素最容易定位，总是存在于父元素fieldset的内部，默认是在上边框的最顶端。如果想要把它放在fieldset的内部其他地方，需要先对fieldset定位，在对legend定位。\n&lt;textarea&gt;元素被浏览器默认为display: inline-block，与文本底线对齐。\n“ugly” elements\nIncluding drop-down boxes, complex control types like color and datetime-local, and feedback—oriented controls like  &lt;progress&gt; &lt;meter&gt;.\nThe problem is that these elements have very different default looks across browsers, and while you can style them in some ways, some parts of their internals are literally impossible to style.\n\nappearance: controlling OS-level styling浏览器内核引擎大致有Gecko(Firefox)、Webkit(Safari/Chrome)，每个引擎默认的网页排版都不一样，所以需要加前缀指定特定浏览器内核下的样式。\n为了使浏览器特有的样式失效，可以使用appearance和带前缀的appearance(是非标准属性)，使其值为none。\nselect, option &#123;  -webkit-appearance : none; /* To gain control over the appearance on WebKit/Chromium */  -moz-appearance : none; /* To gain control over the appearance on Gecko */  /* To gain control over the appearance on and Trident (IE)     Note that it also works on Gecko and has partial effects on WebKit */    background : none;&#125;\nrequired元素属性+伪类:optinal :required属于简单的客户端表单验证\n其他表单部件基于input元素，type属性取值+其他辅助属性。\n\n数字 number + min + max + step\n滑块 range + min + max + step\n本地时间 datetime-local + min + max\n月 month + min + max\n时间 time + min + max\n星期 week + min + max\n拾色器 color\n文件接收 file + accept(约束文件类型的属性) + multiple(允许接收多个文件的属性)\n不可见隐藏内容 hidden + name +value\n图像按钮 image (提交表单时提交的数据是相对于图像的XY坐标，形式为name.x/name.y，常用于构建热图)\n\n进度条，基于progress元素。\n仪表，基于meter元素。\n使用JavaScript发送表单HTML表单只负责收集用户输入，当用户尝试发送数据时，应用程序在后台采取控制并异步地传输数据，只更新UI中需要更改的部分。\n异步地发送任何数据被称为AJAX(Asynchronous JavaScript and XML)。\nAJAX就是在不刷新当前页面的情况下，使用XMLHttpRequest(XHR) DOM对象和服务器进行通信（发送HTTP请求，接收服务器数据），可以使用的数据格式有JSON、XML、HTML和text文本。\n构建XMLHttpRequest发送表单数据基本步骤\n新建一个XMLHttpRequest对象\n\n告诉XMLhttp请求对象的onreadystatechange属性命名为请求状态改变时调用的函数，这里只是一个引用赋值，并不是调用，此函数需要提前声明。或者直接使用匿名函数响应处理的操作。\n\n声明接到响应后要做什么。发送一个实际的请求，通过调用HTTP请求对象的open()和send()方法。\n\n\nhttpRequest.open(&#x27;GET/POST/HEAD&#x27;, URL, true-by-default-for-synchroneous);httpRequest.send(what-you-want-to-send-to-the-server);\n\n回调函数处理服务器响应的步骤：检查请求状态，即服务器是否收到了请求并且没有问题httpRequest.readyState === XMLHttpRequest.DONE；其次判断响应码范围if(request.status &gt;= 200 &amp;&amp; request.status &lt; 400)；利用httpRequest.responseText/responseXML获取返回数据。\n\n细节\n对空格的处理\n\n// Combine the pairs into a single string and replace all %-encoded spaces to // the &#x27;+&#x27; character; matches the behaviour of browser form submissions.urlEncodedData = urlEncodedDataPairs.join( &#x27;&amp;&#x27; ).replace( /%20/g, &#x27;+&#x27; );\n\n服务器请求状态readyState与响应状态status作区分\n对于POST方法需要设定HTTP header\n\n// Add the required HTTP header for form data POST requests  XHR.setRequestHeader( &#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27; );\nXMLHttpRequest+FormData引入新的FormData对象，只可写(write only)can change them but not retrive their contents。\n\n新建空的FormData对象const FD = new FormData()，后续利用appen()更新。\n将FormData对象与HTML表单form元素绑定const FD = new FormData(form) \n\n二进制数据处理哪里获得二进制数据？FileReader API、Canvas API、 WebRTC API。\n直接利用formData的append()方法。\n如果出现多种类型的表单数据，需要手动构建。需要定义一个分隔符来定义请求的每一个部分，该分隔符前面有其他符号，分隔符后面有换行。每一个类型的数据再放入data字符串时要有metada+data两个部分。\n","categories":["HTML"],"tags":["HTML"]},{"title":"Redux异步数据流与性能优化","url":"/2020/12/08/redux-async-data-flow/","content":"异步逻辑Redux store本身是不能处理异步逻辑的。为了使异步逻辑与Redux store产生交互，引入Redux middleware。\nThe most common reason to use middleware is to allow different kinds of async logic to interact with the store.\n最常用的异步逻辑中间件就是redux-thunk。\n使用thunk前的准备为了使用thunk，首先要让redux store支持thunk middleware。由于Redux Toolkit的configureStore API自动配置好了thunk middleware，所以将thunk作为用redux书写异步逻辑的标准形式。\n\nthunk的特质以及手写thunk能够在store中调用thunkOnce the thunk middleware has been added to the Redux store, it allows you to pass thunk functions directly to store.dispatch.\n能够dispatch plain action creatorsA thunk function will always be called with (dispatch, getState) as its arguments, and you can use them inside the thunk as needed.\n手写thunk action&#x2F;&#x2F; my-app&#x2F;src&#x2F;app&#x2F;store.jsconst store &#x3D; configureStore(&#123; reducer: counterReducer &#125;)const exampleThunkFunction &#x3D; (dispatch, getState) &#x3D;&gt; &#123;  const stateBefore &#x3D; getState()  &#x2F;&#x2F; 能够和其他reducer一样读取store中的状态&#x2F;数据  console.log(&#96;Counter before: $&#123;stateBefore.counter&#125;&#96;)  dispatch(increment())  &#x2F;&#x2F; dispatch的是一个action creator  const stateAfter &#x3D; getState()  console.log(&#96;Counter after: $&#123;stateAfter.counter&#125;&#96;)&#125;store.dispatch(exampleThunkFunction)\n手写thunk action creators类比普通的action和action creators，把箭头函数的部分放到return语句中去，并且将参数传入整体creators。这样的一个好处就是可以给thunk action中要dispatch的action传入参数。\nconst logAndAdd &#x3D; amount &#x3D;&gt; &#123;  return (dispatch, getState) &#x3D;&gt; &#123;    const stateBefore &#x3D; getState()    console.log(&#96;Counter before: $&#123;stateBefore.counter&#125;&#96;)    dispatch(incrementByAmount(amount))    const stateAfter &#x3D; getState()    console.log(&#96;Counter after: $&#123;stateAfter.counter&#125;&#96;)  &#125;&#125;store.dispatch(logAndAdd(5))\n但在实际写代码的过程中，会把thunk action/thunk action creators放在slice文件中，而我们在书写slice时使用的createSlice本身是不支持定义thunks的，因此他们作为独立的函数和createSlice一同存在于slice文件中。\n使用thunk对server API进行AJAX callsrequest的阶段与手写thunk以下三个步骤不是必须的，但都是commonly used。\n\na “start” action is dispatched before the requst, to indicate that the request is in progress.常用于追踪loading状态，然后让UI同时显示在加载中。\nThe async request is made\nDepending on the request result, the async logic dispatches either a “success” action containing the result data, or a “failure” action containing error details. \n\n\n这三个步骤即相当于三个action，我们如果手写thunk就需要先定义好这三个步骤的type和error，最后用一个含有异步逻辑async/await的函数，以及try catch语句把这些步骤拼接起来。\nconst getRepoDetailsStarted &#x3D; () &#x3D;&gt; (&#123;  type: &#39;repoDetails&#x2F;fetchStarted&#39;&#125;)const getRepoDetailsSuccess &#x3D; repoDetails &#x3D;&gt; (&#123;  type: &#39;repoDetails&#x2F;fetchSucceeded&#39;,  payload: repoDetails&#125;)const getRepoDetailsFailed &#x3D; error &#x3D;&gt; (&#123;  type: &#39;repoDetails&#x2F;fetchFailed&#39;,  error&#125;)const fetchIssuesCount &#x3D; (org, repo) &#x3D;&gt; async dispatch &#x3D;&gt; &#123;  dispatch(getRepoDetailsStarted())  try &#123;    const repoDetails &#x3D; await getRepoDetails(org, repo)    dispatch(getRepoDetailsSuccess(repoDetails))  &#125; catch (err) &#123;    dispatch(getRepoDetailsFailed(err.toString()))  &#125;&#125;\n为什么不用Promise.then?而是使用async/await关键字呢？因为阶段的最后我们需要捕捉错误信息，也就是使用try/catch模块，而它不能Promise.then一起使用。\n\n使用createAsyncThunk定义thunk手写fetching data的问题在于每个action都要定义，或者说为每个action都定义action creators很麻烦。所以createAsyncThunk API抽象出了这三个步骤，最终产生了一个能够自动处理这三个步骤的thunk。\ncreateAsyncThunk接受两个参数：\n\nA string that will be used as the prefix for the generated action types\n本质上thunk function也是action creator，只不过是异步的。\n\nA “payload creator” callback function that should return a Promise containing some data, or a rejected Promise with an error\n这部分承担了发出AJAX请求的工作，返回的是Promise from the AJAX call，或者是some data from the API response。\n一般使用JS async/await关键字，而不是一般的somePromise.then()语法，为了能够结合try/catch逻辑一起使用。\n\n\n使用createAsyncThunk API创建thunk function的实例。在使用createAsyncThunk创建hunk function之后，该函数会返回pending/fulfilled/rejected三种action creators（对应到上一个章节就是request的三个阶段），这个在后续与createSlice中extraReducer的互动中会使用到。\nexport const fetchPosts &#x3D; createAsyncThunk(&#39;posts&#x2F;fetchPosts&#39;, async () &#x3D;&gt; &#123;  const response &#x3D; await client.get(&#39;&#x2F;fakeApi&#x2F;posts&#39;)  return response.posts&#125;)\n\ntracking request states总共有四个可能的请求状态。\nWhen we make an API call, we can view its progress as a small state machine that can be in one of four possible states:\n\nThe request hasn’t started yet\nThe request is in progress\nThe request succeeded, and we now have the data we need\nThe request failed, and there’s probably an error message\n\n&#123;  status: &#39;idle&#39; | &#39;loading&#39; | &#39;succeeded&#39; | &#39;failed&#39;,  &#x2F;&#x2F; 名称都是可以自己定义的，例如pending&#x3D;loading&#x2F;complete&#x3D;succeeded。  error: string | null&#125;\n使用createAsyncThunk自动产生的三个action creators来显示request的状态。\ncreateAsyncThunk accepts a “payload creator” callback that should return a Promise, and generates pending/fulfilled/rejected action types automatically。\n上面这段话的意思应该是虽然createAsyncThunk会自动产生action type，但是这个action的具体内容，他的行为是需要我们去定义的。当AJAX calls在pending的状态时，我们希望在什么数据区域做出什么样的动作。这个数据区域可能就是某个feature中，也有可能是全局redux store中，更有可能是在UI component中。\nWhy tracking一方面，这些状态信息信息可以背被UI使用，比如在loading的时候可以UI显示转圈圈；另一方面，这些meta data可以是我们的fetch data行为只进行一次，而不是在每一次该UI重新渲染的时候都rerender一下。\n但是问题是request状态信息pending/fulfilled/rejected都是由thunk本身的promise对象保存着的。而这个信息要从slice流通到UI去，需要另外考虑。\nHow trackingThunk=&gt;extraReducers=&gt;initialState=&gt;store=&gt;UI componentcreateAsyncThunk写在slice文件中，同时slice文件中的initialState也需要有一个key status来指示数据从第三方API获得数据进展到了哪一步，这样的话我们就能决定UI在request进行的过程中该如何显示。\n为了追踪dispatch AJAX calls的状态，也就是track AJAX calls states，一个好的模式就是在该slice的数据结构中有一个state section。也就是tracking request states in slices。\nWe could track the request status in slice file using a second loading enum if we wanted to.\n定义部分：\n&#x2F;&#x2F; postsSlice中initialState的定义const initialState &#x3D; &#123;  posts: [],    &#x2F;&#x2F; 数据实体  status: &#39;idle&#39;,    &#x2F;&#x2F; 这里的status更像是一个窗口，连通了thunk function和UI component  error: null&#125;export const fetchPosts &#x3D; createAsyncThunk(&#39;posts&#x2F;fetchPosts&#39;, async () &#x3D;&gt; &#123;  const response &#x3D; await client.get(&#39;&#x2F;fakeApi&#x2F;posts&#39;)  return response.posts&#125;)const postsSlice &#x3D; createSlice(&#123;  name: &#39;posts&#39;,  initialState,  reducers: &#123;    &#x2F;&#x2F; omit existing reducers here  &#125;,  extraReducers: &#123;    &#x2F;&#x2F; 并不是所有的状态都需要考虑，忽略pending就是什么不都不做    [fetchPosts.pending]: (state, action) &#x3D;&gt; &#123;      state.status &#x3D; &#39;loading&#39;    &#125;,    [fetchPosts.fulfilled]: (state, action) &#x3D;&gt; &#123;      state.status &#x3D; &#39;succeeded&#39;      &#x2F;&#x2F; Add any fetched posts to the array      state.posts &#x3D; state.posts.concat(action.payload)    &#125;,    [fetchPosts.rejected]: (state, action) &#x3D;&gt; &#123;      state.status &#x3D; &#39;failed&#39;      state.error &#x3D; action.error.message    &#125;  &#125;&#125;)\n调用部分：\n&#x2F;&#x2F;postList.jsexport const PostsList &#x3D; () &#x3D;&gt; &#123;  const dispatch &#x3D; useDispatch()  const posts &#x3D; useSelector(selectAllPosts)  const postStatus &#x3D; useSelector(state &#x3D;&gt; state.posts.status)  useEffect(() &#x3D;&gt; &#123;    if (postStatus &#x3D;&#x3D;&#x3D; &#39;idle&#39;) &#123;      dispatch(fetchPosts())    &#125;  &#125;, [postStatus, dispatch])  &#x2F;&#x2F; omit rendering logic&#125;\nThunk=&gt;UI component=&gt;statusEnum=&gt;try/catch/disptach首先add a loading status enum field as a React useState hook，这个loading status enum就类似于之前slice中initialState对象中的status field。\n&#x2F;&#x2F; UI componentexport const AddPostForm &#x3D; () &#x3D;&gt; &#123;  &#x2F;&#x2F; other datas  const [addRequestStatus, setAddRequestStatus] &#x3D; useState(&#39;idle&#39;)\n在try模块中，先将enum的状态设置为pending，然后开始dispatch thunk function，由于createAsyncThunk在函数内部处理错误，所以我们不能获取rejected message，这不利于catch模块输出错误信息。\ncreateAsyncThunk handles any errors internally, so that we don’t see any messages about “rejected Promises” in our logs. \n为了解决错误信息的问题，Redux Toolkit拥有一个功能函数，名为unwrapResult，他让dispatch后的thunk action creator有两种表现：如果是fulfilled action就返回action.payload，如果是rejected action就报错，这样就能在try/catch模块中使用了。\n&#x2F;&#x2F; UI componentconst onSavePostClicked &#x3D; async () &#x3D;&gt; &#123;    if (canSave) &#123;      try &#123;        setAddRequestStatus(&#39;pending&#39;)                  const resultAction &#x3D; await dispatch(          addNewPost(&#123; title, content, user: userId &#125;)        )                unwrapResult(resultAction)                  setTitle(&#39;&#39;)        setContent(&#39;&#39;)        setUserId(&#39;&#39;)      &#125; catch (err) &#123;        console.error(&#39;Failed to save the post: &#39;, err)      &#125; finally &#123;        setAddRequestStatus(&#39;idle&#39;)      &#125;    &#125;  &#125;\n在UI中调用thunk首先从对应slice中import thunk至想要使用它的UI component。\nthunk也是属于action creator的一种，我们需要dispatch，因此需要添加useDispatch hook。\nexport const PostsList &#x3D; () &#x3D;&gt; &#123;  const dispatch &#x3D; useDispatch()  const posts &#x3D; useSelector(selectAllPosts)  const postStatus &#x3D; useSelector(state &#x3D;&gt; state.posts.status)  useEffect(() &#x3D;&gt; &#123;    if (postStatus &#x3D;&#x3D;&#x3D; &#39;idle&#39;) &#123;        &#x2F;&#x2F; 这样可以避免re-render的时候也重新fetch data      dispatch(fetchPosts())    &#125;  &#125;, [postStatus, dispatch])  &#x2F;&#x2F; omit rendering logic&#125;\ncreateSlice对非createSlice API定义action的响应There are times when a slice reducer needs to respond to other actions that weren’t defined as part of this slice’s reducers field. We can do that using the slice extraReducers field instead.\na slice reducer可能需要对thunk这个action creator产生的action或者createAction产生的action进行相应，为了实现这个目的在createSlice API中设立了一个extraReducers field。\n extraReducers allows createSlice to respond to other action types besides the types it has generated.  It’s particularly useful for working with actions produced by createAction and createAsyncThunk.\nextraReducers field的action type在extraReducers中定义的action createor产生的action不会被自动地添加到createSliceAPI的action field中去。extraReducers are meant to reference “external” actions, they will not have actions generated in slice.actions.\n方式一：引号内action typekeys in extraReducer Object就是redux action type strings，类似于&#39;counter/increment&#39;，因为key中含有斜杠/，所以要用单引号扩起来。\n方式二： 计算属性但是Redux Toolkit有一个性质就是如果调用actionCreator.toString()函数，他会自动返回action type。因此可以可以把action creator用ES6计算属性的方式传入extraReducer object field。\nimport &#123; increment &#125; from &#39;..&#x2F;features&#x2F;counter&#x2F;counterSlice&#39;const postsSlice &#x3D; createSlice(&#123;  name: &#39;posts&#39;,  initialState,  reducers: &#123;    &#x2F;&#x2F; slice-specific reducers here  &#125;,  extraReducers: &#123;&#x2F;&#x2F; 这个extraReducer本质也是一个object    [increment]: (state, action) &#x3D;&gt; &#123;      &#x2F;&#x2F; normal reducer logic to update the posts slice    &#125;  &#125;&#125;)\n方式三： builder callback将builder callback function传入extraReducers，而不是传入一个对象。builder callback function接受builder作为参数，对builder调用addCase就可以添加action creators。\nimport &#123; increment &#125; from &#39;..&#x2F;features&#x2F;counter&#x2F;counterSlice&#39;const postsSlice &#x3D; createSlice(&#123;  name: &#39;posts&#39;,  initialState,  reducers: &#123;    &#x2F;&#x2F; slice-specific reducers here  &#125;,  extraReducers: builder &#x3D;&gt; &#123;    builder.addCase(&#39;counter&#x2F;decrement&#39;, (state, action) &#x3D;&gt; &#123;&#125;)    builder.addCase(increment, (state, action) &#x3D;&gt; &#123;&#125;)  &#125;&#125;)\nextraReducers的action creator内容也就是(state, action) =&gt; {}箭头函数里面的内容，应当都是对createSlice中的数据域进行操作。描述外部的某个action creator引起的某个action对本slice内部的数据产生了什么影响。\n性能优化React DevTools中的Prolifier可以协助查看用户在某个行为前后UI渲染的情况。需要先录制，然后做出行为，然后结束录制。就可以看到在该动作发生前后React各个组件的渲染行为。\nextracting selectors from UI在书写代码的过程中，一开始总是建议现在UI中使用useSelector选取希望获得的数据。因为虽然extracting selectors可以在更新slice中数据形式的时候简便一点，但这也意味着更多需要去维护的代码。\n不是每一个UI都必须要写通用的selectors。Don’t feel like you need to write selectors for every single field of your state.\n这种抽象适合这个sleectors在多个UI中被多次重复使用。Try starting without any selectors, and add some later when you find yourself looking up the same values in many parts of your application code。\n问题描述我们一般认为在UI中访问redux store的数据就是要在UI中使用useSelector。这样处理的问题在于如果我们要从redux store中获取的那部分数据变化了，也就是说在slice中定义的数据形式变化了，相应地又要转到使用了该slice中的数据的多个UI中去进行变动。\n解决该问题的方式就是在slice文件中定义可以被export且可以被重复使用的selector functions。\nOne way to avoid this is to define reusable selector functions in the slice files, and have the components use those selectors to extract the data they need instead of repeating the selector logic in each component. That way, if we do change our state structure again, we only need to update the code in the slice file.\n定义方式如下&#x2F;&#x2F; src&#x2F;features&#x2F;posts&#x2F;postsSLice.jsexport const selectAllPosts &#x3D; state &#x3D;&gt; state.posts\n注意这里的state时redux store整体的state。 \nThe state parameter for these selector functions is the root Redux state object, as it was for the inlined anonymous selectors we wrote directly inside of useSelector.\n使用方式如下&#x2F;&#x2F; src&#x2F;features&#x2F;posts&#x2F;PostList.jsimport &#123; selectAllPosts &#125; from &#39;.&#x2F;postsSlice&#39;export const PostsList &#x3D; () &#x3D;&gt; &#123;  const posts &#x3D; useSelector(selectAllPosts)  &#x2F;&#x2F; omit component contents&#125;\ncreate “memoized” selectors问题描述useSelectors的特点就是只要app中一个行为发生了，他就会重新运行，只要他的return value是a new refernce value，那么它迫使组件重新渲染。\n&#x2F;&#x2F; UI component中const postsForUser &#x3D; useSelector(state &#x3D;&gt; &#123;    const allPosts &#x3D; selectAllPosts(state)    return allPosts.filter(post &#x3D;&gt; post.user &#x3D;&#x3D;&#x3D; userId)  &#125;)\n如果return value返回的对象总是无条件的是a new refernce value，比如filter函数，就算filter函数的内容都是一样的，reference都是不同，也就是说无论如何都会重新渲染一遍。\n我们希望useSelector函数每重新运行一次，都保存先后两次select出来的value，如果发生了变化，在渲染，如果没有变化，就还是不渲染。这种想法就是memoize。\nMemoizing Selector functionsReselect is a library for creating memoized selector functions, and was specifically designed to be used with Redux. It has a createSelector function that generates memoized selectors that will only recalculate results when the inputs change.\n想要使用createSelector，只需要先从Redux Toolkit中import它。\n&#x2F;&#x2F; slice中import &#123; createSlice, createAsyncThunk, createSelector &#125; from &#39;@reduxjs&#x2F;toolkit&#39;\ncreateSelector接受多个input selector function，以及一个output selector function作为参数。给createSelector传入的参数是input selector function的参数，而output selector function的参数是input selestor function的return value。如果传递给output selector function的value前后都没有变化，那么output selector function就不会re-run。\nWhen we call selectPostsByUser(state, userId), createSelector will pass all of the arguments into each of our input selectors. Whatever those input selectors return becomes the arguments for the output selector.\nexport const selectAllPosts &#x3D; state &#x3D;&gt; state.posts.postsexport const selectPostById &#x3D; (state, postId) &#x3D;&gt;  state.posts.posts.find(post &#x3D;&gt; post.id &#x3D;&#x3D;&#x3D; postId)export const selectPostsByUser &#x3D; createSelector(  [selectAllPosts, (state, userId) &#x3D;&gt; userId],  (posts, userId) &#x3D;&gt; posts.filter(post &#x3D;&gt; post.user &#x3D;&#x3D;&#x3D; userId))\n为什么要给input selector functions加括号呢？联系array destructing，这就相当于把input selector function运行并把返回值作为一组array，能够传递给下一个output selector function。\nSolving cascade re-render问题描述React的渲染行为是级联的，只有父亲组件重新渲染了，那么父亲组件内部的所以儿子组件都会重新渲染。\nReact’s default behavior is that when a parent component renders, React will recursively render all child components inside of it!. \nmemo()wrap the sub component in React.memo(), which will ensure that the component inside of it only re-renders if the props have actually changed. \nlet PostExcerpt &#x3D; (&#123; post &#125;) &#x3D;&gt; &#123;  &#x2F;&#x2F; omit logic&#125;PostExcerpt &#x3D; React.memo(PostExcerpt)\n条件渲染子组件如果要进行条件渲染，那么就要从store中获取更多的信息，储存前后信息，并比较。\n并且组件获取信息尽量不要基于内容本身获取信息，最好每一条信息都有一个识别符id。\n数据ID与Normalized Data之前一直都是手动维护一个ID field，用array.find来匹配希望获得的ID。其实这本质上就是一个lookup table，如果我们能通过id寻找到一条信息，而不是通过循环数组匹配来实现，那么这个过程就是normalization。能够实现这种模式的数据称为Normalized State Structure。\nNormalized State Structure具有以下特质的数据被称为normalized state structure。\n\nWe only have one copy of each particular piece of data in our state, so there’s no duplication\nData that has been normalized is kept in a lookup table, where the item IDs are the keys, and the items themselves are the values.\nThere may also be an array of all of the IDs for a particular item type\n\nJavaScript Objects就可以被表示称lookup table，一个object中有两个field，一个是ids，另一个是entities。ids的组成是一个数组，数组中的每一个值又是entities中的key，也就是数据id对应到数据实体。\nRedux Toolkit提供了一个操作normalized state structure的create EntityAdapter API，它将某个slice中的数据都按照&#123; ids: [], entities: &#123;&#125; &#125; 的形式存放。\nimport &#123;  createEntityAdapter  &#x2F;&#x2F; omit other imports&#125; from &#39;@reduxjs&#x2F;toolkit&#39;\nand will only update that array if items are added / removed or the sorting order changes.\ncreateEntityAdapter数据对象创建createEntityAdapter可以依据内容把ID array排序，它接收an option object that include a sortComparer function，通过比较两个entity的内容，把ID array中的id进行排序。\nconst postsAdapter &#x3D; createEntityAdapter(&#123;  sortComparer: (a, b) &#x3D;&gt; b.date.localeCompare(a.date)&#125;)\n数据对象初始化createEntityAdapter.getInitialState()，这个函数自动返回一个空的&#123; ids: [], entities: &#123;&#125; &#125; 对象。还可以通过给getInitialState传入更多的参数，来给让返回的对象有更多的fields。\nconst initialState &#x3D; postsAdapter.getInitialState(&#123;  status: &#39;idle&#39;,  error: null&#125;)\n数据对象选择createEntityAdapter.getSelector()，把一个用于从redux store中选择某个特定slice的selector function作为参数传入该函数后，该函数能够自动返回名称总为selectAll和selectById这样的selector function。\n由于自动生成的selectors function总是固定的两个名字，所以利用ES6 array destructing的语法来为selector function重新命名。\n\nThe generated selector functions are always called selectAll and selectById, so we can use ES6 destructuring syntax to rename them as we export them and match the old selector names. \n\n&#x2F;&#x2F; Export the customized selectors for this adapter using &#96;getSelectors&#96;export const &#123;  selectAll: selectAllPosts,  selectById: selectPostById,  selectIds: selectPostIds  &#x2F;&#x2F; Pass in a selector that returns the posts slice of state  &#x2F;&#x2F; Since the selectors are called with the root Redux state object, they need to know where to find our posts data in the Redux state, so we pass in a small selector that returns state.posts.&#125; &#x3D; postsAdapter.getSelectors(state &#x3D;&gt; state.posts)\n数据对象更新它返回一个包含了许多自动生成的reducer function的对象。这个对象中的reducer functions能够实现”add all these items”, “update one item”, or “remove multiple items”这一类的功能。\nextraReducers: &#123;    &#x2F;&#x2F; omit other reducers    [fetchPosts.fulfilled]: (state, action) &#x3D;&gt; &#123;      state.status &#x3D; &#39;succeeded&#39;      &#x2F;&#x2F; Add any fetched posts to the array      &#x2F;&#x2F; Use the &#96;upsertMany&#96; reducer as a mutating update utility      postsAdapter.upsertMany(state, action.payload)    &#125;,    &#x2F;&#x2F; Use the &#96;addOne&#96; reducer for the fulfilled case    [addNewPost.fulfilled]: postsAdapter.addOne  &#125;\n","categories":["React"],"tags":["React","redux","slice","store","thunk","normalized data"]},{"title":"redux数据流基础","url":"/2020/12/10/redux-fundamentals/","content":"action所有的Redux Action必须满足两个要求：第一，是一个朴素的JavaScript对象；第二，有type field。type field的值用于描述这个action，命名上要与该action的语义一致。\nAn action is a plain JavaScript object that has a type field. You can think of an action as an event that describes something that happened in the application.\nThe type field should be a string that gives this action a descriptive name. We usually write that type string like &quot;domain/eventName&quot;.\nAn action object can have other fields with additional information about what happened. By convention, we put that information in a field called payload.\naction规范化Flux standard actions conventions： FSA convention\n\naction对象的实体数据本身需要放在action.payload中。\naction对象必须拥有用于描述其他描述性信息的action.meta field。\naction对象必须拥有用于提供错误信息的action.error field。\n\n\n结合Redux action的两个必备条件：JS object以及type field，可以得出一个规范化的action对象必须用一以下三个fields：\n\na payload field\nan error field\na meta field\n\naction creatorsaction creators是一个抽象了具体action的形式的一个函数。它接收payload field的值作为参数，返回action对象；该action对象的type对于该action creators应该是一致的。\nAn action creator is a function that creates and returns an action object. We typically use these so we don’t have to write the action object by hand every time.\n调用action creator function后，将它返回的action object直接传递给dispatch函数。\nreducersreducer是一个更新数据/状态的函数，它接收当前状态和action对象作为参数，返回更新后的状态。\nA reducer is a function that receives the current state and an action object, decides how to update the state if necessary, and returns the new state: (state, action) =&gt; newState. \nReducers的调用逻辑You can think of a reducer as an event listener which handles events based on the received action (event) type.可以把reducer堪称一个监听状态变化的监听函数，action就相当于call backfunction/event handler。\n调用逻辑——The logic inside reducer functions typically follows the same series of steps:\n\nCheck to see if the reducer cares about this action\nIf so, make a copy of the state, update the copy with new values, and return it\n\n\nOtherwise, return the existing state unchanged\n\n类比useEffect Hook就相当于传入了第二个参数，有条件地针对某个state的变化去更新状态。\n\n手写Reducers返回对象newState如果手写newState就面临一个问题，改动的值可能就一两个，返回的却是整个对象，这个对象可能还有很多子对象nested object。为了遵循redux state要求的immutable updates，每一次的返回都要在update之前先copy一份obj，然后再改动，进入下一层子对象还要继续copy再update，十分麻烦。\n\nwirte immutable updates by hand, by using JavaScript’s array / object spread operators and other functions that return copies of the original values.\nThis becomes harder when the data is nested. A critical rule of immutable updates is that you must make a copy of every level of nesting that needs to be updated.\n\n\nReducers第一个参数的state初始值整个app初始化的时候一般是没有状态的，但是又不能给reducer提供undefined state，所以一般需要手动提供一个initialState value。\nA reducer may be called with undefined as the state value when the application is being initialized. If that happens, we need to provide an initial state value so the rest of the reducer code has something to work with. Reducers normally use ES6 default argument syntax to provide initial state: (state = initialState, action).\n\nReducers拆分如果把一个app中的所有reducer结合起来，就是一个由switch/case组成的函数，传入的参数是action type。但是本身一个app涉及的action type就很多，每个action的内容也很多，所以考虑拆分reducers。\nRedux reducers are typically split apart based on the section of the Redux state that they update. \n拆分准则We recommend organizing your Redux app folders and files based on “features” - code that relates to a specific concept or area of your application.\n建议基于app的features拆分reducers。\nThe Redux code for a particular feature is usually written as a single file, known as a “slice” file, which contains all the reducer logic and all of the action-related code for that part of your app state.\n每一个feature的action以及state的相关的内容都被写在slice file中。\n拆分的好处在基于feature拆分后，对action type的命名也可以写成’feature/actionName’。\n在基于feature拆分后，slice file中的action只需要应对feature-related state。也就意味着不再是nested object了。\n\nReducer组合因为redux store需要一个root reducer function，所以我们需要把slice文件中的各个feature的reducer组合起来。本质上reducer就是一个function，只需要把它们import到root reducer文件，重新写一个root reducer来调用slice中的reducer。\nimport todosReducer from &#39;.&#x2F;features&#x2F;todos&#x2F;todosSlice&#39;import filtersReducer from &#39;.&#x2F;features&#x2F;filters&#x2F;filtersSlice&#39;export default function rootReducer(state, action) &#123;  &#x2F;&#x2F; always return a new object for the root state  return &#123;    &#x2F;&#x2F; the value of &#96;state.todos&#96; is whatever the todos reducer returns    todos: todosReducer(state.todos, action),    &#x2F;&#x2F; For both reducers, we only pass in their slice of the state    filters: filtersReducer(state.filters, action)  &#125;&#125;\n可以看出来手写root reducer，每一次调用某一个reducer遵循的模式都是相通的。因此redux core library把这种pattern抽象了出来，写成一个新的utility function名为combineReducers，这样能让代码更简洁。\nimport &#123; combineReducers &#125; from &#39;redux&#39;import todosReducer from &#39;.&#x2F;features&#x2F;todos&#x2F;todosSlice&#39;import filtersReducer from &#39;.&#x2F;features&#x2F;filters&#x2F;filtersSlice&#39;const rootReducer &#x3D; combineReducers(&#123;  &#x2F;&#x2F; Define a top-level state field named &#96;todos&#96;, handled by &#96;todosReducer&#96;  todos: todosReducer,  filters: filtersReducer&#125;)export default rootReducer\ncombineReducers接受一个对象作为参数，对象的key是root state object的feature（也就是redux store的state.key对象），对象的value是该feature的slice reducers functions。\nstore用于管理整个app的当前状态。整个redux application只能有唯一一个store。\nThe current Redux application state lives in an object called the store .\nThe store is created by passing in a reducer, and has a method called getState that returns the current state value:\nimport &#123; configureStore &#125; from &#39;@reduxjs&#x2F;toolkit&#39;const store &#x3D; configureStore(&#123; reducer: counterReducer &#125;)console.log(store.getState())\nstore功能\n储存当前应用的所有state value以及所有的reducer function\n允许外部文件通过store.getState()访问当前状态\n允许通过store.dispatch(action)更新当前状态\n允许通过store.subscribe(listener)将listener callback绑定\n允许通过store.unsubscribe(listener)将listener callback的绑定解除\n\n这些功能能够组成createStore API的内部逻辑。The store API is an object with {dispatch, subscribe, getState} inside。\ngetState just returns whatever the current state value is. That means that by default, nothing prevents you from accidentally mutating the current state value! \nstore本身并不会在外部调用getState()的时候提前做一个原来state value的copy，store本身不能防止accidential mutatable updates。一种最常见的accidental mutations就是sorting arrays。\n创建store及三个参数rootReducer/initialState/enhancerRedux core library有一个createStore API用于创建store，只需要把从reducer中rootReducer给import进来就可以。\nimport &#123; createStore &#125; from &#39;redux&#39;import rootReducer from &#39;.&#x2F;reducer&#39;const store &#x3D; createStore(rootReducer)export default store\n除了接受rootReducer为第一个argument以外，createStore还接受一个装载了初始状态值的preloadedState value作为第二个参数。\n另外createStore还接受一个enhancer作为第三个参数（如果没有initialState就是第二个参数）。enhancer就相当于用enhancer的函数包裹住了原来的redux store，他可以override or replace原来store中的任何方法。\nA store enhancer is like a special version of createStore that adds another layer wrapping around the original Redux store.\n如果有多个enhancers存在该怎么办？可以用compose API把这些enhancers合并起来。\n\n从enhancer到middleware但是有时候我们只需要customize how dispatch behaves，我们希望在dispatch函数运行的时候有一些特殊的行为，那么就可以使用middleware。\nRedux uses a special kind of addon called middleware to let us customize the dispatch function.\nmiddleware在redux数据流中的位置Middleware form a pipeline around the store’s dispatch method. 当我们dispatch一个action时，实际上我们是在calling the first middleware in the pipeline。首先，middleware会检查这个action是不是它要去customize的action，如果不是他就传递给流水线中下一个middleware；如果是需要customize的action，那么他就运行一些custom logic。\nRedux middleware provides a third-party extension point between dispatching an action, and the moment it reaches the reducer. \n手写middlewareredux middleware手写的话就是三层嵌套的函数：outer的功能是someCustomMiddleware；middle功能是wrapDispatch；inner的功能是handleAction。\n使用ES5手写中间件&#x2F;&#x2F; Middleware written as ES5 functions&#x2F;&#x2F; Outer function:function exampleMiddleware(storeAPI) &#123;  return function wrapDispatch(next) &#123;    return function handleAction(action) &#123;      &#x2F;&#x2F; Do anything here: pass the action onwards with next(action),      &#x2F;&#x2F; or restart the pipeline with storeAPI.dispatch(action)      &#x2F;&#x2F; Can also use storeAPI.getState() here      return next(action)    &#125;  &#125;&#125;\n最外层的outer exampleMiddleware就是我们调用的middleware本身，它接受包含了store’s &#123;dispatch, getState&#125; functions的storeAPI对象作为参。called once。\n中间层的inner wrapDispatch接受一个名为next的function作为函数。这个next function本质上就是pipeline中的下一个middleware。如果该middleware已经是最后一个中间件了，那么next function就是original store.dispatch function。Calling next(action) passes the middleware to the next middleware in the pipeline. called once。\n最里层的inner handleAction接受当前action作为参数，called everytime an action is dispatched。\n\nmiddleware inner handleAction的逻辑如下：\nreturn内容可以是任何值。the return value from the first middleware in the pipeline is actually returned when you call store.dispatch()。\n通常会利用一个if判断去匹配某一个特定的action，然后do something when that action is dispatched。\nconst delayedMessageMiddleware &#x3D; storeAPI &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;  if (action.type &#x3D;&#x3D;&#x3D; &#39;todos&#x2F;todoAdded&#39;) &#123;    setTimeout(() &#x3D;&gt; &#123;      console.log(&#39;Added a new todo: &#39;, action.payload)    &#125;, 1000)  &#125;  return next(action)&#125;\n\n使用ES6的箭头函数重写middleware因为是implicit return所以比较难阅读：\nconst anotherExampleMiddleware &#x3D; storeAPI &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;  &#x2F;&#x2F; Do something in here, when each action is dispatched      return next(action)&#125;\n调用手写middleware需要用到applyMiddleware(middleWare)函数作为middlewareEnhancer再次传入createStore API去。\nconst middlewareEnhancer &#x3D; applyMiddleware(alwaysReturnHelloMiddleware)const store &#x3D; createStore(rootReducer, middlewareEnhancer)\n当一个action被dispatch的时候运行逻辑如下：\n\n最内层的handleAction会最先运行\n接着将action传递到next section，也就是另一个middleware或者real store dispatch。\n最后reducer会运行然后状态被更新，next 函数返回\n可以通过storeAPI.getState()获取当前状态\n\nasync function middleware手写async function middleware的两种方式以上涉及的middleware都是同步逻辑下的，能够让我们书写异步逻辑的middleware怎么书写？一种方式就是在middleware内部，用if条件语句匹配特定的action type，并且return async logic（比如在内部调用了定时器）。\nconst delayedActionMiddleware &#x3D; storeAPI &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;  if (action.type &#x3D;&#x3D;&#x3D; &#39;todos&#x2F;todoAdded&#39;) &#123;    setTimeout(() &#x3D;&gt; &#123;      &#x2F;&#x2F; Delay this action by one second      next(action)    &#125;, 1000)    return  &#125;  return next(action)&#125;\n但是这种写法过于specific且only do one thing（因为通过action type来识别异步逻辑）。因为我们传递给middleware的是用action type来识别的action object。\n更好的想法就是我们把异步逻辑从middleware的定义中剥离(write async logic ahead of time, without knowing what Redux store is being used)，但是middleware为异步逻辑代码块提供store的dispatch函数与getState方法的访问许可。\n\nIt would be nice if we had a way to write any async logic ahead of time, separate from the middleware itself, and still have access to dispatch and getState so that we can interact with the store.\n\nWe could have our middleware check to see if the “action” is actually a function instead, and if it’s a function, call the function right away. That would let us write async logic in separate functions, outside of the middleware definition.\n为middleware配备识别function的能力：let us pass a function to dispatch\nconst asyncFunctionMiddleware &#x3D; storeAPI &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;  &#x2F;&#x2F; If the &quot;action&quot; is actually a function instead...  if (typeof action &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;    &#x2F;&#x2F; then call the function and pass &#96;dispatch&#96; and &#96;getState&#96; as arguments    return action(storeAPI.dispatch, storeAPI.getState)  &#125;  &#x2F;&#x2F; Otherwise, it&#39;s a normal action - send it onwards  return next(action)&#125;\n在middleware外部定义异步逻辑并调用：\nconst middlewareEnhancer &#x3D; applyMiddleware(asyncFunctionMiddleware)const store &#x3D; createStore(rootReducer, middlewareEnhancer)&#x2F;&#x2F; Write a function that has &#96;dispatch&#96; and &#96;getState&#96; as argumentsconst fetchSomeData &#x3D; (dispatch, getState) &#x3D;&gt; &#123;  &#x2F;&#x2F; Make an async HTTP request  &#x2F;&#x2F; 使用dispatch和getState书写异步逻辑&#125;store.dispatch(fetchSomeData)\n使用redux-thunk middlewareThe thunk middleware allows us to write functions that get dispatch and getState as arguments.\n在使用redux-thunk middleware的时候可以简单分两种情况。\n第一种是从第三方API获取数据。直接export async function之后disptach该thunk function即可。\n第二种是将UI中的数据传到服务器。简单的async function只能接受dispatch和getState作为arguments，但是UI中的数据从何而来？需要先写一个接受UI数据作为参数的函数，然后创建使用该UI数据的thunk function。We need a way to write one function that accepts text as its parameter, but then creates the actual thunk function so that it can use the text value to make the API call. \n方法就是先在外层写一个同步逻辑把UI数据做为参数的函数，该函数返回的是一个异步逻辑的thunk function。\n&#x2F;&#x2F; Write a synchronous outer function that receives the &#96;text&#96; parameter:export function saveNewTodo(text) &#123;  &#x2F;&#x2F; And then creates and returns the async thunk function:  return async function saveNewTodoThunk(dispatch, getState) &#123;\n在UI中调用这个function要先传入UI数据，然后再dispatch。\ndispatchdispatch作为更新app当前状态store的唯一媒介，接受一个action obejct作为参数。由于action creator返回一个action object，所以可以把action creators传入dispatch函数。\nThe Redux store has a method called dispatch. The only way to update the state is to call store.dispatch() and pass in an action object. \nYou can think of dispatching actions as “triggering an event”.类比事件监听函数，这就像客户端有一个用户去点击了网页，触发了事件监听函数。\nselectors选择store中的特定状态\nSelectors are functions that know how to extract specific pieces of information from a store state value.\n一般作为参数传入useSelector中去。\nredux sync data flow\n\n首次渲染\n\n创建一个redux store。\nstore调用root reducer，将它返回的值作为initial state。\n当UI被渲染的时候，UI中的组件从redux store中读取当前状态，并渲染。\n\n\n重新渲染\n\n用户有一些行为，UI组件发现了这些行为的发生，这些行为用action对象来描述。\n通过给dispatch函数传递该行为action，获得的返回值就是current state，store将这更新后的值覆盖原值地保存起来。（immutable）\n\n\nIn order to update values immutably, your code must make copies of existing objects/arrays, and then modify the copies.\n\n\nstore会通知所有的UI组件状态值被更新了\n那些需要从store中获取状态的UI组件就检查store看自己需要的值是否被更新了，更新了的话就重新渲染自己的那个部分。\n\n\n\nUI and Redux最原始的基础的redux and UI integration必须经历一下几个步骤：\n\nCreate a Redux store\nSubscribe to updates(UI中的render)\nInside the subscription callback:(render函数的具体内容)\nGet the current store state\nExtract the data needed by this piece of UI\nUpdate the UI with the data\n\n\nIf necessary, render the UI with initial state(初始UI呈现通过调用render函数来实现)\nRespond to UI inputs by dispatching Redux actions\n\n有许多UI binding libraries协助use Redux with a given UI framework，他们承担subscribing to the store和update UI的工作。其中react-redux UI binding library就是redux core的一个独立包。\nConnectconnect函数的作用就是connects a React component to a Redux store。使用connect的好处就是：it encapsulates the logic of talking to the Redux store。\n从UI component的角度出发，该函数为UI提供了data needed from store，以及提供了functions it can use to dispatch actions to the store。\nfunction connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?)\nThe mapStateToProps and mapDispatchToProps deals with your Redux store’s state and dispatch, respectively.\nConnect: Extracting Data with mapSateToPropsmapStateToProps是传递给connect函数的第一个参数。它的作用是从整体store中把所需要的那部分数据传递给connected components，也就是让UI组件订阅保存全体数据的store。\n如果不希望该组件订阅全体store，可以直接给connect函数的第一个参数传入null或者undefined。\n\n该函数有以下特性：\n\n每次store发生变化该函数就会重新调用。\n\n如果整个app中有一个action被dispatched了，这就意味着store state有可能改变。那么mapStateToProps的UI component就会调用store.getState() 来检查是否 lastState === currentState，如果两次的state value是identical by reference，那么就不会重新调用 mapStateToProps function\n\n它就接受整个的store state作为参数，返回an object of data this component needs。\n\n\n定义mapStateToProps：\nfunction mapStateToProps(state, ownProps?)&#123; return &#123;    a: 42,    todos: state.todos&#125;&#125;\n参数说明：\nstate参数代表了整个app的redux store state。(the same value returned by a call to store.getState())。这是必须有的一个参数。\nownProps参数(optional)是一个可选参数，如果UI组件需要使用它自己的props去retrieve date from store的话就需要改参数。比如当前UI component中拥有名为id的props，该id可以作为key去查找store，所以要把该id作为ownProps传入mapStateToProps。\n返回内容：\nmapStateToProps函数返回一个plain object，这个对象中的每一个field都会成为该UI component的props。返回对象中的field的value决定了你的UI component是否需要重新渲染。比如上面的例子就说明该component会接受props.a/props.todos。\n\n为什么要使用mapStateToProps？\n这个函数拥有re-shaping store data as needed for that component的功能。它可以将整个UI component所需要的数据都集中到一个返回对象中。\n一般在mapStateToProps的函数体中会用到useSelector。useSelector用于在mapStateToProps函数内部实现选取数据，每一次useSelector选取的数据都是互相独立，如果单独使用useSelector，这个选取数据的过程会和UI component交织在一起。(useSelector help encapsulate the process of extracting values from specific locations in the state tree)\nConnect: Dispatching Actions with mapDispatchToPropsmapDispatchToProps是传递给connect函数的第二个参数。它的作用是dispatching action to the store。\n如果connect的第二个参数没有传入或者传入的是null，那么默认UI component会接受dispatch函数作为props.dispatch。在UI中调用时依然需要给dispatch函数传递action type。\n&#x2F;&#x2F; UI与store绑定默认dispatch的三种方式&#x2F;&#x2F; 1connect()(MyComponent)&#x2F;&#x2F; 2connect(null, null)(MyComponent)&#x2F;&#x2F; 3connect(mapStateToProps &#x2F;** no second argument *&#x2F;)(MyComponent)&#x2F;&#x2F;在UI描述中调用时需要传递action typefunction Counter(&#123; count, dispatch &#125;) &#123;  return (    &lt;div&gt;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;DECREMENT&#39; &#125;)&#125;&gt;-&lt;&#x2F;button&gt;          &lt;&#x2F;div&gt;  )&#125;\n\n关于dispatch函数\ndispatch is a function of the Redux store. You call store.dispatch to dispatch an action. This is the only way to trigger a state change.\n\n由于当前UI component并不能access the store directly，所以connect就实现了让UI component直接与redux store对接。同样的useDispatch hook也实现了相同的功能。\n\n定义mapDispatchToProps能帮我们省去写dispatch函数。if you define your own mapDispatchToProps, the connected component will no longer receive dispatch. \n\n定义mapDispatchToProps的两种方式：\nFunction form Allows more customization, gains access to dispatch and optionally ownProps\n传入参数说明：\n第一个必选参数是dispatch，一般会在mapDispatchToProps函数的返回对象中使用dispatch。给dispatch函数传入一个action object或者是action creator。\nconst mapDispatchToProps &#x3D; dispatch &#x3D;&gt; &#123;  return &#123;&#x2F;&#x2F; dispatching plain actions    increment: () &#x3D;&gt; dispatch(&#123; type: &#39;INCREMENT&#39; &#125;),  &#125;&#125;\n第二个参数是ownProps(optional)可选参数。在bind on component mount的基础之上，还能bind on props change。当传入的ownProps Change的时候也会dispatch action。\n返回对象说明：\n返回的应该是a plain object。这个object的每一个field都会被添加为该UI component的prop，也就在在原来UI compoennt的基础之上继续添补进去。（The return of the mapDispatchToProps function will be merged to your connected component as props.）同时the value should normally be a function that dispatches an action when called.\n&#x2F;&#x2F; way1 plain object returnconst mapDispatchToProps &#x3D; dispatch &#x3D;&gt; &#123;  return &#123;    &#x2F;&#x2F; dispatching plain actions    increment: () &#x3D;&gt; dispatch(&#123; type: &#39;INCREMENT&#39; &#125;),    decrement: () &#x3D;&gt; dispatch(&#123; type: &#39;DECREMENT&#39; &#125;),    reset: () &#x3D;&gt; dispatch(&#123; type: &#39;RESET&#39; &#125;)  &#125;&#125;\n如果给dipsatch传入的是action creator函数而非plain obejct action，通常的习惯就是把action creator的名字与mapDispatchToProps的return object的field也命名为相同的名字。\n如果存在多个action creator要dispatch绑定到props，这个过程很tedious，所以可以使用bindActionCreators函数来实现。\n&#x2F;&#x2F; way2 action creator returnconst increment &#x3D; () &#x3D;&gt; (&#123; type: &#39;INCREMENT&#39; &#125;)const decrement &#x3D; () &#x3D;&gt; (&#123; type: &#39;DECREMENT&#39; &#125;)const reset &#x3D; () &#x3D;&gt; (&#123; type: &#39;RESET&#39; &#125;)const mapDispatchToProps &#x3D; dispatch &#x3D;&gt; &#123;  return &#123;&#x2F;&#x2F; dispatching actions returned by action creators    increment: () &#x3D;&gt; dispatch(increment()),    decrement: () &#x3D;&gt; dispatch(decrement()),    reset: () &#x3D;&gt; dispatch(reset())  &#125;&#125;\n使用bindActionCreator：\n&#x2F;&#x2F; way3 bindActionCreator returnconst boundActionCreators &#x3D; bindActionCreators(  &#123; increment, decrement, reset &#125;,  dispatch)\nObject shorthand form：More declarative and easier to use（更推荐使用）\n由于在define as function的语法中多次出现了类似another function that looks like (…args) =&gt; dispatch(actionCreator(…args))这样的pattern，这种模式可以抽取出来简化。走在上面我们尝试使用bindActionCreators来简化，但实际上还可以更加简化，这就是Object shorthand form。\n在obejct shorthand form当中，我们直接给mapDispatchToProps传递一个对象，对象中的每一个field都是action creators。那么根据内容重新命名mapDispatchToProps可以发现其实这本质上就是actionCreators的集合，作为第二个参数传入connect。\nconst mapDispatchToProps &#x3D; &#123;increment, decrement, reset&#125;\nreact-reduxreact-redux提供了一系列的hooks让store和UI发生数据双向流动。但是在使用这些hook前，需要让这些hook能够找到正确的redux store。\n我们需要告诉react-redux我们希望在compnents中使用哪一个store。因此我们需要rendering a &lt;Provider&gt;  component around our entire &lt;App&gt;, and passing the Redux store as a prop to &lt;Provider&gt;.\n\n\nIn a React + Redux app, your global state should go in the Redux store, and your local state should stay in React components.\n\nuseSelectorreact中提供类似于useState hook让react function components能够访问react state values。\n同样的react-redux提供useSelector hook让react component能够从redux store中读取数据。它接收selector function作为参数。selector function本身只接受一个state参数，这个state时entire redux store state，它的返回值可以是store state的某个slice，也可以是经过一些运算得到的derived value。\n那么useSelector本身不能执行select的功能，那么他的功能何在？它主要承担为selector function传递entire redux state object的工作。\n\nuseSelector accepts a single function, which we call a selector function. A selector is a function that takes the entire Redux store state as its argument, reads some value from the state, and returns that result.\n\n如果store中的state value有了变化该怎么办？useSelector自动帮我们subscribe to the redux store。意思就是只要selector返回的value和上一次的value不一样，useSelector就会force our component to re-render with the new data。\n\nuseSelector compares its results using strict === reference comparisons, so the component will re-render any time the selector result is a new reference! \n\n\nuseSelector总是返回new reference解决办法如果传递给useSelector的selector函数返回的总是是一个新的reference，那么这就回导致无条件re-render。比如filter函数和map函数总是return a new reference。\n在书写传入useSelector的selector function时最好注意以下几点：\n\n单次selector选择store中尽可能少的数据量建议在一个component中使用useSelector的时候，每一次的调用尽量返回最少的数据smallest amount of state。比如比起一个item本身，我们可能更希望返回指向该item的id。\n\nuseSelector with ShallowEuqal comparison但是方法1中提供的返回少量数据也不能改变返回的id本质上也是array的事实。因此我们需要一个比较前后返回数据的function（返回数据的volume越小这种comparison执行起来就越快）。将shallowEqual comparison function函数作为第二参传入useSelector函数。\n\nReact-Redux has a shallowEqual comparison function we can use to check if the items inside the array are still the same.\n\nimport &#123; useSelector, shallowEqual &#125; from &#39;react-redux&#39;&#x2F;&#x2F;selector functionconst selectTodoIds &#x3D; state &#x3D;&gt; state.todos.map(todo &#x3D;&gt; todo.id)const TodoList &#x3D; () &#x3D;&gt; &#123;  &#x2F;&#x2F; useSelector in UI  const todoIds &#x3D; useSelector(selectTodoIds, shallowEqual)    &#x2F;&#x2F; UI rendering&#125;\n使用memoized seletorsmemoized selectors中的memoization的意思就是一种caching机制，储存经过较大运算量后得出的结果，并在后续遇到相同输入的时候重复使用该储存值。\n而memoized selector functions就是那些 save the most recent result value的selector。遇到相同的input，reuse the same result value；遇到不同的input，recalculate a new result value。\n那么如果创建memoized selector functions呢？Reselect library提供了createSelector API供创建memoized selector function。该函数接受一个或多个input selector function作为第一参数，接受一个output selector function作为第二参数，并且返回一个新的selector function。\n运行机制如下：\n\nAll “input selectors” are called with all of the arguments\nIf any of the input selector return values have changed, the “output selector” will re-run\nAll of the input selector results become arguments to the output selector\nThe final result of the output selector is cached for next time\n\n这是原来的写法：\nconst selectTodoIds &#x3D; state &#x3D;&gt; state.todos.map(todo &#x3D;&gt; todo.id)\n这是使用createSelector的写法：\nexport const selectTodoIds &#x3D; createSelector(  &#x2F;&#x2F; First, pass one or more &quot;input selector&quot; functions:  state &#x3D;&gt; state.todos,  &#x2F;&#x2F; Then, an &quot;output selector&quot; that receives all the input results as arguments  &#x2F;&#x2F; and returns a final result value  todos &#x3D;&gt; todos.map(todo &#x3D;&gt; todo.id))\n就相当于把原来的一步到位拆分成了两个步骤。\n什么时候建议使用memoized selectors？当你需要从redux store中获取derived additional values。换句话说return的值是经过某些逻辑后产生的值，步骤较多。\nuseDispatchuseSelector解决了如何从redux store读取数据到UI的问题，但是如何解决从UI component去dispatch action到store的问题呢？当然我们可以调用store.dispatch(action)来完成，但是我们在component file中是无法访问到store的，因此我们需要一个API能让我们在UI component中使用dispatch function。\n由此react-redux提供了useDispatch Hook，它的作用是gives us the store’s dispatch method as its result. (In fact, the implementation of the hook really is return store.dispatch.)\n在UI component中使用useDispatch的方法一般是：调用const dispatch = useDispatch()，然后在需要时调用dispatch(someAction)。\n","categories":["React"],"tags":["React","Redux"]},{"title":"Webpack笔记","url":"/2021/01/08/webpack/","content":"为什么需要webpackwebpack是前端项目中的一个脚本管理工具，当代码从后端经由网络发布到前端，需要考虑网络环境的拥塞程度以及资源请求的先后顺序。在前度项目的配置中决定如何处理通信资源是webpack要解决的问题。\nwebpack所做的就是把项目文件夹webpack-demo/src下的（默认entry point，可自定义）所有内容（包括javascript脚本，css，字体，图片等，只要是loader或plugin支持的文件），按照webpack.config.js中说明的那样，以另一种形式生成到webpack-demo/dist（默认）文件夹下（可以在配置中更改生成路径）。这个过程被称为transcompile（转译）。\n例如，在html中引入script可以改成在js文件中利用import引入其他的script；而html中的script应当指向webpack生成的script。\n默认的配置文件webpack.config.js的出现是为了减少在终端手动输入大量项目配置命令。实际上可以在命令行npx webpack --config webpack.config.js用任何配置去转译当前项目。\n可以在package.json的的scripts字段进行脚本自定义，以更便捷的方式调用webpack。例如以npm run build代替npx webpack --config webpack.config.js。\n以下所有内容均是在webpack.config.js文件中的module.exports = &#123;&#125;对象中定义的。\nentryentry point的值是指向某个文件的路径，告诉webpack用哪一个文件开始建立内部的dependency graph（一个文件夹中各个文件的依赖关系，entry point路径的文件应该就是依赖图的根节点）。\n默认值是./src/index.js。可以有一个或者多个。注意这里的路径是当前文件夹下的相对路径。\nentry property可以接受利用缩写接受一个路径，也可以接受一个对象，更可以接受一个数组。\n基础设置single entry// single entry shorthand syntaxmodule.exports = &#123;  entry: &#x27;./path/to/my/entry/file.js&#x27;&#125;;// signle entry non-shorthand syntaxmodule.exports = &#123;  entry: &#123;    main: &#x27;./path/to/my/entry/file.js&#x27;      // 如果有多个项目就是object syntax  &#125;&#125;;\n多入口的代码分离如果利用entry写了多个入口起点，那就是手动的去分离了代码，每一个入口起点被转译后的bundle就更小了，更能实现按需加载文件。\n// multi-main entry with array syntax// 尽量避免使用多入口的入口module.exports = &#123;  entry: [     &#x27;./src/file_1.js&#x27;,    &#x27;./src/file_2.js&#x27;  ]    // 传递数组只会生成一个chunk，因此webpack会把数组里的源代码都打包到一个bundle中&#125;;// objecy syntaxmodule.exports = &#123;  entry: &#123;    app: &#x27;./src/app.js&#x27;,    adminApp: &#x27;./src/adminApp.js&#x27;      // 对象中几个字段就生成几个chunk      // 这里会生成两个  &#125;&#125;;\n有几个entry point，就代表webpack需要几个互相独立的依赖图。\n在多个entry的情况下，也需要有多个output bundle。通过引用[name]来实现output.filename匹配到对应entry name。\n多入口代码分离模块重复代码与实例化隐患Modules relied on by multiple entry bundles can be extracted into common bundles used across multiple pages.\nWhether extracted or inlined, it’s important that a module never be instantiated multiple times - both ECMAScript Modules and CommonJS Modules specify that a module must only be instantiated once per JavaScript context. \n但是这种方式的问题在于每一个引用模块的代码都会被实例化多次；如果每一个entry都包含相同的引用模块的代码，会在结果bundle的各个文件中再次重复，增加代码量。\n期望的结果：a module used by two different entry bundles will be instantiated only one time.\n多入口代码分离重复防止模块多次实例化的方法可以是在entry字段中的每个entry都添加一个dependOn字段，但是这无法解决输出bundle间代码重复的问题。\n如下：\nmodule.exports = &#123;  entry: &#123;   index: &#x27;./src/index.js&#x27;,   another: &#x27;./src/another-module.js&#x27;,   index: &#123;     import: &#x27;./src/index.js&#x27;,     dependOn: &#x27;shared&#x27;,   &#125;,   another: &#123;     import: &#x27;./src/another-module.js&#x27;,     dependOn: &#x27;shared&#x27;,   &#125;,   shared: &#x27;lodash&#x27;,  &#125;,&#125;;\n并且如果这些entry生成的bundle都服务于同一个html页面，还需要在webpack.config.js中设置optimization.runtimeChunk: &#39;single&#39;。\n\nThis doesn’t prevent Webpack from copying module code between entry points, but it prevents it creating two instances of the same module at runtime, while reducing the number of HTTP requests needed to load modules for a given page.\n\noutputoutput告诉webpack在哪个路径下输出他解析这些文件依赖关系后得出的bundles，以及如何命名输出的bundles，因此用一个对象来表示output.path和output.filename。\n默认值是./dist/main.js，其他相关的生成文件bundle都放在./dist文件夹下。\n基础设置single entry只需要在output property中指定filename的值。只适用于single entry的情况。\nmodule.exports = &#123;  output: &#123;    filename: &#x27;bundle.js&#x27;,  &#125;&#125;;\n这个语句告诉webpack，把输出的文件放到默认的dist目录的bundle.js中。\nmultiple entry如果有多个entry，那么也会有多个依赖图，也就是多个js文件输出。在output.filename中使用&#39;[name].js&#39;，（可替换模版字符串substitution）这里的name匹配的是entry point的名字。\nmodule.exports = &#123;  entry: &#123;    app: &#x27;./src/app.js&#x27;,    search: &#x27;./src/search.js&#x27;  &#125;,  output: &#123;    filename: &#x27;[name].js&#x27;,    // filename: &#x27;[name].[contenthash].js&#x27;,    path: __dirname + &#x27;/dist&#x27;  &#125;&#125;;// writes to disk: ./dist/app.js, ./dist/search.js\n还有其他的通过带方括号的字符串来模版化文件名的方式。[name]引用entry的名字，[contenthash]根据资源内容创建唯一hash。\n基础用法需要注意output.path使用的是执行环境下的相对路径，需要使用path package解析执行环境。\nconst path = require(&#x27;path&#x27;);module.exports = &#123;  entry: &#x27;./path/to/my/entry/file.js&#x27;,  output: &#123;    path: path.resolve(__dirname, &#x27;dist&#x27;),    filename: &#x27;my-first-webpack.bundle.js&#x27;  &#125;&#125;;\nloaders in module.rules默认情况下，webpack只能理解JavaScript以及JSON文件。但是前端项目中设计其他的语言，比如css，为了使css也能够被bundle并输出到output.path去，需要loaders。\n\nLoaders can transform files from a different language (like TypeScript) to JavaScript or load inline images as data URLs. Loaders even allow you to do things like import CSS files directly from your JavaScript modules!\n\n针对某个类型的文件，需要两个属性。一个是用于鉴别哪一个文件（涉及到使用正则表达式进行文件匹配）是当前loader需要转换的test property，另一个是说明需要用到哪些loaders的use property。\n在module内部定义a rules property for a single module with two required properties: test and use. \nmodule.exports = &#123;  module: &#123;    rules: [      &#123; test: /\\.txt$/, use: &#x27;raw-loader&#x27; &#125;,      &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;] &#125;,      &#123; test: /\\.ts$/, use: &#x27;ts-loader&#x27; &#125;    ]  &#125;&#125;;\n以上这些语句告诉webpack compiler在require()/import语句中遇到一个一.txt结尾的文件时，先使用raw-loader把它转换成目标代码，再添加到输出bundle去。\n在使用正则表达式匹配文件的时候，不应当使用单引号或者双引号。/\\.txt$/是正确的，告诉webpack去匹配所有以txt结尾的文件；但&quot;/\\.txt$/&quot;是错误的，它告诉webpack去匹配绝对路径&#39;.txt&#39;下的某个文件。\n\nLoaders can be chained. A chain is executed in reverse order. \n\n在use中loader是可以被串联起来的，但loaders的放置先后顺序有讲究。loaders都是从右到左/从下到上被执行的。在test css结尾的文件中，loader执行的顺序先是sass-loader，sass-loader将执行结果传递给css-loader， 最后css-loader的执行结果被传递给style-loader。\n加载CSS首先，需要下载npm包style-loader以及css-loader。如果希望压缩css等，需要使用sass-loader，postcss-loader。\n其次，在modules.rules中分别配置test和use。\n然后，就可以在任何文件中通过import语法获取.css文件。\nasset/resource加载图像字体webpack5内置的type: ‘asset/resource’可以解决图片资源加载的问题。无需借助loader。\nmodule.exports = &#123;  //...  module: &#123;    rules: [     &#123;       test: /\\.(png|svg|jpg|jpeg|gif)$/i,       type: &#x27;asset/resource&#x27;,     &#125;,     &#123;       test: /\\.(woff|woff2|eot|ttf|otf)$/i,       type: &#x27;asset/resource&#x27;,     &#125;,    ],  &#125;,&#125;;\n加载数据json/csv/tsv/xml由于JOSN文件格式是默认支持的，无需下载loaders。但是csv/tsv/xml需要下载csv-loader以及xml-loader。\n在import时注意json文件只支持export default默认导出。 \n在数据可视化的场景下，直接将数据作为构建时的资源，浏览器就可以直接访问解析后的数据，无需在构建完成后运行时再发送http请求。\npluginsloader是用来transform certain type of modules的；plugins用途更为广泛，涉及bundle optimization，asset management以及injection of environment variables。\nplugins的实现原理webpack也是基于plugin system而建立的。webpack plugin本质上就是一个拥有apply方法的JavaScript对象。apply(compiler)表示这个apply方法是由webpack compiler执行的。\n基础使用plugin需要使用npm安装，并使用require引用。\n在使用特定的plugin之前需要建立一个const指向require()，require的对象就是该plugin。在使用该plugin的时候，是在plugins array中使用new运算符，并传入特定的需求。\n为什么使用new运算符调用一个plugin？因为一个plugin并不是单一功能的，有可能在一个文件中为了各种需求需要多次使用该plugin，因此要使用new运算符在每一次创建的时候都生成一个实例。\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); //installed via npmconst webpack = require(&#x27;webpack&#x27;); //to access built-in pluginsmodule.exports = &#123;  plugins: [    new HtmlWebpackPlugin(&#123;template: &#x27;./src/index.html&#x27;&#125;)  ]&#125;;\nhtml-webpack-plugin为什么需要HtmlWebpackPlugin？这个plugin的作用是在webpack输出文件夹下依据规则，自动生成index.html，这个index.html还会依据输出的javascript bundle自动引用script，这样就无需手动添加html与引用script了。\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);module.exports = &#123;   entry: &#123;     index: &#x27;./src/index.js&#x27;,     print: &#x27;./src/print.js&#x27;,   &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;      title: &#x27;管理输出&#x27;,    &#125;),  ],  output: &#123;     filename: &#x27;[name].bundle.js&#x27;,      // 生成的html会自动引用这些bundle     path: path.resolve(__dirname, &#x27;dist&#x27;),  &#125;, &#125;;\nclean-webpack-plugin默认每一次不同的配置文件产出在dist下的文件，除非文件名相同，否则是不会覆盖的。因此dist文件夹会相当混乱。clean-webpack-plugin的作用是在每次build前先清理dist文件夹，构建后dist中只会有生成且用得到的文件。\nsplit-chunks-plugin该插件用于代码分离，将公共的依赖模块提取到已有入口的chunk中。\nmodule.exports = &#123;   optimization: &#123;     splitChunks: &#123;       chunks: &#x27;all&#x27;,     &#125;,   &#125;,  &#125;;\n该插件自动移除依赖模块，并且依赖模块会被分离到单独的chunk。\n也可以使用该插件提取引导模版extracting boilerpate，即将第三方库，也就是node_modules中涉及的内容提取到单独的vendor chunk文件中，通过split-chunks-plugin的cacheGroups选项实现。\noptimization: &#123;    moduleIds: &#x27;deterministic&#x27;,    // 这是为了保证每一次build生成的依赖库的hashname都一样。    runtimeChunk: &#x27;single&#x27;,    // runtimeChunk: &quot;single&quot;会将Webpack在浏览器端运行时需要的代码单独抽离到一个文件    splitChunks: &#123;      cacheGroups: &#123;        vendor: &#123;          test: /[\\\\/]node_modules[\\\\/]/,          name: &#x27;vendors&#x27;,          chunks: &#x27;all&#x27;,        &#125;,      &#125;,    &#125;,\n这部分vedor的代码，很少会被修改，缓存在client端，既减少了想server获取资源的请求，也能保证依赖模块版本一致。\n参考深入Webpack快取机制\n但是要求每一次构建后，vendor hash都保持一致。如何让每一次的hash结果保持一致？影响hash结果的因素有哪些？\n第一是文件的内容，既然是node_moudles第三方库，内容应该是不会改变，因此vendors的hash名称也应当build前后一致。但是实际上并不是这样，这时候需要添加moduleIds: &#39;deterministic&#39;，为什么？由此引入第二个原因。\n但是还有第二个因素就是执行先后顺序，在webpack中执行先后顺序通过依赖图dependency graph来实现。在runtime.js中，记录者所有模module与块chun之间的关系，module id与chunk id默认情况下会在每一次build前后都可能发生变化，而固定module id可以让build前后\nmodemode设定可以有devlopment，production，none。默认取值是production。\nmodule.exports = &#123;  mode: &#x27;production&#x27;&#125;;\n开发环境下常用工具source-map有多种形式，可以追踪出错的源码，涉及浏览器开发工具。\nmodule.exports = &#123;  mode: &#x27;development&#x27;,  devtool: &#x27;inline-source-map&#x27;,&#125;;\n代码变化后自动编译\n使用watch mode\n\n通过添加一个用于启动webpack watch mode的npm scripts实现，注意开发时如果不希望clean-webpack-plugin自动删除不使用的文件，可以配置clean-webpack-plugin的选项。\n\n使用webpack-dev-server\n\n提供一个简单的web server并实现live reloading。\n需要告知dev Server去哪里查找文件，在webpack.config.js中添加devServer:&#123; contentBase: &#39;./dist&#39;&#125;选项。默认会将dist目录下的文件serve到localhost:8080。\n添加一个用于启动devServer的npm script：&quot;start&quot;: &quot;webpack serve --open&quot;\n\n使用webpack-dev-middleware\n\nWeb pack-dev-server内部就是通过使用webpack-dev-middleware来实现的，直接设置webpack-dev-middleware可以更自定义，比如在哪个端口监听。\n需要同时使用express和webpack-dev-middleware，并在webpack.config.js的output字段添加publicPath: &#39;/&#39;，配置express的server脚本server.js会使用到publicPath。而webpack-dev-middleware的作用应该就是让server.js能够访问webpack.config.js的内容。\nserver.js的配置如下，在完成server.js的配置后，需要把node server.js配置添加到npm scripts中。\nconst express = require(&#x27;express&#x27;);const webpack = require(&#x27;webpack&#x27;);const webpackDevMiddleware = require(&#x27;webpack-dev-middleware&#x27;);const app = express();const config = require(&#x27;./webpack.config.js&#x27;);const compiler = webpack(config);// 告知 express 使用 webpack-dev-middleware，// 以及将 webpack.config.js 配置文件作为基础配置。app.use(  webpackDevMiddleware(compiler, &#123;    publicPath: config.output.publicPath,  &#125;));// 将文件 serve 到 port 3000。app.listen(3000, function () &#123;  console.log(&#x27;Example app listening on port 3000!\\n&#x27;);&#125;);\n而在vue3-demo3中的server.js又是这样的：\nconst express = require(&quot;express&quot;);const history = require(&quot;connect-history-api-fallback&quot;);const serveStatic = require(&quot;serve-static&quot;);const enforce = require(&quot;express-sslify&quot;);const app = express();app.use(enforce.HTTPS(&#123; trustProtoHeader: true &#125;));app.use(serveStatic(__dirname + &quot;/dist&quot;));app.use(history());app.listen(process.env.PORT || 5000);\n不同之处在于不是通过webpack-dev-middleware来访问webpack.config.js，vue脚手架已经写死了配置，默认路径就是dist。\n约定\n使用require()语法导入其他文件或者npm uitilites\n使用JavaScript control flow expression如?:\n为常用值设置const或者let变量\n为常用的配置建立函数并执行\n\n不要在一个文件中书写多个configuration，应当把整个项目的configuration写成多个文件multiple .config.js files。\nwebpack module为什么需要模块化与去模块化一方面，模块化便于JavaScript在服务器端便于开发，测试，查错。另一方面浏览器只能理解一整个JavaScript文件，因此又要在生产的时候去模块化，将符合模块化规范的代码转换成浏览器支持的代码。因此如browserify与webpack都是从入口模块开始把所有模块打包成一个在浏览器中运行的js文件的模块化工具。\nmodule/chunk/bundle区分webpack是一个模块打包机，一个项目中的任何单一文件，对于webpack而言都是模块。\nchunk是webpack打包过程中，一堆module的集合。一般来说一条entry对应一个chunk，也有异步加载模块与代码分割可以产生chunk。\nA Chunk is a unit of encapsulation for Modules. Chunks are “rendered” into bundles that get emitted when the build completes.\nbundle是webpack最终输出的一个或者多个打包文件，在命令行中运行webpack的输出asset的个数就是产生的bundle数。多数情况下，一个chunk产生一个bundle，但也有例外情况。比如在单个文件入口mai n.js以及不设置代码分割的情况下，设置source-map后，依然会产生main.js以及main.js.map两个bundle。\n参考Webpack理解Chunk\n支持模块化语法在webpack中，可以使用多种语法来表明module之间的dependency。（按照产生先后顺序）\n\nCommon JS require() \nAMD define and require \nES2015 import \n@import inside of a css/sass/less file 属于\nimage url in a stylesheet url(...) or HTML file &lt;img src=...&gt;\n\n\n这些为模块化服务的语法都是怎么产生的？演化路线CommonJS-&gt;AMD/CMD-&gt;ES6 Module。\n参考前端科普系列-CommonJS：不是前端却革命了前端。\n\nCommonJSNode.js的模块化是在CommonJS基础上实现的，CommonJS是以JavaScript在网页浏览器之外（服务器端backend）创建模块约定的一个项目。CommonJS约定了每个文件就是一个拥有自己作用域的模块。CommonJS规定了两个语法：require语法用于加载某个模块exports导出的值；module以对象代表当前模块，module.exports保存当前模块导出的接口或者变量。\nCommonJS用于服务器端同步加载模块，却不适合浏览器端，不可能每每通过require去发送网络请求，等待资源返回，要是资源一直不返回就阻塞了后面的代码。\nAMD/CMD因此就出现了为浏览器端服务的AMD(Asynchroneous Module Definition)，他实现了异步加载模块，利用require.js库。也有CMD(Common Module Definition)，利用sea.js库。\nES6 Module而后续出现的ES6 Module规范成为了浏览器端和服务器端的通用解法。主要有export和import两个命令。import内部的实现是使用了Promise的，因此也就实现了异步加载。\n由于import返回的是一个promise，因此import语句可放在在async function中，等到模块加载完成之后在执行函数内容，从而实现动态导入模块代码分离。\n","categories":["webpack"],"tags":["前端","webpack"]},{"title":"腾讯云使用踩坑记录","url":"/2021/03/13/qcloud-use/","content":"登陆云服务器方式一：用户名在Terminal使用ssh登陆远程服务器，终端输入ssh 用户名@云服务器ip，然后输入密码就行。\n所有的用户，登录进去后都是有~表示这是当前用户的home目录，如果使用change directory命令cd /，就可以进入系统根目录。\n\n~在Linux中代表用户主目录，对一般用户，~表示/home/（用户名），对于root用户，~表示/root。如果要查看~的真实面貌，可以先进入~目录cd ~，然后用print working directory命令pwd -P命令查看~的绝对路径。\n\n方式二：密钥首先在腾讯云的页面创建密钥，生成并下载的密钥文件保存在本地。将云服务器关机后在腾讯云中绑定云服务器实例。\n然后，在本地Terminal中进行登录信息的配置。输入vim ~/.ssh/config，进入编辑模式，添加如下信息：\nHost sweetsweetcloud        HostName ip或者是域名        User ubuntu或root或其他账户        IdentityFile 密钥文件所在的绝对路径，例如 ~/.ssh/qcloud\n\n如果要查看密钥文件的绝对路径，可以拖动文件到Terminal中直接查看。\n\n再次确认输入无误后保存并退出。\n终端输入ssh sweetsweetcloud，随后可能会有一个确认连接的消息弹出，输入yes并回车即可连接。\n同样的ftp，sftp，也可以直接使用这些配置登陆。如果要进行sftp连接，输入sftp sweetsweetcloud即可。\n方式三：PyCharm连接版本PyCharm 2020.3 Professional，软件语言为英文。\n第一步是先找到Tools&gt;Deployment&gt;Configuration。\n\n第二步，添加一个配置。输入的new server name知识这个配置的名称，没有其他实际意义。\n\n第三步，填写具体配置。注意到最上面有三个分页，connection、mappings、excluded paths。\n\n在connection mappings中，传输类型Type选择SFTP，ssh configuration点击三个小点，会弹出一个新的页面。\n\nHost部分就填写服务器的公网IP，User name与password就相当于使用用户名登陆云服务器，也可以改变Authentication type选择用key pair来验证。输入之后Test Connection成功就说明配置成功。\n继续回到Deployment页面中，Root Path就是传输文件的最初始路径，后面mappings也有一个路径，那个mappings路径是基于这里的root path的。\nWeb Server继续填写http前缀+服务器的公网IP。最后保存即可。\n在刚填写完没多久，Tools&gt;Deployment&gt;Configuration&gt;Upload to…选项可能是灰色的，等过了五六分钟大概就会能够让你上传。也可以在Tools&gt;Deployment&gt;Options中设置自动上传。\nTools&gt;start SSH session可以在Pycharm中连接远程终端，就和在自己的Terminal中连接远程终端一个道理。\n登陆云服务器报错及解决ECSDA host key报错如果像我一样重置了系统，并且重新绑定了密钥到云服务器上，或报错诸如：Warning: the ECDSA host key for &#39;myserver&#39; differs from the key for the IP address &#39;192.168.1.123&#39;，只需要在Terminal中移除为该ip缓存的密钥即可，ssh-keygen -R 你的服务器ip。\n连接时发生broken pipe错误以sudo模式修改服务器端ssh配置文件sudo vim /etc/ssh/sshd_config。\n找到TCPKeepAlive，ClientAliveInterval，ClientAliveCountMax选项，分别uncomment，并且修改为yes，300，10（自定义数值）。\n\n连接远程服务器时提示Permission denied (publickey,password)因为默认使用了ssh密钥进行连接，所以用户名、密码的方式不可行，并且一开始也没有设置密码。如果想要使用用户名密码登陆，需要修改sshd的配置。\n进入sudo vim /etc/ssh/sshd_config，修改为PermitRootLogin yes， PubkeyAuthentication no，PasswordAuthentication yes几项，有的可能被comment了，仔细找找。\n保存后重启sshd服务，systemctl sshd restart。\n网上提供的解决办法也有单改PermitRootLogin的，没效果。\n如果一开始就没有设置密码或者忘记密码了，登陆后使用sudo passwd root改一下密码。\n解决方法了这篇文章。\n\n在mac终端使用sftp向服务器传输文件也是使用sftp root@ip-address，然后会要求输入密码，正确后就能传输文件了。如果要传输整个文件夹，记得使用put -r local-file remote-file，否则没有-r会报错non-regular file。\n\nCentOS由于一开始选择的系统是CentOS，后来感觉找教程都不太方便，就改成了ubuntu了。虽然后来又因为Ubuntu下安装python不带pip的bug重返了CentOS。\n参考的文章是这一篇：半小时搞会 CentOS 入门必备基础知识，里面涉及CentOS根目录文件说明，目录相关命令，Vim编辑器使用方法，进程管理，ssh登陆与上传文件。\n创建新的用户使用adduser username创建用户名为username的用户，命令行不会有输出，但继续使用passwd username可以在出现的响应栏中设定username的用户密码。参考CentOS 7中添加一个新用户并授权。\ngcc与动态库升级为什么需要gcc升级无力吐槽了，本意是想在云服务器上跑个RESTful API供前端调用的，因为项目用到了tensorflow以及bert4keras等库，这些库对底层gcc的动态库（如glibc，libstdc++，libm等）的要求较高，而centos7.6自带的gcc版本是4.8.5的，动态库根本不能支持python的依赖库，一直一直报错，一定要手动编译升级gcc还有glibc动态库。\n至今为止遇到的错误包括但不限于一下几个，按出现先后顺序排列：\n\n报错信息ImportError: /lib64/libstdc++.so.6: version CXXABI_1.3.9&#39; not found\n\nImportError: /lib64/libm.so.6: version GLIBC_2.23&#39; not found\n\n加载共享库时发生Linux错误：cannot open shared object file: No such file or directory\n\n一般遇到上面三个报错，搜索出来的教程都是和你说gcc动态库过老，要你查找编译gcc时生成的最新动态库。但这一切都基于一个前提，你必须编译gcc了。如果没有编译过高版本的gcc，单纯连接动态库的操作还是会报错。所以解决上面两个问题的核心办法就是先升级gcc后更新动态库。\n\n编译glibc :LD_LIBRARY_PATH shouldn&#39;t contain the current directory\nglicc2.23编译错误setenv.c:279:6: error: suggest explicit braces to avoid ambiguous &#39;else&#39; [-Werror=parentheses] if (ep != NULL)\nglicc2.23[Bug build/23883] error: &#39;__EI___errno_location&#39; specifies less restrictive attributes than its target &#39;__errno_location&#39;:\n\n接下来主要分为两个部分，第一个部分是升级gcc，第二个部分是更新动态库。\n建议升级的版本匹配方案\nCentOS7.6，运行基于Tensorflow1.14，bert4keras0.7，flask1.1，numpy1.16，scipy1.6，pandas1.2等模块的Python项目。\nGCC 8.2.0（原4.8.5）\nGNU Make 4.2.1（原3.8.2）\nglibc 2.28（原2.17）\n\n写在最前面安装包的一些建议\n安装任何东西的时候一定要看清楚这个东西是否是支持操作系统版本的，比如有些包就分CentOS8的和CentOS7的。\n如果国内服务器，如腾讯云服务器，使用wget下载国外ftp服务器的文件过慢，有两种方式。第一，找镜像网站。第二，曲线救国，先在本地用终端代理命令走proxy下载到本机，然后和用sftp上传到服务器，我就这么干了好多回。\n\n升级gcc到8.2.0\n不建议使用scl方法。这篇文章介绍了使用scl安装的方式，确实很快，但是有一个问题，就是安装并切换了目标版本的gcc后发现无法通过find / -name &quot;libstdc++.so.6&quot;找到动态库（也有可能是我的方式不对）。\n\n建议根据centos6升级gcc、centos7升级gcc、glibc报错解决这三篇文章做升级。因为编译很慢，我的服务器是1核2G内存的，make花了将近三个小时，每一步都仔细检查，谨慎执行。\nyum update -yyum install -y  gcc-c++  glibc-static gcc bzip2 wget tmuxcd ~wget http://ftp.gnu.org/gnu/gcc/gcc-8.2.0/gcc-8.2.0.tar.gztar -xzf gcc-8.2.0.tar.gzcd gcc-8.2.0./contrib/download_prerequisites# gmp-6.1.0.tar.bz2: OK# mpfr-3.1.4.tar.bz2: OK# mpc-1.0.3.tar.gz: OK#isl-0.18.tar.bz2: OK# All prerequisites downloaded successfully. # 创建一个存放编译后文件的目录，并进入该目录编译 mkdir gcc-build-4.8.5 cd gcc-build-4.8.5\n配置编译选项，此处没有指定路径，默认安装到/usr/local中。\n../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib\n如果希望指定目录，建议这么做：../configure --prefix=/usr/local/gcc-8.2.0  -enable-checking=release -enable-languages=c,c++ -disable-multilib这会将编译生成的文件自动放置到/usr/local/gcc-8.2.0，强烈建议带版本号，不然多个gcc会很麻烦。\n开始编译并安装。\nmakemake install\ngcc升级后的系统路径配置# 环境变量pathecho  &quot;export PATH=/usr/local/gcc-8.2.0/bin:$PATH&quot; &gt;&gt; /etc/profile.d/gcc.shsource /etc/profile.d/gcc.sh# 头文件ln -sv /usr/local/gcc-8.2.0/include/ /usr/include/gcc# 库文件echo &quot;/usr/local/gcc-8.2.0/lib64&quot; &gt;&gt; /etc/ld.so.conf.d/gcc.confldconfig -vldconfig -p |grep gcc\n这里的路径都是基于刚才我们../configure后的—prefix选项生成的。如果没有—-prefix选项，默认就是PATH=/usr/local/bin,PATH=/usr/local/include/,PATH=/usr/local/lib64。\n在这之后使用gcc -v查看版本号应该就没有任何问题了。\n编译后会生成的文件都长这样。\n\n\n用命令查找系统中已经存在的gcc：\nfind /usr -name gcc# 返回如下内容# 这是之前按照掘金上那一篇教程安装的路径--prefix为/usr/local/gcc的gcc9.1.0，因为版本太高仍然在python中报错/usr/local/gcc/usr/local/gcc/lib/gcc/usr/local/gcc/bin/gcc/usr/local/gcc/libexec/gcc# 这是后来没有指定--prefix的gcc8.2.0，默认直接安装到了/usr/local下，后来我觉得移动一下这些文件，于是就有了上面那张截图/usr/local/lib/gcc/usr/local/bin/gcc/usr/local/libexec/gcc# 这是系统自带的gcc4.8.5/usr/lib/gcc/usr/bin/gcc/usr/libexec/gcc/usr/include/gcc\n之前我还用scl安装了gcc，但是并没有显示在这里。可能是因为那个安装的是预编译的gcc编译器？不太懂这其中的关系。\n\nlibstdc++动态库连接查看当前系统的glibc动态库。\nstrings /usr/lib64/libstdc++.so.6 | grep GLIBC\n查找编译gcc后的生成动态库。\nfind / -name &quot;libstdc++.so*&quot;\n选择新生成的动态库、复制到/usr/lib64下，建立软连接。\nsudo cp /usr/local/lib64/libstdc++.so.6.0.25 /usr/lib64cd /usr/lib64sudo rm -rf libstdc++.so.6sudo ln -s libstdc++.so.6.0.25 libstdc++.so.6\n之后再次查看glibc动态库就会发现有更高的版本了。\nglibc升级过程一开始我自己选择的glibc2.23进行升级的，编译的时候总有少个括号多个括号的报错，虽然能进入.c文件直接修改，但是问题在于解决了这个出错了那个。报错的一个解决例子可以参考这篇博客。如果在对glibc升级的时候出现错误，建议直接更换glibc的版本。\n参考这篇博客，注意博主后来安装的是gcc8.2.0，因为后面glibc编译报错了！\n在glibc官网下载glibc2.28版本，glibc官网地址：http://ftp.gnu.org/gnu/glibc/。\n# 解压、进入目录、创建build目录并进入tar -xf glibc-2.28.tar.gzcd glibc-2.28mkdir build; cd build# 编译配置../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin # 开始编译并安装make make install # 这一步的2个问题可以忽略\n\n如果先前没有编译安装升级gcc到8.2.0，就可能报错these critical programs are missing or too old: make。我是只出现了make的报错，但是参考博客的博主既有bison又有make，所以大家一定要结合自己的情况。\n\nGNU Make升级过程因为在升级glibc的过程中我有make版本过低的报错，因此从3.82升级gnu make到4.2.1。\n从GNU Make官网下载对应版本的GNU Make：https://ftp.gnu.org/gnu/make/。过程与博客分享的一致。\n# 解压tar -zxvf make-4.2.1.tar.gz# 安装cd make-4.2.1# 建立编译目录mkdir buildcd build# 执行../configure --prefix=/usr# 执行完，这里需要编译，会生成build.sh文件，然后执行这个文件sh build.sh# 然后安装make install# 然后就安装完成了，查看版本make -vGNU Make 4.2.1Built for x86_64-pc-linux-gnuCopyright (C) 1988-2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.\nglibc升级成功查看结果成功编译glibc会出现这样的结果。\n# 查看动态库ls -l /lib64/libc.so.6# glibc2.28的意思就是在动态库中查找glibc会有一直到2.28版本strings /lib64/libc.so.6 | grep GLIBC.....GLIBC_2.26GLIBC_2.27GLIBC_2.28GLIBC_PRIVATE\n手动安装Python本文主要是在CentOS 7.6的腾讯云服务器尝试安装Python3.7，以及pip、virtualenv。\nUbuntu下安装请谨慎，因为我自己重新编译了好多次，发现依然安装的Python不自带pip，十分麻烦，原因想不出来，但是网络上也有提出相同问题的人。\n如果是CentOS 8的系统，安装Python3源文件的编译环境的时候会报错无法安装该编译模块！\n安装过程1. 从Python官方网站下载python所有Python的版本都可以在这个网站找到，点击对应的版本号，会给出一系列安装包，把安装包的名字拼接到网址后面就是我们使用wget获取的文件对象。\n如，对于网址https://www.python.org/ftp/python/3.7.4/，选取Python-3.7.4.tgz安装包，所以目标网址为https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz。\n在使用wget之前，先进入某个目录，后续下载wget与解压tar都会在这个目录进行。全部过程如下：\ncd /homewget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgztar -zxvf Python-3.7.4.tgz \n解压缩之后，home文件夹下会有一个Python-3.7.4.tgz压缩包、Python-3.7.4文件夹，编译源文件与安装都在Python-3.7.4下进行。\n2. 安装Python编译环境建议编译环境的安装宁可多不可少。\nsudo yum -y install gcc gcc-c++ sudo yum -y install zlib zlib-develsudo yum -y install libffi-develsudo yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel\n之前就是因为没有安装libffi-devel这个模块，导致后面在使用pip安装bert4keras的时候已知报错ModuleNotFoundError: No module named &#39;_ctypes&#39;，解决方法参考了make install fails: no module _ctypes和Python3: ImportError: No module named ‘_ctypes’ when using Value from module multiprocessing。尽量一次编译一次成功，编译环境齐全太重要了，重新编译好浪费时间，一次花半个小时的那种浪费。\n3. 开始编译先进入Python3源文件的文件夹。\ncd Python-3.7.4\n然后配置安装目录，编译，安装。\n./configure --prefix=/usr/local/python3 --enable-optimizations --with-sslmakemake altinstall\n关于make altinstall与make install的区别，就是altinstall省去了make install之后配置软连接的过程。默认altinstall会在系统环境中创建和版本号相同的python环境变量。不要随意去删除本来就存在的指向系统自带Python的软连接，亲测会报错！\n终端输入python3.7与pip3.7 --version能给出正确回应就说明安装没问题。通过在终端输入which python3.7或whereis python3.7可以查找到路径。\n参考强烈建议找教程一定要找最新发布的，文章，能够明确系统版本的更好。虽然跟着结合这两个教程做了，还是出了问题重新编译了多次。\n腾讯云服务器Linux系统—安装python3.7.6\nlinux安装Python3\nvirtualenv管理虚拟环境在使用pip安装包之前先查看这个pip对应的是哪个Python解释器。像这样，pip3和pip对应的其实都是CentOS自带的Python解释器，而pip3.7 install才会对应到真正的我们想要安装的python版本去。\n\n首先使用pip3.7安装virtualenv：pip3.7 install virtualenv。\n进入项目根目录，创建一个名为venv的虚拟环境。进入虚拟环境所在文件夹，激活虚拟环境后回到项目根目录，安装requirements.txt文件中的库。\ncd myChatbotvirtualenv venvcd ./venvsource bin/activatecd ../pip intsall -r requirements.txt\n如果想要删除虚拟环境，直接删除虚拟环境的venv文件夹即可。\ngit安装sudo yum -y install https://packages.endpoint.com/rhel/7/os/x86_64/endpoint-repo-1.7-1.x86_64.rpm # 使用endpoint安装sudo yum install gitgit --version # 查看版本\n服务器git clone过慢使用国内镜像，目前已知Github国内镜像网站有github.com.cnpmjs.org和git.sdut.me/。速度根据各地情况而定，在clone某个项目的时候将github.com替换为github.com.cnpmjs.org即可。\npyenv管理python版本安装pyenv正常步骤是使用git clone https://github.com/yyuu/pyenv.git ~/.pyenv，但是腾讯云实在是……git clone太慢了，于是就用了镜像网站下载.\ngit clone https://github.com.cnpmjs.org/yyuu/pyenv.git ~/.pyenv\n接下来配置环境变量即可。\nvim ~/.bash_profile## pyenvexport PYENV_ROOT=&quot;$HOME/.pyenv&quot;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;eval &quot;$(pyenv init -)&quot;source ~/.bash_profile\n使用pyenv安装特定版本的python正常步骤是使用pyenv install 版本号，但是实在是太慢了！无语！这辈子没这么无语过！\n使用国内镜像下载。下面的命令的意思是从镜像网站huaweicloud下载版本为3.7.3的python压缩包，并放置在~/.pyenv/cache文件下，并使用pyenv安装压缩包。\nv=3.7.3;wget https://mirrors.huaweicloud.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v\n","categories":["必备技能"],"tags":["linux","腾讯云"]},{"title":"Word2Vec原理、训练与优化","url":"/2021/03/16/word2vec/","content":"如何量化一个词方法总的来说又两种，分别是one-hot representation与distributional representation。\none-hot表示方法虽然十分直观，但问题在于如果词汇量很大，每一个单词用向量来表示的dimension就十分大，所有词汇的one-hot向量组成的矩阵是sparse的。\ndistributional representation的方法在于它通过在每一个dimension上都有取值，从而实现词向量dimension的降低。并且单词变成词向量后，可以通过向量的加减法来实现词意的变化。\n词向量的算法有skip-gram与Continuous Bag of Words（CBOW）两种。训练方法主要有hierarchical softmax与negative sampling两种。\n给定词的上下文词的概率公式自然语言处理当中的原始概率计算公式为：\n\np(o|c) = \\frac{\\exp(v_o^T v_c)}{\\sum_{w=1}^{V}\\exp(v^T_{w} v_c)}其中来表center word的vector representation，代表context word（outside word）的vector representation。V代表整个文章的所有词汇。整个式子就是求在已知center word的条件下哦，求context word出现的概率。\n这个式子有何数学含义？分母是两个向量的点积。有，结果越大说明两个向量u和v越相似，单词u和v越有关联。点积的结果使用exp是为了保证分子为正。整个式子结合分子分母来看是一个softmax，它的作用是将数字转化为概率分布。\n\nSoftmax function: Standard map from  to a probability distribution\nsoftmax为什么叫softmax？soft+max，max因为它将大的值更强化了比重，soft因为它仍然考虑较小的值而不知和max函数一样直接抹去它的存在。它的作用类似于max函数，式子的形式有点像求一个数的exp占总体比例的大小。分母的求和是normalize to give probability。\n\n参数说明V/vocabulary：词表中的词数量，代表词表中所有词的个数。\nd/dimension：每个词表示为多少维度的向量。\nm：代表window size，每一个center word向前向后考虑m个单词。\nCBOWCBOW是用window outside word来预测center word的模型。模型的输入是one-hot context word vector ，输出是一个one-hot center word vector 。这是已知的量。\n未知的量的定义如下。首先是两个矩阵，其中d是一个定义了embedding space的大小。是input word matrix，的第列就是词表中的第个单词的词向量，它的大小是。同样的是output word matrix，的第行就是词表中的第个单词的词向量。从这里就可以看出，我们实际上为每个单词学习到了两个embeded vector，一个是input word vector ，另一个是output word vector 。\n模型架构第一步，为落在window size中的context word生成one-hot word vector ，共2m个，维度为。\n第二步，将input word matrix与one-hot context word vector相乘获得embedded word vectors，如单个词的结果为。\n\n这就是Keras等框架中所谓的embedding层，以one-hot为输入、中间层节点维字向量维数的全连接层，全连接层的参数就是一个字向量表。\n因为one-hot型矩阵与其他矩阵相乘，操作就相当于查表，而不是真正的矩阵运算，所以运算量很低。\n\n如果我们把2m个one-hot向量放在一起组成一个维度为的矩阵来考虑，就可以获得。\n第三步，将所有第二步获得的vectors求平均，，维度为。\n第四步，生成一个score vector，。\n第五步，将score vector中的每一个cell值用softmax变为probability，。\n第六步，将中对应为，就是把最大值所在的cell变为1，其余小值全变为0，这样子变换后输出也是一个one-hot vector。\n如何训练现在我们已经知道了在拥有input word matrix和output word matrix的情况下，模型如何运作了。但是如何获得这两个矩阵，如何学习到这些参数呢？通常我们希望从一个实际存在的概率分布中学习到一个概率分布模型，我们通过减小实际分布与概率分布模型的距离来找到最优解。这里使用cross entropy 来measure the distance between two probability distribution。\n对于这个例子，我们输出的向量是一个one-hot向量，可以去掉sum符号。在下面这个式子中，我们用代表我们希望模型的结果是1的正确的单词。如果预测的对应到了应该出现的单词，那么。带入下面这个式子，交叉熵就是0，这种情况没有loss或penalty。但是如果模型预测的很糟糕，假设正确的词所在输出向量的概率为，那么带入下面的式子交叉上就会为4.6左右。\n\nH(\\hat{y}, y) = -\\sum_{j=1}^{|V|} y_j \\log(\\hat{y}_j) = - y_j \\log(\\hat{y}_j)因此我们的目标函数就是：\n\n\\begin{array}{ll}\n\\text{minimize}\\space J \\\\\n= -\\log{P(w_c|w^{(c-m)}, …, w^{(c-1)}, w^{(c+1)}, … , w^{(c+m)})} \\\\\n= -\\log P(u_c|\\hat{v}) \\\\\n= - \\log \\frac{\\exp(u_c^T \\hat{v})}{\\sum_{j=1}^{|V|}\\exp(u_j^T \\hat{v})} \\\\\n= - u_c^T \\hat{v} + \\log \\sum_{j=1}^{|V|}\\exp(u_j^T \\hat{v})\n\n\\end{array}skip-gramskip-gram是用center word来预测window outside word的模型，和CBOW的区别是，CBOW中的输入现在是Skip-Gram的输出。对于skip-gram的输入，我们用来表示，因为center word只有一个，依然是one-hot vector；输出向量用来表示，有多个。同样定义两个矩阵。\n模型架构第一步，生成输入的center word的one-hot vector 。\n第二步，将input word matrix 与输入向量相乘，获得embedded word vectors。\n第三步，由于输入向量只有一个，不像CBOW一样需要averaging，直接令。\n第四步，用input word matrix 与相乘，即获得2m个score vectors 。\n第五步，使用softmax将score转为概率。\n第六步，我们希望产生的中概率最大的位置和真实位置相对应。\n\n如何训练首先定义两种类型的单词，一个是center word ，另一个是context words。\n以skip-gram为例，我们希望从center word   推导出他的前后的单词个数。设定一个窗口大小m，窗口的大小决定了我们从center word   分别向前向后看多少个单词。例如，对于center word   的前一个位置的单词出现的概率为 。我们要预测的准，就希望前后窗口的所有单词的概率之积最大。即\n\nJ^{'}(\\theta) = \\prod_{t=1}^T \\prod_{-m \\leq j\\leq m} P(w^{t+j}|w^{t} ; \\theta)这里的就是我们要求的word2vec的向量表示。\n用log把乘积转变为和，并把max转换成min。\n\nJ(\\theta) = -\\frac{1}{T}\\sum_{t=1}^T \\sum_{-m \\leq j\\leq m} \\log{P(w^{t+j}|w^{t})}结合原始概率计算公式，对目标函数的求导，暂时不考虑前面的两个求和，从对数函数开始考虑。\n\n\\begin{array}{ll}\n\\frac{\\partial}{\\partial v_c} \\log{\\frac{\\exp(v_o^T v_c)}{\\sum_{w=1}^{V}\\exp(v^T_{w} v_c)}} \\\\ \n= \\frac{\\partial}{\\partial v_c} \\log{\\exp(v_o^T v_c)} - \\frac{\\partial}{\\partial v_c} \\log{\\sum_{w=1}^{V}\\exp(v^T_{w} v_c)} \\\\\n= eq1 - eq2\n\\end{array}分前后两个式子分别观察，可以看到log和exp是相互抵消的，对矩阵求微分。\n\neq1 = \\frac{\\partial}{\\partial v_c} \\log{\\exp(v_o^T v_c)} = \\frac{\\partial}{\\partial v_c} v^T_ov_c = v_o对于第二个式子，对最外层的log函数使用链式法则，需要注意应用了链式法则的sum中参数由w变为x，因为已经不是同一个了。\n\neq2 = \\frac{\\partial}{\\partial v_c} \\log{\\sum_{w=1}^{V}\\exp(v^T_{w} v_c)} = \\frac{1}{\\sum_{w=1}^{V}\\exp(v^T_{w} v_c)}\\frac{\\partial}{\\partial v_c}{\\sum_{x=1}^{V}\\exp(v^T_{x} v_c)}现在单独考虑partial开始的式子，将partial符号放到sum符号后面，对每一项求partial，并且在此应用链式法则。\n\n\\frac{\\partial}{\\partial v_c}{\\sum_{x=1}^{V}\\exp(v^T_{x} v_c)} = \\sum_{x=1}^{V}\\frac{\\partial}{\\partial v_c} \\exp(v_x^Tv_c) = \\sum_{x=1}^{V} \\exp(v_x^Tv_c) v_x将这个结果放回第二个式子中，可以得到\n\neq2 = \\frac{\\sum_{x=1}^{V} \\exp(v_x^Tv_c) v_x}{\\sum_{w=1}^{V}\\exp(v^T_{w} v_c)}注意到分母是一个常数，因此可以进一步化简为\n\neq2 = \\sum_{x=1}^{V} \\frac{\\exp(v_x^Tv_c) v_x}{\\sum_{w=1}^{V}\\exp(v^T_{w} v_c)} = \\sum_{x=1}^{V} P(x|c)v_x我们发现eq2中sum的对象形似softmax，可以看作是所有context vector 与它出现在center word 前后的概率的乘积之和，就相当于expectation of all context vectors weighted by their likelihood of occurence.\n总的求偏微分后的结果为\n\n\\frac{\\partial}{\\partial v_c} \\log{\\frac{\\exp(v_o^T v_c)}{\\sum_{w=1}^{V}\\exp(v^T_{w} v_c)}} = v_o - \\sum_{x=1}^{V} P(x|c)v_x怎么理解这个式子？主要由两部分组成，第一项是正确的target word的positive reinforcement，第二项是词表中所有其他词汇的一个negative reinforcement，意义是服从分布的所有词向量的期望。这对接下来训练优化方式的的方向至关重要，很多训练优化都致力于让第二项negative reinforcement更容易计算。\n训练优化方式我们注意到是一个十分大的数，理论上来说，我们要获得词表的socre vectors，即每一个单词的score，还要做summation，这个步骤十分消耗资源。\n下面所有的优化，都在尝试用其他方法逼近softmax的效果。大致有两种方向。第一种是在softmax的基础上改良，如hierarchical softmax。第二种是以sampling为基础的新方法，这种方法完全抛开了softmax层，但效果和softmax一样好，如negative sampling和noise contrastive sampling。\n\n注意！sampling-based approach只能在训练的时候去使用，在验证的时候还是需要老老实实使用softmax。\nWhile the approaches discussed so far still maintain the overall structure of the softmax, sampling-based approaches on the other hand completely do away with the softmax layer. They do this by approximating the normalization in the denominator of the softmax with some other loss that is cheap to compute. \n\nnce loss/noise contrastive estimationNCE loss的直观想法就是把多分类问题转化为二分类问题，词表中的每一个word都代表着一个class，随着词汇量的增多，就要求模型具备从好多个class判断的能力，计算量非常大。为了实现不计算所有class的probability，但同时能在训练时给予一个合理的loss，这就引入了NCE loss。\nNCE做的就是让模型具备区分真实数据和噪声做出来的假数据的能力，和GAN有点相似。对于每一个单词，它的context 由n个单词构成，我们从a noise distribution Q中生成k个噪声样本。\n我们要实现一个二分类的任务，因此需要需要给每一个正确的单词以及匹配的context 一个正确的label y=1，来自于训练数据集的真实分布；而噪声样本就是错误的lable y=0，来自于噪声分布。从这两个分布中进行采样。\nNCE loss function因此重新定义目标函数NCE loss function。为了避免计算每一个word的概率，使用蒙特卡洛近似用均值去代替原式子中的期望。\n\n接下来尝试表示损失函数中的概率P。因为label y可能来自两个分布，并且一个真实的(x,y)对会跟随k个噪声分布产生的虚假的(x, y’)。因此有如下式子：\n\nP(y, w|c) = \\frac{1}{k+1}P_{\\text{train}(w|c)}+\\frac{k}{k+1}Q(w)于是，可以计算给定的条件下，一个采样从中获得的条件概率为：\n\nP(y=1|w,c) = \\frac{P_{\\text{train}(w|c)}}{P_{\\text{train}(w|c)}+kQ(w)}由于是二分类问题，label y=0的概率就是\n\nP(y=0|w,c) = 1 - P(y=1|w,c)由于实际上我们并无法获得真实训练数据的分布，因此考虑用probability of our model 去替代。\n因此，可得\n\nP(y=1|w,c) = \\frac{P(w|c)}{P(w|c)+kQ(w)}注意到，就是文章最开始提到的给定词的上下文词的概率（the probability of a word given its context c），也是一个softmax公示。\n\nP(w|c) = \\frac{\\exp(h^Tv_{w}^{'})}{\\sum_{w_i\\in V}\\exp(h^Tv_{w_i}^{'})} = \\frac{\\exp(h^Tv_{w}^{'})}{Z(c)}将分母用代表，而要求分母意味着又要计算每一个单词的概率，如何简化？有两种方式，一种是将作为一个参数去学习，另一种是直接固定为值1。\n把固定为1后，重新写出。\n\nP(y=1|w,c) = \\frac{\\exp(h^Tv_{w}^{'})}{\\exp(h^Tv_{w}^{'})+kQ(w)}代入NCE loss function可以获得最终的结果。\n\n\n文章存疑？：It can be shown that as we increase the number of noise samples kk, the NCE derivative tends towards the gradient of the softmax function.\n\nnegative sampling/NEG每一个训练阶段，不要遍历所有的词汇，而是采几个负样本。思想是We “sample” from a noise distribution  whose probabilities match the ordering of the frequency of the vocabulary。负采样可以看作是NCE的一种再近似。\n和NCE不同的是，在计算the probability that a word  comes from the empirical training distribution  given a context  as\n\nP(y=1|w,c) = \\frac{\\exp(h^Tv_{w}^{'})}{\\exp(h^Tv_{w}^{'})+kQ(w)}NEG直接把分母的，为\n\nP(y=1|w,c) = \\frac{\\exp(h^Tv_{w}^{'})}{\\exp(h^Tv_{w}^{'})+1} = \\frac{1}{1+\\exp(-h^Tv_{w}^{'})}这么做的根据在哪里？第一，在极限情况且为均匀分布/uniform distribution的时候，NEG就等于NCE；其他情况下NEG只是NCE的近似，这意味着NEG并不会直接最优化correct words的likelihood。第二，这种情况下这个条件概率可以上下同时除以exp，获得一个sigmoid形式的结果。并且求label为0的时候的概率表达式也会简单很多。\n最终NEG loss function结果如下。\n\n参考word2vec初步认识莫烦 Python教学 Continuous Bag of Words (CBOW)\n word2vec中的数学原理详解\nword2vec架构解析cs224d的note\nword2vec训练词向量的转换过程\nword2vec是如何得到词向量的？ - crystalajj的回答 - 知乎\nword2vec训练优化Understanding tf.nn.nce_loss() in tensorflow\n通俗易懂的NCE Loss\nOn word embeddings - Part 2: Approximating the Softmax\nsoftmax与交叉熵的关系CS231n课堂笔记sotmax讲解\nword2vec、词向量、Embedding层苏神博客-词向量与Embedding究竟怎么回事？\n","categories":["NLP"],"tags":["NLP","词向量","word2vec"]},{"title":"如何使用Vue框架的记录","url":"/2020/10/17/learn-vue/","content":"创建Vue应用使用const app = Vue.createApp(&#123;&#125;)创建Vue应用，在创建完Vue应用之后，还要利用app.mount(&quot;#vue-app&quot;)把当前Vue应用mount/挂载到对应html节点中去，而html节点用id唯一标识&lt;div id=&quot;vue-app&quot;&gt;&lt;/div&gt;。\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;vue-app&quot;&gt;&lt;/div&gt;    &lt;script&gt;      const app = Vue.createApp(&#123;        template: &quot;&lt;div&gt;&lt;h1&gt;HI&lt;/h1&gt;&lt;/div&gt;&quot;,      &#125;);      app.mount(&quot;.vue-app&quot;);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n其实只要是一个选择器都能实现挂载，利用class对应点选择器也能实现挂载，问题在于一个class可以对应到多个html标签，而使用id是因为id的唯一性。因此约定都适用id选择器和标签的id属性。\ntemplate syntax在创建template的时候，使用引号将html语言包裹起来，能正常加载，但是问题在于必须在一行内全部写完所有html内容，因此使用模版字符串中来实现分栏。\n\n\n\n\nVue.js使用了基于HTML的模版语法，利用模版字符串可以在Vue实例的template中直接写入合法的HTML。\n在HTML文件中，将想要传递简单值值的属性用双括号(“Mustache” Syntax)包裹（如果是复杂值参考computed attribute field）。但是只能在HTML元素两个尖括号之间使用，作为HTML元素内容。\n&lt;tag&gt;&#123;&#123; Mustache-Syntax &#125;&#125;&lt;/tag&gt;\n双括号既可以用在我们想要mount id特定的原生html中，也可以用在我们创建的Vue实例的template中。\ntemplate syntax和v-directive中的v-text很相似，但是v-text的问题在于不管template中父亲元素内部有什么内容，都会被v-text的内容替换/覆盖。\n生命周期钩子每个Vue实例被创建时都要经过一系列初始化过程， 而实例生命周期钩子就是在初始化过程中执行的函数，可以在特定的初始化阶段插入我们想要的代码。\nbeforeCreate(页面载入之前)/created(Vue实例被创建之后)，例子就比如在刚进入页面，或者刷新页面的时候。\nbreforeMount(挂载之前)/mounted(挂载成功)：如果在html元素内部有内容却没有在vue实例的template定义内容，那么将html元素的outerHTML编译成template；如果有template，将template编译成render function。\nmounted和beforeMount的例子就比如在页面间路由，如果从当前页面跑到另外一个页面去，那么当前页面的vue实例就会经历beforeUnmount以及unmounted，而去往的目的页面的vue实例就会经历beforeMount以及mounted。\nbeforeUpdate(数据改变，更新之前)/updated(更新完毕），例如用户在文本框输入了数据，传递到vue，那么就会重新渲染显示到页面。\n注意不能使用箭头函数来定义一个生命周期方法，因为箭头函数没有指向实例的this。\n生命周期函数定义在methods field中，以函数的形式定义。\n\nv- directives指定约定A directive’s job is to reactively apply side effects to the DOM when the value of its expression changes.\n指令是带有v-前缀的特殊的由vue来处理的attribute。指令接受单个JavaScript表达式（v-for和v-on除外）。attribute的值都需要从我们定义的vue实例中去寻找，而不是默认的DOM对象。\n\nDirectives are prefixed with v- to indicate that they are special attributes provided by Vue, and they apply special reactive behavior to the rendered DOM.\n\nVue为最常用的v-bind和v-on提供了缩写指令。v-bind语法中可以直接省去v-bind，直接在html标签中用冒号传参数:url/:[computed]；v-on可以用@符号替代v-on:，直接在html中用at符号和事件名@click/@[event]。\n修饰符 (modifier) 是以半角句号.指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。每个v-directive可用的修饰符见具体的说明模块。\nv-bind:实现值的绑定在v-指令后面添加一个冒号，让指令接受一个html attribute参数，v-指令会让该html attribute和等号后传入的单个JavaScript表达式的值绑定。（主要任务是绑定当前vue实例中的值）\nv-bind让我们把html field中任何一个attribute的值和定义在vuejs中的data联系起来，因为我们把value放在引号中，如果没有v-bind，html中的attribute会直接被理解为字符串值传递过去。比如href=”url”的意思就是href的值是url，而不是url这个变量所指向的具体的url地址。\n例如：\n&lt;a v-bind:href=&quot;url&quot;&gt; ... &lt;/a&gt;\n在这里 href 是参数，告知 v-bind 指令将该元素的 href attribute 与表达式 url 的值绑定。\n又如：\n&lt;a v-on:click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;\n在这里click监听事件名称是参数，告知v-on指令将该html元素的click事件与表达式doSomething回调函数绑定。\n实现属性的绑定既然属性值可以从vuejs的data中传递过来，那么属性是否也可以从vuejs的data中传递过来呢？通过方括号将变量括起来放到v-directive的冒号后面，vue首先会将方括号里的变量当作一个JavaScript表达式在vuejs的代码部分查找到匹配名字的变量后求值后再作为静态的html attribute传递给html（在vue的data field中定义这个属性一定要是字符串）与等号后JavaScript表达式值的绑定。\n例如：\n&lt;a v-bind:[attributename]=&quot;url&quot;&gt; ... &lt;/a&gt;\n如果[attributename]被求值出来的结果是一个null字符串，表示移除该绑定。\n在DOM中使用模版是（也就是直接在html文件中撰写模版）避免在方括号中使用大写字符，因为DOM会把代码转换为小写。如&lt;a v-bind:[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt;就会被自动转换为v-bind:[someattr]，除非js文件的vue实例中确实有return一个someattr，否则代码不会工作。\n不要在方括号内书写空格和引号，因为空格和引号在html的attribute名里都是无效的。\n绑定html class通过对象true/false切换class通过给:class一个对象，实现动态切换class。\nhtml class在该对象的object field中定义，而该class是否存在取决于该对象的obejct field value的truthiness。\n:class指令可以与html的普通的class共存。\n\n\n内联定义方式\n\n当然该对象可以直接内联定义在html template中，如：\n&lt;div :class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;&gt;&lt;/div&gt;\n\n\n解耦定义方式\n\n也可以在vue实例的data field中return，如html中定义：\n&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;\n并在JavaScript中定义：\ndata() &#123;  return &#123;    classObject: &#123;      active: true,      &#x27;text-danger&#x27;: false    &#125;  &#125;&#125;\n通过数组值应用多个class可以把一个数组传给 :class，以应用一个 class 列表。\n&lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;\ndata() &#123;  return &#123;    activeClass: &#x27;active&#x27;,    errorClass: &#x27;text-danger&#x27;  &#125;&#125;\n这两个部分组合起来渲染结果就是\n&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;\n绑定html style和绑定html class遵循相似的方式，对象语法和数组语法都可以。\nv-model表单输入双向绑定v-bind和v-model的区别v-bind虽然能够实现js中的数据传递向html（也就是视图），但是用开发工具查看当用户在视图上的input框里输入的内容是不会自动同步到js中去的，也就是说这是一个单向绑定。\n如果实现双向绑定，直接使用v-model，v-model隐含的语义就是在v-bind实现的单项数据基础上，再把反向增加一个数据流，作用的属性是value。\nv-model的具体使用v-model指令用于表单input textarea 以及 select元素上创建和JavaScript的data对象的双向数据绑定。\nv-model会忽略HTML文件中表单元素的各种属性的初始值，只会依据JavaScript文件中的实例数据作为初始数据来源。\n\n\n\n\nTag\nProperty\nEvent\n\n\n\n\ntext/textarea\nValue\nInput\n\n\ncheckbox/radio\nChecked\nChange\n\n\nselect\nValue\nChange\n\n\n\n\n选择框单选时需要注意提供一个值为空的初始禁用选项，选择框多选时绑定到一个数组。\n使用v-model修饰符v-model的绑定是默认用户在focus时每次输入都要vue去响应去同步，这是很不高效的。因此就有了v-model.lazy修饰符，这告诉vue，等用户的focus从当前表单输入离开了之后，你再去更新vue实例反向的数据流。\n有时候用户会在输入文本头尾添加无意义的空格，我们不希望接受这些无意义的输入，因此就有了v-model.trim修饰符，这告诉vue，你把用户输入的头尾空格都修剪掉在作为同步到vue实例对应的地方去储存值。\n默认接受用户输入是字符串格式，有时候希望把字符串作为number形式储存在vue 实例中，因此就有了v-model.number修饰符。\nv-once一次性渲染DOMv-once 代表只在DOM中渲染一次该组件，但是该组件中涉及的数据仍然由vue组件管控，会在vue devtools的data field中（如果有的话）被更新。但是被v-once标记的元素不会再初始渲染后再次重新渲染。\nv-html在template中插入html代码在template中的元素上使用v-html会告诉vue，父亲标签里面的字标签应当被当作原生html渲染。\n&lt;template&gt;  &lt;h1 v-html=&quot;title&quot;&gt;&lt;/h1&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data()&#123;    return &#123;      title: &quot;&lt;h1&gt;Hey Vue3&lt;/h1&gt;&quot;,    &#125;  &#125;&#125;&lt;/script&gt;\nv-if v-else-if v-else条件渲染 v-if option的使用决定了这个标签是否会被销毁或者再造，即是否存在于DOM树中。如有必要还可以和v-else-if v-else紧邻配对使用。\nv-if option只能加载一个单独的元素标签上，如果要对好多个元素标签使用条件渲染，应该把需要条件渲染的所有元素标签都放在&lt;template v-if=&quot;??&quot;&gt; &lt;\\template&gt;标签中。\n不推荐一起使用v-if和v-for。因为当二者存在于同一个元素节点上时，v-if有更高的优先级，总是先测试它。因此v-if没有权限访问v-for作用域内的变量。\nv-showCSS切换使用了v-show option的元素总是会被渲染并且留在DOM中，它的作用仅仅是切换CSS property是否display。给插入的父亲标签添加一个&lt;h1 style=&quot;display: none;&quot;&gt;这里是script中的template的内容&lt;/h1&gt;\nv-for多选素渲染使用v-for来循环渲染包含多个元素的内容，可以是遍历数组元素，也可以是遍历对象属性。\nVue使用v-for进行渲染的时候，默认使用就地更新(in-place patch strategy)。如果数据项的顺序改变，Vue不会移动DOM元素来匹配数据项的顺序，而是就地更新，并确保它们在每个索引位置正确渲染（因此会造成不必要的渲染）。因此，为了确保Vue正确识别节点，在使用v-for的时候带上v-bind:key=&quot;&quot;。\n修饰符modifiers.lazy在Change事件之后进行同步，（比如，不是在用户选中对话框且输入时就同步，而是用户光标离开对话框后再同步）\n.number自动将用户的输入值转为数值类型\n.trim自动过滤用户输入的收尾空白字符\nv-on事件监听利用v-on: event-listener=&quot;&quot;(short for @event-listener=&quot;&quot; )。\n赋值语句后跟一个javascript简单语法（这个语句和在vue实例中执行的语句有相同的效果比如@submit.prevent=&quot;newHero = &#39;Wonder Woman&#39;&quot;就是可以的），或者就是在js文件的methods field中预先定义好的（带参数的）回调函数。\n当在HTML的内联语句中需要访问原始的DOM事件时，可以将原始DOM事件利用$event特殊变量传入回调函数中。\n对于一个事件的多个事件处理函数用逗号分开回调函数。\nv-on修饰符在事件处理函数中经常需要调用 event.preventDefault() 或者 event.stopPropagation()。这属于DOM细节的考虑范畴，因此通过事件修饰符将这个操作框定在html中。虽然可以在Vue的methods中去实现，但methods更多需要处理的事数据逻辑而非DOM细节。由此引入事件修饰符，directive.postfix-event-modifiers。\n\n.stop\n.prevent在DOM中如果发生了表单提交行为，是默认会重新刷新当前网页，并且路径会变成http://localhost:8080/?，这意味着表单提交了，我们不希望这样的默认行为发生，因此引入了v-on:submit.prevent这样的修饰符，vue会阻止DOM在发生了submit事件是自动提交表单刷新页面的行为。\n.capture\n.self\n.once 点击事件只触发一次，也可以被用到component events中\n.passive 相当于addEventListener的passive选项，执行事件的默认行为\n\n监听键盘事件时需要检查详细按键，Vue允许为v-on在监听键盘事件时添加按键修饰符。将KeyBoardEvent.key中规定的任意有效按键名转换为kebab-case(短横线形式)作为按键修饰符即可。\n&lt;input v-on:keyup.page-down=&quot;onPageDown&quot;/&gt;//处理函数只会在$event.key等于PageDown时才会被调用。\nvue组件实例全体field约定创建组件实例通过调用Vue.createApp(&#123;&#125;)方法来实现，通过给它添加data/computed/watch/methods/lifecycle-hooks这些field来描述他的数据和数据操作。\nconst app = Vue.createApp(&#123;&#125;)const vm = app.mount(&#x27;#app&#x27;)\n在JavaScript文件中定义的组件通过const vm = app.mount(&#39;#app&#39;)的mount方法挂载到对应的html中去。\nVue 使用 $ 前缀通过组件实例暴露自己的内置field。它还为内部 property 保留 _ 前缀。\nfield中的所有return{}的内容都可以在挂载后的html中直接访问到，无需经过该field。\nVue中所有field内，this都指向当前组件实例。\ndata field约定const app = Vue.createApp(&#123;    data() &#123;        return &#123;            property1: value1        &#125;    &#125;&#125;)\n实例中的data()是一个function，每当新建一个实例，Vue就会调用这个函数。\n我们需要保证所有需要用到的数据都在data()函数的return&#123;&#125;中，因为这些实例属性(instance properties)只会在instance第一次被创建的时候被Vue的响应式系统记录在$data对象中。如果存在一些属性你不知道他一开始要取何值，用null undefined占位。\n访问/修改Vue实例中的data部分，可以通过两种形式的点访问法：vm.$data.property1或着vm.property1。\n通过以上两个方式修改的vue实例的data部分都会同步到实例中去。而实例属性的变化会对应的渲染到视图UI中去，这属于响应式更新。\n但是，只有Vue实例被创建时已经存在于数据对象中的属性才是响应式的。通过使用Object.freeze(data)会阻止修改data中已有的property，意味着响应系统无法再追踪变化。\nmethods field约定在Vue实例的methods field内部可以有多个方法，一般结合@[event]/@click之类的v-指令当作事件监听的回调函数使用。\n如果method方法内部有用到任何data field中的响应式数据，那么method会自动把响应式数据作为渲染依赖项进行跟踪。\n用this指向当前实例，因为Vue自动将this和当前实例绑定在了一起。注意不要使用箭头函数，默认情况下Vue的自动绑定this执行环境，但在箭头函数中没有指向该vue实例的this，但我们在methods中需要用到vue实例中的data function里面的数据，并且每一次使用vue实例中的数据都要在this.variablename。\nmethod中的方法不应该包含异步操作？或者说不应该调用它？，异步操作应该出现在生命周期钩子中。\ncomputed attribute field约定我们使用Mustache Syntax的时候建议在花括号内仅存放简单表达式，如果花括号内的template syntax不再简明易懂，即复杂到包含了reactive data的情况下，需要使用计算属性。 \n计算属性是Data和Methods这两个field之间的一个中间量。\n把复杂表达式抽象成一个函数，在in-template expression中只使用这个函数名&#123;&#123;complex-expression&#125;&#125;，在JS中添加如下\nVue.createApp(&#123;     computed: &#123;        // a computed getter        // no side effects        complex-expression()&#123;    \t// `this` points to vm instance    \t\treturn this.????    \t&#125;    &#125;&#125;)\ncomputed与method比较为什么这个函数放在computed option中而不是methods option中？\n\n计算属性的值依赖于表达式中的reactive data。\nreactive data的变化会让该计算属性的值自动更新。\n一方面，如果reactive data没有变化，那么计算属性会一直使用上一次计算过的缓存的值。\n另一方面，如果依赖的值不是reactive data，那么计算属性的值无论如何都不会改变。\n\nComputed properties are cached based on their reactive dependencies.\n计算属性的值是通过基本的、简单的属性值计算而来的，这些用于计算的属性值就是这里所说的reactive dependency。\n\n\n如果将属性计算通过方法定义，就意味着每一次Vue实例的重新渲染都会导致函数（可能是不必要的）调用。\n\n\ngetter &amp; setter在上面的例子中通过简单的计算return一个项目的时候，我们其实是在定义一个getter。在有必要时也可以提供一个setter，修改属性。\ncomputed: &#123;  fullName: &#123;    // getter    get() &#123;      return this.firstName + &#x27; &#x27; + this.lastName    &#125;,    // setter    set(newValue) &#123;      const names = newValue.split(&#x27; &#x27;)      this.firstName = names[0]      this.lastName = names[names.length - 1]    &#125;  &#125;&#125;\n在html中用mustache syntax访问fullName会调用get()，而在javascript中调用vm.fullname=’John Doe’时就会调用set()函数。\nwatch field适用于执行数据变化的异步或开销较大的操作，需要谨慎使用。\n对于数据改变所引起的其他数据的改变，选择使用计算属性而非侦听器。\n在watch内部定义一个接受依赖数据项作为参数的函数，当这些依赖数据项发生改变的时候，该定义在watch内的函数就会运行。这个函数可以调用methods中定义的异步函数。\nemits field自定义事件详情见组件-emit实现自底向上数据流-利用emits field自定义事件。\nrefs field获得元素引用相当于DOM中的getElementByXX中获取html元素的方法。只需要在vue实例的template中为组件添加&lt; ref=&quot;RefName&quot;/&gt;属性，双引号中即为ref名。当我们在当前实例中需要获得这个元素的时候，只需要使用this.$refs.RefName就可以获得元素的引用并在该元素上添加方法。\n例如，我们为表单的input添加一个名为InputRef，并且希望在当前页面挂载的时候自动聚焦到当前页面，那么在script的mounted field中需要使用mounted() &#123;this.$refs.InputRef.focus();&#125;让输入文本框自动聚焦。\n组件Since components are reusable instances, they accept the same options as a root instance, such as data, computed, watch, methods, and lifecycle hooks.\n在HTML文件中被当做可以被重复利用的用户自定义元素(custom element)。\n创建自定义组件的两种方式全局注册const app = Vue.createApp(&#123;&#125;) //根组件 root instanceapp.component(&#x27;component-name&#x27;, &#123;&#125;)//全局自定义组件，即root instance的custom elementapp.mount(&#x27;#components-demo&#x27;) // 挂载root instance\n这样子的调用默认是全局注册的组件(根实例的子实例)，可以被根实例中的template和根实例中的所有其他子组件使用。\n挂载后的root instance通过id绑定到html中去，在root instance的内部，可以像一个自定义组件custom element一样去使用用.component(&#39;&#39;,&#123;&#125;)定义的全局注册的组件，自定义的html标签就是传入component的第一个字符串。\n&lt;div id=&quot;components-demo&quot;&gt;  &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt;\n局部注册全局注册往往是不够有效率的，因为全局注册的组件意味着就算它不再被使用，它仍然会被包含在最终的构建结果中，这会造成用户下载多余的JavaScript代码。\n可以通过一个JavaScript对象来定义组件，并在父组件的components field中用绑定使用。任何一个组件想要使用另外一个局部注册的、通过对象定义的组件，都需要把它绑定到components field中后才可以访问。\nconst ComponentA = &#123;&#125;// 在根组件中绑定局部注册的组件const app = Vue.createApp(&#123;    components: &#123;        &#x27;component-a&#x27;: ComponentA    &#125;&#125;)// 在其他局部注册的子组件中绑定另一个局部注册的子组件const ComponentB = &#123;    components: &#123;        &#x27;component-a&#x27;: ComponentA    &#125;&#125;\n使用了ES6/Babel/webpack等模块系统中的局部注册建议把所有局部注册的组件都放置在components目录中，如果组件A的定义需要使用到同层级的组件B和组件C，需要在局部注册组件A之前导入同级别文件夹下的组件B和组件C，过程如下：\n// current file is ComponentA.vue or ComponentA.jsimport ComponentA from &#x27;./ComponentB&#x27;import ComponentC from &#x27;./ComponentC&#x27;export default &#123;  components: &#123;    ComponentB,    ComponentC    // 注意以上写法其实是ComponentB: ComponentB的缩写  &#125;  // ...&#125;\n自定义组件名的两种方式kebab-case第一种是kebab-case，遵循W3C规范，即字母全部小写且必须包含连字符，如&lt;my-component-name&gt;。\nPascalCase第二种是PascalCase，即首字母大写命名组件，如&lt;MyComponentName&gt;。\n直接在dom中使用自定义组件时（即非字符串的模版），只有kebab-case有效。\n非prop的attribute这里所说的非prop的attribute，就是那些在定义vue组件时，没有在props field和emits field中定义的attribute；也可以说是html标签自带的诸如class/style/id之类的属性。\n如何访问如何访问这些非prop的attribute？在vue组件内部调用this.$attr就可以访问。\nroot element的attribute inheritance在js文件中定义组件时返回的是单个根节点时，在html文件中调用vue组件时定义的非prop的attribute将在vue的渲染结果中自动添加到根节点去。\n以下是在js文件中定义组件：\napp.component(&#x27;date-picker&#x27;, &#123;  template: `    &lt;div class=&quot;date-picker&quot;&gt;      &lt;input type=&quot;datetime&quot; /&gt;    &lt;/div&gt;  `&#125;)\n以下是在html文件中调用组件：\n&lt;date-picker data-status=&quot;activated&quot;&gt;&lt;/date-picker&gt;\n以下是vue经过一系列操作的结果：\n&lt;div class&#x3D;&quot;date-picker&quot; data-status&#x3D;&quot;activated&quot;&gt;  &lt;input type&#x3D;&quot;datetime&quot; &#x2F;&gt;&lt;&#x2F;div&gt;\n如果有单个根节点，绑定的非prop的attribute自动添加到渲染后的html的根节点。\n如果有vue组件返回多个根元素，必须在定义vue组件时显式地在某个根元素上v-bind: &quot;$attrs&quot;。否则会有runtime warning。\n禁用attribute inheritance如果不希望根元素自动属性继承，需要在定义vue组件时inheritAttrs：false。\n在禁用根元素的元素继承的同时，我们又希望根元素内的其他元素去继承这个非prop的attribute，如何控制？需要使用v-bind方法和当前组件的$attr属性，这个属性会自动包括除了vue组件内部定义的prop field和emits field内的所有属性。\n以上两个操作都是在vue组件所在js文件中完成的。\napp.component(&#x27;date-picker&#x27;, &#123;  inheritAttrs: false,  template: `    &lt;div class=&quot;date-picker&quot;&gt;      &lt;input type=&quot;datetime&quot; v-bind=&quot;$attrs&quot; /&gt;    &lt;/div&gt;  `&#125;)\nprops实现自顶向下的数据流\nProps are custom attributes you can register on a component. When a value is passed to a prop attribute, it becomes a property on that component instance. \n\n怎么解释props的出现？就比如html的a标签有src属性，这里自定义的组件使用方式也就是html的某种标签，既然是用户自定义元素，那么应当也有用户自定义元素属性。props定义了这个自定义元素有什么属性，通过给这个属性传值，将数据从View/UI/html传递到Model/data/JavaScript。\n用字符串数组定义prop在定义组件的时候直接引入一个props: []选项即可。如：\nconst app = Vue.createApp(&#123;&#125;)app.component(&#x27;blog-post&#x27;, &#123;  props: [&#x27;title&#x27;],  template: `&lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;`&#125;)app.mount(&#x27;#blog-post-demo&#x27;)\n在html中的使用遵循如下形式：\n&lt;div id=&quot;blog-post-demo&quot; class=&quot;demo&quot;&gt;    &lt;!--首先要把自定义组件包裹在mount id下的对应根组件中--&gt;   &lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;    &lt;!--自定义组件的props可以当作元素标签的attribute使用--&gt;   &lt;blog-post title=&quot;Blogging with Vue&quot;&gt;&lt;/blog-post&gt;  &lt;blog-post title=&quot;Why Vue is so fun&quot;&gt;&lt;/blog-post&gt;&lt;/div&gt;\n\n当然，这些数据最好和View/UI/html分开存放比较好，根组件的data field可以用来存放这些数据。\n因此，整个过程就变成了：首先，在JavaScript中定义根组件和子组件的各个field；其次，在HTML中调用JS文件中定义组件，通过已有html tag的id/class属性或者自定义的custom element attribute绑定数据，数据来自于JavaScript文件的根实例。\n\n用对象列出prop通常会为每个prop都指定取值类型，对象中的每一个名称和值分别时prop各自的名称和类型，如\nprops: &#123;  title: String,  likes: Number,  isPublished: Boolean,  commentIds: Array,  author: Object,  callback: Function,  contactsPromise: Promise // 或任何其他构造函数&#125;\n如果想把一个对象的所有property都当作prop传入，使用不带参数的v-bind取代v-bind:prop-name即可，如\npost: &#123; //这个对象的所有property都要传入  id: 1,  title: &#x27;My Journey with Vue&#x27;&#125;\n在html中调用如下：\n&lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt;\n这个表达式就等价于：\n&lt;blog-post v-bind:id=&quot;post.id&quot; v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;\nprop验证为组件的prop指定验证的要求，比如说基础的类型检查（包括String/Number/Boolean/Array/Object/Date/Function/Symbol基本类型，以及自定义的构造函数），是否有必填的字符串，是否带默认值，自定义验证函数等功能。验证内容都是对当前prop的描述，也就是一种元数据的概念（描述数据的数据）。\n前面提到的用对象列出prop，提供了最简单的prop类型检查，如果在props field中定义的prop名称后面跟一个花括号包裹的对象，就能实现prop验证。\napp.component(&#x27;my-component&#x27;, &#123;  props: &#123;    // 基础的类型检查     // (`null` 和 `undefined` 会通过任何类型验证)    propA: Number,    // 多个可能的类型    propB: [String, Number],    propF: &#123;      validator: function(value) &#123;        // 这个值必须匹配下列字符串中的一个        return [&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27;].indexOf(value) !== -1      &#125;    &#125;,  &#125;&#125;\n注意prop的验证会在组件实例创建之前进行，因此实例的data/computed等field中涉及的变量在prop验证中不能使用。\nprop书写约定因为在HTML中attribute名是大小写不敏感的，因此浏览器会把所有大写字符全部解释为小写字符，因此在JavaScript中使用的camelCase应用到HTML中就变成对应的kabab-case。\n父子组件prop的单向下行绑定这里的单项数据流是从父组件的prop流动到子组件的prop，也就是说：父级prop的更新会向下流动到子组件中，每一次父组件发生变更时，子组件的所有prop都会刷新为最新的值；子组件不应该变更父组件的状态。\n\n虽然子组件不应该变更父组件的状态，但也是可以实现改变的，因为JavaScript的对象和数组是通过引用传入的。\n如果在子组件上变更对象或数组定义的prop本身，父组件的状态就会被改变，Vue也会在控制台发出警告。\n\n当尝试在一个子组件内部改变prop时，不要直接对props field中的原始prop进行变更，因为这个prop时从父组件中传递过来的，或者是从View/UI/html中传递过来的。\n当需要直接利用prop中的数据时，正确的做法是在当前组件的data field中定义一个新的data property（用react中的说法也就是当前state），并用this.prop作为它的初始值。\nprops: [&#x27;initialCounter&#x27;],data() &#123;  return &#123;    counter: this.initialCounter  &#125;&#125;\n当需要经过某些计算再利用prop中的数据时，正确的做法是在当前组件的computed field中定义一个新的computed property，并用this.prop经过一系列的运算后返回想要的数据。\nprops: [&#x27;size&#x27;],computed: &#123;  normalizedSize: function () &#123;    return this.size.trim().toLowerCase()  &#125;&#125;\nemit实现自底向上的数据流事件名称约定不像components和props会自动在各种书写方式之间自动转换，事件名称在js文件中被emit的时候的名称必须和在html文件中被监听的名称一致。\n// my-compoennt.vuethis.$emit(&#x27;my-event&#x27;)\n&lt;my-component @my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt;\n如果定义的时候使用camelCase/PascalCase，在监听的时候却又使用kebab-case，是不会有效果的。\n所以总是建议使用kebab-case来定义事件名称。\nemit作用emit的作用是什么？\n在子组件上通过emit定义一个事件/注册一个事件，如果父组件/父亲页面的.vue文件中的该子组件被点击了，就可以监听该事件，然后调用event handler，并且事件处理函数可以使用父亲页面/父亲组件中的数据去处理子组件上的事件。\n比如，html中button这个元素本身就有click事件，我们直接使用了button这个元素和click这个事件。按照vue的思考方式，在button这个组件内部定义好了button本身以及click事件。因此我们才可以在html中使用这个元素并且监听这个事件。\n总结：emit能够在组件上自定义事件供父组件监听发生在该组件上的行为并添加回调函数，虽然组件上的自定义事件很有可能也是通过默认事件如click触发，但是emit可以放在method中中供其他method调用，比如用户点击了某个组件就出发一个窗口消失的emit事件，或用户完成登陆之后在method中自动emit一个窗口消失的事件。\n实现emit某个子组件与用户发生了某种交互，或者说用户给子组件传递了某些值，子组件此时需要emit an event on itself by calling the built-in $emit method, passing the name of the event，如：\n&lt;button @click=&quot;$emit(&#x27;enlarge-text&#x27;)&quot;&gt;  Enlarge text&lt;/button&gt;\n当然也可以把$emit(‘enlarge-text’)抽象到methods中的某个函数去，当调用这个函数的时候就有这个事件，而不必须发生click。\nmethods: &#123;  close() &#123;    this.$emit(&quot;enlarge-text&quot;);    &#125;,&#125;\n而父组件可以通过v-on或者@标志来监听子组件上的任何事件，如：\n&lt;blog-post ... @enlarge-text=&quot;postFontSize += 0.1&quot;&gt;&lt;/blog-post&gt;&lt;blog-post ... @enlarge-text=&quot;onEnlargeText&quot;&gt;&lt;/blog-post&gt;\n事件发生在子组件上，但是这个事件通过v-on/@标志被传递到了父组件上，且回调函数却是由父组件定义的，或者可以直接用methods field中定义的函数。\n\n在定义子组件的时候提供emits选项，方法如下：\napp.component(&#x27;blog-post&#x27;, &#123;  props: [&#x27;title&#x27;],  emits: [&#x27;enlarge-text&#x27;]&#125;)\n\nemit an event’s value有时候需要在子组件中emit一个定义在父组件上的事件，并向父组件传递一个参数，例如：\n&lt;button @click=&quot;$emit(&#x27;enlarge-text&#x27;, 0.1)&quot;&gt;  Enlarge text&lt;/button&gt;\n在父组件中，可以通过$event访问到这个event value。\n&lt;blog-post ... @enlarge-text=&quot;postFontSize += $event&quot;&gt;&lt;/blog-post&gt;\n利用emits field自定义事件在定义组件的时候在emits field中用数组或者对象的形式定义custom events，只要出现在emits field中，就是自定义事件。custom event会覆盖native event。\n建议所有的emitted event都定义在emits field中。\narray syntax(not recommended)app.component(&#x27;custom-form&#x27;, &#123;  emits: [&#x27;in-focus&#x27;, &#x27;submit&#x27;]&#125;)\nobejct syntax to validate通过数组array syntax定义的事件不能被validate，因此建议使用对象object syntax。\nevent name在object中就变成了key，对应value是一个验证函数，该函数接受传递给$emit call的payload作为参数，对参数进行操作后返回boolean值去验证这个事件是有效还是无效的。如果不希望event有验证，直接讲key对应value取null。\napp.component(&#x27;custom-form&#x27;, &#123;  emits: &#123;    // No validation    click: null,    // Validate submit event    submit: (&#123; email, password &#125;) =&gt; &#123;      if (email &amp;&amp; password) &#123;        return true      &#125; else &#123;        console.warn(&#x27;Invalid submit event payload!&#x27;)        return false      &#125;    &#125;  &#125;,  methods: &#123;    submitForm() &#123;      this.$emit(&#x27;submit&#x27;, &#123; email, password &#125;)    &#125;  &#125;&#125;)\n插槽slots插槽就是在js文件中定义vue组件的template field中插入的一个标志元素，形如&lt;slot&gt;&lt;/slot&gt;。当在html文件中调用该vue组件时，直接在vue组件开闭合标签内添加想要插入的内容，该内容就会替代原js template中的插槽。\n\n注意如果希望不是用插槽，那么调用vue组件的开闭合标签内不能有任何文字，甚至是comment也不行。\n\n插槽也能够在指定渲染域中访问数据，该渲染域是和它在同一DOM树层级的兄弟节点，也就是说插槽不能访问父亲节点中的数据。\n&lt;todo-button action=&quot;delete&quot;&gt;  Clicking here will &#123;&#123; action &#125;&#125; an item  &lt;!--  The `action` will be undefined, because this content is passed  _to_ &lt;todo-button&gt;, rather than defined _inside_ the  &lt;todo-button&gt; component.  --&gt;&lt;/todo-button&gt;\n之前讨论的插槽标签之间都是空内容的，有时候为一个插槽提供后备内容fallback content也很有用，该内容会在html文件调用该组件没有传入内容时被渲染。&lt;slot&gt;Submit&lt;/slot&gt;这个时候Submit就是后备内容。\n当需要多个插槽的时候，需要在js文件中定义组件时给每一个插槽一个name attribute，形如&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;，一个不带有name的插槽隐含的名字就是default。\n为了在html文件中调用该组件并为特定的插槽提供特定的内容，将想要提供的内容包裹在&lt;template&gt;元素中。给该&lt;template&gt;元素一个v-slot:header指令，冒号后面就是name attribute的取值；或者直接在#hash符号后面跟上插槽的名字。\n&lt;template v-slot:header&gt;&lt;/template&gt;&lt;template v-slot:default&gt;&lt;/template&gt;&lt;template #header&gt;&lt;/template&gt;\nteleportteleport用于解决逻辑与视图不一致的情况。比如在当前组件中存在一个子组件，虽然该子组件的数据逻辑归属于当前组件，但是UI视图并不从属于当前视图。那么就需要在当前组件的template中将该子组件用&lt;teleport&gt; 标签包裹，并在&lt;teleport to=&quot;&quot;&gt;中选择html元素，指定该子组件在DOM树中的位置。\n比如网站首页点击登陆之后会弹出登陆信息框，虽然登陆的信息由首页的导航栏维护，但是在视图层面并不属于导航栏这个vue实例，而是属于body元素的子元素。\n&lt;template&gt;  &lt;AppHeader :isLoggedIn&#x3D;&quot;isLoggedIn&quot; @open-login-model&#x3D;&quot;isLoginOpen &#x3D; true&quot; &#x2F;&gt;  &lt;div class&#x3D;&quot;w-full flex&quot;&gt;    &lt;router-view&gt;&lt;&#x2F;router-view&gt;  &lt;&#x2F;div&gt;  &lt;teleport to&#x3D;&quot;body&quot;&gt;    &lt;LoginModel v-if&#x3D;&quot;isLoginOpen&quot; @close-login&#x3D;&quot;isLoginOpen &#x3D; false&quot; &#x2F;&gt;  &lt;&#x2F;teleport&gt;&lt;&#x2F;template&gt;\nComposition API","categories":["Vue"],"tags":["Vue"]},{"title":"JavaScript基础","url":"/2020/11/21/learn-js/","content":"变量变量就是一个用来存储数据类型的容器。\n声明var&amp;letvar会被变量提升，但是let没有。因此使用var时，可以根据需要多次声明相同名称的变量，但是let不能。\n声明的意义声明但不初始化变量就相当于让容器存在于执行环境中，但里面是“空”的，什么也不放，因而在控制台会返回undefined。\n没有声明也没有初始化的变量相当于执行环境中没有该变量，不存在容器，因而控制台直接会返回报错信息。\n变量类型\nNumber\n\n数值的数据分类有哪些，基本运算符有哪些，变量自增自减在控制台中的表现。\n\nString需要单引号或者双引号包围\n\n字符串中转义字符的使用：\\&#39; \n字符串拼接：myString1+myString2 \n利用字符串长度索引：myString1[0]&amp;string1[string1.length-1] \n查找子串： myString1.indexOf(&#39;mySubstring1&#39;)\n切割子串： myString1.slice(i,j)第二个参数可选，如果没有传入那么一直切割到末尾，不会改变myString1\n替换子串：myString1.replace(&#39;mySubstring1&#39;, &#39;mySubstring2&#39;)，返回更新后的字符串。\n\n如果要用新的字符串替换原来的字符串，一定不可以只有newStory.replace(&#39;130&#39;, pound);，这对原字符串并不会有任何影响，一定要newStory = newStory.replace(&#39;130&#39;, pound);才会修改原字符串。\n\n大小写：myString1.toLowerCase()/toUpperCase()\n\nNumber &amp; String类型互相转换\nNumber(myString)可以将String类型转换为Number类型\nmyNum.toString()可以讲Number类型转换为String类型\n\n\nBoolean可以取值true/false\n\nArray是单个对象，用方括号包含很多元素，元素之间用逗号分隔，元素索引从0开始。\n\n\n获取长度：sequence.length\n添加末尾元素：let length = sequence.push(element1)返回新数组的长度\n删除末尾元素：let removedItem = sequence.pop()返回已删除的项目\n添加头部元素：let length = sequence.unshift(element1)\n删除头部元素：let removedItem = sequence.shift()返回已删除的项目\n\nArray &amp; String类型互相转换\n当String中存在重复出现的分隔符时，可以将String分成许多元素放入Array中，如let myArray = myString.split(&#39;,&#39;);\n当Array中的元素想通过某种方式连接起来变成String时，可以使用let myString = myArray.join(&#39;,&#39;);，也可以使用let myString = myArray.toString();。二者区别是join可以指定分隔符。\n\n\nObject\n\nJavaScript时一种动态类型语言，不需要人为指定变量包含什么类型的数据。你赋什么类型的值，变量就会是什么类型。可以利用typeof操作符检查传递给改操作符的变量的数据类型。\n循环for-loopfor (initializer; exit-condition; final-expression) &#123;  // code to run&#125;\nwhile loopinitializerwhile (exit-condition) &#123;  // code to run  final-expression&#125;\ndo-while loopinitializerdo &#123;  // code to run  final-expression&#125; while (exit-condition)\n函数函数是对象方法的一部分。\n内置浏览器函数基于浏览器API，并不是核心JavaScript语言的一部分，他们是方法。方法是在对象哪定义的函数，浏览器内置函数（方法）和变量（属性）储存在结构化对象里，使得代码管理更高效，易于处理。\n声明与调用function myFunction()&#123;    &#125;//声明myFunction()//调用\n怎么样才算调用一个函数呢？函数名后面的括号叫做函数调用运算符(function invocation operator)。\n注意以下两种写法。\nbtn.onclick = displayMessage;的意思是当按钮被点击就运行该名称的函数。\nbtn.onclick = displayMessage();的意思是不需要点击按钮该函数就会被调用。\n为了改变第二种结果，最适合的写法应该是将要调用的函数包裹在匿名函数中\nbtn.onclick = function() &#123;  displayMessage();&#125;;\n匿名函数一个没有名称的函数就是匿名函数，它本身不会做任何事情，一般将匿名函数和事件处理程序一起使用。\nmyButton.onclick = function()&#123;    &#125;\n还可以把匿名函数分配为多个变量值。\nvar myGreeting = function()&#123;    &#125;myGreeting()//调用\n匿名函数也叫匿名表达式。函数声明会declaration hoisting，而函数表达式不会。\n参数参数值放在函数括号内，可以叫做参数arguments，也被叫做属性properties/attributes。\n函数作用域scope和冲突所有函数的最外层被称为全局作用域。 在全局作用域内定义的值可以在任意地方访问。\n当你创建一个函数时，函数内定义的变量和其他东西都在它们自己的单独的范围内, 意味着它们被锁在自己独立的隔间中, 不能被函数外的代码访问。\n参数的存在就相当于把属于一个作用域的变量传递另一个作用域。\n返回值一些没有返回值的函数调用后在控制台输出就是空值void或未定义值undefined。\n通常函数返回值是用作中间步骤的计算结果，该结果可以用于计算的下一阶段。\n事件每个可用的事件都会有一个事件处理器，也就是事件触发时会运行的代码块。当我们定义了一个用来回应事件被激发的代码块的时候，我们说我们注册了一个事件处理器。\n监听器留意事件是否发生，然后处理器就是对事件发生做出的回应。\n响应网页事件的几种机制事件处理器属性比如对于几乎所有HTML元素，都有onclick属性，和其他.style,.textContent一样。\n行内事件处理器-不要使用也叫事件处理程序HTML属性，会混用HTML和JavaScript。\naddEventListener()定义在DOM Level2 Events中的函数addEventListener()，接受两个参数。第一个参数是我们想要将处理器函数应用上去的时间名称，第二个是用来回应事件的函数，可以是一个匿名函数。\n相较于事件处理器属性被覆盖，addEventListener()可以实现一个监听器注册多个处理器。\n事件对象有时候在处理函数内部，可一个固定指定名称的参数，如event,evt,e，这是事件对象，它被自动传递给事件处理函数。\n事件对象 e 的target属性始终是事件刚刚发生的元素的引用。\n阻止默认行为自定义注册表单。，当你填写详细信息并按提交按钮时，自然行为by default是将数据提交到服务器上的指定页面进行处理，并将浏览器重定向到某种“成功消息”页面（或 相同的页面，如果另一个没有指定。）\n但是当用户提交的数据并不正确时，开发人员希望停止提交信息到服务器，并给用户错误提示，需要在事件对象上调用preventDefault()函数，这样就停止了表单提交。\n事件冒泡及捕获事件冒泡和捕捉是两种机制，主要描述当在一个元素上有两个相同类型的事件处理器被激活会发生什么。\n当一个事件发生在具有父元素的元素上时，现代浏览器运行两个不同的阶段：捕获阶段和冒泡阶段。\n在现代浏览器中，默认情况下，所有事件处理程序都在冒泡阶段进行注册。\n捕获阶段：\n浏览器检查元素的最外层祖先&lt;html&gt;，是否在捕获阶段中注册了一个onclick事件处理程序，如果是，则运行它。\n然后，它移动到&lt;html&gt;中单击元素的下一个祖先元素，并执行相同的操作，然后是单击元素再下一个祖先元素，依此类推，直到到达实际点击的元素。\n\n冒泡阶段：\n浏览器检查实际点击的元素是否在冒泡阶段中注册了一个onclick事件处理程序，如果是，则运行它\n然后它移动到下一个直接的祖先元素，并做同样的事情，然后是下一个，等等，直到它到达&lt;html&gt;元素。\n\n修复标准事件对象具有可用的名为 stopPropagation()的函数，当在事件对象上调用该函数时，它只会让当前事件处理程序运行，但事件不会在冒泡链上进一步扩大，因此将不会有更多事件处理器被运行(不会向上冒泡)。\n事件委托\nEvent delegation allows you to avoid adding event listeners to specific nodes;  instead, the event listener is added to one parent.  That event listener analyzes bubbled events to find a match on child elements.\n\ncheck the event object’s target property to gain a reference to the actual clicked node.\n虽然事件处理函数添加在父元素上，但通过if语句对事件对象进行条件判断，可以访问父元素及其内部子元素，从而实现特定的相应操作。\nif(e.target &amp;&amp; e.target.nodeName == &quot;LI&quot;)\nUsing the Element.matches API, we can see if the element matches our desired target.\nif (e.target &amp;&amp; e.target.matches(&quot;a.classA&quot;)) \n参考\n一些实作的易错点关于单引号的双引号的区分。规定自己对于html元素名称或者属性的引用都使用单引号，但对字符串统一使用双引号。如if(btn.getAttribute(&#39;class&#39;) === &quot;dark&quot;)。\n对属性赋值都是赋值字符串，如overlay.style.backgroundColor = &quot;rgba(0, 0, 0, 0.5)&quot;;，如果rgba没有加双引号，那最后javascript编译器会把它当作一个函数，从而报错。\n对象对象是一个包含相关数据和方法的集合（通常由一些变量和函数组成，我们称之为对象里面的属性和方法）。\n面向对象对象包（object package，或者叫命名空间 namespace）存储（官方用语：封装）着对象的数据（常常还包括函数），使数据的组织和访问变得更容易了；对象也常用作数据存储体（data stores），用于在网络上运输数据，十分便捷 —— 也就是JSON(JavaScript对象表示法)。\n对象字面量一个对象由许多的成员组成，每一个成员都拥有一个名字（像上面的name、age），和一个值（如[‘Bob’, ‘Smith’]、32）。每一个名字/值（name/value）对被逗号分隔开，并且名字和值之间由冒号（:）分隔。\n对象成员的值可以是任意的，可以是字符串(string)，数字(number)，数组(array)，函数(function)。前三种属于资料项目，被称为对象的属性(property)；最后一个函数，允许对象对资料做一些操作，被称为对象的方法(method)。\nvar objectName = &#123;  member1Name : member1Value,  member2Name : member2Value,  member3Name : member3Value&#125;\n一个如上所示的对象被称之为对象的字面量(literal)——手动的写出对象的内容来创建一个对象。\n访问对象属性点表示法使用点表示法(dot notation)来访问对象的属性和方法。\n对象的名字表现为一个命名空间(namespace)，它必须写在第一位。\n\n子命名空间\n可以用一个对象来做另一个对象成员的值。访问对象内的对象成员就相当于要用两次点表示法。\n\n紧接着是你想要访问的项目，标识可以是简单属性的名字，或者是数组属性的一个子元素，又或者是对象的方法调用。\n括号表示法另外一种访问属性的方式是使用括号表示法(bracket notation)，例如person[&#39;age&#39;]。\n对象有时被称之为关联数组(associative array)了——对象做了字符串到值的映射，而数组做的是数字到值的映射。\n括号表示法与点表示法的区别括号表示法能接受一个变量作为成员名字；点表示法只能接受字面量的成员的名字，不接受变量作为名字。\n设置成员对象既可以对已有的成员的值进行改变，也可以创建新的成员并赋值。\nthis关键字”this”指向了当前代码运行时的对象( 原文：the current object the code is being written inside )，它保证了当代码的上下文(context)改变时变量的值的正确性。\n在字面量的对象里this看起来不是很有用，但是当你动态创建一个对象（例如使用构造器）时它是非常有用的。\n对象与类的关系用类（class）的概念去描述一个对象。\n类并不完全是一个对象，它更像是一个定义对象特质的模板。 我们能够基于类创建出一些拥有class中属性及方法的对象。\n当一个对象需要从类中创建出来时，类的构造函数就会运行来创建这个实例。\n创建对象的方式总结声明一个对象去创建对象使用构造函数创建对象使用Object()构造函数创建对象首先使用var person1 = new Object();创建一个空的对象。\n其次根据需要使用点或括号表示法向此对象添加属性和方法。\n\n也可以将对象文本传递给Object()构造函数作为参数。var person1 = new Object(&#123;name: &#39;Chris&#39;, age: 38, greeting: function()&#123;&#125; &#125;);。\n基于现有对象创建新对象使用Object2.create(Object1)，基于现有对象创建新的对象， 它们具有相同的属性和方法。\n结合原谅来看，这个函数做的就是从指定原型对象Object1创建一个新的对象Object2，在控制台输入Object2.__prooto__返回的就是对象Object1。\n原型JavaScript 常被描述为一种基于原型的语言 (prototype-based language)。\n每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。\nprototype属性如果某一对象把属性定义在prototype属性之中，那就意味着这个对象允许其他对象继承这些方法。也就是说该对象可继承的内容都放在了该对象的prototype这个子命名空间中，其实这个子命名空间也是一个对象。\n其他不位于prototype 对象内的成员，不会被“对象实例”或“继承自 Object() 的对象类型”所继承。这些方法/属性仅能被 Object() 构造器自身使用。\nconstructor属性每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。\n某个对象的constructor属性可以告诉我们该对象从什么对象继承而来。可以获取作为构造器的对象的属性。\n在对象的constructor属性末尾添加一对圆括号（括号中包含所需的参数），并在前面添加 new 关键字，从而用这个构造器创建另一个对象实例。\n原型存在的意义如果某个对象的原型更新了方法，该对象可以通过上溯圆形链调用原型的方法，而不必把上游对象的方法复制到该对象中。\n利用原型定义对象一种极其常见的对象定义模式是，在构造器（函数体）中定义属性、在 prototype 属性上定义方法（也就是将方法都放在构造器的prototype 属性中）。如此，构造器只包含属性定义，而方法则分装在不同的代码块，代码更具可读性。\n实际操作中的一些问题实现继承\nfunction Shape(x, y, velX, velY, exist)&#123;    // 将属性值当作构造函数的参数传入，使用this指向对象    // 注意对象要大写    this.x = x;    this.y = y;    this.velX = velX;    this.velY = velY;    this.exist = exist;&#125;function Ball(x, y, velX, velY, exist, size, color)&#123;  Shape.call(this, x, y, velX, velY, exist);   // 继承属性  // 需要注意的是传入call函数的参数一定也要出现在构造函数的参数中  this.size = size;  this.color = color;  this.exist = true;&#125;\n构造函数的参数与确定属性值的关系\nfunction EvilCircle( x, y,exist, color, size)&#123;  Shape.call(this, x, y, exist);  this.color = color;  this.size = size;  this.velX = 20;  this.velY = 20;  // 这里确定值的velX和velY就没有作为参数传入&#125;\n构造函数和原型之间的关系\n// 这是构造函数，需要大写function Ball(x, y, velX, velY, exist, size, color)&#123;  Shape.call(this, x, y, velX, velY, exist);   // 继承属性  // 需要注意的是传入call函数的参数一定也要出现在构造函数的参数中  this.size = size;  this.color = color;  this.exist = true;&#125;// 这是原型对象，用于定义方法，可以通过this访问构造函数的属性Ball.prototype.draw = function()&#123;  ctx.beginPath();  ctx.fillStyle = this.color;  ctx.arc(this.x, this.y, this.size, 0, 2*Math.PI);  ctx.fill();&#125;\n异步一个线程是一个基本的处理过程，程序用它来完成任务。每个线程一次只能执行一个任务。\nJavaScript 传统上是单线程的。即使有多个内核，也只能在单一线程上运行多个任务，此线程称为主线程（main thread）。\nWeb workers借助web workers把一些任务交给一个名为worker的单独的线程。一般来说，用一个worker来运行一个耗时的任务，主线程就可以处理用户的交互（避免了阻塞）。\n异步callbacks异步callbacks函数只不过是作为参数传递给那些在后台执行的其他函数。\n原理涉及两个函数，他们的关系是函数和参数，回调函数和调用回调函数的函数（包含函数）。\n当我们把回调函数作为一个参数传递给另一个函数时，仅仅是把回调函数定义作为参数传递过去——回调函数并没有立刻执行，回调函数会在包含它的函数的某个地方异步执行，包含函数负责在合适的时候（例如触发了某个事件）执行回调函数。\naddEventListener()的第二个参数就是异步callback函数。第一个参数是侦听的事件类型，第二个就是事件发生时调用的回调函数。\n回调函数和异步的关系不是所有的回调函数都是异步的。\n当遍历数组时使用的Array.prototype.forEach()函数需要的参数就是一个回调函数，它无需等待立刻运行。\n问题回调地狱与每层嵌套都需要调用一个失败回调。\nPromises基本流程创建最初的promise首先，为fectch()传入网络资源的URL作为参数。该函数返回一个promise对象，代表了异步操作完成或失败的对象。\n\n这个最初既不成功也不失败的中间状态下的promise的官方术语叫作pending。\n\n返回promise其次，使用then()块，传入回调函数作为参数。如果前一个操作成功，该函数将运行，并且每个回调都接收前一个成功操作的结果作为输入，因此您可以继续对它执行其他操作。\n每个.then()块返回另一个promise，这意味着可以将多个.then()块链接到另一个块上，这样就可以依次执行多个异步操作。\n如果任何一个.then()块返回失败，就运行末尾的catch()块，也是传入一个回调函数作为参数，提供了一个错误对象，可用来报告发生的错误类型。\n\n当promise返回时，称为 resolved（已解决）.\n\n一个成功resolved的promise称为fullfilled（实现）。它返回一个值，可以通过将.then()块链接到promise链的末尾来访问该值。.then()块中的执行程序函数将包含promise的返回值。\n一个不成功resolved的promise被称为rejected（拒绝）了。它返回一个原因（reason），一条错误消息，说明为什么拒绝promise。可以通过将.catch()块链接到promise链的末尾来访问此原因。\n\n\npromise完成后运行一段代码在promise完成后，你可能希望运行最后一段代码，无论它是否已实现（fullfilled）或被拒绝（rejected）。\n.then()块与AddEventListener().then()块的工作方式类似于使用AddEventListener()向对象添加事件侦听器时的方式。\n\n最显着的区别是.then()每次使用时只运行一次，而事件监听器可以多次调用。\n\n流程合并请记住，履行的promise所返回的值将成为传递给下一个 .then() 块的executor函数的参数。\nfetch(&#x27;coffee.jpg&#x27;).then(response =&gt; response.blob()).then(myBlob =&gt; &#123;  let objectURL = URL.createObjectURL(myBlob);  let image = document.createElement(&#x27;img&#x27;);  image.src = objectURL;  document.body.appendChild(image);&#125;).catch(e =&gt; &#123;  console.log(&#x27;There has been a problem with your fetch operation: &#x27; + e.message);&#125;);\n多个promise协同工作Promise.all()函数将一个promises数组，也就是多个pending，作为输入参数，并返回一个新的Promise对象，只有当数组中的所有promise都满足时才会满足。\nPromise.all([a, b, c]).then(values =&gt; &#123;  ...&#125;);\n只要一个被拒绝了，该函数整体就不会返回promise。需要逐个检查promise返回了什么。\n自定义Promise使用Promise()构造函数构建自己的promise。\nresolve()和reject()是用来实现和拒绝新创建的promise的函数。\nlet timeoutPromise = new Promise((resolve, reject) =&gt; &#123;    resolve();//这个函数表明了调用该promise成功后，作为参数传递给后面的then块的值    reject();//这个函数表明了调用该promise失败后，作为参数传递给最后的catch块的值，一般是要和条件判断一起写的。    &#125;;// 上面的写法也可以写成一个函数，函数返回的return是new Promise\nasync/await这两个关键字async/await是基于promises的语法糖，使异步代码更易于编写和阅读。\nasync在函数声明前使用async关键字，使该函数称为异步函数。函数声明，函数表达式，箭头函数都可以。\n例如，\nasync function hello() &#123; return &quot;Hello&quot; &#125;; //异步函数let hello = async function() &#123; return &quot;Hello&quot; &#125;; // 异步函数表达式let hello = async () =&gt; &#123; return &quot;Hello&quot; &#125;; //箭头函数\n异步函数是一个知道怎么使用await关键字调用异步代码的函数。调用异步函数会返回一个promise。\nawaitawait关键字与异步函数一起使用，且 await只在异步函数里面才起作用。\n使用可以在调用任何返回Promise的函数前使用 await，包括Web API函数，然后将这个返回的量赋值到一个变量去。\nWHYawait作为 .then() 代码块的替代存在，可以让我们用更少的.then()。这让代码的形式看起来更像同步代码，能够将结果返回到中间变量去，而不是像链条一样把一个输出连到另一个的输入。\nawait关键字使JavaScript运行时暂停于此行，允许其他代码在此期间执行，直到异步函数调用返回其结果。一旦完成，您的代码将继续从下一行开始执行。\n超时和间隔以下介绍的三个异步函数都是在主线程上运行的。在给定的时间间隔之前和重复调用之间可以在主线程上运行其他代码。\nsetTimeout()在指定的时间后执行一段代码。\n传入参数\n回调函数/函数引用\n以毫秒为单位的时间间隔：如果指定为0，函数将尽快运行，而不是立即运行。因为需要主线程的堆栈为空才能运行回调函数\n希望传递给回调函数的参数值，在参数列表后面添加即可。\n\n取消任务setTimeout() 返回一个标志符变量用来引用这个间隔。取消该超时任务使用函数clearTimeout(setTimeout(params))。\nsetInterval()以固定的时间间隔重复运行一段代码，例如动画。这与setTimeout()的工作方式非常相似。\n传入参数作为第一个参数传递给它的函数，重复执行的时间不少于第二个参数给出的毫秒数，而不是一次执行。\n可以将正在执行的函数所需的任何参数作为 setInterval() 调用的后续参数传递。\n取消任务setInterval() 返回一个确定的值，稍后你可以用它来取消间隔任务。\n通过将setInterval()调用返回的标识符传递给clearInterval()函数来取消间隔任务。\n\n递归调用setTimeout()和调用setInterval()效果类似。\n二者微妙区别在于：\nsetInterval()的执行时间包括了我们想要运行的代码所花费的时间。\nsetTimeout()每次都等代码运行完了之后，开始计算等待的时间，时间间隔总是相同。\n\nrequestAnimationFrame()setInterval()的现代版本，在浏览器下一次重新绘制显示之前执行指定的代码块，因此该方法将重新加载页面之前要调用的回调函数作为参数。\nWHY动画的平滑度直接取决于动画的帧速率，并以每秒帧数（fps）为单位进行测量。由于大多数屏幕的刷新率为60Hz，因此在使用web浏览器时，可以达到的最快帧速率是每秒60帧（FPS）。\nrequestAnimationFrame() 总是试图尽可能接近60帧/秒的值。\n当然有时这是不可能的如果你有一个非常复杂的动画，你是在一个缓慢的计算机上运行它，你的帧速率将更少。requestAnimationFrame() 会尽其所能利用现有资源提升帧速率。\n使用function draw(timestamp) &#123;   // Drawing code goes here    if(!startTime) &#123;      startTime = timestamp;    &#125;   currentTime = timestamp - startTime;   // Do something based on current time       requestAnimationFrame(draw);&#125;draw();\n传递给 requestAnimationFrame() 函数的实际回调也可以被赋予一个参数（一个时间戳值），表示自 requestAnimationFrame() 开始运行以来的时间。\n\n模版字符串\n$&#123;var&#125;是变量的占位符，常用语字符串拼接。在实际开发中一般在ajax请求中用不变的html$&#123;变量&#125;html标签代替以前传统复杂的单引号双引号与+的拼接。\nspinner.style.transform = &#x27;rotate(&#x27; + rotateCount +&#x27;deg)&#x27;;spinner.style.transform = `rotate($&#123;rotateCount&#125;deg)`;\n\n问题requestAnimationFrame() 的限制之一是无法选择帧率。他总是尽可能地逼近60fps。\n有的时候反而需要限制帧率，比如老式动画。如果需要以较慢的帧速率运行动画，则需要使用setInterval（）或递归的setTimeout（）。\nAPI共性基于对象API使用一个或多个对象来与JavaScript的代码交互，这些对象的功能是：API使用的数据容器（包含在对象属性中），API提供的功能（包含在对象方法中）。\n可识别的入口点文档对象模型 (DOM) API的入口点就是Document对象。\nCanvas API需要为要编写的API代码创建特定的上下文。例如\nvar canvas = document.querySelector(&#x27;canvas&#x27;);var ctx = canvas.getContext(&#x27;2d&#x27;);\n使用事件来处理状态的变化一些Web API不包含事件，但有些包含一些事件。当事件触发时，允许我们运行函数的处理程序属性通常在单独的 “Event handlers”(事件处理程序) 部分的参考资料中列出。\n文档操作的APIweb页面构成window是载入浏览器的标签，用window对象来表示。通过调用该对象的方法，可以返回窗口的大小，操作载入窗口的文档等等。\nnavigator是浏览器存在于web上的状态和标识（即用户代理），用navigator对象来表示，通过调用该对象的方法，可以获取用户摄像头的地理信息、偏好语言、多媒体流等。\ndocument是载入窗口的实际页面，用document对象表示，可以返回、操作文档中HTML和CSS上的信息。\nDOM树元素节点、根节点、子节点、后代节点、父节点、兄弟节点、文本节点等。\n主要需要弄清楚子节点和后代节点的关系。子节点是直接位于另一个节点内的节点，后代节点是位于另一个节点内任意位置的节点。\n\n依据DOM元素存在的各种事件，考虑的角度应该是在创建这个对象的时候就为它添加对应的事件，而不是说在这个事件要发生的时候去考虑该怎么做。\ninput输入框的内容是通过value属性获取的，let content = input.value;。对input输入框的操作还涉及了自动对焦，input.focus();。\nspan这种行内元素的内容是通过innerHTML确定的，span.innerHTML = content;。\n\n操作DOM元素获取Document.querySelector()允许使用CSS选择器选择元素，它调用会匹配它在文档中遇到的第一个匹配的元素。\n如果需要选择多个元素，可以使用Document.querySelectorAll()。会返回一个存放了这些元素的array。\n一般来说对DOM元素的引用全部创建为常量，因为这些引用在应用程序的生命周期中不需要更改。\n\n也有其他方法比如，document.getElementById()/getElementByTagName()，分别传入id属性值和html元素标签名。\n\n新建/放置新建元素使用Document.vreateElement()，放置使用Node.appendChild()。\n新建文本节点要用Document.createTextNode()，放置使用Node.appendChild()。\n移动/删除基于现有元素做一个副本，然后把副本移动到其他节点，需要使用Node.cloneNode()。\n删除节点需要知道父亲节点的引用和要删除节点的引用，Node.removeChild()；但是不知道父亲节点的引用，需要问询父亲节点linkPara.parentNode.removeChild(linkPara);。\n操作样式有两种方式。\n第一种是直接想要动态设置样式的内部元素添加内联样式。通过HTMLElement.style属性来实现，这个属性包含了文档中每一个元素的内联样式的信息。载入页面后会直接看到样式应用到HTML文件对应的元素。\n第二种是使用Element.setAttribute(attribute, value)。\n从服务器获取数据的API主要涉及两个常用API，一个是XMLHttpRequest，另一个是Fetch。这些API允许网页直接对服务器上可用的特定资源进行HTTP请求，并在显示之前根据需要对数据进行格式化。\n\n在早期，这种通用技术被称为Asynchronous JavaScript and XML（Ajax）\n\n第三方API根植于第三方浏览器，要通过JavaScript获取，首先要连接到它的功能接口上并使其在页面上生效。\n使用第三方API首先就是要阅读第三方API的官方文档了解应该如何使用。\n其次需要向第三方API的提供者申请使用密钥。\n浏览器API通常有一个安全性提示，在第三方API中，使用API KEY来允许开发人员访问API功能，但是如果开发者恶意使用API来侵犯用户隐私，API的提供者可以根据密钥撤销该开发者的API使用权。\n引入第三方库需要引入一个&lt;script&gt;&lt;/script&gt;元素连接到第三方服务器所开放的JavaScript库。\n谷歌地图的API如下。\n&lt;script type=&quot;text/javascript&quot; src=&quot;https://maps.google.com/maps/api/js?key=AIzaSyDDuGt0E5IEGkcE6ZfrKfUtE9Ko_de66pA&quot;&gt;&lt;/script&gt;\n基于URL请求一般此类API都遵循RESTful API的设计指南，遵循域名、API版本、Endpoint、Filtering过滤信息参数、状态码、错误处理等相关规定。\n\n利用字符串操作等方式创建相应的URL\n\n首先应当有一个baseURL\n\n建立API和本地应用的链接?api-key=$&#123;key&#125;\n每次向服务器对应的 URL 发起 get 请求，都需要把 API key 作为 get 请求的参数。\n\n个性化请求参数&amp;page=$&#123;pageNumber&#125;\n\n\n\n利用URL从API请求数据，结合Fetch方法/XMLHTTPRequest方法。\n\n对接收到的JSON数据进行解析，拆分显示到当前HTML的各个元素。\n\n\n用于绘制和操作图形的API主要基于&lt;canvas&gt;讲解。\n基本准备\n在body中添加带class的canvas元素并在JS中选择该canvas元素\n获取该画布上下文canvas context并完成设置var ctx = canvas.getContext(&#39;2d&#39;);，还可以选择wbgl1和webgl2。这里的ctx是一个CanvasRenderingContext2D对象。\n画布原点默认是在(0,0)，如需改变，使用ctx.translate()函数，将画布原点移动到指定坐标。\n\n绘制基本形状\n内容填充与描绘边\nctx.fillStyle = &#39;&#39;; ctx.fillRect()\n ctx.storkeStyle = &#39;&#39;; ctx.lineWidth = ; ctx.strokeRect();\n\n路径绘制与画线自定义形状\n前期准备确定一下ctx.fillStyle = &#39;&#39;，即要画什么颜色。\n\n第一步：产生钢笔，并移动钢笔，这个步骤不会绘制任何内容ctx.beginPath(); ctx.moveTo();\n\n第二步：移动钢笔到多个计算好坐标的位置，形成闭合路径 ctx.lineTo();\n\n第三步：选择填充还是描边这两种行为 ctx.fill(); ctx.stroke();\n\n\n\n画圆/画弧\n\n\nctx.fillStyle = &#x27;yellow&#x27;;ctx.beginPath();ctx.arc(200, 106, 50, degToRad(-45), degToRad(45), true);ctx.lineTo(200, 106);ctx.fill();\n\n填充文字\n\nctx.fillStyle = &#x27;red&#x27;; // ctx.strokeStyle = &#x27;white&#x27;; // ctx.lineWidth = 1;ctx.font = &#x27;48px georgia&#x27;;ctx.fillText(&#x27;Canvas text&#x27;, 50, 150);\n\n图片嵌入\n\n首先，使用Image()构造器创建一个新的HTMLImageElement对象，返回对象的类型与非空&lt;img&gt;元素的引用一致，设置改图片的src属性\n其次使用ctx.drawImage()函数来嵌入图片。由于需要事先确保图片已经载入完毕，要在图片的onload事件处理器中调用嵌入图片的函数。\n动画window.requestAnimationFrame()只接受一个参数，这个参数是一个每帧都要运行的函数名，因为请注意每一帧我们都整体清除画布并重新渲染所有内容。\n这个函数传入该方法后就会在一秒内被重复运行多次。下一次浏览器准备好更新屏幕时，将会调用你的函数。如果你的函数向动画中绘制了更新内容，则在函数结束前再次调用 requestAnimationFrame()，动画循环得以保留。\n只有在停止调用 requestAnimationFrame() 时，或 requestAnimationFrame() 调用后、帧调用前调用了 window.cancelAnimationFrame()时，循环才会停止。\n实现步骤\n清除画布内容（可用 fillRect() 或 clearRect()）。\n（在需要时）用 save() 保存状态。（在进行下一步前保存所更新的设置，一般在复杂环境中用到）\n绘制动画图形。\n使用 restore() 恢复第 2 步中保存的状态。\n调用 requestAnimationFrame() 准备下一帧动画\n\n\n3D画布内容通过WebGL API实现，WebGL基于Open GL图形编程语言实现，可以直接与GPU通信，更类似C++的底层语言。\n常用的第三方API有three.js/PlayCanvas等。\n使用three.js的基本步骤如下：\n\n构造一个新的3D场景\n为该3D场景添加摄影机，代表绘图语境中观察着视角\n指定渲染器，并将3D画布与DOM对象关联\n创建基于纹理的画布内容\n\n首先要创建一个TextureLoader对象，把作为纹理的图片在图片载入成功后（通过事件监听实现）传入一个回调函数。\n其次该纹理图可能会经过一系列复制旋转等操作。\n\n为场景打光，分柔光和硬光，分别创建对象。\n\n视频和音频APIHTML5中的播放器HTML5中&lt;video&gt;和&lt;audio&gt;元素允许我们把视频和音频嵌入到网页当中。\n构成HTML视频播放器的主要由两个部分，这两个部分都被包裹在名为&lt;div class=&quot;player&quot;&gt;的div块中。\nHTML部分\n首先是video元素层，包含多个视频source，可以根据浏览器来加载其所支持的不同视频格式。\n&lt;video controls&gt;    &lt;!-- 注意上面的controls是浏览器默认控件 --&gt;    &lt;source src=&quot;video/sintel-short.mp4&quot; type=&quot;video/mp4&quot;&gt;    &lt;source src=&quot;video/sintel-short.mp4&quot; type=&quot;video/webm&quot;&gt;    &lt;!-- fallback content here --&gt;  &lt;/video&gt;\n其次是自定义控件层，涉及多个button以及div。\n四个 &lt;button&gt;涉及play/pause, stop, rewind, and fast forward，分别带有属性一个class名 ，一个data-icon 属性来决定在每个按钮上显示什么图标 (在下一节讲述它是如何工作的)，和一个aria-label 属性为每一个按钮提供容易理解的描述, 即使我们没有在tags内提供可读的标签。\n有一个设定的计时器 &lt;div&gt;用来报告已经播放的时长。由两部分组成， 一个&lt;span&gt; 包含了流逝时间的分钟和秒；一个额外的&lt;div&gt; 用来创建一个水平的随着时间增加而增长的进度条。\n&lt;div class=&quot;controls&quot;&gt;    &lt;button class=&quot;play&quot; data-icon=&quot;P&quot; aria-label=&quot;play pause toggle&quot;&gt;&lt;/button&gt;    &lt;button class=&quot;stop&quot; data-icon=&quot;S&quot; aria-label=&quot;stop&quot;&gt;&lt;/button&gt;    &lt;div class=&quot;timer&quot;&gt;      &lt;div&gt;&lt;/div&gt;      &lt;span aria-label=&quot;timer&quot;&gt;00:00&lt;/span&gt;    &lt;/div&gt;    &lt;button class=&quot;rwd&quot; data-icon=&quot;B&quot; aria-label=&quot;rewind&quot;&gt;&lt;/button&gt;    &lt;button class=&quot;fwd&quot; data-icon=&quot;F&quot; aria-label=&quot;fast forward&quot;&gt;&lt;/button&gt;&lt;/div&gt;\n\nCSS部分关于播放器的CSS设置有如下几个要点。\n\n默认情况下，我们将控件的opacity设置为0.5 opacity，这样当您尝试观看视频时，它们就不会分散注意力。 只有当您将鼠标悬停/聚焦在播放器上时，控件才会完全不透明。\n使用flexbox控制各个按钮\nCSS中设置我们的自定义控件的visible属性为hidden；video元素中默认使用浏览器自带的控件。这样的好处是，一旦JavaScript由于某种原因没有加载, 用户依然可以使用原生的控件播放视频。\n我们使用 ::before状态选择器显示在每个button被点击之前显示内容。\n\n使用APIHTMLMediaElement API允许开发者用编程的方式控制视频和音频播放的相关功能，如例如 HTMLMediaElement.play(), HTMLMediaElement.pause()。\n客户端储存现代web浏览器提供了很多在用户电脑的web客户端存放数据的方法。\n它是由 JavaScript APIs 组成的因此允许你在客户端存储数据 (比如在用户的机器上)，而且可以在需要的时候重新取得需要的数据。例如个性化网站偏好，站点行为如是否记住登录状态，本地化数据的静态资源可以加速访问等。\n传统上使用cookies，现代浏览器使用Web Storage和Indexed DB这两个API。\nWeb Storage API只需存储简单的键名/键值对数据 (限制为字符串、数字等类型) 并在需要的时候检索其值。\n存储对象sessionStorage和localStorage一般所有web storage的数据都包含在浏览器内的两个对象中，他们都属于Storage类的对象。对这两个对象调用方法就能实现客户端数据存储。\n第一个是sessionStorage，只要浏览器开着，数据就会一直保存 (关闭浏览器时数据会丢失)。\n第二个是localStorage，会一直保存数据，甚至到浏览器关闭又开启后也是这样。\nweb storage 的一个关键特性是，数据在不同页面加载时都存在（甚至是当浏览器关闭后，对localStorage的而言）。\n方法调用Storage.setItem()允许在客户端储存中保存一个数据项，接受两个参数：数据项的名字和其值。\n例如localStorage.setItem(&#39;name&#39;,&#39;Chris&#39;);\nStorage.getItem()接受一个参数：想要检索的数据项的名称，返回数据项的值。\n例如localStorage.getItem(&#39;name&#39;);\nStorage.removeItem()接受一个参数：想要删除的数据项的名称，并从web stroage中删除该数据项。\n例如localStorage.removeItem(&#39;name&#39;); \n数据库的使用首先，需要打开数据库并存放在常量中，第一个参数是名字，第二个参数是版本号。如果不存在该数据库，会自动创建。\n我们需要在页面载入成功，也就是window.onload完成之后打开一下数据库并把它放在，而不是在需要用数据库的时候再去调用他，如果数据库很大的话，这个加载需要很久的时间，会导致阻塞。\nlet request = window.indexedDB.open(&#x27;notes&#x27;, 1);\n\n其次，由于数据库操作是异步的，需要给打开后的数据库添加各种状态监听函数。\n监听函数需要包括是否成功打开数据库的后台消息onerror/onsuccess；设置初始数据库onupgradeneeded。\n如何从监听函数内部获取对现有数据库的引用let db = e.target.result;\n如何在数据库中建立一个新的table/对象库let objectStore = db.createObjectStore(&#39;notes&#39;, &#123;keyPath:&#39;id&#39;, autoIncrement: true&#125;); \n如何在数据库的某个对象库中创建数据项objectStore.createIndex(&#39;title&#39;, &#39;title&#39;, &#123;unique: false&#125;);\nrequest.onerror = function()&#123;&#125;;request.onsuccess = function()&#123;&#125;;request.onupgradeneeded = function(e)&#123;        // 从事件目标e.target中获取对现有数据库的引用，即request对象        let db = e.target.result;        // 这个objectStore就像一个table一样存放记录        // 在我们打开的数据库中新建一个对象库，类似于传统数据库系统中的单个表        // id用于唯一标志一条记录        let objectStore = db.createObjectStore(&#x27;notes&#x27;, &#123;keyPath:&#x27;id&#x27;, autoIncrement: true&#125;);        // 定义这个table中会存放什么样的数据项，创建了两个索引        objectStore.createIndex(&#x27;title&#x27;, &#x27;title&#x27;, &#123;unique: false&#125;);        objectStore.createIndex(&#x27;body&#x27;, &#x27;body&#x27;, &#123;unique: false&#125;);        console.log(&#x27;Database setup complete&#x27;);    &#125;\n\n对数据库进行增加数据项的操作\n首先，明确要增加进去的数据项newItem。\n需要引入一个读写数据库的方法的引用let transaction = db.transaction([&#39;notes&#39;], &#39;readwrite&#39;);。\n然后，锁定目标到数据库内的某一个table/对象库。\n最后，基于该对象库调用obJectStore.add(newItem)对象。\nlet newItem = &#123;title: titleInput.value, body: bodyInput.value&#125;;let transaction = db.transaction([&#x27;notes&#x27;], &#x27;readwrite&#x27;);let objectStore = transaction.objectStore(&#x27;notes&#x27;);var request = objectStore.add(newItem);\n该引用成功完成后应当增加transaction.oncomplete监听函数。该引用失败后应当增加transaction.onerror监听函数。\n\n将数据库更新同步到客户端网页DOM中\n首先，需要明确原网页DOM中所有数据库的原先内容都要被移除，否则会出现叠加。\nwhile(list.firstChild)&#123;    list.removeChild(list.firstChild);&#125;\n其次，获得对数据库中的特定对象库table的引用。let objectStore = db.transaction(&#39;notes&#39;).objectStore(&#39;notes&#39;);\n最后，最重要的是获得对对象库中的所有条目的引用。条目的各项index都可以通过cursor.value的属性获得，但是需要注意cursor.value.id是连接DOM中的条目和数据库中条目的通道。删除了的DOM中条目如何对应到数据库中去删除？这就需要id来分辨。\nobjectStore.openCursor().onsuccess = function(e)&#123;    let cursor = e.target.result;// cursor.value就相当于一个table中的一个条目// cursor.value.title/bod就相当于一个条目中的一个index    // 当用户操作删除这个的时候，便于我们在数据库中寻找对应的条目删除\tlistItem.setAttribute(&#x27;data-note-id&#x27;, cursor.value.id);&#125;\n\nDOM树的数据项删除同步到客户端数据库\n首先，需要获得删除数据项在数据库中的唯一id。\nlet noteId = Number(e.target.parentNode.getAttribute(&#x27;data-note-id&#x27;));\n其次，打开数据库的特定对象库。\nlet transaction = db.transaction([&#x27;notes&#x27;], &#x27;readwrite&#x27;);let objectStore = transaction.objectStore(&#x27;notes&#x27;);\n最后，在对象库上传入id参数执行delte操作。\nlet request = objectStore.delete(noteId);\n对该请求设置一个事件监听操作，一旦在数据库中删除成功，这种变化需要反映到DOM树中去。\nrequest.oncomplete = function()&#123;            e.target.parentNode.parentNode.removeChild(e.target.parentNode);\tconsole.log(&#x27;Note $&#123;noteId&#125; deleted.&#x27;);\t// 如是删除到最后都是空列表该怎么做    // 这是没有listitem的默认显示    if(!list.firstChild)&#123;        let listItem = document.createElement(&#x27;li&#x27;);        listItem.textContent = &#x27;No notes stored.&#x27;;        list.appendChild(listItem);    &#125;&#125;;\n","categories":["JavaScript"],"tags":["JavaScript"]}]