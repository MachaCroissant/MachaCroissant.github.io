<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>B站美食区up主推荐</title>
    <url>/2020/10/02/fooder-collection/</url>
    <content><![CDATA[<h1 id="烘焙专长"><a href="#烘焙专长" class="headerlink" title="烘焙专长"></a>烘焙专长</h1><h2 id="姗胖胖Joyce"><a href="#姗胖胖Joyce" class="headerlink" title="姗胖胖Joyce"></a>姗胖胖Joyce</h2><p>第一次知道姗胖还是通过她的空气巧克力一期视频。那个时候还在日本自己生活，从超市买了36%脂肪含量的淡奶油以及Vivani的99%的黑巧克力制作了巧克力甘纳许，然后打发它将它变成了空气巧克力。当时刚入嘴那种轻盈感与幸福感爆棚。</p>
<p>姗胖个人感觉视频风格比较讨喜大众。视频风格方向上，语速适中，声音柔和，节奏恰好，风格俏皮。制作内容方向上，适合烘焙新手，步骤简单，配料常见。</p>
<p>指路：<a href="https://space.bilibili.com/40491956/">姗胖胖Joyce</a></p>
<h2 id="Fennel的铲子"><a href="#Fennel的铲子" class="headerlink" title="Fennel的铲子"></a>Fennel的铲子</h2><p>Fennel中式甜点和西式甜点都有涉及。我跟着Fennel做过牛奶鸡蛋醪糟、北非蛋、椰蓉麦芬、古早蛋糕。</p>
<p>Fennel早期发布的视频偏中式甜点，而且一些东西都挺有民族特色的，比如蒙古奶茶、美玲粥。后期发布的视频偏西式甜点，不过都是属于西点中较为简单的蛋糕。</p>
<p>Fennel给的配方个人感觉偏甜，如果要跟着配方一起做建议不怎么吃甜的适量减糖。</p>
<p>指路：<a href="https://space.bilibili.com/18503157/">Fennel的铲子</a></p>
<h2 id="YannieFoodie"><a href="#YannieFoodie" class="headerlink" title="YannieFoodie"></a>YannieFoodie</h2><p>Yannie简直是我心目中的裱花之神。主打做整个蛋糕，侧重点不在如何做蛋糕体，而在如何优雅地玩弄奶油。跟着Yannie做过红茶香缇奶油蛋糕作为自己21岁的生日蛋糕，十分yummy。</p>
<p>记得第一次知道复古蛋糕还是通过BennyCake的视频，据我长期混迹B站美食烘焙区的经验来看，Yannie是把复古蛋糕做的最好的一位了，没有之一。</p>
<p>蛋糕都是偏复古的裱花，调色美丽。看着她抹面简直是一种享受。由于个人水平受限与锻炼不足，Yannie的视频对我来说主要是提升审美、放松心情的作用。</p>
<p>指路：<a href="https://space.bilibili.com/186622642/">YannieFoodie</a></p>
<h2 id="我又把面包烤糊了"><a href="#我又把面包烤糊了" class="headerlink" title="我又把面包烤糊了"></a>我又把面包烤糊了</h2><p>关注的美食区up主里为数不多的男性烘焙爱好者了。视频特点就是狂放不羁。</p>
<p>视频的拍摄和剪辑都比较不那么精致。一般up主都会提前把材料称重放入碗中准备好，拍摄时直接混合搅拌即可，这位哥不一样，直接铁碗放面粉，边称重边过筛，能少洗一个碗就少洗一个碗，搅拌的时候碗边留点面粉也不在意，十分像平常真实烘焙的我。</p>
<p>还有值得一提的“又到了大家想吃吃不到的试吃环节”，一般就是糊糊拿着铁碗碗喝水配面包，最近又加入了玩偶嘉宾评测环节，当然是糊糊精分的表现。</p>
<p>因为糊糊家里是开面包店的，经常也会直播做面包。日常做的都是大家在面包房里看得到的面包，配方也是经过自己实践改良的那种。</p>
<p>指路：<a href="https://space.bilibili.com/31279395/">我又把面包烤糊了</a></p>
<h2 id="NoNo甜事"><a href="#NoNo甜事" class="headerlink" title="NoNo甜事"></a>NoNo甜事</h2><p>手揉面包必推硬核up主。跟着NoNo做了不知道多少面包，眼看着NoNo涨粉，自己却还只能揉出六分膜。</p>
<p>手揉御用面包粉为王后牌，御用酵母粉为燕子牌。NoNo的配方真的好，强烈建议跟着做。</p>
<p>另外，看NoNo揉面特别解压，适合放松心情，我超喜欢咕叽咕叽的声音。当然和正统ASMR相比，底噪还是有点大的。</p>
<p>指路：<a href="https://space.bilibili.com/13291356/">NoNo甜事</a></p>
<h1 id="硬菜复刻"><a href="#硬菜复刻" class="headerlink" title="硬菜复刻"></a>硬菜复刻</h1><h2 id="小高姐的魔法调料"><a href="#小高姐的魔法调料" class="headerlink" title="小高姐的魔法调料"></a>小高姐的魔法调料</h2><p>小高姐已经算是百万粉丝级别的大up主了，在我眼里她就是一个温柔的爱给孩子做饭的家庭主妇。</p>
<p>既然说了名字有“魔法”，那是真的会有魔法在料理中。看着像魔法，其实是有科学原理的。我认为小高姐的特点在于不仅告诉你怎么做，而且告诉你为什么要这么做，这背后的原理是什么都会和你捋清楚。这是她与其他一般美食up主的区别。</p>
<p>另外，小高姐还会做一些美食类科普视频。比如牛奶的种类及其衍生物，菜刀该如何选择，如何发面，烫面死面发面的区别等等。</p>
<p>进入小高姐的视频，一起听取妈声一片。</p>
<p>指路：<a href="https://space.bilibili.com/216156027/">小高姐的魔法调料</a></p>
<h2 id="绵羊料理"><a href="#绵羊料理" class="headerlink" title="绵羊料理"></a>绵羊料理</h2><p>大姨就不用多说了，直逼千万级元老级美食区up主，雅韵狂魔，硬菜屠戮者，绵羊A货工厂创始人。</p>
<p>除了复刻硬菜，也有美食探店类，旅游探店类食品。专业！</p>
<p>指路：<a href="https://space.bilibili.com/18202105/">绵羊料理</a></p>
<h2 id="淘米睡起床了"><a href="#淘米睡起床了" class="headerlink" title="淘米睡起床了"></a>淘米睡起床了</h2><p>继成功孵化出小鸡之后，淘米在研究孵化可达鸭。</p>
<p>淘米的视频偏研究向，很干货很硬核。这位up主简直就是自底向上构建美食框架。怎么讲，活用电饭煲达人，废物利用顶级选手。看了学不会，看了绝不亏。</p>
<p>指路：<a href="https://space.bilibili.com/314823429/">淘米睡起床了</a></p>
<h1 id="健康轻食"><a href="#健康轻食" class="headerlink" title="健康轻食"></a>健康轻食</h1><h2 id="享瘦厨房-好好吃瘦"><a href="#享瘦厨房-好好吃瘦" class="headerlink" title="享瘦厨房/好好吃瘦"></a>享瘦厨房/好好吃瘦</h2><p>不得不吐槽这两个up主的名字真的很偏营销号风格。</p>
<p>做的内容分量小，适合生酮人群。原材料主打杏仁粉、椰子面粉之类。没有跟着他们做过东西，但是可以为厨房烘焙提供一种新思路。</p>
<p>指路：<a href="https://space.bilibili.com/28469448/">享瘦厨房</a>/<a href="https://space.bilibili.com/444976875/">好好吃瘦</a></p>
<h2 id="芥末的小厨房"><a href="#芥末的小厨房" class="headerlink" title="芥末的小厨房"></a>芥末的小厨房</h2><p>一个主打健身食谱的up主，适合健身人群跟着一起做减脂餐。</p>
<p>跟着芥末一起做过鹰嘴豆泥，了解到白生芝麻酱Tahini，真的好吃，但是热量是真的高，微微泛苦还很香。还做过全麦贝果，配方优秀，操作简单。</p>
<p>指路：<a href="https://space.bilibili.com/43543458/">芥末的小厨房</a></p>
<h2 id="就是Hannah"><a href="#就是Hannah" class="headerlink" title="就是Hannah"></a>就是Hannah</h2><p>Hannah真的太宝藏了，温柔可爱，创意满满。</p>
<p>Hannah的作品颜值高而且还好做，基本原材料都是全麦面粉展开的，主打低糖低脂。</p>
<p>在B站Hannah和粉丝互动也很多，会有不定期抽奖活动。</p>
<p>指路：<a href="https://space.bilibili.com/365289494/">就是Hannah</a></p>
<h2 id="代阿悦啊"><a href="#代阿悦啊" class="headerlink" title="代阿悦啊"></a>代阿悦啊</h2><p>创意早餐博主。有一阵子跟着阿悦做了好多营养健康的早餐，包括但不限于金枪鱼韩式拌饭、奶油蘑菇浓汤、南瓜派、西班牙蛋饼、各种蛋奶烤吐司。</p>
<p>不过这些早餐内容都偏西式，一般都是用现成的切片面包或法棍面包为基础展开，配上一杯含水果的饮品。也有一些拌饭、意面、汤面之类。</p>
<p>阿悦好像断更挺久了。是已婚上班族，好像老公经常出差，希望他们多在一起吧，祝福。</p>
<p>指路：<a href="https://space.bilibili.com/268291670/">代阿悦啊</a></p>
<h2 id="猪侨"><a href="#猪侨" class="headerlink" title="猪侨"></a>猪侨</h2><p>魔芋与豆腐终极爱好者。魔芋代替面条，豆腐代替面粉。</p>
<p>当年还是因为猪侨卷入了爱做饭的芋头SAMA抄袭风波，我才知道猪侨的。现在芋头已经凉透了，猪侨的粉丝量也逐渐上涨了。</p>
<p>她的轻食堂系列真的十分简单易上手，料理残废的福音。马扎儿广播系列有点像朋友聊天，偏Podcast的内容，个人不太了解。</p>
<p>指路：<a href="https://space.bilibili.com/909376/">猪侨</a></p>
<h1 id="探店评测"><a href="#探店评测" class="headerlink" title="探店评测"></a>探店评测</h1><h2 id="我叫大头雨不愁"><a href="#我叫大头雨不愁" class="headerlink" title="我叫大头雨不愁"></a>我叫大头雨不愁</h2><p>大头真的是我看着胖起来的。东北up主，口音可爱，段子层出不穷，粉丝聚合力极强。</p>
<p>看大头的视频是真的能跟着笑出来的那种。头妃、隔壁王哥、妈见打、菜刀切牛排、腹肌除皱er等等，听一个笑一个，见一个笑一个。</p>
<p>从大头那里知道了东北美食，比如麻辣拌、麻辣盆、锅包肉、溜肉段、叉烧肉、东北烧烤、各地特色薯片及饮品。</p>
<p>指路：<a href="https://space.bilibili.com/267038161/">我叫大头雨不愁</a></p>
<h2 id="三联美食"><a href="#三联美食" class="headerlink" title="三联美食"></a>三联美食</h2><p>最近发现的新宝藏up主。偏各地特色美食测评向。</p>
<p>梅姨笑起来真的太好看太治愈了，就像一个姐姐和你坐在一起边吃边聊的感觉，治愈你的心也治愈你的胃，看完梅姨的视频不会让你觉得饿，会让你对产出这个美食的地方有所了解有所向往。</p>
<p>指路：<a href="https://space.bilibili.com/561861315/">三联美食</a></p>
<h2 id="燕子堡BBQ学徒Ray"><a href="#燕子堡BBQ学徒Ray" class="headerlink" title="燕子堡BBQ学徒Ray"></a>燕子堡BBQ学徒Ray</h2><p>知名牛排西餐up主。</p>
<p>从Ray这里学到了牛排熟成的各种方式，也看他开箱试吃试做各种品级的牛肉，反正就是馋人。吃肉多好！</p>
<p>指路：<a href="https://space.bilibili.com/338927049/">燕子堡BBQ学徒Ray</a></p>
]]></content>
      <categories>
        <category>食物猎人</category>
      </categories>
      <tags>
        <tag>Bilibili</tag>
        <tag>烘焙</tag>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Hexo+NexT搭建个人博客的分享</title>
    <url>/2020/10/02/hexoandnext/</url>
    <content><![CDATA[<h1 id="踩坑与出坑"><a href="#踩坑与出坑" class="headerlink" title="踩坑与出坑"></a>踩坑与出坑</h1><h2 id="Mac终端生成SSH-key并添加到Github上"><a href="#Mac终端生成SSH-key并添加到Github上" class="headerlink" title="Mac终端生成SSH key并添加到Github上"></a>Mac终端生成SSH key并添加到Github上</h2><p>参考<a href="https://vic.kim/2019/05/21/Mac%E7%94%B5%E8%84%91%E7%94%A8%E7%BB%88%E7%AB%AF%E7%94%9F%E6%88%90SSH%20key%20%E8%AE%BF%E9%97%AE%E8%87%AA%E5%B7%B1%E7%9A%84Github/">这篇博客</a>。</p>
<p>比较实用的部分是<code>如何检测SSH key是否有权限访问github</code>这一部分，通过在终端输入<code>ssh git@github.com</code>。</p>
<h2 id="执行npm-install出现的各种问题"><a href="#执行npm-install出现的各种问题" class="headerlink" title="执行npm install出现的各种问题"></a>执行<code>npm install</code>出现的各种问题</h2><p>错误1：<code>npm ERR! Unexpected end of JSON input while parsing near</code></p>
<p>执行<code>npm cache clean --force</code>，再执行<code>npm intsall</code>。可能要多尝试几次。</p>
<p>错误2：<code>Missing write access to /usr/local/lib/node_modules</code></p>
<p>执行<code>sudo chown -R $USER /usr/local/lib/node_modules</code>，具体解释在<a href="https://flaviocopes.com/npm-fix-missing-write-access-error/">此处</a>。</p>
<p>错误3：<a href="https://stackoverflow.com/questions/42735837/git-bash-remote-error-you-cant-push-to-git-github-com">Git Bash: remote error: You can’t push to git://github.com/</a></p>
<p>需要使用HTTPS或SSH URL。</p>
<h2 id="区分-config-yml文件"><a href="#区分-config-yml文件" class="headerlink" title="区分._config.yml文件"></a>区分._config.yml文件</h2><p>在<code>hexo site root direcotory</code>和<code>theme directory under site root directory</code>下分别有两个<code>._config.yml</code>文件，在阅读安装教程时请一定要看仔细每一步操作是针对哪一个配置文件进行的。</p>
<p>学会熟练使用配置文件comment中给出的链接，阅读相关内容即可设置出想要的效果。在遇到问题时优先选择阅读最新官方文档！</p>
<h2 id="CNAME文件部署后消失"><a href="#CNAME文件部署后消失" class="headerlink" title="CNAME文件部署后消失"></a>CNAME文件部署后消失</h2><p>直接在<code>hexo/source</code>目录下创建一个纯文件<code>CNAME</code>，里面存放的内容为从域名服务商处购买来的域名。</p>
<p>对于创建纯文件<code>CNAME</code>，应当在终端目录<code>hexo/source</code>下执行命令行<code>vi CNAME</code>，进入<code>vim</code>文本编辑输入模式<code>your-domain-name</code>，退出保存即可。</p>
<h2 id="本地重新部署后浏览器没有显示网页变化"><a href="#本地重新部署后浏览器没有显示网页变化" class="headerlink" title="本地重新部署后浏览器没有显示网页变化"></a>本地重新部署后浏览器没有显示网页变化</h2><p>由于学习使用的时候用的主要还是Chrome浏览器，他会自动缓存上一次的浏览记录，会让重新部署后的网页无法正确显示。在CNAME文件本地创建并上传多次后依然网页404，在设定<code>favicon</code>多次之后发现依然不出现小图标。</p>
<p>可以尝试在Chrome浏览器中删除最近一小时的浏览记录，问题即可解决。也可以多尝试其他浏览器，比如Firefox、Safari。</p>
<h1 id="实用指南"><a href="#实用指南" class="headerlink" title="实用指南"></a>实用指南</h1><h2 id="博客运作原理"><a href="#博客运作原理" class="headerlink" title="博客运作原理"></a>博客运作原理</h2><p> <a href="https://juejin.im/post/6844904131266609165">彻底搞懂如何使用Hexo+GitHubPages搭建个人博客</a></p>
<p>建议参考这篇文章前半部分，能够帮助理解Hexo和Github Pages之间的关系，Hexo在博客中扮演什么角色，Github Pages在博客中扮演什么角色。</p>
<h2 id="域名解析配置"><a href="#域名解析配置" class="headerlink" title="域名解析配置"></a>域名解析配置</h2><p><a href="https://sketchk.xyz/2017/03/24/A-Guide-Of-Making-Your-Personal-Blog-Part-3/">A Guide of Making Your Personal Blog - Part3</a></p>
<p>这系列文章都为我部署我的个人博客提供了很大的帮助。这一篇为我理解域名解析提供了很大帮助，它不仅告诉你操作流程，还告诉你操作流程背后的原因。</p>
<p>主要有三个部分：Namecheap购买域名，Cloudflare域名解析，Github响应解析。</p>
<p>Namecheap购买完域名之后，我们需要告诉Namecheap我需要通过Cloudflare的服务器进行域名解析，而不是通过namecheap自带的服务器解析。所以，我们需要在购买的域名中选择<code>Custom DNS</code>，并将<code>nameservers</code>的值更改为Cloudflare的服务器的地址。</p>
<p>为了获得Cloudflare的服务器地址，需要访问Cloudflare的网站。在这里为购买的域名添加记录，目的是将域名指向Github服务器的地址，添加记录的类型均为CNAME。</p>
<p>我们在这个定位到的是Github服务器的地址，但是服务器却不知道该返回什么样的子资源。为了让属于我们的Github Pages被返回，我们需要将Github Pages的<code>Settings</code>中的<code>Custom Domain</code>设定为在Namecheap购买的域名。</p>
<p>由此才可以建立起完整的域名解析。</p>
<h2 id="Hexo官方文档"><a href="#Hexo官方文档" class="headerlink" title="Hexo官方文档"></a>Hexo官方文档</h2><p><a href="https://hexo.io/docs/">这是Hexo官方文档</a></p>
<p>此官方文档能够指导的内容有：Node.js的安装、Hexo的安装、Hexo生成文件中各个参数的作用、如何使用Hexo来产出博客内容。</p>
<h2 id="NexT官方文档"><a href="#NexT官方文档" class="headerlink" title="NexT官方文档"></a>NexT官方文档</h2><p><a href="https://theme-next.js.org/">这是NexT最新说明文档</a></p>
<p>之前一直参考的是<a href="https://theme-next.iissnan.com/getting-started.html">iissnan</a>给出的说明文档，但是由于NexT更新，最新的指南应该根据最新的文档，否则会发现有<code>hexo/themes/next/_config.yml</code>配置文件内容的不同。</p>
<p>另外，这个最新的文档似乎没有中文版。</p>
]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>踩坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行与npm包管理</title>
    <url>/2020/10/04/command-line/</url>
    <content><![CDATA[<h1 id="shell内置命令行"><a href="#shell内置命令行" class="headerlink" title="shell内置命令行"></a>shell内置命令行</h1><p>CLI tools: command line interface tools</p>
<p>Change directory: <code>cd your-target-directory</code>.</p>
<p><strong>Listing directory contents: <code>ls</code>(short for list).</strong></p>
<p><strong>Create a new directory in current directory: <code>mkdir your-new-directory</code>.</strong></p>
<p>Remove the named directory: <code>rmdir your-target-directory</code>.</p>
<p><strong>Create a new empty file inside the current directory: <code>touch mdn-example.md</code>.</strong></p>
<p>Move a file from the first specified location to the second specified location: <code>mv first-specified-location second-specified-location</code>. Technically moving a file, but practically renaming a file.</p>
<p>Create a copy of the file:  <code>cp first-specified-location second-specified-location</code>.</p>
<p>Remove the specified file: <code>rm your-target-file</code>. Pernament delete and can not be undone via the recycle bin.</p>
<p><strong>Request contents from URLs: <code>curl you-target-URLs</code></strong></p>
<p>Return all the lines that contain the word you want: <code>grep the-word-you-want</code></p>
<h1 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h1><p><strong>Use <code>tab</code> key to auto complete</strong>，使用tab自动补全命令。</p>
<p><strong>Look at the <code>manage</code> page to find out what options each command has available: <code>man your-target-command</code></strong>，使用man命令查询具体命令的使用手册。</p>
<p>To run a command with mutiple options at the same time, you can usually put them all in a single string after the dash character.<strong>用短横线连接命令的options。</strong></p>
<p><strong>Use asterisks <code>*</code> as wild card characters meaning “any sequence of characters”</strong>, which allows you an operation concerning large number of files at once.使用star符号通配符查找满足条件的文件名。</p>
<p><strong>Chian commands together using pipe symbol <code>|</code>. The pipe redirects the output of the former command to the input of the latter command.</strong>使用pipe输出重定向到吓一跳语句。</p>
<p>Counts the number of words, characters, or bytes of whatever is inputted into it: <code>wc the-thing-you-want-to-count</code></p>
<h1 id="开发工具链-Tool-Chain"><a href="#开发工具链-Tool-Chain" class="headerlink" title="开发工具链 Tool Chain"></a>开发工具链 Tool Chain</h1><h2 id="包管理工具的npm解释"><a href="#包管理工具的npm解释" class="headerlink" title="包管理工具的npm解释"></a>包管理工具的npm解释</h2><p><code>npm</code>: Node Package Management. Together with <code>node.js</code>. A package manager is a system taht will manage your project dependencies.</p>
<p><code>Package registries</code>: a central place that a package is published to and thus can be installed from. e.g. The npm registry exists at <a href="https://www.npmjs.com/">npmjs.com</a>.在国内一般使用淘宝源能够更快下载。</p>
<p><code>dependency</code>:  a third-party bit of software that was probably written by someone else and ideally solves a single problem for you.</p>
<h3 id="npm命令集合"><a href="#npm命令集合" class="headerlink" title="npm命令集合"></a>npm命令集合</h3><p>Intialise a new project: <code>npm init</code>.</p>
<p>installing dependencies: <code>npm install your-target-dependency</code>.（这是局部安装，在当前文件夹下）</p>
<p>updating dependencies: <code>npm update</code>. Version of dependencies are specified in <code>package.json</code>.</p>
<p>Audit for vulnerabilities: <code>npm audit</code>.</p>
<p>Checking on a dependency: <code>npm ls your-target-dependency</code>.</p>
<p>（终端）查看已经全局安装的包：<code>npm list -g --depth 0</code></p>
<h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><p>在npm install之后加上<code>-g</code>或者<code>--global</code>就能实现全局安装，默认是安装在Node所在安装目录下的node.js文件夹中。</p>
<p><img src="/2020/10/04/command-line/image-20201226154742591.png" alt="image-20201226154742591" style="zoom:50%;"></p>
<p>安装后的包，包名就是一个命令，例如创建vue/cli项目就可以使用<code>vue create &lt;app-name&gt;</code>来创建一个vue项目，例如通过<code>npm -v</code>就可以查看包的版本号。</p>
<h3 id="局部安装"><a href="#局部安装" class="headerlink" title="局部安装"></a>局部安装</h3><p>局部安装，以webpack为例，就是使用<code>npm install webpack</code>或者<code>npm install webpack --save-dev</code>来安装。</p>
<p>在命令行的当前文件夹输入<code>npm install sass</code>会在当前路径的文件夹下面添加三个文件（当前目录中没有），分别是<code>package.json</code>、<code>package-lock.json</code>、<code>node_modules</code>，如下图所示。</p>
<p><img src="/2020/10/04/command-line/image-20201226155504843.png" alt="image-20201226155504843" style="zoom:50%;"></p>
<p>如果在以上操作之后再次执行一遍<code>npm install babel</code>，那么只会在当前的三个文件中添加依赖，而不会重新创建前面生成的三个文件。</p>
<p><center><br><img src="/2020/10/04/command-line/image-20201226160028474.png" alt="image-20201226160028474" style="zoom:30%;"><img src="/2020/10/04/command-line/image-20201226160248999.png" alt="image-20201226160248999" style="zoom:30%;"></center></p>
<center>

<p>如果执行<code>--save-dev</code> option就是要求把安装信息写在当前路径下已经存在的package.json文件中的devDependencies field中，包安装在当前路径下的node_modules文件夹中。</p>
<p>局部安装一般都是发生在一个具体的项目中，而这些包的的使用需要在文件全体根目录下的<code>eslint.config.js</code>文件（项目级配置）或者<code>.eslintrc.js</code>（文件级配置）。具体配置文件的区别参考<a href="https://stackoverflow.com/questions/60288375/when-to-use-babel-config-js-and-babelrc">StackOverflow的回答</a>。</p>
<p>局部安装更利于将各种依赖包以项目为单位集中管理、升级。</p>
<h3 id="npm与npx的区别"><a href="#npm与npx的区别" class="headerlink" title="npm与npx的区别"></a>npm与npx的区别</h3><p>npm是管理node包的工具。npx是执行node包的工具。</p>
<p>只有全局安装的包才能以包名去执行。</p>
<p>npx可以执行本地项目中的已经局部安装的命令，或者是执行没有安装的包的相关命令。例如<code>npx create-react-app my-app</code>会创建一个名为my-app的react脚手架，创建位置在当前文件夹所在位置。相当于替代了<code>npm create-react-app</code>以及<code>create-react-app my-app</code>这两个命令，且无需在全局安装react脚手架。</p>
<h2 id="项目开发工具"><a href="#项目开发工具" class="headerlink" title="项目开发工具"></a>项目开发工具</h2><h3 id="Formatting"><a href="#Formatting" class="headerlink" title="Formatting"></a>Formatting</h3><p><code>prettier</code>: an opinionated code formatter.</p>
<p>Find the problems in the code format and fix it: <code>prettier --wirte the-path-you-want-prettier-to-fix</code></p>
<h3 id="Linting"><a href="#Linting" class="headerlink" title="Linting"></a>Linting</h3><p>Linting helps with code quality but also is a way to catch potential errors earlier during development.</p>
<p><code>eslint</code>: a linting for JavaScript.</p>
</center>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>命令行</tag>
        <tag>npx</tag>
        <tag>npm</tag>
        <tag>全局安装</tag>
        <tag>局部安装</tag>
      </tags>
  </entry>
  <entry>
    <title>关于个人受益匪浅的生活好习惯</title>
    <url>/2020/10/04/myOctober-plan/</url>
    <content><![CDATA[<h1 id="规律作息"><a href="#规律作息" class="headerlink" title="规律作息"></a>规律作息</h1><p>早睡早起来形容作息还是过于狭隘，个人对于早的定义多少还是有不同的。此处的规律是个人摸索出来的一种可遵循的模式，例如对于我来说十二点前入睡，保证睡眠时间七小时，第二天就可以很精神地起床。</p>
<h1 id="晨起喝水"><a href="#晨起喝水" class="headerlink" title="晨起喝水"></a>晨起喝水</h1><p>不知道是不是最近成都降温了，早上醒来感觉鼻腔内干干的，这个时候一杯温水再好不过了。一般我会在前一天晚上在水杯里倒一半的开水间里的开水，第二天早上倒另一半，就可以获得温水啦。</p>
<p>水给有准备的人喝的。要是等到想喝水了才去倒水，多少会因为开水烫嘴而放弃。夏天的时候我一般会直接从校园超市买成桶卖矿泉水，直接对嘴喝。等天气凉了，就常备凉水壶，常备凉开水，开源节流。</p>
<h1 id="一杯咖啡"><a href="#一杯咖啡" class="headerlink" title="一杯咖啡"></a>一杯咖啡</h1><p>一杯醇香的咖啡真的可以开启美好的一天。加水或加奶都是我的最爱。</p>
<p>当然也可以把咖啡放到运动前喝，真的会感觉提升运动表现，不会很容易就感到疲劳。有一次我下午五点左右喝了一杯黄金曼特宁，晚上做keep的K4级别燃脂运动，连着做了两套，以往都是一套下来就累了。</p>
<h1 id="按时早餐"><a href="#按时早餐" class="headerlink" title="按时早餐"></a>按时早餐</h1><p>在九月底过了一周无早餐轻断食的生活。起因就是前一天晚餐吃得太多，第二天起来撑的慌，也没肚子去吃早餐了，就喝点水糊弄糊弄，到晚餐直接brunch。但是发现了一个问题，那就是我的晨间蹲坑时间开始不固定了。</p>
<p>最近几天开始固定早餐之后，发现自己到晚上对于食物就没那么渴望了，第二天起来也能很正常地蹲坑，就十分安心的感觉。</p>
<p>食物进入胃被消化到大肠直肠还是需要一定的时间的，据我粗浅的理解，大概就是吃得越早，食物被消化得越早，对于正常排泄就越有利。早餐没有吃的份总要在一天中的另外两餐中被补给，要是晚餐吃得多了，不仅容易发胖，还容易损害晚上夜跑的运动表现，更重要的是会让人睡的昏天黑地，第二天恶性循环。</p>
]]></content>
      <categories>
        <category>好好生活</category>
      </categories>
      <tags>
        <tag>习惯</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript ES6 语法特征</title>
    <url>/2020/10/05/es6/</url>
    <content><![CDATA[<h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><p>一共三种变量类型：<code>var</code> <code>let</code> <code>const</code>。</p>
<p>区别他们主要从</p>
<ul>
<li><p><code>scope: functional scope?block scope?</code></p>
</li>
<li><p><code>hoisting or not?</code>是否变量提升</p>
</li>
<li><p><code>can be redeclared?</code> </p>
</li>
<li><p><code>can be reassigned?</code></p>
</li>
</ul>
<p>这四方面。</p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>箭头函数(Arrow Functions)适用于需要使用<strong>匿名函数</strong>的地方。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(multiple/singleParam) =&gt; &#123;statement&#125;</span><br><span class="line">(multiple/singleParam) =&gt; expression</span><br><span class="line">(multiple/singleParam) =&gt; &#123;<span class="keyword">return</span> expression&#125;</span><br><span class="line"><span class="comment">//当只有单一的return语句时可以直接输出expression，没有括号和return语句</span></span><br><span class="line"><span class="comment">//括号既用在多个或单个参数传入</span></span><br><span class="line"><span class="comment">//单个参数传入不适用括号</span></span><br><span class="line">singleParam =&gt; &#123;statement&#125;</span><br><span class="line">() =&gt; &#123;statement&#125;</span><br></pre></td></tr></table></figure>
<h2 id="箭头函数的书写与花括号圆括号"><a href="#箭头函数的书写与花括号圆括号" class="headerlink" title="箭头函数的书写与花括号圆括号"></a>箭头函数的书写与花括号圆括号</h2><p>箭头左边才有可能出现<code>()</code>，这是参数的圆括号。</p>
<p>依据箭头函数代码块语句是一句还是多句，可以分成以下两个情况：</p>
<ul>
<li><p>箭头的右边出现<code>&#123;&#125;</code>，这是函数体的花括号，代表函数体内部会有多条语句，且会出现return语句。</p>
</li>
<li><p>箭头的右边没有花括号，代表函数体就一条语句，且这条语句自动会被作为箭头函数的return value。</p>
<p>但如果返回的是一个对象，需要再对象的花括号外层嵌套一个小圆括号，例如<code>() =&gt; (&#123;name: &#39;greg&#39;, id: 12345&#125;)</code>。</p>
</li>
</ul>
<h2 id="箭头函数与函数组件"><a href="#箭头函数与函数组件" class="headerlink" title="箭头函数与函数组件"></a>箭头函数与函数组件</h2><p>有的时候会使用匿名函数来创建函数组件，这种形式被称作arrow function component，并且把该匿名函数赋值给一个const变量，同时作为moudle被export出去。形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TryToLogin = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">// 返回的内容是大写的HTML标签构成的JSX对象</span></span><br><span class="line">        <span class="comment">// 必须要有一个根节点包裹，不能同时多个并列标签直接返回</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般函数组件的写法。当不给函数传递参数时，就代表该函数组件起一个组装UI或者路由的作用，比如下面这个顶层App组件。当为函数传递参数时，一般又是要进行数据传递的组件，会需要export。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">      &#x2F;&#x2F; HTML内置标签，定义react component后的标签</span><br><span class="line">      &#x2F;&#x2F; 全部大写</span><br><span class="line">      &#x2F;&#x2F; 路由标签</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>class组件与函数组件比较：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &#x2F;&#x2F; UI显示</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>render()&#123; return( )&#125;</code>这个模式在class组件中十分常见，代表的是UI渲染部分。</p>
<hr>
<p>在return语句内部本来应该返回的是类HTML语言，但是由于JSX语法的出现，只要我们把类JavaScript的语法放到花括号中，我们就可以在return语句内部写JavaScript。当然JavaScript语法的返回内容本质上还是类HTML语言。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> users = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Robin&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Markus&#x27;</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;users.map(<span class="function"><span class="params">user</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;user.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)&#125;</span><br><span class="line">      <span class="comment">// 第一层花括号是因为return语句返回的应该是html语言，但是users.map显然是javascript语言，所以我们需要用上花括号。</span></span><br><span class="line">      <span class="comment">// map语句内部表明用第一层花括号括起来的JavaScript语言返回的仍然是html语言/注意li标签。</span></span><br><span class="line">      <span class="comment">// 但是li标签内部又用了一层花括号，因为user.name是javascript语言。</span></span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<h2 id="单闭合标签调用与JSX语法引用"><a href="#单闭合标签调用与JSX语法引用" class="headerlink" title="单闭合标签调用与JSX语法引用"></a>单闭合标签调用与JSX语法引用</h2><p>无论组件时函数组件还是class组件，使用匿名函数定义的还是普通名称函数定义的，在调用组件的时候，都是将函数名称/组件名称/或者复制匿名函数到变量的名称（注意都需要大写）以HTML element的单闭合标签来使用。这个过程就好像是在<strong>调用函数，关注组件的return语句部分</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;TryToLogin &#x2F;&gt;</span><br><span class="line">&lt;Welcome &#x2F;&gt;</span><br><span class="line">&lt;App &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>但是有的时候又很奇怪为什么不用花括号取包裹这些标签，比如说在把模块import到当前文件后，使用<code>&#123;Welcome&#125;/&#123;App&#125;/&#123;TryToLogin&#125;</code>这种语法，需要指出的是，这个花括号只是让我们在HTML中能用JavaScript，如果用花括号包裹着这些内容，那就好像是<strong>把函数声明放在了html文件中</strong>，不会有任何渲染。</p>
<h1 id="模版字面量"><a href="#模版字面量" class="headerlink" title="模版字面量"></a>模版字面量</h1><p>模版字面量(Template Literals)通过在字符串中引入占位符<code>$&#123;&#125;</code>实现允许嵌入表达式的字符串字面量。</p>
<p>功能包括但不限于：</p>
<ul>
<li><p>代码中直接换行就能实现字符串输出换行</p>
</li>
<li><p>占位符中的表达式被直接计算输出</p>
</li>
</ul>
<h1 id="展开语法"><a href="#展开语法" class="headerlink" title="展开语法"></a>展开语法</h1><p>展开语法(Spread Syntax)可以使可迭代对象在某一处被展开，例如</p>
<ul>
<li>在函数调用或数组构造时，将数组表达式在语法层面展开，当作函数参数或数组元素传入</li>
</ul>
<p><code>myFunction(...iterableObj)</code>：用于代替<code>Function.prototype.apply(null, ...iterableObj)</code></p>
<p><code>[...iterableObj, &#39;4&#39;, &#39;five&#39;, 6]</code>：实现数组拷贝及连接</p>
<ul>
<li>在构造对象字面量时，将对象表达式按照key-value展开</li>
</ul>
<p><code>let objClone = &#123;...obj&#125;</code>：实现对象字面量的拷贝及连接</p>
<h1 id="剩余语法"><a href="#剩余语法" class="headerlink" title="剩余语法"></a>剩余语法</h1><p>剩余语法(Rest Syntax)和展开语法进行的是相反的操作，展开语法将某一东西展开为许多元素，剩余语法将多个元素收集合并成一个东西。</p>
<p>剩余语法允许我们将不被预期的、多余的（没有对应形参的实参）、不定量的参数收集成一个数组（是真正的<code>Array</code>实例）。</p>
<p><code>function(a, b, ...theArgs)&#123; &#125;</code></p>
<h1 id="类-继承"><a href="#类-继承" class="headerlink" title="类 继承"></a>类 继承</h1><p>类语法本质是基于原型的继承的语法糖。关于一个类包括定义类和类体方法。</p>
<h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>方法有两种：类声明和类表达式。</p>
<ul>
<li><p>类声明<code>class class-name&#123;&#125;</code></p>
</li>
<li><p>类表达式，可以分为具名类和匿名类</p>
<p><code>let var-name = class &#123;&#125;</code></p>
<p><code>let var-name = class class-name &#123;&#125;</code></p>
</li>
</ul>
<h2 id="类体方法"><a href="#类体方法" class="headerlink" title="类体方法"></a>类体方法</h2><p>构造函数：<code>constructor</code></p>
<p>静态方法： <code>static</code>关键字，常用于为一个应用程序创建工具函数</p>
<p>属性：</p>
<ul>
<li>实例属性定义在类的方法里</li>
<li>静态的或原型的数据属性通过点访问形式定义在类的外面</li>
</ul>
<h2 id="extends子类"><a href="#extends子类" class="headerlink" title="extends子类"></a><code>extends</code>子类</h2><p>​    <code>class sub-class-name extends super-class</code></p>
<h1 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h1><p>通过创造<code>Promise</code>链来实现链式调用，将前一个函数的返回情况绑定在<code>new Promise</code>对象上，而后调用<code>then()函数</code></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
        <tag>Arrow Function</tag>
        <tag>class</tag>
        <tag>Rest Syntax</tag>
        <tag>Spread Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title>React的条件渲染</title>
    <url>/2020/10/05/react-components/</url>
    <content><![CDATA[<h1 id="元素变量"><a href="#元素变量" class="headerlink" title="元素变量"></a>元素变量</h1><p>在组件的<code>render()</code>中引入一个元素变量。通过<code>if-else</code>条件语句判断表达式真假，将关于条件渲染的语句相关语速储存在这个条件变量中。</p>
<p>在最后的<code>return()</code>语句中只需要输出这个元素变量即可。</p>
<h1 id="内联渲染"><a href="#内联渲染" class="headerlink" title="内联渲染"></a>内联渲染</h1><p>适用于简单条件，对于过于复杂的条件应当选择提取组件。</p>
<h2 id="与运算符-amp-amp"><a href="#与运算符-amp-amp" class="headerlink" title="与运算符 &amp;&amp;"></a>与运算符 &amp;&amp;</h2><p><code>&#123;条件判断语句 &amp;&amp; 条件渲染语句&#125;</code></p>
<p>如果条件判断语句为<code>true</code>，则总返回右侧条件渲染语句；否则，直接忽略右侧语句总返回<code>false</code>。</p>
<h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p><code>condition ? true : false</code></p>
<h1 id="阻止组件渲染"><a href="#阻止组件渲染" class="headerlink" title="阻止组件渲染"></a>阻止组件渲染</h1><p>组件直接返回<code>null</code>，对于函数组件，直接<code>if</code>判断后<code>return null</code>；对于class组件，在<code>render()</code>中<code>return null</code>。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>条件渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>React的元素、组件与事件处理</title>
    <url>/2020/10/05/react-learning/</url>
    <content><![CDATA[<h1 id="HTML-DOM结点与React-DOM"><a href="#HTML-DOM结点与React-DOM" class="headerlink" title="HTML DOM结点与React DOM"></a>HTML DOM结点与React DOM</h1><p>一个HTML DOM结点对于React来说是“根”DOM结点，关于该节点的所有内容都由React DOM管理。</p>
<p>在<code>.js</code>文件中利用<code>React</code>语法生成各种元素、组件，而后通过<code>ReactDOM.render(待渲染的元素或组件, 利用普通DOM获得HTML中的节点)</code>渲染到HTML中对应的根DOM节点中。</p>
<p>利用React DOM的优点是它只将元素和它的子元素与它们之前的状态比较，只进行必要的更新来达到预期状态。</p>
<h1 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h1><p>React元素既可以是原HTML文件中的DOM标签及其组合，也可以是用户自定义的组件。</p>
<p><code>const element = DOM-tag-or-self-defined-component</code></p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p><strong>组件名称必须大写字母开头。</strong></p>
<h2 id="一般组件"><a href="#一般组件" class="headerlink" title="一般组件"></a>一般组件</h2><h3 id="函数组件：本质是编写JavaScript函数。"><a href="#函数组件：本质是编写JavaScript函数。" class="headerlink" title="函数组件：本质是编写JavaScript函数。"></a>函数组件：本质是编写JavaScript函数。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toppercase</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React-element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="class组件"><a href="#class组件" class="headerlink" title="class组件"></a><code>class</code>组件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toppercase</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> React-element;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h3><p>（更高一层级/更偏向用户层的）组件可以在其输出中引用其他（更低一层级/实现功能更单一的）组件。</p>
<p>一般来说，每个新的React应用程序的顶层组件都是<code>App</code>组件。</p>
<h2 id="如何抽取组件"><a href="#如何抽取组件" class="headerlink" title="如何抽取组件"></a>如何抽取组件</h2><p>元素的声明可以包含不止一个HTML结点（当然这是被允许的JSX写法），将元素抽取出来利用组件重新声明。</p>
<p>在被抽取出来的部分需要利用<code>props</code>对象在组件内部访问组件本身的属性、子组件及其属性；在更高层次的组件内部使用较低层次的组件，使用大写的单闭合的标签来标明属性及其取值。</p>
<p>这是属于外观的封装。</p>
<h2 id="组件内部属性访问"><a href="#组件内部属性访问" class="headerlink" title="组件内部属性访问"></a>组件内部属性访问</h2><h3 id="props"><a href="#props" class="headerlink" title="props"></a><code>props</code></h3><p>当React元素为用户自定义组件时，它会将JSX所接收的属性attributes以及子组件children转换为<strong>单个对象</strong>传递给组件，这个对象被称为<strong>props</strong>。</p>
<p>要在更高层级更抽象的组件层次访问更低层次更具体的组件层次，需要使用点访问，<code>props.children.child-attribute</code>或<code>props.attribute</code>。</p>
<p><code>props</code>具有只读性，组件不能修改自身的<code>props</code>。因为这是静态的，不可更改的，后面需要在组件中引入<code>state</code>来实现组件自我更新。</p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a><code>state</code></h3><p>1、只能在构造函数中对<code>this.state=</code>使用赋值语句。</p>
<p>2、为了达成更改state且重新渲染组件的目的，需要使用<code>setState()</code>。</p>
<p>3、<code>this.state</code>与<code>this.props</code>的更新可能是异步的，不要利用这两个值来更新下一个状态。应当将他们作为函数的参数传入，在函数体内更新。</p>
<p>4、 当state包含多个属性时，单独更新其中某一个属性的值时，<code>setState()</code>会自动将更新的state合并到当前没有更改的state。</p>
<h3 id="state与props的关系"><a href="#state与props的关系" class="headerlink" title="state与props的关系"></a>state与props的关系</h3><p>自上而下的单项数据流决定了：</p>
<p>任何state只属于拥有并设置了它的组件，是局部的、封装的。</p>
<p>某一组件可以将state作为props乡下传递给它的子组件。</p>
<h2 id="将函数组件转换成class组件"><a href="#将函数组件转换成class组件" class="headerlink" title="将函数组件转换成class组件"></a>将函数组件转换成class组件</h2><h3 id="为什么需要从函数组件转换到class组件"><a href="#为什么需要从函数组件转换到class组件" class="headerlink" title="为什么需要从函数组件转换到class组件"></a>为什么需要从函数组件转换到class组件</h3><p>每次组件更新时都有实例中的<code>render()</code>被调用。</p>
<p>让<code>ReactDOM</code>渲染DOM节点的时候，只有一个此组件的实例被创建，关于这个实例可以使用<code>state</code>或生命周期方法。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1、同名class且继承与<code>React.Component</code></p>
<p>2、类体添加<code>render()</code>方法并将函数体放入其中</p>
<p>3、函数体中的<code>this.props</code>替换<code>props</code></p>
<p>4、删除剩余的空函数声明</p>
<h3 id="在class组件中添加并使用state"><a href="#在class组件中添加并使用state" class="headerlink" title="在class组件中添加并使用state"></a>在class组件中添加并使用state</h3><p>1、将需要做出变化的属性从<code>props</code>的点访问转移到<code>state</code>的点访问。</p>
<p>2、添加<code>class</code>构造函数，为<code>this.state</code>赋初始值，且通过<code>super(props)</code>传递到父类的构造函数中。</p>
<h3 id="在class组件中添加并使用生命周期方法"><a href="#在class组件中添加并使用生命周期方法" class="headerlink" title="在class组件中添加并使用生命周期方法"></a>在class组件中添加并使用生命周期方法</h3><p>目的是在组件被销毁时释放资源。</p>
<p>当组件第一次被渲染到DOM的时候，设置一个“挂载”(mount)。<code>componentDidMount()&#123;&#125;</code>。</p>
<p>当组件被删除的时候，设置一个“卸载”(unmount)。<code>componentWillUnmount()&#123;&#125;</code>。</p>
<h3 id="class组件关于state和生命周期的调用顺序"><a href="#class组件关于state和生命周期的调用顺序" class="headerlink" title="class组件关于state和生命周期的调用顺序"></a>class组件关于state和生命周期的调用顺序</h3><p>组件被传递给<code>ReactDOM.render()</code>，对应到匹配的根节点DOM，进入组件。</p>
<p>React会调用该组件的构造函数，对象初始化。</p>
<p>React会调用该组件的<code>render()</code>方法，确定在html页面上要展示什么，更新根节点DOM来匹配组件输出。</p>
<p>一旦组件的初始输出被插入到根节点DOM中后，React调用组件中挂载的生命周期方法。</p>
<p>生命周期方法或其调用的其他方法会涉及<code>setstate()</code>方法，由此React知道了state已经改变，重新调用<code>render()</code>确定页面显示内容，从而渲染更新根节点DOM。</p>
<p>一旦组件从DOM中被移除，React调用卸载的生命周期方法。</p>
<h2 id="列表组件与key"><a href="#列表组件与key" class="headerlink" title="列表组件与key"></a>列表组件与key</h2><p>在一个组件中渲染列表，通常可以对数组进行调用<code>arr.map( arrow-function)</code>。箭头函数执行将数组转化为列表元素(list item)的功能。</p>
<p>当我们创建一个列表元素(list item)时，我们必须给每一个列表元素指定一个<code>key</code>属性，即<code>&lt;li key=&#123;&#125;&gt; &#123;JS-expression&#125; &lt;/li&gt;</code>。</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>key 帮助 React 识别哪些元素改变了，比如被添加或删除。</p>
<p>key是传递给React的，而不是传递给组件的，即不能用<code>props.key</code>来获取key属性的值。可以另外引入一个别名属性如id，其属性值与key属性值相同，可以被组件利用<code>props.id</code>读出。</p>
<p>一般使用数据中的id(<code>data.id</code>)来作为元素的key，不到万不得已使用元素索引。</p>
<p>key不一定要全局唯一，但是在其兄弟节点之间独一无二。</p>
<p>当把单个列表元素作为函数组件提取出来的时候，应该在哪里设置key？经验总是：在<code>map()</code>方法中的元素设置key。</p>
<h2 id="受控组件与表单"><a href="#受控组件与表单" class="headerlink" title="受控组件与表单"></a>受控组件与表单</h2><h3 id="为什么需要受控组件"><a href="#为什么需要受控组件" class="headerlink" title="为什么需要受控组件"></a>为什么需要受控组件</h3><p>HTML表单元素的工作方式与其他DOM元素不一样。表单元素如<code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>，<code>&lt;select&gt;</code>通常会维护一个属于自己的“state”，根据用户输入自动进行UI上的更新。</p>
<p>React中，组件的state属性控制着可变状态(mutable state)，并且只能通过<code>setState()</code>来更新。</p>
<p>需要让这两个state建立依赖关系统一起来——让React组件的state称为唯一的数据源，并让组件能够控制用户输入过程中表单发生的操作。</p>
<p>被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p>
<h3 id="受控组件的建立"><a href="#受控组件的建立" class="headerlink" title="受控组件的建立"></a>受控组件的建立</h3><p>分为两个步骤</p>
<p>1、 将<code>React</code>里的<code>state</code>属性和表单元素的值建立依赖关系。</p>
<p>也就是让组件获得对表单元素输入框内容的控制权。输入框的内容取决于元素的<code>value</code>属性，将表单元素的<code>value</code>属性赋值为<code>this.state.value-of-element</code>。</p>
<p>此时，表单元素内容是只读的，用户输入新的内容并不会让组件的state有所变化。此时运行会给出警告：</p>
<blockquote>
<p>Warning: Failed prop type: You provided a <code>value</code> prop to a form field without an <code>onChange</code> handler. This will render a read-only field. If the field should be mutable use <code>defaultValue</code>. Otherwise, set either <code>onChange</code> or <code>readOnly</code>.</p>
</blockquote>
<p>2、 通过<code>onChange</code>事件与<code>setState()</code>结合更新<code>state</code>属性</p>
<p>用一个事件来监听输入内容的改变，在回调函数中利用<code>this.setState</code>更新表单元素的<code>value</code>属性。</p>
<h2 id="组件间的数据共享"><a href="#组件间的数据共享" class="headerlink" title="组件间的数据共享"></a>组件间的数据共享</h2><p>多个组件需要反应相同的数据变化时，需要把共享<strong>状态提升</strong>到共同父组件中去，让父组件中共享的state称为多个子组件的唯一的数据源。实现<strong>自上而下的数据流</strong>。</p>
<p>一般在一个组件内部变化的数据通过state来访问或控制，多个组件在个字内部的state中相互独立地保存着各自的数据。</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>第一步，需要夺取子组件对共享数据的控制权，包括初始赋值与变化赋值。其思想与受控组件相同。</p>
<p>将想要共享的数据从由子组件内部state访问变成由父组件props传入，即由<code>this.state.shared-data</code>变为<code>this.props.shared-data</code>。</p>
<p>当我们需要子组件相应来自父组件的数据改变时，不再使用<code>this.setState()</code>，而是调用<code>this.props.shared-data-change-function</code>，获取父组件中具体的值，这个值就是一个事件处理函数。</p>
<p>第二步，相应改变父组件。</p>
<p>需要在父组件中构造函数中把<code>this.state</code>设置为想要共享的数据。</p>
<p>在父组件中提供子组件相应数据更改的函数，并作为属性值传入子组件中。</p>
<h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><h2 id="空元素"><a href="#空元素" class="headerlink" title="空元素"></a>空元素</h2><p><strong>空元素(empty element)</strong>是在HTML中不能存在子节点（例如内嵌的元素或者元素内的文本）的element。</p>
<p>一般的HTML元素的名称是在<strong>尖括号</strong>中使用的<strong>小写</strong>名称。例如，<code>&lt;p&gt;&lt;\p&gt;</code>带有一个斜杠开始的<strong>结束标记</strong>。</p>
<p>在一个空元素上结束标记既不需要也不允许，使用闭合标签是无效的。<code>&lt;input&gt;&lt;\input&gt;</code>是无效的写法，应该使用<code>&lt;input \&gt;</code>。</p>
<h2 id="组件使用的约定"><a href="#组件使用的约定" class="headerlink" title="组件使用的约定"></a>组件使用的约定</h2><p>在组件使用中我们需要注意两点：</p>
<p>1、 必须大写字母开头。这是为了和一般的HTML元素的小写名称加以区别</p>
<p>2、 在使用时没有闭合标签。这样的组件就与之前提到的空元素类似。</p>
<p>第二个注意点不一定是完全成立。当我在组件中包含/嵌套子组件，可以通过带闭合标签的尖括号将子组件传递给组合组件。由此引入组合、<code>props.children</code>的概念。</p>
<h2 id="组合与props"><a href="#组合与props" class="headerlink" title="组合与props"></a>组合与<code>props</code></h2><p>方式1:</p>
<p>在组件定义中引入<code>&#123;props.children&#125;</code>。</p>
<p>在组件使用时传入<code>&lt;Component&gt;your-children-Component&lt;\Component&gt;</code>。</p>
<p>方式2:</p>
<p>在组件定义中引入<code>&#123;props.self-defined-attribute&#125;</code>。</p>
<p>在组件使用时传入<code>&lt;Component self-defiend-attribute=&#123;sub-Component&#125;\&gt;</code>。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>组件</tag>
        <tag>props</tag>
        <tag>state</tag>
        <tag>生命周期</tag>
        <tag>受控组件</tag>
        <tag>列表组件</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的回调函数</title>
    <url>/2020/10/06/callback-function/</url>
    <content><![CDATA[<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>回调函数本质是一个在特定时刻特定事件下执行的函数，意思就是这个函数他和某个时间或事件相关联了，到达那个时间点或关注的事件被触发了，回调函数将被执行。</p>
<p>回调函数的作用是实现异步操作。程序不需要一直等待某个事件的发生才去执行回调函数，而是等事件发生后再去执行。</p>
<p>一个比较好理解的回答：</p>
<p><a href="https://www.zhihu.com/question/19801131/answer/17312995">回调函数（callback）是什么？ - 朱栩的回答 - 知乎</a></p>
<h1 id="回调函数与this"><a href="#回调函数与this" class="headerlink" title="回调函数与this"></a>回调函数与this</h1><p>React官方文档<a href="https://zh-hans.reactjs.org/docs/handling-events.html">事件处理</a>一章节给出了一个例子，提到需要谨慎使用JSX回调中的this。</p>
<p><code>this.handleClick = this.handleClick.bind(this);</code></p>
<p>一旦删除构造函数中的这句语句：</p>
<ul>
<li><p>一开始会正常显示初始页面(这是因为构造函数中初始化了属性)。</p>
</li>
<li><p>一旦进行点击操作，也就是通过“点击”事件触发回调函数handleClick()，就会导致TypeError: Cannot read property ‘setState’ of undefined——也就是handleClick()中的this是未定义的。</p>
</li>
</ul>
<p>对于事件处理器/事件处理函数handleClick()：</p>
<ul>
<li><p>为什么需要添加语句？</p>
<p>从它被定义的外围环境来看，该函数被作为一个类的方法在class组件中，而类的方法的<code>this</code>默认是取决于他们如何被调用的，是不会绑定指向这个类的实例的。通过改写这个行为，让类中<code>this</code>的值指向这个类实例，也就是开头提到的<code>bind()</code>语句。</p>
</li>
<li><p>为什么删除语句会报错？</p>
<p>从它是一个函数内部环境来看：在非严格模式下<code>`this</code>的值默认指向全局对象，在浏览器中就是<code>window</code>；在严格模式下，进入执行环境却没有设置<code>this</code>的值，<code>this</code>会保持<code>undefined</code>。</p>
</li>
</ul>
<p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">MDN Web Docs关于this的说明</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>回调函数</tag>
      </tags>
  </entry>
  <entry>
    <title>JSX语法</title>
    <url>/2020/10/06/jsx-syntax/</url>
    <content><![CDATA[<p>JSX是一种允许在JavaScript中编写类XML语言的语法，它需要通过<code>babel</code>编译器转换成标准的JS语言。</p>
<h1 id="使用JSX语法的必要准备"><a href="#使用JSX语法的必要准备" class="headerlink" title="使用JSX语法的必要准备"></a>使用JSX语法的必要准备</h1><ul>
<li><p>凡是使用JSX的<code>.js</code>文件都需要声明<code>&lt;script type=&quot;text/babel&quot;&gt;</code>。</p>
</li>
<li><p>三个库</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;vendor-js/react.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;vendor-js/react-dom.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;vendor-js/babel-core/browser.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="JSX的几个表现形式"><a href="#JSX的几个表现形式" class="headerlink" title="JSX的几个表现形式"></a>JSX的几个表现形式</h1><h2 id="HTML与JavaScript混写"><a href="#HTML与JavaScript混写" class="headerlink" title="HTML与JavaScript混写"></a>HTML与JavaScript混写</h2><p>HTML语言直接不带引号地写在JS语言中。如<code>&lt;h1&gt;Hello world&lt;\h1&gt;</code>。</p>
<h2 id="React组件可被使用"><a href="#React组件可被使用" class="headerlink" title="React组件可被使用"></a>React组件可被使用</h2><p>（约定都是大写）可以在被定义之后像普通的HTML标签一样<code>&lt;React-component /&gt;</code>被使用。</p>
<blockquote>
<p>React的JSX约定：开头大写代表自定义本地组件，小写开头代表HTML标签。</p>
</blockquote>
<h2 id="JavaScript表达式"><a href="#JavaScript表达式" class="headerlink" title="JavaScript表达式"></a>JavaScript表达式</h2><p>注意这里的JavaScript表达式可以是：</p>
<ul>
<li><p>包括常量、关键字、变量的原始表达式</p>
</li>
<li><p>对象和数组的初始化表达式</p>
</li>
<li><p>函数定义表达式</p>
</li>
<li><p>基于运算符的算术表达式</p>
</li>
</ul>
<h3 id="作为结点属性值"><a href="#作为结点属性值" class="headerlink" title="作为结点属性值"></a>作为结点属性值</h3><p>在大花括号内放置任何有效的JavaScript表达式并进行为节点属性进行赋值操作，这里的结点既可以是HTML自带的标签，也可以是自定义的元素或组件。</p>
<p><code>attribute = &#123;JavaScript-expression&#125;</code>。</p>
<h3 id="作为子节点表达式"><a href="#作为子节点表达式" class="headerlink" title="作为子节点表达式"></a>作为子节点表达式</h3><p>在大花括号内放置任何有效的子节点表达式，两边用父节点包括起来。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;</span><br><span class="line">                &#123;button&#125;<span class="comment">//这里的button就是子节点表达式</span></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JSX</tag>
      </tags>
  </entry>
  <entry>
    <title>React设计理念</title>
    <url>/2020/10/08/react-way-of-thinking/</url>
    <content><![CDATA[<h1 id="将设计好的UI划分为组件层级"><a href="#将设计好的UI划分为组件层级" class="headerlink" title="将设计好的UI划分为组件层级"></a>将设计好的UI划分为组件层级</h1><p>依据单一功能原则判断组件范围。</p>
<p>UI与数据模型数据同构，一一对应。</p>
<h1 id="用React创建静态版本"><a href="#用React创建静态版本" class="headerlink" title="用React创建静态版本"></a>用React创建静态版本</h1><p>将<strong>渲染UI</strong>与<strong>添加交互</strong>这两个过程分开。静态版本就是一个不包含交互功能的UI，需要编写较多代码而无需考虑组件间的交互细节。</p>
<p>建议：</p>
<ol>
<li><p>自下而上地构建应用，从最基本的组件开始编写。</p>
</li>
<li><p>只需要用到<code>porps</code>而不应该使用<code>state</code>。</p>
</li>
<li><p>只需要提供<code>render()</code>方法用于渲染。</p>
</li>
</ol>
<h1 id="确定UI-state的最小且完整表示"><a href="#确定UI-state的最小且完整表示" class="headerlink" title="确定UI state的最小且完整表示"></a>确定UI state的最小且完整表示</h1><p>设计理念： DRY(Don’t Repeat Yourself)</p>
<p>考虑每个组件中的所有数据，逐个检查数据是否属于state：</p>
<blockquote>
<ol>
<li>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。</li>
<li>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。</li>
<li>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</li>
</ol>
</blockquote>
<h1 id="确定state的放置位置"><a href="#确定state的放置位置" class="headerlink" title="确定state的放置位置"></a>确定state的放置位置</h1><p>对于应用中的每一个state：</p>
<blockquote>
<ul>
<li>找到根据这个 state 进行渲染的所有组件。</li>
<li>找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。</li>
<li>该共同所有者组件或者比它层级更高的组件应该拥有该 state。</li>
<li>如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。</li>
</ul>
</blockquote>
<p>至此，完成了从上而下的数据流，此时state的值有顶层组件控制，用户对底层组件的操作无法改变其值。</p>
<h1 id="添加反向数据流"><a href="#添加反向数据流" class="headerlink" title="添加反向数据流"></a>添加反向数据流</h1><p>因为用户的操作是对于底层的组件进行的，我们需要让数据反向传递：处于较低层级的表单组件更新较高层级组件的state。</p>
<p>这里涉及到<code>onChange</code>事件、回调函数、<code>setState()</code>。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>九月观影总结</title>
    <url>/2020/10/09/my-Sep-films/</url>
    <content><![CDATA[<h1 id="信条"><a href="#信条" class="headerlink" title="信条"></a>信条</h1><p>去影院看了两遍，不愧是诺兰，烧脑啊。但是依然还是有很多点不太懂，比如到底是平行世界还是因果世界。</p>
<h1 id="饥饿站台"><a href="#饥饿站台" class="headerlink" title="饥饿站台"></a>饥饿站台</h1><p>B站有一阵子每个影视区UP主都搞这个影视解说。感觉就是图一个猎奇血腥。</p>
<h1 id="八佰"><a href="#八佰" class="headerlink" title="八佰"></a>八佰</h1><p>电影亮度本来就低，导致我这个脸盲直接全程认错了演员匹配错了人。</p>
]]></content>
      <categories>
        <category>好好生活</category>
      </categories>
      <tags>
        <tag>观影</tag>
        <tag>审美</tag>
      </tags>
  </entry>
  <entry>
    <title>十月观影总结</title>
    <url>/2020/10/09/my-Oct-films/</url>
    <content><![CDATA[<h1 id="姜子牙"><a href="#姜子牙" class="headerlink" title="姜子牙"></a>姜子牙</h1><p>和哪吒之魔童降世应该是同一世界观的影片。男友告诉我导演是在暴雪和梦工厂呆过的，此片预算充足，国外工业漫画的味道略重。</p>
<p>个人观影比较注重画面与效果，姜子牙在这方面呈现得很不错。</p>
<p>故事铺垫过长，背景交代在整部影片中占据了较大的部分，导致后面高潮呈现较为局促。虽然能看出是要把狐族的线和姜子牙的线交织在一起，但是紧密程度不高。</p>
<h1 id="大护法"><a href="#大护法" class="headerlink" title="大护法"></a>大护法</h1><p>男友听说我对姜子牙观感甚好，就强烈建议我去看大护法和妙先生。</p>
<p>构思巧妙，隐喻到位，不愧是走的国产成人动漫的风格。我实在是太喜欢花生人的隐喻了，后面婆婆带着小姜参观工厂的画面把我震惊到了。不过后面为了圆大护法和太子的线，花生人的内部革命以及统治猪猡的那群人的部分感觉收尾潦草。应该会有第二部，期待构建整个世界观。</p>
<p>台词一般，配音一般。不知道编剧怎么想的，能把台词写的这么故作高深。也不知道是过于一般的台词导致了过于一般的配音，还是二者并无关系，这个配音真的有点蹩脚，国产漫画的配音还有很多路要走啊。</p>
<p>太子的人物角色担当了整部剧的笑点，就是画风实在是……一言难尽。</p>
<h1 id="妙先生"><a href="#妙先生" class="headerlink" title="妙先生"></a>妙先生</h1><p>如果说大护法是给了你隐喻，妙先生可以说就是把东西都掰开了揉碎了告诉你了，矛盾与纠纷的点都融合在人物的台词里了，经典的电车问题。可能就是太直白了，反而没什么意思，包装一下藏一下可能还让观众觉得有猜头。</p>
<p>画面精美度比大护法高多了，不过大护法的预算摆在那里呢，也不好比。</p>
<p>故事完成度较高，前因后果解释得很清楚，每一条线也都串了起来。</p>
<h2 id="燃烧女子的肖像"><a href="#燃烧女子的肖像" class="headerlink" title="燃烧女子的肖像"></a>燃烧女子的肖像</h2><p>久闻大名的姬片，百闻不如一见，果真名副其实。</p>
<p>服化道精美。篝火与阿卡贝拉、着火的裙子、被流产的女佣和她耳边的孩子、砧板壁炉与蔬菜、烤火的油画、赤裸女子的身躯、白色床单上唾液交缠的湿吻、深色岩石下迟到的初吻、读书少女红红的眼角、女画家的回眸、两个女孩坐在钢琴前的曲子。</p>
<p>台词氛围渲染极致。每一句台词都有深意，特别喜欢两位女主势均力敌说出对方的小习惯的那一段，莫名有种打情骂俏的感觉，哈哈。</p>
<p>最后两个演员真漂亮啊。小姐一开始真的满脸颓态，到最后和女画家相爱后那种富足的神态，真是太让人喜欢了，实打实的爱情啊。</p>
<h1 id="楚门的世界"><a href="#楚门的世界" class="headerlink" title="楚门的世界"></a>楚门的世界</h1><p>太残酷了。</p>
<p>当我们在玻璃罩子外面看里面的楚门，觉得他可怜。可是当玻璃罩子里面的楚门挣脱出来，一直呆在外面的我们，依然觉得他可怜。精神高潮只在他毅然决然走出那个出口的时刻。</p>
<h1 id="福尔摩斯小姐：失踪的侯爵"><a href="#福尔摩斯小姐：失踪的侯爵" class="headerlink" title="福尔摩斯小姐：失踪的侯爵"></a>福尔摩斯小姐：失踪的侯爵</h1><p>在私人影院看的，网飞无脑剧系列。看之前搜了一下豆瓣，发现评分一般，所以也没有报很大的期望去看。</p>
<p>值得的看点有：贵族少爷的三次剪发，怎么说，越变越好看，有种一步步颜值提升的感觉。女主的卷发和裙裙，不过不得不吐槽一下姑娘跑大城市去身怀巨资竟然只想被害命没被谋财。福尔摩斯庄园的家庭陈列，那些装饰品被打碎的时刻我竟然不是觉得怜惜而是觉得痛快。</p>
<p>侦探、推理元素涉及的太少了，看得出来导演想掺合一些女权、政治、家庭伦理在里面，但是掺合得稀烂。</p>
<h1 id="Emily-In-Paris"><a href="#Emily-In-Paris" class="headerlink" title="Emily In Paris"></a>Emily In Paris</h1><p>快餐剧。幸亏女主颜值在线能看看，但是造型师简直是把演员的脸和身材用造型糟蹋了明明白白地给你看。</p>
<p>本质上是披着职场生活外衣的玛丽苏后宫言情剧。</p>
]]></content>
      <categories>
        <category>好好生活</category>
      </categories>
      <tags>
        <tag>观影</tag>
        <tag>审美</tag>
      </tags>
  </entry>
  <entry>
    <title>MAMP本地服务器</title>
    <url>/2020/10/10/local-server-environment/</url>
    <content><![CDATA[<p>MAMP = Macintosh + Apache + MySQl + PHP</p>
<h1 id="教程分享"><a href="#教程分享" class="headerlink" title="教程分享"></a>教程分享</h1><p>还是Tania Rascia的教程</p>
<p><a href="https://www.taniarascia.com/local-environment/">安装MAMP并配置本地服务器</a></p>
<p><a href="https://www.taniarascia.com/setting-up-virtual-hosts/">多个虚拟主机的实现</a></p>
<h1 id="踩坑与出坑"><a href="#踩坑与出坑" class="headerlink" title="踩坑与出坑"></a>踩坑与出坑</h1><h2 id="不经过代理连接的主机设置"><a href="#不经过代理连接的主机设置" class="headerlink" title="不经过代理连接的主机设置"></a>不经过代理连接的主机设置</h2><p>系统代理是ClashX，出站规则是规则判断。不影响访问。</p>
<p>但是问题在于浏览器扩展中的SwitchyOmega，虽然模式是auto switch，但是一定要从选项中把不经过代理的主机列表添加进去，并且应用选项。</p>
<h2 id="浏览器问题（未出坑）"><a href="#浏览器问题（未出坑）" class="headerlink" title="浏览器问题（未出坑）"></a>浏览器问题（未出坑）</h2><p>Chrome浏览器是默认浏览器，在设置完不代理的主机之后能够成功访问虚拟主机。但是在Firefox中无法访问，显示链接被重置。</p>
<h2 id="Allow-SymLink-Override设定方式"><a href="#Allow-SymLink-Override设定方式" class="headerlink" title="Allow SymLink Override设定方式"></a>Allow SymLink Override设定方式</h2><p>教程中给出的是在路径为<code>/Applications/MAMP/conf/apache/httpd.conf</code>的<code>http.conf</code>文件中修改None为All。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Directory &#x2F;&gt;</span><br><span class="line">    Options Indexes FollowSymLinks</span><br><span class="line">    AllowOverride None</span><br><span class="line">&lt;&#x2F;Directory&gt;</span><br></pre></td></tr></table></figure>
<p>后来自己没有修改这部分，而是直接在添加的虚拟主机配置中设定，删除示例的两个虚拟主机，并在文件尾部添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    DocumentRoot &quot;&#x2F;Applications&#x2F;MAMP&#x2F;htdocs&quot;</span><br><span class="line">    ServerName myphpdev.test</span><br><span class="line">    ServerAlias myphpdev.test</span><br><span class="line">    &lt;Directory &quot;&#x2F;Applications&#x2F;MAMP&#x2F;htdocs&quot;&gt;</span><br><span class="line">        Options Indexes FollowSymLinks   </span><br><span class="line">        AllowOverride All</span><br><span class="line">        Order deny,allow</span><br><span class="line">        Allow from all</span><br><span class="line">    &lt;&#x2F;Directory&gt;</span><br><span class="line">&lt;&#x2F;VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<h2 id="虚拟主机名的设定"><a href="#虚拟主机名的设定" class="headerlink" title="虚拟主机名的设定"></a>虚拟主机名的设定</h2><p>谷歌浏览器不再支持<code>.dev</code>结尾的域名，自定义的虚拟主机名不要完全按照教程中来。</p>
<h2 id="端口更改"><a href="#端口更改" class="headerlink" title="端口更改"></a>端口更改</h2><p>端口更改需要在两个地方确认，一个是配置文件，一个是MAMP图形界面中的偏好设置。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><code>/Applications/MAMP/conf/apache/httpd.conf</code>的<code>http.conf</code>文件中修改两处</p>
<p><code>Listen 80</code>以及<code>ServerName localhost:8888</code>，这两个语句不在同一处。</p>
<h3 id="MAMP的偏好设置"><a href="#MAMP的偏好设置" class="headerlink" title="MAMP的偏好设置"></a>MAMP的偏好设置</h3><p>在MAMP的图形界面中打开<code>Preferences &gt; Ports</code>并修改端口分别为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Apache Port: 80</span><br><span class="line">Ngix Port: 8888</span><br><span class="line">MySQL Port: 3306</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>踩坑记录</tag>
        <tag>前端</tag>
        <tag>虚拟主机</tag>
        <tag>本地服务器</tag>
        <tag>MAMP</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP入门</title>
    <url>/2020/10/10/my-php-tutorial/</url>
    <content><![CDATA[<h1 id="PHP介绍"><a href="#PHP介绍" class="headerlink" title="PHP介绍"></a>PHP介绍</h1><p>PHP = Hypertext Preprocessor，超文本预处理器。</p>
<p>PHP脚本是在服务器上运行的。</p>
<h1 id="PHP-amp-JSON"><a href="#PHP-amp-JSON" class="headerlink" title="PHP &amp; JSON"></a>PHP &amp; JSON</h1><p>使用PHP语言来编码和解码JSON对象</p>
<h2 id="json-encode"><a href="#json-encode" class="headerlink" title="json_encode"></a><code>json_encode</code></h2><p>用于对PHP语言中的变量进行JSON编码，执行成功返回JSON数据，否则返回false。</p>
<h2 id="json-decode"><a href="#json-decode" class="headerlink" title="json_decode"></a><code>json_decode</code></h2><p>用于对JSON格式的字符串进行解码，并转换为PHP变量。</p>
<h2 id="json-last-error"><a href="#json-last-error" class="headerlink" title="json_last_error"></a><code>json_last_error</code></h2>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>前端技术栈的区别与联系</title>
    <url>/2020/10/10/what-we-have-to-learn-in-frontend/</url>
    <content><![CDATA[<h1 id="逐个解释"><a href="#逐个解释" class="headerlink" title="逐个解释"></a>逐个解释</h1><p>HTML是最基本的浏览器能够阅读的语言，是网页标记语言，是静态的。</p>
<p>CSS是层叠样式表，用于规定HTML元素的形态，被嵌套在网页中。</p>
<p>JavaScript是利用HTML标记代号内嵌于HTML中的JavaScript代码段。让静态的HTML网页有互动能力。</p>
<p>HTML/CSS/JavaScript都是<strong>基于浏览器端的解释运行</strong>，可以完全<strong>独立于服务器</strong>。以上三者创造出的是<strong>静态页面</strong>。</p>
<p>如果要让网页对外部数据请求产生大规模相应，就需要用到<strong>动态页面(Dynamic Webpage)</strong>，为此引入动态编程语言之一PHP。</p>
<p><strong>PHP不能被浏览器</strong>(也就是不能在客户端执行)执行，但是可以被<strong>安装了PHP解释插件的Web服务器(比如Apache)</strong>运行。在服务器端运行PHP程序，但发送到客户端只有HTML，<strong>服务器有选择地向客户端呈现内容</strong>。</p>
<p>还需要搭配数据库完成动态网页的构建，也就要用到<strong>数据库系统MySQL</strong>。对于客户端发送过来的请求，PHP服务器向MySQL服务器请求查询并获得MySQL的返回结果，<strong>以动态的方式生成静态资源(HTML/CSS/JavaScript)发送到客户端</strong>，完成页面的呈现。</p>
<h1 id="关系总结"><a href="#关系总结" class="headerlink" title="关系总结"></a>关系总结</h1><p>许多静态资源(包括HTML、CSS、JavaScript、Images、datas)被存放在Web服务器(如Apache)上。</p>
<p>动态编程语言(如PHP)依据客户端请求的具体资源，选择组合这些静态资源并将它们以动态文件(如PHP文件)的形式再投放到Web服务器上。</p>
<p>Web服务器上搭载的动态编程语言解释器将动态网页解释成静态资源，并返回给客户端，客户端收到的资源依然是静态资源。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhihu.com/question/22646257/answer/22378602">HTML、CSS、JavaScript、PHP、 MySQL 的学习顺序是什么？ - 知乎用户的回答 - 知乎 </a></p>
<p><a href="https://www.zhihu.com/question/19896544/answer/83808274">怎样通俗的讲解 PHP 和 Apache 的关系？ - 知乎用户的回答 - 知乎</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>PHP</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON入门</title>
    <url>/2020/10/10/working-with-json/</url>
    <content><![CDATA[<h1 id="JSON介绍"><a href="#JSON介绍" class="headerlink" title="JSON介绍"></a>JSON介绍</h1><p>JavaScript Object Notation(JSON/<code>.json</code>): JavaScript对象表示法用于将结构化数据表示为JavaScript对象的标准格式，常用于网站上表示和传输数据。</p>
<p>JSON对象基于JavaScript对象。将JS对象写入<strong>JSON数据</strong>从而构造一个对象树。将JSON文件保存为一个对象，加载它进入JS程序，通过.或[]访问JSON对象内的数据。</p>
<h2 id="JSON应用场景"><a href="#JSON应用场景" class="headerlink" title="JSON应用场景"></a>JSON应用场景</h2><p>用于浏览器(browser)和服务器(server)之间数据的传输。</p>
<p>注意：</p>
<p>JSON是一种纯数据格式，<strong>只包含属性</strong>，没有方法。</p>
<p>JSON要求在字符串和属性名周围<strong>使用双引号</strong>。</p>
<h1 id="JSON形式"><a href="#JSON形式" class="headerlink" title="JSON形式"></a>JSON形式</h1><p><a href="https://www.json.org/json-zh.html">官方文档</a></p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是一个无序的“名称/值”对的集合。他也可以被理解为<em>struct/dictionary/hash table/associative array</em>。</p>
<p>因此访问对象可以利用<code>-&gt;</code>访问法以及<code>[]</code>访问法。</p>
<p>对象总以左花括号开始，右花括号结束，“名称/值”对之间用逗号分隔。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object</span></span><br><span class="line">&#123;</span><br><span class="line">  key1: value1,</span><br><span class="line">  key2: value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是值的有序集合。</p>
<p>数组总以左中括号开始，右中括号结束。值之间使用逗号分隔。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array</span></span><br><span class="line">[</span><br><span class="line">  value1,</span><br><span class="line">  value2,</span><br><span class="line">  value3</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="值"><a href="#值" class="headerlink" title="值"></a>值</h1><p>值可以是双引号括起来的字符串、数值、布尔值、null、对象、或者数组。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串是由双引号包围的任意数量的Unicode字符的集合，使用反斜线转义。</p>
<h1 id="使用JSON"><a href="#使用JSON" class="headerlink" title="使用JSON"></a>使用JSON</h1><h2 id="设置XHR加载JSON格式数据"><a href="#设置XHR加载JSON格式数据" class="headerlink" title="设置XHR加载JSON格式数据"></a>设置XHR加载JSON格式数据</h2><ol>
<li><p>将保存一个待访问的URL作为变量保存在<code>var requestURL</code>中。</p>
</li>
<li><p>创建一个HTTP请求对象，利用new构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHTTPRequest()</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用HTTP请求对象的<code>open()</code>函数打开新的请求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.open(<span class="string">&quot;GET&quot;</span>, requestURL)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设定HHTTP请求对象的参数并发送请求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.responseType = <span class="string">&#x27;json&#x27;</span>;</span><br><span class="line">request.send()</span><br></pre></td></tr></table></figure>
</li>
<li><p>相应来自服务器的返回数据，并自定义处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> data = request.response;</span><br><span class="line">	<span class="comment">// function-with-data-as-params</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="JSON传输中数据和字符串的转换"><a href="#JSON传输中数据和字符串的转换" class="headerlink" title="JSON传输中数据和字符串的转换"></a>JSON传输中数据和字符串的转换</h2><ol>
<li><p>接收一些字符串作为JSON数据，需要将它转换为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.open(<span class="string">&quot;GET&quot;</span>, requestURL);</span><br><span class="line">request.responseType = <span class="string">&#x27;text&#x27;</span>;</span><br><span class="line">request.send()</span><br><span class="line"></span><br><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> textObj = request.response;</span><br><span class="line">	<span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(textObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>发送JSON数据作为信息，需要将它转换为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myJson = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> myString = <span class="built_in">JSON</span>.stringify(myJSON);</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>初始化后的create-my-react的文件解释</title>
    <url>/2020/10/11/create-my-react-explanation/</url>
    <content><![CDATA[<p>文件树如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">my-react-tutorial</span><br><span class="line">├── README.md</span><br><span class="line">├── node<span class="emphasis">_modules</span></span><br><span class="line"><span class="emphasis">├── package.json</span></span><br><span class="line"><span class="emphasis">├── package-lock.json</span></span><br><span class="line"><span class="emphasis">├── .gitignore</span></span><br><span class="line"><span class="emphasis">├── public</span></span><br><span class="line"><span class="emphasis">│   ├── favicon.ico</span></span><br><span class="line"><span class="emphasis">│   ├── index.html</span></span><br><span class="line"><span class="emphasis">│   └── manifest.json</span></span><br><span class="line"><span class="emphasis">└── src</span></span><br><span class="line"><span class="emphasis">    ├── App.css</span></span><br><span class="line"><span class="emphasis">    ├── App.js</span></span><br><span class="line"><span class="emphasis">    ├── App.test.js</span></span><br><span class="line"><span class="emphasis">    ├── index.css</span></span><br><span class="line"><span class="emphasis">    ├── index.js</span></span><br><span class="line"><span class="emphasis">    ├── logo.svg</span></span><br><span class="line"><span class="emphasis">    └── serviceWorker.js</span></span><br></pre></td></tr></table></figure>
<h1 id="极为重要的两个文件"><a href="#极为重要的两个文件" class="headerlink" title="极为重要的两个文件"></a>极为重要的两个文件</h1><ul>
<li><p>Page template<code>public/index.html</code></p>
</li>
<li><p>JavaScript entry point<code>src/index.js</code></p>
</li>
</ul>
<p>以上两个文件必须以此命名并存放在该路径，其余文件可以自由命名。</p>
<h1 id="README-md"><a href="#README-md" class="headerlink" title="README.md"></a>README.md</h1><p>从命令行角度来说明如何整体操作项目，包括启动项目、初始化项目、构建项目、部署项目。</p>
<h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><p>这是所有的npm包在项目根目录都有的一个文件。</p>
<p>该文件包含了Node.js/npm为了建立起具体项目的元数据(metadata)，包括依赖包(dependencies)、项目版本(version of the project)、许可证信息(license information)、配置信息(configuration data)。</p>
<h1 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h1><p>如果有人使用了<code>npm</code>下载了你的项目，所有列出在package.json中的依赖包都会被下载并放到<code>./node_modules</code>目录下。</p>
<p>如果自己在本地项目的根目录下运行命令行<code>npm install</code>，那么下载的依赖包就会被放到<code>./node_modules</code>目录下。</p>
<p>因此，我们通过在命令行中运行<code>npm create-react-app my-react-tutorial</code>，就是下载了React官方发布的项目，且列出在package.json中的所有依赖包都被我们下载并放到了<code>./node_modules</code>目录下。</p>
<h1 id="public"><a href="#public" class="headerlink" title="public"></a>public</h1><p>只有在<code>public</code>目录中的文件才可以被<code>public/index.html</code>使用。一般来说除了修改<code>title</code>元素的内容来更改应用程序的名字，其他<code>index.html</code>中的内容都不应当被编辑，除非你清楚自己在进行什么样的操作。</p>
<p><code>public</code>目录只有在build和deploy的时候会被更新。</p>
<h1 id="src"><a href="#src" class="headerlink" title="src"></a>src</h1><p>该目录存放该项目的JS以及CSS文件，只有<code>src</code>目录下的文件才会被<a href="https://www.webpackjs.com/concepts/">Webpack静态模块打包器</a>处理。可以在<code>src</code>目录中新建子目录。</p>
<p>React将<code>src</code>目录中的代码嵌入到HTML文件的DOM树中，从而让浏览器能够解析出<code>index.html</code>文件。</p>
<h2 id="关于index-js的解读"><a href="#关于index-js的解读" class="headerlink" title="关于index.js的解读"></a>关于index.js的解读</h2><h3 id="顶部import语句"><a href="#顶部import语句" class="headerlink" title="顶部import语句"></a>顶部<code>import</code>语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import logo from &#39;.&#x2F;logo.svg&#39;;</span><br><span class="line">import &#39;.&#x2F;App.css&#39;;</span><br></pre></td></tr></table></figure>
<p>第一句导入React库，这一步的目的是允许React库将JS文件中的JSX语句转换成<code>React.createElement()</code>。所有与React相关的部分都需要包括这个React库。</p>
<p>这里值得注意的是，我们没有给<code>import React</code>指定路径，是因为<code>React</code>是作为一个依赖库存在于<code>package.json</code>中的。</p>
<p>第二句导入一个当前文件夹下的普通文件，需要指明路径。</p>
<p>第三句是导入CSS文件，这里直接就是就是路径，没有变量名也没有from导入。</p>
<h3 id="中间class-函数组件"><a href="#中间class-函数组件" class="headerlink" title="中间class/函数组件"></a>中间class/函数组件</h3><p>组件名称遵循<code>pascal-case variable</code>，一定要大写。</p>
<p>对于JSX写法的元素(element)设定属性(attribute)，和HTML中写法大致一致。区别在于HTML中元素的<code>class attribute</code>到JSX中变成了<code>className attribute</code>，这是因为<code>class</code>作为关键字被使用了。</p>
<h3 id="底部export语句"><a href="#底部export语句" class="headerlink" title="底部export语句"></a>底部<code>export</code>语句</h3><p>一个<code>.js</code>文件底部的<code>export default this-js-name.js</code>使该文件能够在其他的<code>.js</code>文件的顶部利用<code>import</code>导入并使用。</p>
<h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h1><p><a href="https://create-react-app.dev/docs/folder-structure">create-my-react document: folder structure</a></p>
<p><a href="https://wiki.developer.mozilla.org/zh-CN/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_getting_started">MDN web docs: React getting started</a></p>
<p><a href="https://nodejs.org/en/knowledge/getting-started/npm/what-is-the-file-package-json/">What is the file package json</a></p>
<p><a href="https://juejin.cn/post/6844903502720794638">前端基础配置详解</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/26041084">webpack配置解释</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>create-react-app</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript调用API</title>
    <url>/2020/10/11/js-with-api/</url>
    <content><![CDATA[<h1 id="API定义"><a href="#API定义" class="headerlink" title="API定义"></a>API定义</h1><blockquote>
<p><strong>API</strong> stands for Application Program Interface, which can be defined as a set of methods of communication between various software components. In other words, an API allows software to communicate with another software.</p>
</blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Introduction">MDN web docs的Web API简介</a></p>
<p>API抽象了该应用中复杂的代码，提供一些简单的接口规则供使用其他应用使用。相当于应用之间互相借用功能的一个渠道。</p>
<h1 id="访问第三方API的方式"><a href="#访问第三方API的方式" class="headerlink" title="访问第三方API的方式"></a>访问第三方API的方式</h1><p>首先，需要明确访问第三方API的主体是谁。</p>
<p>我们把网页的资源（包括静态资源和动态资源）放在网页服务器(Web Server)上。当客户端浏览器对服务器进行请求的时候，网页服务器依据这些资源作出回应。返回这些资源之前需要访问第三方API，因此是网页服务器在访问第三方API。</p>
<h2 id="HTTP-Requests"><a href="#HTTP-Requests" class="headerlink" title="HTTP Requests"></a>HTTP Requests</h2><blockquote>
<p>Use <strong>HTTP requests</strong> to communicate to a publicly available URL <strong>endpoint</strong> containing JSON data. </p>
</blockquote>
<h3 id="常用HTTP方法"><a href="#常用HTTP方法" class="headerlink" title="常用HTTP方法"></a>常用HTTP方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">动作</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Create</td>
<td style="text-align:center"><code>POST</code></td>
<td style="text-align:center">创建新的资源</td>
</tr>
<tr>
<td style="text-align:left">Read</td>
<td style="text-align:center"><code>GET</code></td>
<td style="text-align:center">获取资源</td>
</tr>
<tr>
<td style="text-align:left">Update</td>
<td style="text-align:center"><code>PUT/PATCH</code></td>
<td style="text-align:center">更新已有资源</td>
</tr>
<tr>
<td style="text-align:left">Create</td>
<td style="text-align:center"><code>DELETE</code></td>
<td style="text-align:center">删除资源</td>
</tr>
</tbody>
</table>
</div>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">request.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;https://ghibliapi.herokuapp.com/films&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(<span class="built_in">this</span>.response)</span><br><span class="line">  <span class="keyword">if</span>(request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">400</span>)&#123;</span><br><span class="line">  <span class="comment">// 对数据的操作</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 链接不存在的情况</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">request.send();</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h3><ol>
<li>在获取到JSON数据后，先不着急把数据放入到已存在的或者已创建的DOM元素中，先使用<code>console.log()</code>在<strong>控制台输出数据</strong>，并用浏览器的检查元素<code>Inspect</code>查看一下。</li>
<li>需要<strong>考虑链接失效的情况</strong>，对于每一个<code>HMLHttpRequest</code>对象，都会在请求结束资源后返回一个状态码<code>status</code>，用它来判断是否成功获取了资源。</li>
<li>一般需要<strong>查询第三方API的官方说明文档</strong>，里面会有获取资源的说明，以及会返回什么样的状态码。</li>
</ol>
<h2 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h2><p>Fetch API用于取代XHR，是HTML 5的内置API。</p>
<blockquote>
<p> <code>fetch()</code> 必须接受一个参数——资源的路径。无论请求成功与否，它都返回一个 Promise 对象，resolve 对应请求的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a>。你也可以传一个可选的第二个参数 <code>init</code>（参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request"><code>Request</code></a>）。</p>
<p>一旦 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 被返回，就可以使用一些方法来定义内容的形式，以及应当如何处理内容（参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Body"><code>Body</code></a>）。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// replace url with your JSON feed</span></span><br><span class="line">fetch(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line">	.then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> response.json();</span><br><span class="line">&#125;)</span><br><span class="line">	.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  	<span class="comment">// work with JSON data here</span></span><br><span class="line">  	<span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">	.catch(<span class="function">(<span class="params">error</span>) =&gt;</span>&#123;</span><br><span class="line">  	<span class="comment">// do something for an error here</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="简单Demo"><a href="#简单Demo" class="headerlink" title="简单Demo"></a>简单Demo</h1><p><a href="https://www.taniarascia.com/how-to-connect-to-an-api-with-javascript/">How to Connect to an API with JavaScript</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>JavaScript</tag>
        <tag>Fetch</tag>
        <tag>HTTPRequest</tag>
        <tag>endpoint</tag>
      </tags>
  </entry>
  <entry>
    <title>用于React学习的demo</title>
    <url>/2020/10/11/react-demo-lists/</url>
    <content><![CDATA[<h1 id="React安装"><a href="#React安装" class="headerlink" title="React安装"></a>React安装</h1><p>MDN web docs对执行create-react-app初始化项目的操作步骤，完成初始化之后的文件树结构进行了十分详细的介绍，有助于理解文件之间的关系。</p>
<p><a href="https://wiki.developer.mozilla.org/zh-CN/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_getting_started">MDN web docs关于create-react-app的解释</a></p>
<h1 id="React学习"><a href="#React学习" class="headerlink" title="React学习"></a>React学习</h1><p>React官方学习指南，主要阅读并实现核心概念的部分即可。</p>
<p><a href="https://zh-hans.reactjs.org/docs/hello-world.html">逐步学习指南</a></p>
<h1 id="React实践"><a href="#React实践" class="headerlink" title="React实践"></a>React实践</h1><h2 id="Tania-Rascia的React教程"><a href="#Tania-Rascia的React教程" class="headerlink" title="Tania Rascia的React教程"></a>Tania Rascia的React教程</h2><p>主要涉及对<code>src</code>目录中JS代码的编写。</p>
<p><a href="https://www.taniarascia.com/getting-started-with-react/">React Tutorial: An Overview and Walkthrough</a></p>
<h2 id="网页端简书项目"><a href="#网页端简书项目" class="headerlink" title="网页端简书项目"></a>网页端简书项目</h2><p>原项目时间较久，三年前了，但是胜在解读清晰。</p>
<p>地址：<a href="https://github.com/huyaocode/react-jianshu">huyaocode react-app</a></p>
<hr>
<p>后来找到了其他人的复刻项目，有踩雷与语法更新，值得参考学习。</p>
<p>地址：<a href="https://github.com/xingorg1/JuFengGuo/tree/master/advanceCourse/react">JuFengGuo react</a>。</p>
<p>腾讯云有他的博客： <a href="https://cloud.tencent.com/developer/user/2140806">xing.org1^ Blog</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title>Endpoint解释</title>
    <url>/2020/10/11/what-is-endpoint/</url>
    <content><![CDATA[<h1 id="What-is-an-API-Endpoint"><a href="#What-is-an-API-Endpoint" class="headerlink" title="What is an API Endpoint?"></a>What is an API Endpoint?</h1><blockquote>
<p>Simply put, an endpoint is one end of a communication channel. When an API interacts with another system, <strong>the touchpoints of this communication are considered endpoints</strong>. For APIs, an endpoint can include a URL of a server or service. <strong>Each endpoint is the location from which APIs can access the resources they need to carry out their function.</strong></p>
<p>APIs work using ‘requests’ and ‘responses.’ When an API requests information from a web application or web server, it will receive a response. The place that APIs send requests and where the resource lives, is called an endpoint.</p>
</blockquote>
<p>References: <a href="https://smartbear.com/learn/performance-monitoring/api-endpoints/">API Endpoints</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>JavaScript</tag>
        <tag>endpoint</tag>
      </tags>
  </entry>
  <entry>
    <title>Github使用操作以及问题</title>
    <url>/2020/10/20/github-up-down/</url>
    <content><![CDATA[<h1 id="项目建立与关联"><a href="#项目建立与关联" class="headerlink" title="项目建立与关联"></a>项目建立与关联</h1><h2 id="登陆个人github创建新的远程仓库"><a href="#登陆个人github创建新的远程仓库" class="headerlink" title="登陆个人github创建新的远程仓库"></a>登陆个人github创建新的远程仓库</h2><p>创建结束代码库之后会跳出指示操作界面，分两种情况：</p>
<ul>
<li>or create a new repositoory on the command line</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">git remote add origin SSH-KEY</span><br><span class="line">git push -u origin BRANCH-NAME</span><br></pre></td></tr></table></figure>
<ul>
<li>or push an existing repository from the command line</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin SSH-KEY</span><br><span class="line">git push -u origin BRANCH-NAME</span><br></pre></td></tr></table></figure>
<p>二者区别主要在于我们的本地电脑上是否有初始化git仓库，即含有代码的文件夹有没有在命令行中被git化。</p>
<p>git化之后的文件夹当中应当有一个隐藏的<code>.git</code>文件，在mac下直接<code>cmd</code>+<code>shift</code>+<code>.</code>可以显示。</p>
<p>SSH-KEY和BRANCH-NAME就是下图所示的内容。</p>
<p><img src="/2020/10/20/github-up-down/ssh-key.png" alt="ssh-key" style="zoom:50%;"></p>
<h2 id="第一次上传代码"><a href="#第一次上传代码" class="headerlink" title="第一次上传代码"></a>第一次上传代码</h2><h3 id="第一步：在终端下分别进入目标文件夹并初始化git"><a href="#第一步：在终端下分别进入目标文件夹并初始化git" class="headerlink" title="第一步：在终端下分别进入目标文件夹并初始化git"></a>第一步：在终端下分别进入目标文件夹并初始化git</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> target-dir</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<h3 id="第二步：关联本地库与远程库"><a href="#第二步：关联本地库与远程库" class="headerlink" title="第二步：关联本地库与远程库"></a>第二步：关联本地库与远程库</h3><p>从本地工作区(working directory)到暂缓区/提交区(staging srea)；从暂缓区/提交区到git目录/版本库(git directory)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m &quot;description-for-this-commit&quot;</span><br></pre></td></tr></table></figure>
<p>关联远程github库并设置分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin SSH-KEY</span><br><span class="line">git branch -M main</span><br></pre></td></tr></table></figure>
<h3 id="第三步：上传到github"><a href="#第三步：上传到github" class="headerlink" title="第三步：上传到github"></a>第三步：上传到github</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<h2 id="第二次更新代码"><a href="#第二次更新代码" class="headerlink" title="第二次更新代码"></a>第二次更新代码</h2><p>首先查看仓库状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>之后的操作和关联本地库与远程库相同。</p>
<h2 id="添加项目更新总结"><a href="#添加项目更新总结" class="headerlink" title="添加项目更新总结"></a>添加项目更新总结</h2><p>先在Github上创建一个repository，并复制SSH。</p>
<p>在本地终端进入目的文件夹，并用命令<code>git init</code>初始化，<code>git add .</code>或者<code>git add -A</code>把所有该文件夹下的文件放到本地暂缓区，在利用命令<code>git commit -m &quot;&quot;</code>把本地暂缓区的内容放到本地版本库。</p>
<p>利用命令<code>git remote set-URL origin SSH</code>先把本地url设置为ssh的地址，并转到具体分支<code>git branch -M BRANCH_NAME</code>。</p>
<p>利用命令<code>git push -u origin BRACH_NAME</code>把文件提交到BRACH_NAME的分支中，默认repository创建只有一个main brach。</p>
<h1 id="查看历史版本"><a href="#查看历史版本" class="headerlink" title="查看历史版本"></a>查看历史版本</h1><p>跟随做项目的时候为了看懂别人的代码，需要用到查看历史Commits。一般git clone出来的总是最新更新的版本，通过版本退回可以看到别人实现项目的思路演变。</p>
<p><a href="https://segmentfault.com/a/1190000010771974">操作参考</a></p>
<ol>
<li>正常git clone项目到目的文件夹</li>
<li>点击Commits进入历史版本，获取你想要查看的那个版本的SHA</li>
<li>在目的文件夹下使用git checkout SHA</li>
</ol>
<h1 id="可能遇到的问题集合"><a href="#可能遇到的问题集合" class="headerlink" title="可能遇到的问题集合"></a>可能遇到的问题集合</h1><h2 id="Repository-not-found"><a href="#Repository-not-found" class="headerlink" title="Repository not found"></a>Repository not found</h2><p>可能遇到的问题如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">remote: Repository not found.</span><br><span class="line">fatal: repository <span class="string">&#x27;https://github.com/MyRepo/project.git/&#x27;</span> not found</span><br></pre></td></tr></table></figure>
<ul>
<li><p>解决办法1: </p>
<p>尝试从钥匙串中删除所有与GitHub有关的内容</p>
</li>
<li><p>解决办法2: </p>
<p>检查是否正确地设置了远程仓库地址</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>如果发现不对就重新设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote set-url origin https://username@github.com/MyRepo/project.git</span><br></pre></td></tr></table></figure>
<h2 id="无法打开github文件夹"><a href="#无法打开github文件夹" class="headerlink" title="无法打开github文件夹"></a>无法打开github文件夹</h2><p>很有可能是因为子文件夹下面已经有了一个隐藏的.git文件夹，导致无法解析，github把这个文件夹默认为untracked content。只需要删除.git文件夹即可。</p>
<p>对于一个repository中的所有文件夹，必须只能 only one root<code>.git</code> folder，否则无法解析。</p>
<p>参考StackOverflow的回答<a href="https://stackoverflow.com/questions/28384464/why-can-i-not-open-my-folder-in-github">为什么无法打开github文件夹</a>。</p>
]]></content>
      <categories>
        <category>必备技能</category>
      </categories>
      <tags>
        <tag>踩坑记录</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch+Anaconda+JupyterNotebook环境搭建</title>
    <url>/2020/10/22/ml-env-setup/</url>
    <content><![CDATA[<h1 id="常见conda指令"><a href="#常见conda指令" class="headerlink" title="常见conda指令"></a>常见conda指令</h1><ul>
<li><code>conda -V</code></li>
<li><code>conda list</code></li>
<li><code>conda install PACKAGE_NAME=MAJOR.MINOR.PATCH</code></li>
<li><code>conda create --name ENVIRONMENT</code></li>
<li><code>conda activate ENVIRONMENT</code></li>
<li><code>conda deactivate</code> </li>
<li><code>conda info --env</code></li>
</ul>
<h1 id="正确配置步骤"><a href="#正确配置步骤" class="headerlink" title="正确配置步骤"></a>正确配置步骤</h1><p>应当在命令行<code>base</code>环境中新建环境<code>pytorch</code>；进入该环境后；再执行<code>conda install</code>安装JupyterNotebook；再执行<code>conda install pytorch torchvision -c pytorch</code>安装pytorch的包。</p>
<p>新的环境中是不会有JupyterNotebook的，所以打开在该环境下执行<code>jupyter notebook</code>是报错的。</p>
<p>新的环境中也不会有pytorch的包，所以就算打开了JupyterNotebook执行python语句，涉及到pytorch的语法，也会报错。</p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch入门</title>
    <url>/2020/10/22/start-with-pytorch/</url>
    <content><![CDATA[<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><p><strong>机器学习</strong>研究如何使计算机系统利用经验改善性能。它是人工智能领域的分支，也是<strong>实现人工智能的一种手段，人工智能是最终目的</strong>。</p>
<p>在机器学习的众多研究方向中，<strong>表征学习关注如何自动找出表示数据的合适方式，以便更好地将输入变换为正确的输出</strong>。</p>
<p><strong>深度学习是具有<em>多级表示</em>的表征学习方法。</strong>在每一级（从原始数据开始），深度学习通过简单的函数将该级的表示变换为更高级的表示。因此，<em>深度学习模型也可以看作是由许多简单函数复合而成的函数。</em>当这些复合的函数足够多时，深度学习模型就可以表达非常复杂的变换。</p>
<p>深度学习可以<strong>逐级表示越来越抽象的概念或模式</strong>。</p>
<p>深度学习的一个外在特点是<strong>端到端的训练</strong>。也就是说，并不是将单独调试的部分拼凑起来组成一个系统，而是将整个系统组建好之后一起训练。</p>
<p>除端到端的训练以外，我们也正在经历<strong>从含参数统计模型转向完全无参数的模型</strong>。</p>
<p>任务可以分为三种：回归Regression(线性模型)，分类classification(非线性模型，包括深度学习、SVM等)，结构化学习structured learning。</p>
<p>实现的手段可以有：监督学习、半监督学习、无监督学习、强化学习。相同点是统一都有输入，区别在于是否有输入的匹配输出。从前往后输入输出正确匹配对以此减少。</p>
<h1 id="Tensor与Numpy"><a href="#Tensor与Numpy" class="headerlink" title="Tensor与Numpy"></a>Tensor与Numpy</h1><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<p>PyTorch<strong>操作inplace版本</strong>都有后缀<code>_</code>, 例如<code>x.copy_(y), x.t_()</code></p>
<p><strong>判断操作是否开辟新内存</strong>，使用Python自带的<code>id</code>函数：如果两个实例的ID一致，那么它们所对应的内存地址相同；反之则不同。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>torch.tensor()与np.array()用法类似，创建方法类似，二者可以转换，可接受基本运算法。</p>
<p>四种形式的加法(+, add(), add_(), +=)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>Torch</th>
<th>Numpy</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建</td>
<td>torch.tensor([0.1, 0.2, 0.3])</td>
<td>np.array([0.1, 0.2, 0.3])</td>
<td></td>
</tr>
<tr>
<td>转换</td>
<td>torch.from_numpy(x_numpy)</td>
<td>x_torch.numpy()</td>
<td>这两个函数所产生的<code>Tensor</code>和NumPy中的数组共享相同的内存（所以他们之间的转换很快）。</td>
</tr>
<tr>
<td>四则运算</td>
<td>x_torch + y_torch</td>
<td>x_numpy + y_numpy</td>
<td></td>
</tr>
<tr>
<td>范数</td>
<td>torch.norm(x_torch)</td>
<td>np.linalg.norm(x_numpy)</td>
<td></td>
</tr>
<tr>
<td>正则化</td>
<td>torch.mean(x_torch, dim=0)</td>
<td>np.mean(x_numpy, axis=0)</td>
<td></td>
</tr>
<tr>
<td>索引</td>
<td></td>
<td></td>
<td>我们还可以使用类似NumPy的索引操作(:)来访问<code>Tensor</code>的一部分，不会开辟内存。需要注意的是：<strong>索引出来的结果与原数据共享内存。</strong></td>
</tr>
</tbody>
</table>
</div>
<p>将NumPy中的array转换成<code>Tensor</code>的另一个方法就是<code>torch.tensor()</code>, 需要注意的是，此方法总是会进行数据拷贝（就会消耗更多的时间和空间），所以返回的<code>Tensor</code>和原来的数据不再共享内存。</p>
<p>函数<code>item()</code>可以将一个标量<code>Tensor</code>转换成一个Python number。</p>
<h2 id="Reshape"><a href="#Reshape" class="headerlink" title="Reshape"></a>Reshape</h2><div class="table-container">
<table>
<thead>
<tr>
<th>Tensor</th>
<th>Numpy</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tensor.view()</td>
<td>np.shape()</td>
<td>Torch.view() can also automatically calculate the correct dimension if a <code>-1</code> is passed in. This is useful if we are working with batches, but the batch size is unknown. Torch.view()返回的torch.Size其实就是一个tuple, 支持所有tuple的操作。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意<code>view()</code>返回的新<code>Tensor</code>与源<code>Tensor</code>虽然可能有不同的<code>size</code>，但是是共享<code>data</code>的，也即更改其中的一个，另外一个也会跟着改变。(顾名思义，view仅仅是改变了对这个张量的观察角度，内部数据并未改变)</strong>。</p>
<p>虽然<code>view</code>返回的<code>Tensor</code>与源<code>Tensor</code>是共享<code>data</code>的，但是依然是一个新的<code>Tensor</code>（因为<code>Tensor</code>除了包含<code>data</code>外还有一些其他属性），二者id（内存地址）并不一致。</p>
<p>想返回一个真正新的副本（即不共享data内存）该用<code>clone</code>创造一个副本然后再使用<code>view</code>。view和copy存在区别。</p>
<h1 id="Broadcasting"><a href="#Broadcasting" class="headerlink" title="Broadcasting"></a>Broadcasting</h1><p>遵循以下两个原则：</p>
<ul>
<li>Each tensor has at least one dimension.</li>
<li>When iterating over the dimension sizes, starting at the trailing dimension, the dimension sizes must either be equal, one of them is 1, or one of them does not exist.</li>
</ul>
<p>对应dimension要么相同，要么一个是1另一个是更大的数字。</p>
<h1 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h1><p>为什么需要用到计算图？<a href="http://colah.github.io/posts/2015-08-Backprop/">参考</a></p>
<p>计算图将函数表达式用树状结构表示。求偏导，联系链式法则，因子路径。</p>
<p>对于某一个结点往根结点去就是forward propagation，可以求该节点对它上面的所有节点的影响。对于某一个节点往叶子结点去就是backpropagation，可以求该节点受它下面的那些节点的影响。</p>
<p>记录了计算图，就能追踪每一次微分。</p>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2><h1 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h1><p>用方法<code>to()</code>可以将<code>Tensor</code>在CPU和GPU（需要硬件支持）之间相互移动。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gpu = torch.device(<span class="string">&quot;cuda:0&quot;</span>)</span><br><span class="line">x.to(gpu)</span><br></pre></td></tr></table></figure>
<h1 id="批量数据"><a href="#批量数据" class="headerlink" title="批量数据"></a>批量数据</h1><p>主要涉及两个工具</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br></pre></td></tr></table></figure>
<h2 id="custom-dataset"><a href="#custom-dataset" class="headerlink" title="custom dataset"></a>custom dataset</h2><p>Your custom dataset should inherit <code>Dataset</code> and override the following methods:</p>
<ul>
<li><code>__len__</code> so that <code>len(dataset)</code> returns the size of the dataset.</li>
<li><code>__getitem__</code> to support the indexing such that <code>dataset[i]</code> can be used to get 𝑖\ th sample</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FakeDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> len(self.x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, idx</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.x[idx], self.y[idx]</span><br></pre></td></tr></table></figure>
<h1 id="data-loader"><a href="#data-loader" class="headerlink" title="data loader"></a>data loader</h1><p>实现数据批量处理：batch/shuffling/parallel loading。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataset = FakeDataset(x, y)</span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">4</span>,</span><br><span class="line">                        shuffle=<span class="literal">True</span>, num_workers=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h1 id="反向传播与自动求梯度"><a href="#反向传播与自动求梯度" class="headerlink" title="反向传播与自动求梯度"></a>反向传播与自动求梯度</h1><h2 id="追踪梯度的步骤"><a href="#追踪梯度的步骤" class="headerlink" title="追踪梯度的步骤"></a>追踪梯度的步骤</h2><ol>
<li><p>对input tensor x的定义<code>.requires_grad</code>属性设置为<code>True</code></p>
</li>
<li><p>调用反向传播<code>y.backward()</code>，来完成所有梯度计算。此input的<code>Tensor</code>的梯度将累积到Tensor类的<code>.grad</code>属性中。</p>
</li>
<li><p>随后用gradient descent更新x</p>
</li>
<li><p>然后需要把每一次反向传播后的梯度清零，因为.grad的数据不会被覆盖只会在前一个基础之上累加。</p>
<p>We need to zero the grad variable since the backward call accumulates the gradients in .grad instead of overwriting.</p>
<p>为了方便操作先调用调用<code>.detach()</code>将其从追踪记录中分离出来；再调用<code>x.grad.zero_()</code>清零梯度。</p>
</li>
</ol>
<h2 id="其他自动求梯度的设置"><a href="#其他自动求梯度的设置" class="headerlink" title="其他自动求梯度的设置"></a>其他自动求梯度的设置</h2><p>by using <code>.detach()</code> to get a new Tensor with the same content but that does not require gradients:</p>
<p> stop autograd from tracking history on Tensors with <code>.requires_grad=True</code> either by wrapping the code block in <code>with torch.no_grad():</code></p>
<h2 id="构造复杂模块"><a href="#构造复杂模块" class="headerlink" title="构造复杂模块"></a>构造复杂模块</h2><p>Many times, we want to compose Modules together. <code>torch.nn.Sequential</code> provides a good interface for composing simple modules.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = torch.nn.Sequential(</span><br><span class="line">                            nn.Linear(d_in, d_hidden),</span><br><span class="line">                            nn.Tanh(),</span><br><span class="line">                            nn.Linear(d_hidden, d_out),</span><br><span class="line">                            nn.Sigmoid()</span><br><span class="line">                           )</span><br></pre></td></tr></table></figure>
<h2 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h2><p>两种常见的loss function。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mse_loss_fn = nn.MSELoss()</span><br><span class="line">loss = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure>
<h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>训练模型需要用到求梯度的几种方法，比如SGD之类的。<code>torch.optim</code>提供了求梯度的一些方法，至少要传入<strong>模型参数和学习率</strong>。</p>
<p>PyTorch implements a number of gradient-based optimization methods in <code>torch.optim</code>, including Gradient Descent. At the minimum, it takes in the model parameters and a learning rate.</p>
<p>在一个关于data_size/batch_size的循环，或者data_size的循环中，首先计算y_hat，其次计算loss，接下来求梯度(<strong>Optimizers do not compute the gradients for you, so you must call <code>backward()</code> yourself. </strong>)，要注意先清空梯度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">step_size = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">linear_module = nn.Linear(d, <span class="number">1</span>)</span><br><span class="line">loss_func = nn.MSELoss()</span><br><span class="line">optim = torch.optim.SGD(linear_module.parameters(), lr=step_size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    <span class="comment"># shuffling data</span></span><br><span class="line">    rand_idx = np.random.choice(n) <span class="comment"># take a random point from the dataset</span></span><br><span class="line">    x = X[rand_idx] </span><br><span class="line">    y_hat = linear_module(x)</span><br><span class="line">    loss = loss_func(y_hat, y)</span><br><span class="line">    <span class="comment"># You also must call the optim.zero_grad() function before calling backward() since by default PyTorch does and inplace add to the .grad member variable rather than overwriting it.</span></span><br><span class="line">    optim.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    optim.step()</span><br></pre></td></tr></table></figure>
<p>在初始化参数的时候可以定一个momentum的初始值，之后当作参数传入<code>torch.optim</code>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.youtube.com/watch?v=kQeezFrNoOg&amp;feature=youtu.be">台大李宏毅机器学习助教补充课</a></p>
<p><a href="https://pytorch.org/docs/stable/index.html">Pytorch官方文档</a></p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归</title>
    <url>/2020/10/23/dl-math-bacis/</url>
    <content><![CDATA[<h1 id="掌握术语"><a href="#掌握术语" class="headerlink" title="掌握术语"></a>掌握术语</h1><p>Model training</p>
<p>Training data set/training set = input/output of target function,</p>
<p>Sample</p>
<p>Label = function output</p>
<p>Feature = variant函数变量，输入个数也叫特征数或特征向量维度</p>
<p>Loss function</p>
<p>误差最小化问题的解可以分为解析解(Analytical Solution)和数值解(Numerical Solution)。</p>
<p>Hyperparameter = 超参数是人为设定的参数，并非通过模型训练学出的。</p>
<p>输出层中的神经元和输入层中各个输入完全连接。因此，这里的输出层又叫全连接层（fully-connected layer）或稠密层（dense layer）。</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h2><p>选择框架</p>
<h2 id="模型评估，损失函数"><a href="#模型评估，损失函数" class="headerlink" title="模型评估，损失函数"></a>模型评估，损失函数</h2><p>Loss function —  Input: function, output: how bad it is</p>
<h3 id="Loss-function-with-one-parameter-L-omega"><a href="#Loss-function-with-one-parameter-L-omega" class="headerlink" title="Loss  function with one parameter$L(\omega)$"></a>Loss  function with one parameter$L(\omega)$</h3><p>对该函数在某一初始点(given an initial value)求微分(didderentaite)；判断此点的微分正负，决定向哪一个方向更新$w$能够让Loss function更小；决定往那个方向变化，结合一个Learning rate — $\eta$ 来决定步长；更新参数直到微分成为0。</p>
<p>存在一个问题？Local Optinal VS Global Optimal</p>
<h3 id="存在多个参数的情况"><a href="#存在多个参数的情况" class="headerlink" title="存在多个参数的情况"></a>存在多个参数的情况</h3><p>对各个参数分别求偏微分，再更新。</p>
<h2 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h2><p>梯度下降 — Gradient Descent</p>
<p>要求loss function是convex(no local optimal) </p>
<p>存在限制 — very slow at plateau/ stuck at saddle point/ stuck at local minima</p>
<h2 id="过拟合-overfitting"><a href="#过拟合-overfitting" class="headerlink" title="过拟合 overfitting"></a>过拟合 overfitting</h2><p>复杂的模型再training data上表现良好，但是再testing data上表现很差。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>如何选择优化方式需要考虑loss function的误差有哪些来源，依据情况进行选择。以下是针对线性回归的每个步骤可以参考的问题优化思路。</p>
<ul>
<li><p>对数据分类，引入0-1函数参数。</p>
</li>
<li><p>引入更多参数/特征/input。</p>
</li>
<li>正则化Regularization，目的是为了让函数更加平滑，相对于训练数据输入相近的测试输入，在进入函数之后引起的输出变化会比较小。并不是越平滑越好，bias对于平滑度没有影响。</li>
</ul>
<h1 id="误差来源"><a href="#误差来源" class="headerlink" title="误差来源"></a>误差来源</h1><p>在统计学中涉及到评估随机变量$X$的偏差和方差。涉及到无偏估计.</p>
<h2 id="Bias"><a href="#Bias" class="headerlink" title="Bias"></a>Bias</h2><p>Average/ Expectations描述准确性</p>
<p>简单模型 — high bias，复杂模型 — low bias。</p>
<p>模型本质就是一个function set。简单模型的function space较小，难以涵盖target；而复杂模型的function space较大，有更大几率包括target，因此bias更小。</p>
<p>Error from bias越大代表Underfitting，说明模型连最基本训练数据都没有办法适用。解决办法：选择更复杂的模型，增加更多的特征变量。</p>
<h2 id="Variance"><a href="#Variance" class="headerlink" title="Variance"></a>Variance</h2><p>描述确定性。</p>
<p>简单模型 — low variance ，复杂模型 — high variance。</p>
<p>因为简单模型更少受样本数据的影响。</p>
<p>Error from variance越大代表Overfitting，说明过于关注某些样本训练数据而忽略了整体，当测试数据输入的时候，会得到较大的误差。解决办法：更多数据，正则化。</p>
<h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>A trade-off between bias and variance. </p>
<p>Select a modle that balances two kinds of error to minimize total error.</p>
<h2 id="模型选择的误区"><a href="#模型选择的误区" class="headerlink" title="模型选择的误区"></a>模型选择的误区</h2><p>假设现在有三个数据集合：Training set — Testing set(public) — Testing set(private)</p>
<h3 id="what-NOT-do"><a href="#what-NOT-do" class="headerlink" title="what NOT do"></a>what NOT do</h3><ul>
<li>不应该用训练集训练不同的模型，然后在测试集上比较错误。意思就是不应该用Testing set来选择模型。模型的选择应该在Training set内部进行决定。</li>
<li>不应该在public测试集上得到较大的误差之后再返回训练集调试参数，更应当选择调整模型。</li>
</ul>
<h2 id="DO-cross-validation"><a href="#DO-cross-validation" class="headerlink" title="DO cross validation"></a>DO cross validation</h2><p>交叉验证就是将Trainging set分成两组，一部分作为Training set，另一部分作为Validation set。用验证集选出合适模型，再用Public测试集合进行测试。</p>
<p>N-fold cross validation: 将数据集分成N份，每一份都有机会成为训练集/验证集，以此对目前正在考虑的模型进行验证。</p>
<h1 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h1><p>梯度下降是一种在用损失函数评估模型时，确定特征的参数系数来让损失函数最小的方法。它的目的就是求特征的参数系数。</p>
<blockquote>
<p>Gradient descent is a standard tool for <strong>optimizing complex functions iteratively</strong> within a computer program. </p>
<p>Its goal is: <strong>given some arbitrary function, find a minumum</strong>. For some small subset of functions - those that are <strong><em>convex</em></strong> - there’s just a single minumum which also happens to be global. For most realistic functions, there may be many minima, so most <strong>minima are local.</strong> </p>
<p>The main premise of gradient descent is: given some current location <em>x</em> in the search space (the domain of the optimized function) we ought to <strong>update <em>x</em> for the next step in the direction opposite to the gradient of the function computed at <em>x</em></strong>. </p>
<p>Where $\eta$ is what we call a “<strong>learning rate</strong>“, and is <strong>constant for each given update</strong>. It’s the reason why <strong>we don’t care much about the magnitude of the derivative at $x_0$, only its direction</strong>. </p>
<p>Reference: <a href="https://eli.thegreenplace.net/2016/understanding-gradient-descent/">理解梯度下降</a></p>
</blockquote>
<h2 id="数学理论"><a href="#数学理论" class="headerlink" title="数学理论"></a>数学理论</h2><p>对于损失函数的一个初始点$\{\theta_1, \theta_2\}$，需要在其邻域(表现在这里就是在等高图上着一个平面圆圈)找一个新的值使得损失函数更小，该怎么找？</p>
<blockquote>
<p>contour graph和gradient是什么关系？如果把等高线图画出来，且标出所有的梯度方向，可以发现等高线和梯度垂直。</p>
</blockquote>
<p>对该损失函数在该初始点使用泰勒展开式化简，我们要求的损失函数就从一个很复杂的难以表现的式子变成了线性函数。<strong>损失函数本身可以表示成梯度向量和目前待求解的下一次更新的点的点积</strong>，表现在图像上就是两个向量方向相反。</p>
<blockquote>
<p>为什么可以这么说？梯度向量有什什么？下一次更新的点又是什么？</p>
<p>首先需要明白偏导数，全微分，方向导数与梯度的概念。</p>
<h1 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h1><p>偏导数是改变坐标系基向量的某一个维度的值，固定其他维度的值，衡量函数值变化的情况。</p>
<h2 id="Graphical-Explanation"><a href="#Graphical-Explanation" class="headerlink" title="Graphical Explanation"></a>Graphical Explanation</h2><p>表现在二元函数的图像上就是用x/y平面切空间上的图像，切出来的那个函数是一个平面函数，求的偏导数就是在固定维度的值的那个点，该平面函数的导数/切线。</p>
<h2 id="梯度向量"><a href="#梯度向量" class="headerlink" title="梯度向量"></a>梯度向量</h2><p>梯度向量就是对多元函数的基向量的所有维度求偏微分之后获得的每一个维度都是一个带有所有原变量的函数的向量。</p>
<h1 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h1><p>方向导数是偏导数的推广，衡量在某个特定的方向上函数值的变化情况。</p>
<h1 id="Graphical-Explanation-1"><a href="#Graphical-Explanation-1" class="headerlink" title="Graphical Explanation"></a>Graphical Explanation</h1><p>偏导数中用基向量的平面取切，如果我们要所有方向的平面都能切该怎么做？</p>
<p>首先基向量可以用来表示其他任何向量，由自然基向量构成的一个向量表示在三维空间就是一个平面。求方向导数就是把偏导数投影到该向量所在的平面上，联系到内积。</p>
<p>该任意向量可以有任意长度，但是把它scale到模为1就可以表示用这个向量平面去切空间里的函数，在那个点的切线斜率。</p>
<h1 id="方向导数与偏微分-梯度向量"><a href="#方向导数与偏微分-梯度向量" class="headerlink" title="方向导数与偏微分/梯度向量"></a>方向导数与偏微分/梯度向量</h1><p>由内积的定义可知，梯度向量是方向导数最大的地方，就是曲面最陡峭的方向。</p>
<h1 id="全微分"><a href="#全微分" class="headerlink" title="全微分"></a>全微分</h1><p>全微分就是改变坐标系基向量的所有维度的值，衡量函数值变化的情况。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/39059717">知乎专栏</a></p>
<p><a href="https://www.youtube.com/watch?v=AXqhWeUEtQU&amp;list=PLSQl0a2vh4HC5feHa6Rc5c0wbRTx56nF7&amp;index=15&amp;ab_channel=KhanAcademy">Khan Acadamy Multivariable Calculus</a></p>
</blockquote>
<p>注意这里化简的前提，是基于泰勒展开式对于损失函数在该点的模拟的精确度，因此我们适用的邻域就要足够小，这个邻域的大小表现在数据上就是我们选择的学习率。</p>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h3 id="小心地调整Learning-Rate"><a href="#小心地调整Learning-Rate" class="headerlink" title="小心地调整Learning Rate"></a>小心地调整Learning Rate</h3><ul>
<li><p>直接画出损失函数关于要调整的参数的曲线，但是这个可视化只能在参数一维或者二维时进行。</p>
</li>
<li><p>将Learning Rate学习率的改变对损失函数的影响的图像可视化。</p>
</li>
<li><p>自适应学习率，通过添加一些因子来随着次数增加降低学习率。刚开始的时候用大一些的学习率；更新多次参数之后较为高进最低点，减少学习率。</p>
</li>
<li><p>不同的参数需要不同的学习率。</p>
</li>
</ul>
<h4 id="常规梯度下降法-Vanilla-Gradient-Descent"><a href="#常规梯度下降法-Vanilla-Gradient-Descent" class="headerlink" title="常规梯度下降法 Vanilla Gradient Descent"></a>常规梯度下降法 Vanilla Gradient Descent</h4><script type="math/tex; mode=display">
\omega^{t+1} \larr \omega^{t} - \eta^tg^t \\
\eta^t = \frac{\eta^t}{\sqrt{t+1}}</script><h4 id="Adagrad算法"><a href="#Adagrad算法" class="headerlink" title="Adagrad算法"></a>Adagrad算法</h4><script type="math/tex; mode=display">
\omega^{t+1} \larr \omega^{t} - \frac{\eta^t}{\sigma^t}g^t \\
g^t = \frac{\partial{L(\theta^t)}}{\partial{\omega}}\\</script><p>$\sigma^t = \sqrt{\frac{1}{t+1} \sum_{i=0}^t(g^i)^2}$是之前该参数的所有微分的均方根，对于每个参数都是不一样的。</p>
<p>代入化简可得</p>
<script type="math/tex; mode=display">
\omega^{t+1} \larr \omega^{t} - \frac{\eta}{\sqrt{\sum_{i=0}^t(g^i)^2}}g^t</script><p>这个式子中的分式是为了显示how suprise this step is，要求步长前后反差大。</p>
<p>对于单参数问题，梯度越大就代表和最低点的距离越远。对于多参数问题，前面的结论不成立。</p>
<p>不仅要和一次微分成正比，还要和二次微分成反比。但是求二次微分带来的代价过于巨大，所以尝试使用一次微分来estimate二次微分，也就是分式中的分母。</p>
<h3 id="随机梯度下降法-Stochastic-Gradient-Descent"><a href="#随机梯度下降法-Stochastic-Gradient-Descent" class="headerlink" title="随机梯度下降法 Stochastic Gradient Descent"></a>随机梯度下降法 Stochastic Gradient Descent</h3><p>常规梯度下降法走一步要处理所有数据。而随机梯度下降法的损失函数每次只选取一个数据，对其进行梯度更新，因此速度更快。</p>
<h3 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h3><p>由于输入的分布范围很不一样，单位也不一样，一个变量的实际数据很大会导致它对特征参数的变化影响很大。因此要适当选择缩放，make different features having the same scaling。</p>
<p>其中一种常见的缩放方法就是将输入的数据先0-1正规化。make the means of all dimensions 0 and variances 1.</p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>DL</tag>
        <tag>LinearRegression</tag>
      </tags>
  </entry>
  <entry>
    <title>概率分类与Logistic回归</title>
    <url>/2020/10/26/classification-basics/</url>
    <content><![CDATA[<h1 id="分类定义"><a href="#分类定义" class="headerlink" title="分类定义"></a>分类定义</h1><p>找一个function，输入对象x的特征，输出该对象是属于n个类别中的哪一个。</p>
<h1 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a>生成模型</h1><h2 id="盒子抽球问题"><a href="#盒子抽球问题" class="headerlink" title="盒子抽球问题"></a>盒子抽球问题</h2><blockquote>
<p>两个盒子，每个盒子中各有XX的概率抽出红球或者蓝球，问抽出一个球，抽到x号盒子中蓝色球的概率。</p>
</blockquote>
<h3 id="需要的已知信息"><a href="#需要的已知信息" class="headerlink" title="需要的已知信息"></a>需要的已知信息</h3><p>将一个盒子映射成一个类别，抽一个球是某个盒子中的球的概率分别是$class1-P(C_1), class2 - P(C_2)$ ；对于一个盒子，抽出球$x$的概率分别是$class1 - P(x|C_1), class2-P(x|C_2)$。</p>
<h3 id="利用已知信息推测回答"><a href="#利用已知信息推测回答" class="headerlink" title="利用已知信息推测回答"></a>利用已知信息推测回答</h3><p>对于给定的一个$x$，就可以计算出它属于每一个盒子的概率是多少</p>
<script type="math/tex; mode=display">
P(C_i|x)=\frac{P(x|C_i)*P(C_i)}{\sum{P(x|C_i)*P(C_i)}}(贝叶斯公式)=\frac{P(x|C_i)*P(C_i)}{P(x)(全概率公式)}</script><p>依据哪个盒子的概率大，我们就判断这个球属于哪个盒子。</p>
<p>如何获得等式右边的各种数据？我们需要从训练集中估测需要的已知信息。这个想法叫做<strong>生成模型(Generative Model)</strong>。</p>
<h2 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h2><h3 id="先验概率"><a href="#先验概率" class="headerlink" title="先验概率"></a>先验概率</h3><p>先验概率是通过我们的训练集，也就是已知分类的对象来获取的。</p>
<p>对于某个特定分类的对象的数据，可以把它当作某个随机变量$X$的抽样。如果我们有了这个随机变量$X$的分布函数或概率密度函数，就可以推测其他我们未知取值的概率。</p>
<p>每一个真实世界中的待分类或者已分类的对象需要在数学上被抽象成一个vector，该vector的每个分量都是这个对象的attribute，我们称之为feature。</p>
<h3 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h3><p>如何确定这个训练集数据的分布函数或概率密度函数呢？</p>
<p>首先要确定这个分布的形式。是高斯分布、伯努利分布或者其他，这需要自己选择。例如对于二元分类来说，可以假设是符合Bernoulli distribution。</p>
<p>其次将分布函数/概率密度函数看作一个function，输入的就是向量$x$，输出是选中$x$的概率。如果选高斯分布，那就是求期望$\mu$和协方差矩阵$\sum$，分别决定了最高点和离散度。</p>
<p>根据已有sample求解概率密度函数的estimate，采用最大似然估计Maximum Likelihood。任意的期望和协方差都能构成高斯分布，都可以生成我们训练集中的数据，但是问题是对我们已有数据的命中率的高低。</p>
<h3 id="寻找最好的函数-求参数"><a href="#寻找最好的函数-求参数" class="headerlink" title="寻找最好的函数/求参数"></a>寻找最好的函数/求参数</h3><p>如何衡量一个确定estimate为$\mu_0,\sum_0$的高斯函数对我们已有数据的命中率？引入样本的似然函数的概念。</p>
<p>对于高斯分布的样本$x_1, x_2, x_3 \dots , x_n$，我们假设高斯分布的期望为$\mu$，协方差矩阵为$\sum$，用这些样本的概率值——也就是样本作为输入传入高斯函数后的输出——的乘积，作为样本的似然函数。</p>
<script type="math/tex; mode=display">
L(\mu,\sum) = f_{\mu,\sum}(x_1)*f_{\mu,\sum}(x_2)*f_{\mu,\sum}(x_1) * \dots * f_{\mu,\sum}(x_n)</script><p>能让$L(\mu,\sum)$最大的$L(\mu^{i},\sum^{i})$就是所有$L(\mu,\sum)$的最大似然估计。</p>
<p>用数学来求解就是对两个estimate分别求偏微分为0的点。直观的来看，期望就是样本平均，协方差就是样本方差。</p>
<h3 id="抽球模型和分类问题的联系"><a href="#抽球模型和分类问题的联系" class="headerlink" title="抽球模型和分类问题的联系"></a>抽球模型和分类问题的联系</h3><p>回到盒子抽球问题中的贝叶斯公式，等式中的$P(x|C_i)$就是通过概率密度函数求得的。</p>
<p>我们需要定义计算出来的$P(C_i|x)$在什么样的情况下我们会把对象$x$归为$C_i$。可能概率大于某一个数值？</p>
<p>为什么令每个类别的高斯分布的协方差矩阵相同后，高斯分布获得的最大似然函数是线性的？</p>
<script type="math/tex; mode=display">
\begin{split}
P(C_1|x) &= \frac{1}{1+\frac{P(x|C_2)P(C_2)}{P(x|C_1)P(C_1)}}\\&=\frac{1}{1+exp(-z)} \\&= \sigma(z)[Sigmoid \, function] \\
\end{split}
\\
z = ln\frac{P(x|C_1)P(C_1)}{P(x|C_2)P(C_2)}</script><p>拆分$ln$，用概率密度函数替换掉表达式的中的$P$，展开项合并，并对表达式进行关于$x$的整理，可以得到一个一次函数。</p>
<p>详细推导见GoodNotes。</p>
<script type="math/tex; mode=display">
P_{\omega, b}(C_1|x) = \sigma(z) [Sigmoid Function]\\
z = \omega  x + b</script><blockquote>
<p>之前学的多变量分析中的判别分析，为了降低输入数据的维度，将数据投影到了组间直线的分界线上discriminant score。输入为$x$，输出经过一个一次方程式。</p>
</blockquote>
<p><img src="/2020/10/26/classification-basics/generativemodel.png" alt="generativemodel" style="zoom:50%;"></p>
<p><img src="/2020/10/26/classification-basics/generativemodel2.png" alt="generativemodel2" style="zoom:50%;"></p>
<p>整理出来得到的是一个一次函数，回顾之前的推导过程，我们需要estimate很多参数包括$\mu_1,\mu_2,\sum_1,\sum_2$，并且我们做了假设样本数据服从于某个分布。</p>
<h2 id="步骤优化"><a href="#步骤优化" class="headerlink" title="步骤优化"></a>步骤优化</h2><ul>
<li><p>描述类别的高斯分布的协方差矩阵强制相同。此时分类的边界线，也就是最大似然函数（？）是线性的，所以也叫linear model。</p>
<p>理由有二。</p>
<p>第一，因为协方差矩阵和输入feature的大小的平方成正比，因此feature较大时，协方差矩阵增长会过快。</p>
<p>第二，因为模型参数过多容易过拟合，应当有效减少参数。</p>
</li>
<li><p>如果数据的feature是一个vector，每一个维度的概率分布相互独立，可以将多维的高斯分布通过每一维度的概率密度函数相乘，转化成一维高斯分布(Naive Bayes Classifier朴素贝叶斯分类器)。</p>
</li>
</ul>
<p>从获得的结果来看，最终只与$\omega, b$有关，是否可以尝试直接求解这两个参数？由此引入Logistic Regression。</p>
<h1 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h1><h2 id="逻辑回归的函数集"><a href="#逻辑回归的函数集" class="headerlink" title="逻辑回归的函数集"></a>逻辑回归的函数集</h2><p>定义Logistic Regression的函数集为$f_{\omega,b}(x) = P_{\omega,b}(C_1,x)=\sigma (z)$。我们需要假设训练数据集从此密度函数上获得，即任意一对$\omega,b$都能让我们的训练数据集的input通过此函数获得一个output，即在该input下，分类正确的几率作为output。</p>
<p>对于用于训练的数据集通过某个function，可以获得input$x_1, x_2, \dots, x_n$，output$C_1, C_2, \dots, C_n$。要将所有的数据都转换成实际的数据，用分类结果$C_i$肯定不行。对于二元分类问题直接映射分类结果到0和1；对于多元分类问题该怎么办？后面解决。</p>
<h2 id="定义损失函数-1"><a href="#定义损失函数-1" class="headerlink" title="定义损失函数"></a>定义损失函数</h2><p>如何从function set中选出令衡量效果最好的那一个function？直观来说就是能够正确分类，输出概率最大的那个function是最好的。确定最优化函数function也就是查找一个特定的$\omega^<em>,b^</em>$。</p>
<script type="math/tex; mode=display">
L(\omega, b) = f_{\omega,b}(x_1) f_{\omega,b}(x_2) (1-f_{\omega,b}(x_3)) \dots f_{\omega,b}(x_n)  \\</script><script type="math/tex; mode=display">
\omega^*, b^* = {arg \, \max\limits_{\omega^*,b^*}} \, {L(\omega, b)} \iff 
{arg \, \min\limits_{\omega^*,b^*}} \,{ -\ln{L(\omega, b)}}</script><p>注意到有两种形式的分式在相乘，不可能展开求解，需要改写函数集来同时能够匹配分类正确/属于Class0和分类错误/属于Class1两种情况。</p>
<script type="math/tex; mode=display">
\begin{split}
-\ln{L(\omega, b)} 
&= -\ln{f_{\omega,b}(x_1)}\ln{f_{\omega,b}(x_2)} \ln{(1-f_{\omega,b}{(x_3)})} \dots  \\
&= \sum_\limits{n} -[\hat{y}^n \ln{f_{\omega,b}(x_n)} + (1-\hat{y}^n) \ln{(1-f_{\omega,b}(x_n))}] \, \\

\end{split}</script><p>上式可以看作两个0-1分布的交叉熵。</p>
<h3 id="求导结果"><a href="#求导结果" class="headerlink" title="求导结果"></a>求导结果</h3><p><img src="/2020/10/26/classification-basics/logisticregressiondifferential-5104031.png" alt="logisticregressiondifferential" style="zoom:50%;"></p>
<p><img src="/2020/10/26/classification-basics/logisticregressiondifferential2-5104031.png" alt="logisticregressiondifferential2" style="zoom:50%;"></p>
<h3 id="MLE-amp-amp-Cross-Entrpy-Explanation"><a href="#MLE-amp-amp-Cross-Entrpy-Explanation" class="headerlink" title="MLE &amp;&amp; Cross-Entrpy Explanation"></a>MLE &amp;&amp; Cross-Entrpy Explanation</h3><p>什么是Cross Entropy？为什么作为衡量goodness of function的标准？</p>
<p><a href="https://medium.com/konvergen/cross-entropy-and-maximum-likelihood-estimation-58942b52517a">Reference</a></p>
<h4 id="熵的定义"><a href="#熵的定义" class="headerlink" title="熵的定义"></a>熵的定义</h4><p>熵用于衡量随机变量的不确定性。</p>
<p>Entropy is a measure of <strong>the uncertainty</strong> of a random variable. If we have a random variable <em>X</em>, and we have probability mass function <em>p</em>(<em>x</em>) = Pr[<em>X=x</em>], we define the Entropy <em>H</em>(<em>X)</em> of the random variable <em>X</em> with</p>
<script type="math/tex; mode=display">
H(X) = -\sum\limits_{x}{p(x)\log{p(x)}}</script><p>由于形式和随机变量的数学期望十分相像，所以将它改写为</p>
<script type="math/tex; mode=display">
\begin{split}
H(X) &= -\sum\limits_{x}{p(x)\log{p(x)}} \\
&= \sum\limits_{x}{p(x)\log{\frac{1}{p(x)}}}\\
&= \mathbb{E}_{X \sim p(x)}[\log{\frac{1}{p(x)}}]
\end{split}</script><p>So the entropy of a random variable is the expected value of the random variable log(1/<em>p</em>(<em>x</em>)) where <em>X</em> is drawn from <em>p</em>(<em>x</em>). </p>
<hr>
<h4 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h4><p>假设对于我们的数据集，有两个分布，一个是unkown but true的distribution$p(x)$，一个是modeled approximate的distribution$q(x)$。为了衡量这两个分布之间的差异性，我们引入the Kullback–Leibler divergence (also called <strong>relative entropy</strong>)的概念。如果两个分布一摸一样的话，交叉熵就是熵。</p>
<script type="math/tex; mode=display">
\begin{split}
D_{KL}(p||q) &= \sum\limits_{x}{p(x)\log{\frac{q(x)}{p(x)}}}
\\&= \mathbb{E}_{X \sim p(x)}[\log{\frac{q(x)}{p(x)}}] \\ &=
\mathbb{E}_{X \sim p(x)}[\log{\frac{1}{p(x)}}] - \mathbb{E}_{X \sim p(x)}[\log{\frac{1}{p(x)}}]
\end{split}</script><p>第一项是Cross-Entropy，第二项是分布<em>p</em>(x)的熵。</p>
<p>将Cross-Entropy为$H(p,q)$，用真实分布的熵和Relative-Entropy表示Cross-Entropy，为$H(p,q) = H(p) + D_{KL}(p||q)$。</p>
<hr>
<h4 id="Cross-Entropy-amp-amp-MLE-Relationship"><a href="#Cross-Entropy-amp-amp-MLE-Relationship" class="headerlink" title="Cross-Entropy &amp;&amp; MLE Relationship"></a>Cross-Entropy &amp;&amp; MLE Relationship</h4><p>如何将Cross Entropy和Maximum Likelihood Estimation联系起来？需要理解的是，极大似然估计是用来估计一个概率模型的参数的一种方法。</p>
<p>Suppose that for a problem, we have a set of examples X_example = {<em>x</em>_1, <em>x</em>_2, …, <em>x</em>_m} that drawn independently from a true but unknown distribution p_data(x). </p>
<p>Then we try to model the true distribution by parametric model p_model(<em>x</em>;𝜃) with 𝜃 as the parameter. </p>
<p>We can say that p_model(<em>x</em>,𝜃) maps <em>x</em> to estimate the true but unknown p_data(<em>x</em>) given the same data.</p>
<p>To get the best model, <strong>we need to find such 𝜃 that yields the most similar outcome of p_model(<em>x</em>,𝜃) to p_data(<em>x</em>)</strong>. We can use MLE principle to find such 𝜃, that is by using maximum likelihood estimator for 𝜃.</p>
<hr>
<p>Simlification1. <em>i.i.d</em>.</p>
<script type="math/tex; mode=display">
\begin{split}
\theta_{ML} &= arg\max \limits_{\theta} p_{model}(X_{example};\theta) \\ & \stackrel{i.i.d}{\longrightarrow} arg\max \limits_{\theta}\prod_{i=1}^{m}p_{model}(x_{i};\theta)
\end{split}</script><hr>
<p>Simplification2. prodction to summation</p>
<p>算数下溢the underflow problem</p>
<p>The product of p_model(<em>x</em>_i;𝜃) is going to be very close to 0 when the example set size m is large since the probability will be in the range of 0≤p_model(<em>x</em>_i;𝜃)≤1. This could cause a serious underflow to the computer, resulting in a less precise estimation of the model.</p>
<p>数据量很大的时候会导致每一个数据的出现概率很小，乘积就会无限趋近于零，在计算机中处理浮点数会带来很大的误差。一个解决办法就是取对数，将相成转换为相加。</p>
<p>改写式子，并scale一个$\frac{1}{m}$，让他变成数学期望的形式。</p>
<script type="math/tex; mode=display">
\begin{split}
\theta_{ML} &= arg\max \limits_{\theta}\sum_{i=1}^{m}p_{model}(x_{i};\theta) \\&= arg\max \limits_{\theta} {\frac{1}{m} \cdot \sum_{i=1}^{m}\log {p_{model}(x_{i};\theta) }} \\
&= arg\max \limits_{\theta} \mathbb{E}_{X\sim p_{example(x)}}{[\log{p_{model}(x; \theta)}]}
\end{split}</script><p>最后的形式和Cross-Entropy一样。</p>
<hr>
<h4 id="过程总结"><a href="#过程总结" class="headerlink" title="过程总结"></a>过程总结</h4><p>This shows that we can see <strong>the problem of getting the best parameter 𝜃_ML using maximum likelihood estimation</strong> as <strong>minimizing the cross-entropy between our parametric model p_model(<em>x</em>;𝜃) and the empirical example distribution p_example(<em>x</em>)</strong>.</p>
<p>Train our model by minimizing the cross-entropy loss since it can lead us to the maximum likelihood estimator of the parameter 𝜃_ML that yields the best model according to the training example.</p>
<hr>
<h2 id="寻找最好的函数"><a href="#寻找最好的函数" class="headerlink" title="寻找最好的函数"></a>寻找最好的函数</h2><p>用梯度下降法求解。对$w$进行微分，运用链式法则在两个偏微分上下分别引入偏微分$\partial z$，获得结果</p>
<script type="math/tex; mode=display">
\frac{\partial{(-\ln{L(\omega, b)} )}}{\partial{w}} = \sum_{n} -(\hat{y}^n-f_{w,b}(x_n))x_i^n</script><script type="math/tex; mode=display">
w_i \leftarrow w_i - \eta  \sum_{n} -(\hat{y}^n-f_{w,b}(x_n))x_i^n</script><p>如何理解括号中的相减的两个式子？代表着Larger Difference, Larger Update。</p>
<h3 id="逻辑回归与线性回归的区别"><a href="#逻辑回归与线性回归的区别" class="headerlink" title="逻辑回归与线性回归的区别"></a>逻辑回归与线性回归的区别</h3><p>从两方面考虑。</p>
<p>第一，实际数据的输出target$\hat{y}$。对于逻辑回归，限定在0～1之间。对于线性回归，可以是任何实数。</p>
<p>第二，定义的损失函数的输出output$f_{\omega,b}(x)$。对于逻辑回归，由于Sigmoid Function的性质，限定在0～1之间。对于线性回归，可以是任何值。</p>
<h3 id="为什么不像线性函数中一样使用Square-Error代表Loss-Function？"><a href="#为什么不像线性函数中一样使用Square-Error代表Loss-Function？" class="headerlink" title="为什么不像线性函数中一样使用Square Error代表Loss Function？"></a>为什么不像线性函数中一样使用Square Error代表Loss Function？</h3><p>从两方面解释。</p>
<p>一方面，output of loss function无论是close to target还是far from target，loss function梯度下降后的偏微分都可以是零。</p>
<p>另一方面，交叉熵距离target越远，微分值越大，更新参数越大。但是平方误差在离target很远的时候，微分值特别小，更新参数会特别慢，效果很差。</p>
<h1 id="Discriminative-Model-V-S-Generative-Model"><a href="#Discriminative-Model-V-S-Generative-Model" class="headerlink" title="Discriminative Model V.S. Generative Model"></a>Discriminative Model V.S. Generative Model</h1><p>用逻辑回归和生成模型找出来的$\omega, b$是不一样的。因为两个模型所做的assumpition都不同，逻辑回归并没有做任何假设；但是生成模型预先假设了样本符合某个分布，给予了更多的信息。</p>
<p>生成方法的优势在于训练数据集很小的情况下，结果受数据量的影响很小，基于分布假设，对噪声数据有更好的鲁棒性。</p>
<p>判别方法的优势在于看训练数据集计算，训练数据量越大，error越小。</p>
<h1 id="多类别分类-n-class"><a href="#多类别分类-n-class" class="headerlink" title="多类别分类 n-class"></a>多类别分类 n-class</h1><script type="math/tex; mode=display">
input \stackrel{\omega_i ,b_i}{\longrightarrow} z_i 
\stackrel{exponential}{\longrightarrow} e^{z_i} \stackrel{normalize}{\longrightarrow} output=\frac{e^{z_i}}{\sum_{j=1}^{n}{e^{z_i}}}</script><p>exponential和normalize的过程都可以被一个叫softmax的方程来完成，这个步骤的工作就是对最大值进行强化。</p>
<p>target该如何定义？如果用连续的0-1-2-3-4存在类别之间有距离大小的问题，而每个类别应当同等看待地位相同。用一个列向量来表示target。</p>
<h1 id="逻辑回归的限制"><a href="#逻辑回归的限制" class="headerlink" title="逻辑回归的限制"></a>逻辑回归的限制</h1><p>逻辑回归就是区分类别，如果raw data并不能让逻辑回归做区别的？比如在平面上，一个正方形的四个顶点，对角同类别，无论怎么拉线都不能分类。这种时候该怎么办？</p>
<p>利用特征转换Feature Transfomation。但是如何衡量一个特征转换的优劣又是需要考虑的。</p>
<p>逻辑回归可以用来做特征转换，也可以用来做分类。把这些逻辑回归级联在一起就得到级联逻辑回归模型。</p>
<p>一个逻辑回归的输入可以来源于其他逻辑回归的输出，这个逻辑回归的输出也可以是其他逻辑回归的输入。把每个逻辑回归称为一个 Neuron（神经元），把这些神经元连接起来的网络，就叫做 Neural Network（神经网络）。</p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>DL</tag>
        <tag>LogisticRegression</tag>
      </tags>
  </entry>
  <entry>
    <title>从Github上下载单一文件夹资源</title>
    <url>/2020/10/27/github-one-file-download/</url>
    <content><![CDATA[<h1 id="使用SVN"><a href="#使用SVN" class="headerlink" title="使用SVN"></a>使用SVN</h1><ol>
<li><p>在网页中打开想要下载的文件夹并复制的URL。</p>
</li>
<li><p>将URL中<code>/tree/master/</code>转换成<code>/trunk/</code>。</p>
<p>如果不是<code>master</code>分支，是另一个<code>branchname</code>分支，只需要将上文中的<code>/trunk/</code>替换成<code>/branches/branchname/</code>即可。</p>
</li>
<li><p>在终端进入目的文件夹，输入<code>svn checkout Changed-URL</code>即可。</p>
</li>
</ol>
<hr>
<p>升级到MacOS BigSur之后发现无法使用svn，因为XCode的Command Line Tools工具包里面没有svn了。解决办法是使用homebrew包管理工具。</p>
<p>之前下载过homebrew，但是报错<code>version value must be a string</code>。解决办法是<code>brew update-reset</code>，之后正常安装即可。</p>
<hr>
<h1 id="使用页面Raw"><a href="#使用页面Raw" class="headerlink" title="使用页面Raw"></a>使用页面Raw</h1><p>在Raw上右键菜单点击链接另存为即可。</p>
<p>但是可能存在文件格式转换。例如下载.csv到电脑就会变成.txt。</p>
<h1 id="Raw-Wget"><a href="#Raw-Wget" class="headerlink" title="Raw+Wget"></a>Raw+Wget</h1><p>把单个文件点击Raw格式，跳出的页面中会有一个新的URL，形式大概为<code>https://raw.githubusercontent.com/datawhalechina/leeml-notes/master/docs/Homework/HW_1/Dataset/result.csv</code>。</p>
<p>在命令行中输入<code>wget Raw-URL</code>，就可以下载内容，且不存在文件格式的转换。</p>
<h2 id="可能会出现的问题"><a href="#可能会出现的问题" class="headerlink" title="可能会出现的问题"></a>可能会出现的问题</h2><p>raw.githubusercontent.com的443端口无法连接的问题</p>
<p>修改主机地址，添加github相关地址，具体参考<a href="https://blog.csdn.net/laoxuan2011/article/details/106177126">解决GitHub的raw.githubusercontent.com无法连接问题</a></p>
]]></content>
      <categories>
        <category>必备技能</category>
      </categories>
      <tags>
        <tag>资源获取</tag>
      </tags>
  </entry>
  <entry>
    <title>使用LaTeX编辑数学公式</title>
    <url>/2020/10/27/latex-and-typora/</url>
    <content><![CDATA[<h1 id="区别常用函数表示"><a href="#区别常用函数表示" class="headerlink" title="区别常用函数表示"></a>区别常用函数表示</h1><p>$ln$ &amp;&amp; $\ln$左边单纯输入ln两个字母，右边加了斜杠，代表是一个函数。</p>
<p>同样适用于min max sin cos等。</p>
<h1 id="函数中的圆括号和花括号"><a href="#函数中的圆括号和花括号" class="headerlink" title="函数中的圆括号和花括号"></a>函数中的圆括号和花括号</h1><p>区别一下两种在函数中加入表达式的方法。</p>
<p>函数后面只用了花括号：<code>\ln&#123;1-f_&#123;\omega,b&#125;(x_n)&#125;</code></p>
<script type="math/tex; mode=display">
\ln{1-f_{\omega,b}(x_n)}</script><p>花括号中另外加了一层圆括号把减号前后包括起来。<code>\ln&#123;(1-f_&#123;\omega,b&#125;(x_n))&#125;</code></p>
<script type="math/tex; mode=display">
\ln{(1-f_{\omega,b}(x_n))}</script><h1 id="下标置于正下方"><a href="#下标置于正下方" class="headerlink" title="下标置于正下方"></a>下标置于正下方</h1><p>使用<code>\limits_&#123;&#125;</code>，需要注意<em>! Limit controls must follow a math operator.</em></p>
<p>如果是非数学符号，结合<code>\mathhop&#123;&#125;</code>将式子转换成数学符号。</p>
<script type="math/tex; mode=display">
\sum\limits_{i=0}^n {x_i} \\
\mathop{argmin}\limits_{x=0}</script><h1 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h1><ul>
<li><p>相当于Tab的空格<code>\quad</code></p>
</li>
<li><p>大空格<code>a\ b</code></p>
</li>
<li><p>中等空格<code>a\;b</code></p>
</li>
<li><p>小空格<code>a\,b</code></p>
</li>
</ul>
<h1 id="波浪号"><a href="#波浪号" class="headerlink" title="波浪号"></a>波浪号</h1><p>常用语随机变量分布<code>\sim</code>$X \sim N(0,1)$。</p>
<h1 id="带文字的箭头"><a href="#带文字的箭头" class="headerlink" title="带文字的箭头"></a>带文字的箭头</h1><p><code>\stackrel&#123;exponential&#125;&#123;\longrightarrow&#125;</code> $\stackrel{exponential}{\longrightarrow}$</p>
<h1 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h1><p><code>\mathbb&#123;E&#125;</code>  $\mathbb{E}$</p>
<h1 id="product-amp-summation"><a href="#product-amp-summation" class="headerlink" title="product &amp; summation"></a>product &amp; summation</h1><p><code>\prod</code> $\prod$</p>
<p> <code>\sum</code> $\sum$</p>
<h1 id="多行公式左对齐"><a href="#多行公式左对齐" class="headerlink" title="多行公式左对齐"></a>多行公式左对齐</h1><script type="math/tex; mode=display">
\begin{split}
\theta_{ML} &= arg\max \limits_{\theta}\sum_{i=1}^{m}p_{model}(x_{i};\theta) \\&= arg\max \limits_{\theta} {\frac{1}{m} \cdot \sum_{i=1}^{m}\log {p_{model}(x_{i};\theta) }} \\
\end{split}</script><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;split&#125;</span></span></span><br><span class="line">x &amp;= a <span class="tag">\<span class="name">\</span></span></span><br><span class="line">&amp;= b <span class="tag">\<span class="name">\</span></span></span><br><span class="line">&amp;= c</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;split&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;array&#125;</span><span class="string">&#123;ll&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;array&#125;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>必备技能</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS布局</title>
    <url>/2020/10/28/css-layout/</url>
    <content><![CDATA[<h1 id="正常布局流"><a href="#正常布局流" class="headerlink" title="正常布局流"></a>正常布局流</h1><p>Normal Flow是指在不对页面进行任何布局控制室，浏览器默认的HTML布局方式。</p>
<p>主要涉及块元素/内联元素。</p>
<p>当你使用css创建一个布局时，你正在离开<strong>正常布局流</strong>，但是对于页面上的多数元素，<strong>正常布局流</strong>将完全可以创建你所需要的布局。</p>
<p>以下布局技术会覆盖默认的布局行为：<code>display</code>/ <code>float</code> / <code>position</code>/ <code>display: table</code>表格布局/ <code>Multi-column layout</code>多列布局。</p>
<h1 id="display"><a href="#display" class="headerlink" title="display"></a>display</h1><p>正常布局流下盒子类型分为inline/block两种，这个属性是根据HTML标签元素是块元素还是内联元素而自带的。</p>
<blockquote>
<p>一个块级元素的内容宽度是其父元素的100%，其高度与其内容高度一致。</p>
<p>内联元素的height width与内容一致。你无法设置内联元素的height width —- 它们就那样置于块级元素的内容里。 如果你想控制内联元素的尺寸，你需要为元素设置<code>display: block;</code> （或者，<code>display: inline-block;</code> inline-block 混合了inline 和 block的特性。)</p>
</blockquote>
<p><code>display</code>还有另外两个取值为<code>flex</code>和<code>grid</code>。</p>
<h2 id="弹性盒子Flexbox"><a href="#弹性盒子Flexbox" class="headerlink" title="弹性盒子Flexbox"></a>弹性盒子Flexbox</h2><p>弹性盒子被用于创建横向或者纵向的一维页面布局。要使用Flexbox，需要<strong>在想要进行flex布局的父亲元素上应用<code>display: flex</code></strong>  ，子元素(flex item)的表现行为就是依据副元素上设置的<code>flex-direction</code>/<code>align-items</code>等属性（默认初始值是row/stretch，以为着子元素排成一行并被拉伸到和作为flex容器的父亲元素一样的高度）。</p>
<h3 id="模型说明"><a href="#模型说明" class="headerlink" title="模型说明"></a>模型说明</h3><p><img src="/2020/10/28/css-layout/flex_terms.png" alt="flex_terms" style="zoom:50%;"></p>
<ul>
<li><p>flex conatiner/flex容器</p>
<ul>
<li>main axis主轴 — cross axis交叉轴 互相垂直</li>
<li>main start — main end</li>
<li>cross start — cross end</li>
</ul>
</li>
<li><p>flex item/flex项</p>
<ul>
<li>main size — cross size</li>
</ul>
</li>
</ul>
<h3 id="指定主轴方向"><a href="#指定主轴方向" class="headerlink" title="指定主轴方向"></a>指定主轴方向</h3><p><code>flex-direction</code>默认值为<code>row</code>。可取值<code>column</code>/<code>column-reverse</code>/<code>row-reverse</code>。</p>
<h3 id="flex容器定宽定高时flex项过多溢出"><a href="#flex容器定宽定高时flex项过多溢出" class="headerlink" title="flex容器定宽定高时flex项过多溢出"></a>flex容器定宽定高时flex项过多溢出</h3><p>添加声明到flex容器(父元素)中添加声明<code>flex-wrap: wrap</code>，意味着任何溢出的元素将被移到下一行。</p>
<p>同时，把<code>flex: 200px</code>添加到flex项(子元素)中，意味着每个子元素的宽度至少是200px。</p>
<p>变换浏览器视窗还可以发现，最后一行上的最后几个项每个都变得更宽，以便把整个行填满。</p>
<h3 id="flex-flow缩写"><a href="#flex-flow缩写" class="headerlink" title="flex-flow缩写"></a>flex-flow缩写</h3><p>存在着 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-wrap"><code>flex-wrap</code></a> — 的缩写 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-flow"><code>flex-flow</code></a>。</p>
<h3 id="控制flex项占用flex容器的空间比例"><a href="#控制flex项占用flex容器的空间比例" class="headerlink" title="控制flex项占用flex容器的空间比例"></a>控制flex项占用flex容器的空间比例</h3><p>在flex项中添加元素<code>article:nth-of-type(f(n)) &#123;flex : 1&#125;</code>，数字是一个无单位的比例值，代表每个flex项沿着主轴占用空间的份额。</p>
<p>总的份额是所有子元素的份额相加，单个子元素的份额默认为1。</p>
<p>对于某一个特定的子元素，为了计算它占用flex容器的空间，用给定它的份额除以总份额即可。</p>
<p>可以配合尝试指定<code>flex</code>最小宽度。</p>
<h3 id="控制flex项的水平和垂直对齐"><a href="#控制flex项的水平和垂直对齐" class="headerlink" title="控制flex项的水平和垂直对齐"></a>控制flex项的水平和垂直对齐</h3><p>从flex容器中使用属性去控制其下flex项的水平和垂直对齐</p>
<ul>
<li><code>align-items</code> 控制 flex 项在交叉轴上的位置。<ul>
<li>默认 <code>stretch</code>，其会使所有 flex 项沿着交叉轴的方向拉伸以填充父容器。如果父容器在交叉轴方向上没有固定宽度（即高度），则所有 flex 项将变得与最长的 flex 项一样长（即高度保持一致）。</li>
<li><code>center</code> 值会使这些项保持其原有的高度，但是会在交叉轴居中。</li>
<li><code>flex-start</code> 或 <code>flex-end</code> 这样使 flex 项在交叉轴的开始或结束处对齐所有的值。</li>
</ul>
</li>
<li><code>justify-content</code> 控制 flex 项在主轴上的位置。<ul>
<li>默认值是 <code>flex-start</code>，这会使所有 flex 项都位于主轴的开始处。<code>flex-end</code>为结尾处。 </li>
<li><code>space-around</code> 使所有 flex 项沿着主轴均匀地分布，在任意一端都会留有一点空间。</li>
<li><code>space-between</code>和 <code>space-around</code> 非常相似，只是它不会在两端留下任何空间。</li>
</ul>
</li>
</ul>
<p>如果想在flex项中单独去控制某个或者某类子元素，可以使用<code>align-self</code>属性覆盖<code>align-items</code>的行为。（在子元素中再一次声明<code>align-items</code>会没有效果）。</p>
<h3 id="控制flex项排序"><a href="#控制flex项排序" class="headerlink" title="控制flex项排序"></a>控制flex项排序</h3><p>在flex项的规则集中添加<code>order</code>属性。改变子元素的顺序的同时，不影响DOM树种元素的顺序。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">sub-element</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认所有flex项<code>order</code>为0。</li>
<li>接受的值可负可0可正。</li>
<li>排序顺序依据order值从小到大依次显示，当order值相同时，按照DOM树中的源顺序。</li>
</ul>
<h2 id="Grid布局"><a href="#Grid布局" class="headerlink" title="Grid布局"></a>Grid布局</h2><p>Grid布局用于同时在两个维度上把元素按照行和列排列整齐。一般都描述一个容器和若干子元素。</p>
<h3 id="模型说明-1"><a href="#模型说明-1" class="headerlink" title="模型说明"></a>模型说明</h3><p><img src="/2020/10/28/css-layout/grid.png" alt="grid" style="zoom:50%;"></p>
<p>分为行和列，行与行以及列与列之间的间隙被称为沟槽。</p>
<h3 id="定义网格"><a href="#定义网格" class="headerlink" title="定义网格"></a>定义网格</h3><p>将容器的<code>display</code>属性设置为<code>grid</code>。与弹性盒子相同，将赴容器改为网格布局后，它的直接子项会变成网格项。</p>
<p>仅有该声明并不会造成网页布局的马上变化，因为<code>display: grid</code>的声明只创建了一个只有一列的网格，所以你的子项还是会像正常布局流那样从上而下一个接一个的排布。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">father-element</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">	<span class="attribute">grid-template-colums</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">    <span class="comment">/* 1fr = 1 fraction相对单位，代表了经过计算后的该子项会使用的份额。如果一个声明中全是fr，那么子元素的排列就是父亲元素宽度分之几。一般配合px等绝对单位使用，fr会根据除去绝对单位后的可用空间按比例分配。*/</span></span><br><span class="line">	<span class="attribute">grid-template-rows</span>: <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">grid-gap</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义网格间隙"><a href="#定义网格间隙" class="headerlink" title="定义网格间隙"></a>定义网格间隙</h3><p>使用<code>grid-column-gap</code>属性来定义列间隙；使用<code>grid-row-gap</code>来定义行间隙；使用<code>grid-gap</code> 可以同时设定两者。</p>
<p>不能使用fr单位。</p>
<h3 id="重复构建行-列"><a href="#重复构建行-列" class="headerlink" title="重复构建行/列"></a>重复构建行/列</h3><p><code>repeat(time, unit)</code></p>
<p>第一个参数值是表明后续要重复多少参数的行/列；第二个参数表示需要把每个行/列设置成多少，可以传入多个参数当作一套参数。</p>
<h3 id="隐式网格V-S-显式网格"><a href="#隐式网格V-S-显式网格" class="headerlink" title="隐式网格V.S.显式网格"></a>隐式网格V.S.显式网格</h3><p>显式网格是我们用<code>grid-template-columns</code> 或 <code>grid-template-rows</code> 属性创建的。隐式网格则是当有内容被放到网格外时才会生成的。</p>
<p>隐式网格中生成的行/列大小是参数默认是<code>auto</code>，大小会根据放入的内容自动调整。也可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-rows"><code>grid-auto-rows</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-columns"><code>grid-auto-columns</code></a>属性手动设定隐式网格的大小。</p>
<h3 id="解决固定行-列高不够用的情况"><a href="#解决固定行-列高不够用的情况" class="headerlink" title="解决固定行/列高不够用的情况"></a>解决固定行/列高不够用的情况</h3><p><code>minmanx()</code>函数为一个行/列的尺寸设置了取值范围。</p>
<blockquote>
<p>set a minimum and maximum size for a track, for example <code>minmax(100px, auto)</code>. The minimum size is 100 pixels, but the maximum is <code>auto</code>, which will expand to fit the content. </p>
</blockquote>
<h3 id="自动使用多列填充"><a href="#自动使用多列填充" class="headerlink" title="自动使用多列填充"></a>自动使用多列填充</h3><p>将repeat函数和minmax函数结合起来设定行列属性。</p>
<p>repeat函数的第一个参数传入关键字<code>auto-fill</code>来替代确定的重复次数；第二个参数传入minmax函数，minmax函数参数传入一个最小的固定值，以及最大的值1fr。</p>
<h3 id="网格项放置"><a href="#网格项放置" class="headerlink" title="网格项放置"></a>网格项放置</h3><p>如果不对子元素指定排列位置，默认自动排列。</p>
<h4 id="基于分割线放置"><a href="#基于分割线放置" class="headerlink" title="基于分割线放置"></a>基于分割线放置</h4><p>可以利用<code>grid-column</code>和<code>grid-row</code>两个属性来制定每一个子元素从哪一个行/列开始，哪一个行列结束（有两个用斜杠分开的数字：开始列/结束列，使子元素在多个行列上展开；如果只有一个数字：只占单列/单行）。</p>
<h4 id="基于grid-template-areas属性放置"><a href="#基于grid-template-areas属性放置" class="headerlink" title="基于grid-template-areas属性放置"></a>基于grid-template-areas属性放置</h4><h5 id="父亲元素操作"><a href="#父亲元素操作" class="headerlink" title="父亲元素操作"></a>父亲元素操作</h5><p>在父亲元素中使用grid-template-areas属性，一行内容用<strong>双引号</strong>，行与行之间直接换行，结束后使用分号。</p>
<p>使用规则如下：</p>
<ul>
<li>你需要填满网格的每个格子</li>
<li>对于某个横跨多个格子的元素，重复写上那个元素<code>grid-area</code>属性定义的区域名字</li>
<li>所有名字只能出现在一个连续的区域，不能在不同的位置出现</li>
<li>一个连续的区域必须是一个矩形</li>
<li>使用<code>.</code>符号，让一个格子留空</li>
</ul>
<p>对于第一条，填满网格的格子，说明至少在父亲元素的规则集中<code>grid-template-columns</code>这个属性上有的列数要和该属性中的列数一样。他们两个是协同工作的。</p>
<h4 id="子元素操作"><a href="#子元素操作" class="headerlink" title="子元素操作"></a>子元素操作</h4><p>子元素中声明<code>grid-area</code>，代表了这个区域的功能别名，用于在父亲元素中使用。不需要引号，冒号后面直接跟别名。</p>
<h1 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h1><p>让元素浮动起来，改变元素本身和在正常布局流中跟随它的其他元素的行为。也就是说一个元素的浮动设置，会影响之后的元素的行为。</p>
<p>通过将某一元素设置左/右浮动，并给出一个元素的margin，实现文字环绕该元素的效果。</p>
<h2 id="float的取值"><a href="#float的取值" class="headerlink" title="float的取值"></a>float的取值</h2><p><code>left</code> — 左侧</p>
<p><code>right</code> — 右侧</p>
<p><code>none</code> — 默认不浮动</p>
<p>结合<code>width</code>的百分比取值和<code>float</code>以及<code>margin-left/right</code>的百分比取值，实现多列布局。</p>
<p><code>float</code>存在的问题就是只要是float过后的元素之后的内容，都会以围绕的方式包裹着浮动元素。由此需要一个”停止浮动”的属性<code>clear</code>。</p>
<h2 id="停止浮动"><a href="#停止浮动" class="headerlink" title="停止浮动"></a>停止浮动</h2><p><code>clear</code>可以取值<code>both</code>/<code>left</code>/<code>right</code>。之后所有的元素都不在浮动，回归正常文档流。除非另外设置了浮动。 </p>
<p>如果没有可用元素来清除浮动（比如页脚），可以在想要清除浮动的元素之前，应用浮动的元素之后添加一个看不见的块元素<code>div</code>，对这个元素应用<code>clear</code>规则。</p>
<blockquote>
<p>浮动元素后超出父元素边框如何解决？:link:<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Floats_skills">Float Three</a></p>
<p>将父亲元素改为inline-block包裹浮动元素即可。</p>
</blockquote>
<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>定位能让我们把一个元素从它原本在正常布局流中应该在的位置移动到另一个位置，用于微调页面中的特殊项目。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a><code>static</code></h2><p>每个元素自带的默认定位，放在<strong>文档流的默认位置</strong>。即使有了<code>top</code> <code>right</code> <code>bottom</code> <code>left</code>也忽略设定。</p>
<h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a><code>relative</code></h2><p>相对定位，允许我们<strong>相对元素在正常的文档流中的位置</strong>移动它。</p>
<p>单纯设定该属性值表现得和static一样，除非设定<code>top</code> <code>right</code> <code>bottom</code> <code>left</code>。</p>
<p>理解相对定位工作的方式——你需要考虑<strong>一个看不见的力，推动定位的盒子的一侧，移动它的相反方向。</strong> 所以例如，如果你指定 <code>top: 30px;</code>一个力推动框的顶部，使它向下移动30px。</p>
<h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a><code>absolute</code></h2><p>绝对定位。</p>
<h3 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h3><p>用了绝对定位的元素在正常文档流中相当于不存在。将元素完全从页面的正常布局流中溢出，类似于单独开设一个图层。</p>
<p>可以利用磁特性创建一个不干扰页面上其他元素的位置的隔离的UI功能。</p>
<h3 id="位置变化"><a href="#位置变化" class="headerlink" title="位置变化"></a>位置变化</h3><p><strong>相对于另外一个元素</strong>定位。这里的<code>top</code> <code>right</code> <code>bottom</code> <code>left</code>属性工作方式和relative中不一样，它们指定元素应距离每个<strong>包含元素</strong>的边的距离，而不是指定元素应该移入的方向。</p>
<p>可以将元素相对于页面的 <code>&lt;html&gt;</code> 元素边缘固定，或者相对于该元素的<em>最近被定位祖先元素(nearest positioned ancestor element)</em>。</p>
<blockquote>
<p>哪个元素是绝对定位元素的“包含元素“？这取决于绝对定位元素的父元素的position属性。分两种情况。</p>
<ul>
<li>所有父元素没有更改默认static</li>
</ul>
<p>所有的父亲元素都没有更改默认的position属性，即所有的父元素默认情况下position属性都是static。结果，绝对定位元素会被包含在<strong>初始块容器</strong>中。</p>
<p>这个初始块容器有着和浏览器视口一样的尺寸，并且<html>元素也被包含在这个容器里面。简单来说，绝对定位元素会被放在<html>元素的外面，并且根据浏览器视口来定位。</html></html></p>
<ul>
<li>所有父元素更改了默认属性static</li>
</ul>
<p>此时包含元素就是那个更改了默认属性static的父亲元素。</p>
</blockquote>
<h3 id="堆叠顺序z-index"><a href="#堆叠顺序z-index" class="headerlink" title="堆叠顺序z-index"></a>堆叠顺序<code>z-index</code></h3><p> “z-index”是对z轴的参考。我们使用水平（x轴）和垂直（y轴）坐标来讨论网页，以确定像背景图像和阴影偏移之类的东西的位置。 (0,0)位于页面（或元素）的左上角，x和y轴跨页面向右和向下。</p>
<p>网页也有一个z轴：一条从屏幕表面到你的脸（或者在屏幕前面你喜欢的任何其他东西）的虚线。<code>z-index</code>的值影响定位元素位于该轴上的位置，也就是定位元素堆叠顺序。</p>
<p>默认情况下，定位的元素都具有z-index为auto，实际上为0。</p>
<h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a><code>fixed</code></h2><p>固定定位，与绝对定位非常类似，<strong>相对于浏览器视口</strong>来定位，即便网页滚动也会停留在相同位置。可以用来创建在整个页面滚动过程中总是处于屏幕的某个位置的导航菜单时使用。</p>
<h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a><code>sticky</code></h2><p>结合static和fixed两个属性。优先保持static，当该元素相对于视口位置到达某一个预设置时，切换fixed定位。</p>
<p>当一个元素被指定了<code>position: sticky</code>时，它会在正常布局流中滚动，直到它出现在了我们给它设定的相对于容器的位置，这时候它就会停止随滚动移动，就像它被应用了<code>position: fixed</code>。</p>
<h1 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h1><p>要把一个块转变成多列容器(multicol container)。</p>
<p>使用 <code>column-count</code>属性来告诉浏览器我们需要多少列。</p>
<p>使用<code>column-width</code>使浏览器将按照你指定的宽度尽可能多的创建列；任何剩余的空间之后会被现有的列平分。 这意味着你可能无法期望得到你指定宽度，除非容器的宽度刚好可以被你指定的宽度除尽。</p>
<p>使用 <code>column-gap</code>改变列间间隙。</p>
<p>用 <code>column-rule</code> 在列间加入一条分割线。和border属性类似，接受相同的单位。</p>
<p>如果多列布局的一个列被拆成了很多碎块，尤其是在你添加了内容背景颜色和边框的情况下会特别明显。对文本容器盒子添加属性<code>break-inside: avoid</code>。</p>
<h1 id="媒体查询基础"><a href="#媒体查询基础" class="headerlink" title="媒体查询基础"></a>媒体查询基础</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> media-type <span class="keyword">and</span> (media-feature-rule) &#123;</span><br><span class="line">  <span class="comment">/* CSS rules go here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="media-type媒体类型"><a href="#media-type媒体类型" class="headerlink" title="media-type媒体类型"></a>media-type媒体类型</h2><p>可取值<code>all</code>/<code>print</code>/<code>screen</code>/<code>speech</code></p>
<h2 id="media-feature-rule媒体特征规则"><a href="#media-feature-rule媒体特征规则" class="headerlink" title="media-feature-rule媒体特征规则"></a>media-feature-rule媒体特征规则</h2><h3 id="宽和高"><a href="#宽和高" class="headerlink" title="宽和高"></a>宽和高</h3><p>使用<code>min-width</code>、<code>max-width</code>和<code>width</code>等媒体特征，在视口宽度大于或者小于某个大小——或者是恰好处于某个大小——的时候，应用CSS。</p>
<h3 id="朝向"><a href="#朝向" class="headerlink" title="朝向"></a>朝向</h3><p><code>orientation</code>，我们可以用它测得竖放（portrait mode）和横放（landscape mode）模式。</p>
<h2 id="构成逻辑表达式"><a href="#构成逻辑表达式" class="headerlink" title="构成逻辑表达式"></a>构成逻辑表达式</h2><p>媒体类型与媒体特征规则之间利用逻辑符号可以构成更复杂的媒体查询。</p>
<ul>
<li>与逻辑 <code>and</code></li>
<li>或逻辑 <code>,</code></li>
<li>非逻辑 <code>not</code></li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSSLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵微分</title>
    <url>/2020/10/28/matrix-calculus-tips/</url>
    <content><![CDATA[<p><a href="https://eli.thegreenplace.net/2015/the-normal-equation-and-matrix-calculus/">正态分布的参数估计中的Matrix Calculus</a></p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>DL</tag>
        <tag>Math</tag>
        <tag>MatrixCalculus</tag>
      </tags>
  </entry>
  <entry>
    <title>Lee-ML-Homework1</title>
    <url>/2020/10/29/MLHW1-tips/</url>
    <content><![CDATA[<h1 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h1><p>使用<code>pandas</code>库，<code>import pandas as pd</code>。</p>
<p><code>data = pd.read_csv(&#39;path&#39;);</code></p>
<p>在加载数据的时候默认第一行就是列号，但是出现第一行就是数据的情况需要添加<code>pd.read_csv(&#39;./Dataset/test.csv&#39;, header=None)</code>。</p>
<h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><h2 id="无关行-列处理"><a href="#无关行-列处理" class="headerlink" title="无关行/列处理"></a>无关行/列处理</h2><p>如果存在不是数据，只是辅助信息的多余的列，需要剔除。</p>
<ul>
<li>使用<code>iloc</code>，即<code>data.iloc[:, 3:]</code>表示保留所有行，列从第三列开始保留。</li>
</ul>
<blockquote>
<p>与python中slice的区别</p>
<p>Note that contrary to usual python slices, <strong>both</strong> the start and the stop are included.</p>
</blockquote>
<ul>
<li>使用<code>drop</code>，<code>train_data.drop([&#39;Date&#39;, &#39;stations&#39;, &#39;observation&#39;], axis=1, inplace=True)</code>。需要确定的源数据中的行列名称(labels)，以及行还是列(axis=0 — index/ axis=1 — column)</li>
</ul>
<h2 id="非数据项转换"><a href="#非数据项转换" class="headerlink" title="非数据项转换"></a>非数据项转换</h2><p>存在一些文字表示的数据项，如果取值为二元就可以转换成0或1的布尔值。</p>
<p><code>data[data == &#39;NR&#39;] = 0</code></p>
<h1 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h1><h2 id="reshape-amp-amp-1"><a href="#reshape-amp-amp-1" class="headerlink" title="reshape &amp;&amp; -1"></a><code>reshape</code> &amp;&amp; <code>-1</code></h2><p><a href="https://stackoverflow.com/questions/18691084/what-does-1-mean-in-numpy-reshape">StackOverflow的解答</a> </p>
<p><code>-1</code>意味着未知的维度，需要<code>numpy</code>依据传入的另外一个参数值进行自行计算。计算遵循的原则是前后数据不能有损失，即<em>‘The new shape should be compatible with the original shape’</em>。</p>
<p><code>reshape(1, -1)</code>转换成一个行向量；<code>reshape(-1, 1)</code>转换成一个列向量。</p>
<h2 id="np-concatenate"><a href="#np-concatenate" class="headerlink" title="np.concatenate"></a><code>np.concatenate</code></h2><p>在线性回归中有一个bias项要添加到x中去，使用<code>np.concatenate((np.ones([row, column]), x), axis=1)</code></p>
<h2 id="声明-更改数组数据类型"><a href="#声明-更改数组数据类型" class="headerlink" title="声明/更改数组数据类型"></a>声明/更改数组数据类型</h2><p>一般在声明一个空数组，全1数组的时候会使用<code>dtype=float</code>之类的命令。</p>
<p>如：<code>test_y = np.empty([240, 1], dtype=float)</code></p>
<p>在对已有的数组进行拼接/截取操作，或从某个文件读取数据到CSV，会使用<code>.astye(float)</code>之类的命令强制类型转换。</p>
<p>如<code>test_x = np.concatenate((np.ones([240, 1]), test_x),axis=1).astype(float)</code></p>
<h1 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h1><p>模型训练是在定义并初始化相关参数以及学习率之后，执行for循环。</p>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>for循环的次数是iter_time。for循环内部需要有output_value y，每次迭代得到的loss function的结果，对loss function求gradient的结果，最后更新参数即可。</p>
<h2 id="参数更新"><a href="#参数更新" class="headerlink" title="参数更新"></a>参数更新</h2><p>如果使用adagrad用到了前面求的梯度，还要专门开设一个变量存放中间结果。</p>
<p>如果参数更新的表达式，后面的负的gradient的式子中存在分式且分母有可能为0，需要在分母上添加一个eps极小值，目的是保证分式子有意义。</p>
<h1 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>在train的.py文件中保存好模型参数，并输出到当前路径。<code>np.save(&#39;weight.npy&#39;, w)</code></p>
<p>在test的.py文件中读入权重。<code>w = np.load(&#39;weight.npy&#39;)</code></p>
<h2 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h2><p>把test的结果输出到CSV文件，前两行通用写法，然后开始定义header并写header；之后开始用for循环写数据，写一次数据就调用一次<code>csv_writer.writerow(content-you-want-write)</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;predict.csv&#x27;</span>, mode = <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    csv_writer = csv.writer(file)</span><br><span class="line">    header = [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;PM2.5&#x27;</span>]</span><br><span class="line">    csv_writer.writerow(header)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">240</span>):</span><br><span class="line">        <span class="keyword">if</span> int(test_y[i][<span class="number">0</span>]) &gt; <span class="number">0</span>:</span><br><span class="line">            row = [<span class="string">&#x27;id_&#x27;</span>+str(i), str(int(test_y[i][<span class="number">0</span>]))]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            row = [<span class="string">&#x27;id_&#x27;</span>+str(i), <span class="string">&#x27;0&#x27;</span>]</span><br><span class="line">        csv_writer.writerow(row)</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mrsuncodes.github.io/2020/03/15/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E8%AF%BE%E4%BD%9C%E4%B8%9A/#more">MrSun Blog</a></p>
<p><a href="https://blog.csdn.net/sinat_35907936/article/details/105075838">CSDN 意疏</a></p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>ML-Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo渲染数学公式</title>
    <url>/2020/10/30/mathjax-on/</url>
    <content><![CDATA[<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p><a href="https://dragon-liu.github.io/2019/04/26/blog6/">参考</a></p>
<p>更改渲染引擎；对渲染引擎文件的转义做修改；在NexT主题的配置中打开MathJax开关。</p>
<h1 id="使用MathJax"><a href="#使用MathJax" class="headerlink" title="使用MathJax"></a>使用MathJax</h1><p><a href="http://blog.mobing.net/content/hexo/hexo-mathjax.html">参考</a></p>
<h1 id="仍然存在的问题"><a href="#仍然存在的问题" class="headerlink" title="仍然存在的问题"></a>仍然存在的问题</h1><p><script type="math/tex">L(\mu^*)</script>在行内$L(\mu^<em>)$是无法正确渲染的，尤其是¥$test^</em>$多个STAR的$test^*$的情况下。</p>
<p><script type="math/tex">\larr, \lrarr, \rarr</script>在本地可以行内渲染，但是部署后会高亮呈红色无法渲染。$\larr$ 的解决办法是使用同等的替代品 <code>\leftarrow, \rightarrow</code>，呈现效果如下$\leftarrow, \rightarrow$。</p>
]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>踩坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title>使用sketch设计商城app原型的流程</title>
    <url>/2020/10/30/sketch-app-design-workflow/</url>
    <content><![CDATA[<p><a href>前锋UI视频教程：2018sketch课程</a></p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><ol>
<li>把各个页面上的元素做成思维导图以供后续参考</li>
<li>查阅基本模型查看需要多少种字体，设定完成并模版化，构成创建该app所需要的所有字体库。</li>
<li>查阅所有图标，单独开一个icon的page，复制出所有需要的在@1x情况下图标尺寸为44*44的rectangle，组成一个group。</li>
</ol>
<blockquote>
<p>TIPS on shortcut</p>
<p><code>cmd++g</code> = group</p>
<p><code>cmd+shift+l</code> = lock</p>
</blockquote>
<h1 id="图标绘制"><a href="#图标绘制" class="headerlink" title="图标绘制"></a>图标绘制</h1><p>选中一个对象，按下<code>option</code>可以查看对象之间的间距。</p>
<p>在设定一个元素的宽和高的时候，需要注意是2的倍数。一方面图标尺寸默认44*44，另一方面2的倍数比较方便居中对齐。</p>
<p>在图标绘制的时候考虑图标的两种状态，一种是选中，一种是未选中，（当然也可以根据hover/clicked等状态自行定义一个图标的多个状态），绘制出一个图标的多种状态。</p>
<h2 id="页面绘制"><a href="#页面绘制" class="headerlink" title="页面绘制"></a>页面绘制</h2><p>一套APP中所有的border和border-radius尽量都保持一致。</p>
<p>中文字体一般用双数，才能让文字显示更完整。</p>
<p>内阴影和外阴影的设置可以让某个物件凸起或者凹陷，但一般不会去做内阴影。</p>
<p>在sketch中@1x的情况下去画线，粗细用0.5px，而不是1px，目的是在@2x的情况下呈现1px的效果。</p>
<p>如何确定两边间距？在一倍率下的间距数值乘以倍率要是一个整数。比如说@0.75x和@1.5X的情况下，选择8的倍数做间距。</p>
<p>一个单个的icon可以做很小，但是考虑到用户交互，一定要大于44X44才适用于用户点击。这种情况下对单个icon创建组件，组件的大小至少为44X44，然后在组件内部点击对象可以做任意大小。</p>
<p>icon的种类可以分两种，一种是用于装饰的，一种是用于交互的。装饰的无需在artboard上生成组件，直接按照合适的大小调整；交互的需要现在artboard中生成组件，在组件页面编辑完成所有需要的元素（可能在组件中还有小组件生成）。</p>
<p>对于组件中的文字，一定要说清楚可以容纳的最大字数是多少，作为备注指示之后的程序员。</p>
<p>文字区域尽量给出提示最多可以容纳最多多少个字符。</p>
<p>蒙板中的MASK是作为最上面的那一个图层出现的，会用MASK的轮廓呈现出底下多个图片的样子。比如最多的应用就是刘海屏。</p>
]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>SKETCH</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习总介绍</title>
    <url>/2020/11/03/back-propagation/</url>
    <content><![CDATA[<h1 id="深度学习三个步骤"><a href="#深度学习三个步骤" class="headerlink" title="深度学习三个步骤"></a>深度学习三个步骤</h1><h2 id="Neural-Network"><a href="#Neural-Network" class="headerlink" title="Neural Network"></a>Neural Network</h2><p>前馈feedforward，输入进入网络后流动是单向的。两层之间的连接并没有反馈feedback。</p>
<p>全链接fully connect，每一层之间两两都有链接。</p>
<p>Input Layer输入层 1层— Hidden Layer 隐藏层 N层 — Output Layer输出层 1层。</p>
<p>Deep = many hidden layers</p>
<h2 id="Goodness-of-function"><a href="#Goodness-of-function" class="headerlink" title="Goodness of function"></a>Goodness of function</h2><h2 id="单个训练样本"><a href="#单个训练样本" class="headerlink" title="单个训练样本"></a>单个训练样本</h2><p>采用损失函数Loss function来反映模型的好差，利用交叉熵函数对$y$和$\hat{y}$的损失进行计算。</p>
<script type="math/tex; mode=display">
x_i \stackrel{\omega_i}{\longrightarrow} \dots\stackrel{Activation\,Function}{\longrightarrow} y_i \stackrel{Cross\,Entropy}{\longleftrightarrow} \hat{y}_i</script><p>注意损失函数是定义在单个训练样本上的（在表达式上使用下标，且使用小写的$l$）也就是一个样本的误差。</p>
<h2 id="所有训练样本"><a href="#所有训练样本" class="headerlink" title="所有训练样本"></a>所有训练样本</h2><script type="math/tex; mode=display">
x^i \stackrel{Neuron\, Network}{\longrightarrow} y^i \stackrel{Cross\,Entropy\, C^i}{\longrightarrow} \hat{y}^i</script><p>总体损失函数Total loss function是所有样本的误差的总和。也是反向传播需要最小化的值。</p>
<script type="math/tex; mode=display">
L = \sum_{n=1}^{n}{l_n}</script><p>注意这里的$x^i$不是一维的数据，是用来表示一个对象的多维度向量，$x^i$和$x_i$表示的对象不相同，注意区分上下标。</p>
<p>注意是吧所有训练数据的损失都加起来得到的总体损失L。为了最小化这个损失L，也就是要在function set里面找一个最优函数，也是酒找神经网络中的参数$\omega$。</p>
<h2 id="Pick-best-function"><a href="#Pick-best-function" class="headerlink" title="Pick best function"></a>Pick best function</h2><p>使用梯度下降。</p>
<p>Back Propagation: an efficient way to compute $\partial{L}/\partial{\omega}$ in neuron network.</p>
<hr>
<h1 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h1><p>反向传播是在使用梯度下降计算参数变化量的时候，让求梯度更方便的一种方法。</p>
<p>反向传播背后的数学原理就是链式法则。</p>
<p>因为单个样本的loss function是关于系统输出$y$的函数，输入$x$通过系统一层层传递才到输出$y$，所以链式法则拆分的时候也是拆阶段性结果做微分。</p>
<h2 id="单个训练样本分析"><a href="#单个训练样本分析" class="headerlink" title="单个训练样本分析"></a>单个训练样本分析</h2><p><img src="/2020/11/03/back-propagation/onesample.png" alt="onesample" style="zoom:50%;"></p>
<p>输入先进入一个由权重weight和偏移b组成的线性系统获得线性函数输出z。</p>
<p>线性输出z进入一个激励函数non-linear activation function获得一个非线性输出，该输出作为下一层神经网络的输入。最常用的非线性激励函数就是Sigmoid Function。</p>
<blockquote>
<p>为什么需要激励函数？用于加入非线性因素。因为有些数据线性可分，但是某些数据线性不可分。</p>
<p><a href="https://www.zhihu.com/question/22334626/answer/103835591">神经网络激励函数的作用是什么？有没有形象的解释？ - 颜沁睿的回答 - 知乎</a></p>
</blockquote>
<script type="math/tex; mode=display">
\frac{\partial l}{\partial \omega} = \frac{\partial l}{\partial z} \frac{\partial z}{\partial \omega}</script><p>计算$\frac{\partial z}{\partial \omega} $就是Forward Pass的过程，结果就是the value of the input connected by the weight，该层神经网络的输入。此处需要注意z已经在forward pass中被确定了。</p>
<p>计算$\frac{\partial l}{\partial z}$就是Backward Pass的过程。运用链式法则的时候需要注意，最终结果$\partial l$是和$\partial y$结合在一起的，而$\partial y$是作为non-linear activation function的输出存在的，而该非线性激励函数的输入又是$z$，即该层神经网络的输入经过线性变换之后得到值。</p>
<h2 id="Mini-Batch"><a href="#Mini-Batch" class="headerlink" title="Mini-Batch"></a>Mini-Batch</h2><p>相关参数<code>batch_size</code>和<code>nb_epoch</code>。</p>
<p>实际操作并不总是对所有样本最小化总的损失函数，而是将数据随机分成几个mini-batch，每个batch的batch_size指定之后，可以根据有多少样本算出有多少个batch。</p>
<p>初始化神经网络参数后，随机选择第一个bacth的样本，对它计算total loss，然后更新神经网络参数；第二个batch..……直到选了batch_size个batch的样本，也就是对神经网络的参数更新了(总样本数/batch_size)次，才能称做遍历了一次nb_epoch。</p>
<p>batch_size代表一个batch有多大(就是把100个example，放到一个batch里)；nb_epoch等于20表示对每个batch重复20次。</p>
<h1 id="Tips-for-Deep-Learning"><a href="#Tips-for-Deep-Learning" class="headerlink" title="Tips for Deep Learning"></a>Tips for Deep Learning</h1><p>在完成深度学习的三个步骤，得到神经网络之后，需要首先考虑是否能在训练集上获得好的表现。</p>
<p>如果在训练集上不能获得好的表现，需要从Adapative Learning Rate和New Activation Function两方面考虑。</p>
<p>如果在训练集上表现良好，但是在测试集上表现差，说明是overfitting，从Early Stopping和Regularization以及Dropout三方面考虑。</p>
<h2 id="训练集表现不好"><a href="#训练集表现不好" class="headerlink" title="训练集表现不好"></a>训练集表现不好</h2><h3 id="Vanishing-Gradient-Problem"><a href="#Vanishing-Gradient-Problem" class="headerlink" title="Vanishing Gradient Problem"></a>Vanishing Gradient Problem</h3><p>梯度消失是在使用Sigmoid Function作为激励函数时存在的问题。</p>
<p>依据Sigmoid Function的图像来看，它将输入输出都限定在0～1范围内，随着输入增大靠近一条渐近线。</p>
<p>当网络比较深，Sigmoid Function的输入值比较大的情况下，每一次对输入值做的变动delta，都会在输出上表现为很小的变动delta，从而靠后的hidden layer对loss的影响非常小。</p>
<hr>
<p>如何解决梯度消失的问题？</p>
<p>有两个方式，一是动态调整学习率，二是直接更改激励函数。</p>
<hr>
<h3 id="更改激励函数"><a href="#更改激励函数" class="headerlink" title="更改激励函数"></a>更改激励函数</h3><h4 id="ReLU激励函数"><a href="#ReLU激励函数" class="headerlink" title="ReLU激励函数"></a>ReLU激励函数</h4><p>input&gt;0, output=input; input&lt;=0, output=0.</p>
<p>对于input&gt;0的范围，在input比较大且变化比较的地方，梯度下降比较快，可以处理梯度下降问题。</p>
<p>对于input&lt;=0的范围，那些output=0的部分直接可以从整个网络中拿走。最后整个网络就变成了thinner linear network。</p>
<h4 id="改进1-Leaky-ReLu"><a href="#改进1-Leaky-ReLu" class="headerlink" title="改进1: Leaky ReLu"></a>改进1: Leaky ReLu</h4><h4 id="改进2-Parametric-ReLU"><a href="#改进2-Parametric-ReLU" class="headerlink" title="改进2: Parametric ReLU"></a>改进2: Parametric ReLU</h4><p>以上改进都是在input&lt;=0的情况下通过乘以一个比较小的参数让output有一点值。</p>
<h4 id="改进3-Maxout-Learnable-Activation-Function"><a href="#改进3-Maxout-Learnable-Activation-Function" class="headerlink" title="改进3: Maxout/Learnable Activation Function"></a>改进3: Maxout/Learnable Activation Function</h4><p>应该是先对每一层的neuron进行group，每一个group后的结果z都是max{group member result z}，对于所有input的可能取值，就相当于线性规划出了一个linear convex function。group的数量越多，那么convex的角就越多，激励函数也就越复杂，更直观地变成了非线性。</p>
<p>该如何训练该网络？一方面，max过后，该网络就相当于剪枝了，另外一个线性变化后的z就不需要考虑了，最终还是得到thinner linear function。另一方面，对于较全的训练集input，应当max函数中的每一个weight和bias过后的z都会成为max过后有效网络的一部分。</p>
<h3 id="动态调整学习率"><a href="#动态调整学习率" class="headerlink" title="动态调整学习率"></a>动态调整学习率</h3><h4 id="PMSProp-Root-Mean-Square-Prop"><a href="#PMSProp-Root-Mean-Square-Prop" class="headerlink" title="PMSProp/Root Mean Square Prop"></a>PMSProp/Root Mean Square Prop</h4><blockquote>
<p>Adagrad中也提出了动态调整学习率，Use first drivative to estimate second derivative。用固定的learning rate除以这个参数过去所有GD值的平方和开根号。</p>
<script type="math/tex; mode=display">
\omega^{t+1} \larr \omega^{t} - \frac{\eta}{\sqrt{\sum_{i=0}^t(g^i)^2}}g^t</script></blockquote>
<p>Root Mean Square of the gradients with previous gradients being decayed.</p>
<script type="math/tex; mode=display">
\omega^{t+1} \larr \omega^{t} - \frac{\eta}{\sigma^t}g^t \\
\sigma^t = \sqrt{\alpha(\sigma^{t-1})^2+(1-\alpha)(g^t)^2}</script><p>$\alpha$值调的小一点，说明倾向于相信新的gradient指示的error surface的平滑程度/陡峭程度。</p>
<h3 id="local-minima的解决"><a href="#local-minima的解决" class="headerlink" title="local minima的解决"></a>local minima的解决</h3><p>当神经网络很大，参数越多，出现local minima的几率越低。</p>
<p>联系物理中的惯性，每次移动的方向，不仅考虑某一点的gradient，还考虑前一个时间点移动的方向movement of last step，将这两者求矢量和。</p>
<p>对于某一个点$\theta^i$，此处有movement为$v^i$，对该点计算gradient得到$\nabla{L(\theta^i)}$，那么下一次移动的方向movement为$v^{i+1} = \lambda v^i - \eta \nabla{L(\theta^i)} $。如果递推下去，可以有</p>
<script type="math/tex; mode=display">
v^{i+1} = \lambda{v^i} - \eta \nabla{L(\theta^i)}  \\
\begin{split}
v^{i+2} &= \lambda{v^{i+1}} - \eta \nabla{L(\theta^{i+1})} \\ 
&= \lambda{(\lambda{v^i} - \eta \nabla{L(\theta^i)})}- \eta \nabla{L(\theta^{i+1})} \\
&= \lambda^2 v_i -\lambda\eta\nabla{L(\theta_i)} - \eta \nabla{L(\theta^{i+1})} 

\end{split}</script><p>$v^i$ is actually the weighted sum of all the previous gradient.越之前的gradient，对此刻的movement影响越小，越多考虑目前的gradient的影响。</p>
<p>Adam = RMSProp + Momentum</p>
<h2 id="测试集表现不好"><a href="#测试集表现不好" class="headerlink" title="测试集表现不好"></a>测试集表现不好</h2><p>注意这个是在训练集表现良好的基础之上进行的。</p>
<p>此处的测试集是cross validation中从原训练集中抽取出来的validation set。</p>
<h3 id="Early-stopping"><a href="#Early-stopping" class="headerlink" title="Early stopping"></a>Early stopping</h3><p>虽然训练集在loss降低，但测试集上有可能loss降低后又升高了。需要让epoch停留在测试集的最低点。</p>
<h3 id="Regulariazation"><a href="#Regulariazation" class="headerlink" title="Regulariazation"></a>Regulariazation</h3><p>通过给原损失函数添加一个Regularization Term，构成一个新的需要最小化的损失函数。目的是weight decay，closer to zero。</p>
<h4 id="L2-Regularization"><a href="#L2-Regularization" class="headerlink" title="L2 Regularization"></a>L2 Regularization</h4><p>Regularization Term = $\lambda \frac{1}{2}  \left|\theta\right|_2$</p>
<p>$\left|\theta\right|_2 = (\omega_1)^2 + (\omega_2)^2 + \cdots$</p>
<p>对新的损失函数求微分且合并同类项后可以发现，对已有weight$\omega^t$总是乘上总小于1的$(1-\eta\lambda)$，相比于之前的乘以1，目的是让weight更接近0。是基于已有weight的。</p>
<h4 id="L1-Regularization"><a href="#L1-Regularization" class="headerlink" title="L1 Regularization"></a>L1 Regularization</h4><p>Regularization Term = $\lambda \frac{1}{2}  \left|\theta\right|_1$</p>
<p>$\left|\theta\right|_1 = |\omega_1| + |\omega_2| + \cdots$</p>
<p>对新的损失函数求微分后发现不可合并同类项，只是减了一个$\eta\lambda sgn(\omega^t)$，每次减的都是固定值。</p>
<h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><p>训练时，每次在更新参数之前，让每个neuron都有p%的几率dropout，然后使用new thinner network去训练。for each mini-batch, resample the dropout neurons。在加上dropout之后，training set上的测试结果会变差。</p>
<p>测试时，不做dropout，训练时的dropout rate是p%，则测试时所有的weight都乘以(1-p)%。</p>
<hr>
<p>为什么dropout会有用？</p>
<p>Dropout is a kind of ensemble. 就相当于把训练集分成了好多个子集，每个子集都生成一个network。当把testing data都分别放入这些网络的时候，每个网络都会给出一个结果，最终给这些结果去一个平均值。</p>
<h1 id="why-deep"><a href="#why-deep" class="headerlink" title="why deep"></a>why deep</h1><p>深度学习其实就是模组化。</p>
<p>每一层neural可以被看做是一个basic classifier，第一层的neural就是最基分类器；第二层的neural是比较复杂的classifier，把第一层basic classifier 的output当做第二层的input(把第一层的classifier当做module)，第三层把第二层当做module，以此类推。</p>
<p>例子：语音辨识/逻辑电路</p>
<p>similar input — different output / different output — similar output</p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>马尔可夫链</title>
    <url>/2020/11/03/markov-chain/</url>
    <content><![CDATA[<p>State is simply the category.</p>
<p>Markov Chains are a combination of probabilities and matrix calculus. </p>
<p>Markove Chains model a process that proceeds in steps(time, sequence, trials, etc.); like a series of probability trees.</p>
<p>Transition diagram 等价于 Transition Matrix，same information represented in different way。</p>
<p>Transition Matrix的行代表to which state，列代表from which state。每一行的概率相加起来等于1。</p>
<p>对于一个特定的initial state vector，在经过许多次state的转移后，转移结果会和initial state vector一样</p>
<script type="math/tex; mode=display">
vP=v</script><p>如果已知Transition Matrix，可以计算出steady state vectors，使用单位矩阵计算。</p>
<script type="math/tex; mode=display">
v(P-I)=0</script>]]></content>
      <categories>
        <category>Statistics</category>
      </categories>
      <tags>
        <tag>MarkoveCahin</tag>
      </tags>
  </entry>
  <entry>
    <title>图像识别与卷积神经网络</title>
    <url>/2020/11/04/cnn-intro/</url>
    <content><![CDATA[<h1 id="图像识别的特征"><a href="#图像识别的特征" class="headerlink" title="图像识别的特征"></a>图像识别的特征</h1><p>Property1： 图像的pattern模式是远小于整张图片的，因此生成一个pattern只需要注意图像的一小部分；</p>
<p>Property2：一张图片中不同的区域可能存在相同的pattern；</p>
<p>因此可以使用Convolution卷积。</p>
<hr>
<p>Property3：对图片采样过后不会改变图像所要表达的东西，因此可以对图像做subsampling减小大小；</p>
<p>因此可以使用Max Pooling。</p>
<hr>
<p>根据以上三个特性设计出的CNN架构：</p>
<p>(Convolution — Max Pooling) X N times — Faltten — fully connected feedforward network</p>
<p>卷积层(nn.Conv2d卷积层 — nn.BatchNorm2d归一化 — nn.ReLU激活层 — nn.MaxPool2d最大池化层)，可叠加很多层，作用是提取出特征。</p>
<p>全链接层(nn.Linear — nn.ReLU — nn.Linear)，作用时对提取出的特征进行分类。</p>
<p>AlphaGo能够使用CNN是因为它和图像有相似的特性。</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="图片的表示方式"><a href="#图片的表示方式" class="headerlink" title="图片的表示方式"></a>图片的表示方式</h2><p>对于黑白图片，每一个pixel就只有0，1两个取值，是一个二维矩阵。</p>
<p>对于彩色图片，用RGB表示，每个pixel用0～255范围内的三个值表示，是三个二维矩阵。</p>
<h2 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h2><p>依据Property1，为了生成一个pattern，需要使用filter。filter也是一个矩阵，维度需要自己选择。一个filter对应到图片中的某一个子矩阵做内积（对应元素相乘后整体再相加），然后向右移动stride=n个单位元素，从左至右从上至下一次移动。</p>
<blockquote>
<p>filter移动的方向，要有具体意义。</p>
<p>比如在文本识别中使用CNN，每一个单词都有一个vector，filter移动的方向一定是多个完整单词的vector的组合的方向，把一个vector拆分多次移动是没有具体语义的。</p>
</blockquote>
<p>当一个filter对一张图片完成一次移动之后，会生成一个新的矩阵。当新的矩阵中有相同的元素时，就代表有相同的pattern在这张图中，对应到Property2。</p>
<p>以上过程对每一个滤波器都来一边就得到了对这张图像的Feature Map。</p>
<h3 id="全链接网络和卷积的关系"><a href="#全链接网络和卷积的关系" class="headerlink" title="全链接网络和卷积的关系"></a>全链接网络和卷积的关系</h3><p>卷积就是内积之和，相当于两个向量做inner product。</p>
<p>全链接网络中给每个input一个weight然后把它们相加添一个bias得到输出，这个形式和卷积相似。可以把图像的二维矩阵转换成一维向量，按照index/row方向拼接成一个向量。</p>
<p>对应起来就是，filter的作用对象就是这个向量中的某些分量，filter就是全链接网络每一个neuron的weight，内积之后的结果就是该neuron的输出。</p>
<p>重要的是对于每一个filter，他们的weight都是相同的，通过实现shared weights可以实现神经网络较少的参数。</p>
<h2 id="Max-Pooling"><a href="#Max-Pooling" class="headerlink" title="Max Pooling"></a>Max Pooling</h2><p>Feature Map中是每一个filter作用于原图像后得到的Matrix。把该Matrix中的数据均分成几组，每组内进行基础的数学运算（如取平均，取最大），每组的多个数据变成一个数据。目的是为了让图像缩小。</p>
<h2 id="Flatten"><a href="#Flatten" class="headerlink" title="Flatten"></a>Flatten</h2><p>flatten就是把Feature Map中多层Matrix拉直成一个vector，每个matrix从左至右从上至下拉直成一个vector，多个matrix前后拼接在一起。</p>
<p>作为输入连接到全连接网络中去。</p>
<h2 id="如何训练"><a href="#如何训练" class="headerlink" title="如何训练"></a>如何训练</h2><h3 id="for-each-filter"><a href="#for-each-filter" class="headerlink" title="for each filter"></a>for each filter</h3><p>定义degree of the activation of the k-th filter为</p>
<script type="math/tex; mode=display">
a^k = \sum_{i=1}^{n}\sum_{j=1}^n a_{ij}^k</script><p>意思是把图像通过该滤波器之后得到matrix的所有元素的和当作这个滤波器对这张图片响应的大小。</p>
<p>想知道第k个filter的作用是什么，就需要照一张图片作为输入，能够让第k个filter被激活的程度最大。也就是找最大值的问题，可以用gradient descent来求。和之前不知道weight，需要依据输入用梯度下降把参数weightupdate出来不同，现在是把输入的图像当作需要找的参数用gradient descent做update，因为作为weight的filter的是已经固定的。</p>
<p>因此对于每个filter，都可以训练出一个能让该filter的degree of the activation最大化的pattern。注意结果不是一个完整的图片，而可能是某一种纹理，重复出现的pattern。</p>
<h3 id="for-fully-connected-NN"><a href="#for-fully-connected-NN" class="headerlink" title="for fully connected NN"></a>for fully connected NN</h3><p>在全连接层的每一个neuron的作用是什么呢？</p>
<p>当找一个图像作为input输入，每一个neuron对这张图片都有不同的输出$a_i$，我们需要找出能够让该neuron输出最大结果的input图像。注意此处的input图像已经开始处理整张图了，而不是图的一小部分。</p>
<p>当找一个图像作为input输入，最终的输出$y_i$要被最大化，确定能够让该output layer输出最大结果的input图像。但是输出的结果可能和人类辨识图像的方式不同；所以需要添加一些constraint（例如L1 Regularization），让输出更容易被人类理解。</p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>半监督学习</title>
    <url>/2020/11/05/semi-supervised-learning/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>半监督学习就是除了有input和label一一对应的数据之外，还有一笔数据只有input没有label。</p>
<p>虽然unlabeled data没有对应的output，但是unlabeled data的分布可以告诉我们一些事，从而影响我们的决定。因而在使用半监督学习的时候往往需要有一些分布假设。</p>
<p>分类有两个：</p>
<ul>
<li><p>transductive learning(unlabled data is the testing data)</p>
</li>
<li><p>inductive learning(unlabeled data is not the testing data )</p>
</li>
</ul>
<h1 id="半监督生成模型"><a href="#半监督生成模型" class="headerlink" title="半监督生成模型"></a>半监督生成模型</h1><p>监督生成模型在「概率分类与Logistic回归」中有详细说明。首先是先验部分，通过训练集的数据做每个类服从高斯分布的假设，获得每个类的期望和方差。其次是后验部分，通过给的一个新的input data做分类，决定decision boundary在哪里。</p>
<p>在半监督生成模型中，unlabeled data能对estimate parameters的结果有影响，对于每个类的期望和方差有影响，从而影响decision boundary。</p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="Initialize-estimators"><a href="#Initialize-estimators" class="headerlink" title="Initialize estimators"></a>Initialize estimators</h3><p>given initial estimators$\theta = \left\{ P(C_1), P(C_2), \mu^1, \mu^2, \sum\right\}$</p>
<p>这组初始化参数是通过已有的labeled data估测出来的。</p>
<h3 id="E-Step-Compute-the-posterior-probability-of-unlabeled-data-P-theta-C-1-x-u"><a href="#E-Step-Compute-the-posterior-probability-of-unlabeled-data-P-theta-C-1-x-u" class="headerlink" title="E-Step/Compute the posterior probability of unlabeled data$P_{\theta}(C_1|x^u)$"></a>E-Step/Compute the posterior probability of unlabeled data$P_{\theta}(C_1|x^u)$</h3><p>这个几率算出来是怎么样的取决于modell$\theta$值，是基于步骤一中的modell$\theta$算出来的后验概率。</p>
<p>感觉这个过程就像在测试model$\theta$，给它一个input，看他的output。与testing data的不同在于，这个output不是用来衡量学习的优劣的，而是作为一笔数据更新model$\theta$的参数。</p>
<h3 id="M-Step-Update-model"><a href="#M-Step-Update-model" class="headerlink" title="M-Step/Update model"></a>M-Step/Update model</h3><p>依据步骤二算出来的unlabeled data属于model$\theta$下的Class 1的概率，更新模型参数。</p>
<hr>
<p>如何更新$P(C_1)$</p>
<script type="math/tex; mode=display">
P(C_1) = \frac{N_1+ \sum_{x^u}{P(C_1|x^u)}}{N}</script><p>分子中$N_1$代表labeled data中属于Class 1的个数，分母中$N$就是所有labeled data的个数。</p>
<p>如果不考虑unlabeled data，结果就是这两个数据的分式子。</p>
<p>如果考虑unlabeled data，需要把所有unlabeled data中属于Class 1的后验概率的和考虑进去。</p>
<hr>
<p>如何更新$\mu^1$</p>
<p>原本不考虑unlabeled data的时候，Class1的期望就是把所有属于Class 1的input做平均。加上unlabeled data之后就是把每一笔unlabeled data的数据和他的相对应的概率想成之后再除以总的概率和。</p>
<script type="math/tex; mode=display">
\mu^1 = \frac{\sum_{x^r\in C_1}x^r}{N_1} + \frac{1}{\sum_{x^u}P(C_1|x^u)} \sum_{x^u}{P(C_1|x^u)}x^u</script><hr>
<p>E-M算法：更新完所有的参数之后又返回步骤二，一直循环到步骤三结束，最终是收敛的结果。</p>
<h1 id="假设一：Low-density-Seperation"><a href="#假设一：Low-density-Seperation" class="headerlink" title="假设一：Low-density Seperation"></a>假设一：Low-density Seperation</h1><p>表示“非黑即白”，在类间交界处，数据的密度较低，可以勾画一个十分明显的界限。</p>
<h2 id="Self-training"><a href="#Self-training" class="headerlink" title="Self-training"></a>Self-training</h2><p>self-training是最简单的一种实现low-density seperation的方式。</p>
<h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>有unlabeled data set和labeled data set。从labeled data set中训练出一个model，然后将这个model应用到unlabeled data set上获得预测出的pseudo-label。然后从unlabeled data set中移除（how to choose data？）一部分数据并添加到labeled data set中，更新模型。</p>
<p>需要注意调整概率阈值threshold，或是多次取样来获得比较可信的数据。例如设置pos_threshold = 0.8，只有 prediction &gt; 0.8 的 data 会被标上1。</p>
<h3 id="类比GenerativeModel"><a href="#类比GenerativeModel" class="headerlink" title="类比GenerativeModel"></a>类比GenerativeModel</h3><p>可以看出来过程和半监督生成模型类似。主要区别在于对unlabeled data set的output处理。</p>
<p>self-training使用hard label，即unlabeled data就一定会属于某一个class；generative model使用soft label，即unlabeled data有多大概率属于Class 1，有多大概率属于Class 2。</p>
<p>显然，生成模型和Self-traning所要求的“Low-density Seperation”/非黑即白相矛盾，因而生成模型不会在neuron network起作用。</p>
<h2 id="Entropy-based-Regularization"><a href="#Entropy-based-Regularization" class="headerlink" title="Entropy-based Regularization"></a>Entropy-based Regularization</h2><p>既然需要unlabeled data能够促进“非黑即白”，联系信息熵，就要求这个unlabeled data通过这个model之后的输出output信息熵越小越好。</p>
<p>对unlabeled data output求信息熵</p>
<script type="math/tex; mode=display">
E(y^u) = -\sum_{m=1}^{N^u}y_m^u\ln{y_m^u}</script><p>可以重新定义model的Loss Function为</p>
<script type="math/tex; mode=display">
L = \sum_{x^r}{C(y^r, \hat{y}^r)} + \lambda E(y^u)\\</script><p>第一个式子是在用交叉熵衡量labeled data上model的output和real data output的距离，希望越小越好；第二个式子是在用熵衡量unlabeled data上model的output的混乱度，自然是越小越好。参数$\lambda$带表了你倾向于偏向unlabeled data多一点还是少一点。</p>
<h2 id="Semi-supervised-SVM"><a href="#Semi-supervised-SVM" class="headerlink" title="Semi-supervised SVM"></a>Semi-supervised SVM</h2><p>Support Vector Machines穷举所有的unlabeled data。</p>
<h1 id="假设二：Smoothness-Assumption"><a href="#假设二：Smoothness-Assumption" class="headerlink" title="假设二：Smoothness Assumption"></a>假设二：Smoothness Assumption</h1><p>similar x has the same y hat.</p>
<p>因为x的分布不是平均的，它在某些地方十分集中，某些地方又十分分散，如果x1和x2在a high density region中十分相近，那么他们的输出label可以很相近。（x1和x2可以看作相近相似的中间状态，不相似的data可以看作是跳跃状态？）</p>
<h2 id="Cluster-and-then-label"><a href="#Cluster-and-then-label" class="headerlink" title="Cluster and then label"></a>Cluster and then label</h2><p>Cluster and then label是最简单的实现Smoothness assumption的方法，但是要求聚类很强。一般都是用一个很好的方法来描述image，提取特征后再进行聚类。</p>
<h2 id="Graph-based-Approach"><a href="#Graph-based-Approach" class="headerlink" title="Graph-based Approach"></a>Graph-based Approach</h2><p>用high density path连接起来的一个区域就是a high density region，相当于在结点之间画边。</p>
<h3 id="画边方式与相似度"><a href="#画边方式与相似度" class="headerlink" title="画边方式与相似度"></a>画边方式与相似度</h3><p>有两种方式：</p>
<ul>
<li><p>K nearest Neighbour</p>
</li>
<li><p><em>e</em>-neighbour</p>
</li>
</ul>
<p>同样考虑到图论中边和边权。可以给相连的边一些权重，让edge和他两端的points的相似度是成正比的。定义相似度选择Gussian Radial Basis Function:</p>
<script type="math/tex; mode=display">
s(x^i, x^j) = exp(-\gamma||x^i-x^j||^2)</script><p>算出两个point的距离之后乘以一个参数取负号在exponential。</p>
<h3 id="定量描述the-smoothness-of-the-labels-on-the-graph"><a href="#定量描述the-smoothness-of-the-labels-on-the-graph" class="headerlink" title="定量描述the smoothness of the labels on the graph"></a>定量描述the smoothness of the labels on the graph</h3><script type="math/tex; mode=display">
S = \frac{1}{2}\sum_{i,j}{\omega_{i,j}(y^i-y^j)^2} = \boldsymbol{y}^TL\boldsymbol{y}</script><p>第一个表达式中，$\frac{1}{2}$是为了后续做微分方便而添加的；$\omega_{i,j}$是两个data point之间的权重，即边权；$y^i-y^j$就是两个data point之间的距离。注意这个式子是对连成图之后的所有data point而言的。这个式子越小代表越光滑。</p>
<p>第二个表达式中，$\boldsymbol{y}$是一个(R+U)维度的向量，$\boldsymbol{L}$是一个(R+U)x(R+U)的矩阵，叫做Graph Matrix。</p>
<script type="math/tex; mode=display">
\boldsymbol{y} = [\cdots y^i \cdots y^j \cdots]^T \\
\boldsymbol{L} = \boldsymbol{D} - \boldsymbol{W}</script><p>其中$\boldsymbol{W}$代表图的邻接矩阵，$\boldsymbol{D}$是邻接矩阵每一行的和放在对角线上。</p>
<h3 id="由smoothness到loss-function"><a href="#由smoothness到loss-function" class="headerlink" title="由smoothness到loss function"></a>由smoothness到loss function</h3><p>在原来的loss function中，有labelled data训练之后的cross entropy，此外添加带$\lambda$的smoothness of the labels on the graph项。因为平滑度是取决于nueron network的，而要找的nueron network就是一组参数。</p>
<p>其实smoothness of the labels on the graph项不一定要放在output layer，可以放在某些hidden layer中。</p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>半监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>无监督学习</title>
    <url>/2020/11/06/unsupervised-learning/</url>
    <content><![CDATA[<h1 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h1><p>聚类的几种常用方法：K-means，Hierarchical Agglomerative Clustering(HAC)。</p>
<p>K-means需要事先决定有K个cluster，每个cluster初始的center也要从training data中随机找k个出来。</p>
<p>Hierarchical Agglomerative Clustering(HAC)就是建树，对每个data两两计算相似度，挑出最相似的一对data，merge成一个新的data vector。一直从下至上构建出root。要分类就是在每一层切一刀获得一种聚类方式。</p>
<h1 id="Dimension-Reduction降维"><a href="#Dimension-Reduction降维" class="headerlink" title="Dimension Reduction降维"></a>Dimension Reduction降维</h1><p>降维的本质就是需要找一个function，当我们input一个vector x的时候，output是另外一个vector z，且output dimension小于input dimension。</p>
<h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><p>把data的分布拿出来看一下，发现都集中在某个特定的dimension，那么就拿掉其他dimension就可以。但问题是很多时候任何一个dimension都不能拿掉。</p>
<h2 id="Principal-Component-Analysis-主成分分析"><a href="#Principal-Component-Analysis-主成分分析" class="headerlink" title="Principal Component Analysis 主成分分析"></a>Principal Component Analysis 主成分分析</h2><h3 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h3><p>$\boldsymbol{z} = \boldsymbol{W}\boldsymbol{x}$需要reduce to 1-D，就是要矩阵中的每一行的data points $x^i$投影到$w^1$，然后就可以得到对应的$z_1$，不同的 $x^i$投影过后都是相同的$z_1$。这里的$w^1$就是$\boldsymbol{W}$的第一行。</p>
<p>该如和确定这个$w^1$？我们希望投影后所有点之间的奇异度越高越好，对应到数学上就是$z_1$的方差越大越好。</p>
<script type="math/tex; mode=display">
Var(z_1) = \sum_{z_1}(z_1-\bar{z}_1)^2 \quad \left\|w^1\right\|_2=1</script><h3 id="高维"><a href="#高维" class="headerlink" title="高维"></a>高维</h3><p>现在想要投影到一个二位平面，除了把矩阵中的每一行的data points $x^i$投影到$w^1$，还要把矩阵中的每一行的data points $x^i$投影到$w^2$，这里的$w^1, w^2$是$\boldsymbol{W}$的第一行和第二行。</p>
<p>除了基向量的模为1的约束条件，还需要基向量之间是垂直的，代表基向量之间正交。因而可以说$\boldsymbol{W}$是一个正交矩阵orthogonal matrix。</p>
<h3 id="如何寻找正交基"><a href="#如何寻找正交基" class="headerlink" title="如何寻找正交基"></a>如何寻找正交基</h3><h4 id="w-1-的寻找"><a href="#w-1-的寻找" class="headerlink" title="$w^1$的寻找"></a>$w^1$的寻找</h4><script type="math/tex; mode=display">
\begin{split}
Var(z_1) &= \frac{1}{N}\sum_{z_1}(z_1-\bar{z}_1)^2 \\
&= \frac{1}{N}\sum_{x}(w^1\cdot x-w^1\cdot\bar{x})^2 \\
&= \frac{1}{N}\sum_{x}(w^1\cdot(x-\bar{x}))^2
\end{split}</script><p>向量内积可以和矩阵乘法转换（第一个等式），scalar做Transpose之后仍然是一个scalar（最后一个等式），获得如下式子：</p>
<script type="math/tex; mode=display">
(a\cdot b)^2 = (a^Tb)^2 = a^Tba^Tb=a^Tb(a^Tb)^T=a^Tbb^Ta</script><p>带入原方程得到</p>
<script type="math/tex; mode=display">
\begin{split}
Var(z_1) &= \frac{1}{N}\sum_{x}(w^1\cdot(x-\bar{x}))^2\\
&= \frac{1}{N}\sum_{x} (w^1)^T(x-\bar{x})(x-\bar{x})^Tw^1 \\
&= (w^1)^T \frac{1}{N}\sum_{x}(x-\bar{x})(x-\bar{x})^T w^1 \\
&= (w^1)^T Cov(x) w^1 \quad S = Cov(x)
\end{split}</script><p>也就是说我们需要找的$w^1$就是能够让$Var(z_1)$最大，且满足约束条件$\left|w^1\right|_2=(w^1)^Tw^1=1$的向量。约束条件是为了保证解出来的vector存在有限个。</p>
<p>运用Lagrange Multiplier拉格朗日数乘法</p>
<script type="math/tex; mode=display">
g(w^1) = (w^1)^T S w^1 - \alpha((w^1)^Tw^1-1)</script><p>对这个式子求偏导数$\partial(w^1)$，得到</p>
<script type="math/tex; mode=display">
Sw^1 = \alpha w^1 \\
(w^1)^TSw^1 = \alpha (w^1)^Tw^1 = \alpha</script><p>意思就是$w^1$是协方差矩阵$S$的特征向量，且它是对应到最大的特征值的那个特征向量。</p>
<h4 id="w-2-的寻找"><a href="#w-2-的寻找" class="headerlink" title="$w^2$的寻找"></a>$w^2$的寻找</h4><p>有两个约束条件，因而拉格朗日数乘法的对象如下</p>
<script type="math/tex; mode=display">
g(w^2) = (w^2)^T S w^2 - \alpha((w^2)^Tw^2-1) - \beta((w^2)^Tw^1-0)</script><p>对这个式子求偏导数$\partial(w^2)$，再同时乘以$(w^1)^T$，得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
S w^2 - \alpha w^2 - \beta w^1 = 0 \\
(w^1)^T  S w^2 -  (w^1)^T  \alpha w^2 - (w^1)^T \beta w^1 = 0 \\
((w^1)^T  S w^2)^T -\alpha \cdot 0 - \beta  \cdot 1 = 0 \\
\beta = ((w^1)^T  S w^2)^T = (w^2)^TSw^1= (w^2)^T \lambda_1 w^1 = 0
\end{aligned}</script><p>上面的推导表明$\beta=0$，那么最初的式子就可以写成</p>
<script type="math/tex; mode=display">
Sw^2=\alpha w^2</script><p>意思就是$w^2$是协方差矩阵$S$的第二大的特征向量，且它是对应到最第二大的特征值的那个特征向量。</p>
<h3 id="投影后数据的特征"><a href="#投影后数据的特征" class="headerlink" title="投影后数据的特征"></a>投影后数据的特征</h3><p>投影和的数据在新的坐标的各个维度之间是不相关的，在数学上的表示就是投影后的$\boldsymbol{z} = \boldsymbol{W}\boldsymbol{x}$的协方差矩阵是一个对角矩阵diagonal matrix。好处是实现模型的时候可以减少参数。</p>
<h3 id="从另一个角度理解PCA"><a href="#从另一个角度理解PCA" class="headerlink" title="从另一个角度理解PCA"></a>从另一个角度理解PCA</h3><p>一个输入input可以看作是有限个component的线性叠加加上所有input的平均值。</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
x = \bar{x} + \hat{x} \\
\hat{x} = c_1u^1+c_2u^2+ \cdots+c_Ku^K
\end{array}</script><p>Reconstruction error: $\left|(x-\bar{x}) - \hat{x}\right|_2$</p>
<p>Find $\{u^1, u^2 \cdots, u^k\}$ minimizing the error</p>
<script type="math/tex; mode=display">
L = min_{\{u^1, u^2 \cdots, u^k\}}\sum\left\|(x-\bar{x}) -(\sum_{k=1}^K{c_ku^k})\right\|_2</script><p>这里要找的$u^k$就是对应前面PCA中的$W$。但是这两者有有不同，因为前面PCA要求必须垂直（线性情况较快），但此处用gradient descent求解出来的对象不一定保证垂直（但是可以deep）。</p>
<p>PCA looks like a neuron network with one hidden layer(linear activation function).</p>
<p>PCA involves adding up and substracting some components, and then the componets may not be part of the input. 也就说是用PCA解得得结果不一定是直观上我们可以理解的东西，为了让eigen vector直观化，需要使用Non-negative matrix factorization（NMF），要么让线性叠加的系数为正，要们让线性叠加的子部component为正。</p>
<h3 id="弱点"><a href="#弱点" class="headerlink" title="弱点"></a>弱点</h3><p>有可能把两个class都放到一个vector上去。需要用到Linear Discriminant Analysis。</p>
<p>只适用于线性。</p>
<h1 id="矩阵分解-Matrix-Factorization"><a href="#矩阵分解-Matrix-Factorization" class="headerlink" title="矩阵分解 Matrix Factorization"></a>矩阵分解 Matrix Factorization</h1><p>推荐系统中，通常我们只会得到一个作为评分结果的矩阵MXN，这个矩阵是两个矩阵（用户-特性矩阵和特性-物品矩阵）通过某些factor作用的结果。如果这个MXN的矩阵中有缺省内容，如何通过已有信息预测空缺项？</p>
<p>用户维度为M，物品维度为N，特性维度就是latent factor的数目假设为是K。我们希望找到MXK，和KXN的矩阵，让他们相乘之后的结果与评分矩阵MXN最接近，需要minimize error。</p>
<p>对于损失函数的定义如下：Minimizing</p>
<script type="math/tex; mode=display">
L = \sum_{(i,j)}{(r^i\cdot r^j-n_{ij})^2}</script><p>Only considering the defined value and find $r^i, r^j$by gradient descent.</p>
<p>当然也可以在loss function中添加偏置项，更多其他与i有关的scale和与j有关的scale。</p>
<h1 id="Word-embedding词嵌入"><a href="#Word-embedding词嵌入" class="headerlink" title="Word-embedding词嵌入"></a>Word-embedding词嵌入</h1><p>为什么需要词嵌入？</p>
<p>传统的表示一个文字的方法就是1-of-N encoding，每一个word用一个vector来表示，这个vector的dimension就是这个世界上可能有的word的数目，很显然这过于大了。但是词汇之间是有联系的，可以组成word class，因此可以把同样性质但是不同的word用所属的class来表示。</p>
<p>词嵌入就是把每一个词都project到high dimension space上去，在这个高维空间中每一个word embedding都有一个feature vector。</p>
<p>如何找到适合该词的词嵌入？了解一个词汇的含义需要看该词的contex。</p>
<h2 id="count-based"><a href="#count-based" class="headerlink" title="count-based"></a>count-based</h2><p>基于计数的词嵌入原则是单词$w_i$的word vector是$V(w_i)$，单词$w_j$的word vector是$V(w_j)$，计算出这两个word vector的inner product后我们希望该值和两个词在该文章中同时出现的次数越近越好。其实这个思想和matrix factorization类似。</p>
<h2 id="prediction-based"><a href="#prediction-based" class="headerlink" title="prediction-based"></a>prediction-based</h2><h3 id="预测结构"><a href="#预测结构" class="headerlink" title="预测结构"></a>预测结构</h3><p>最朴素的就是拿前一个词汇去预测后一个词汇，也可以用前后词汇预测中间词汇，也可以用中间词汇预测前后词汇。</p>
<h3 id="输入输出定义"><a href="#输入输出定义" class="headerlink" title="输入输出定义"></a>输入输出定义</h3><p>希望同class的多个先后连续的词作输入的时候，输出是预测的下一个词汇。为了实现这个效果，中间hidden layer需要通过weight对输入进行转化，让他们对应到相同的空间</p>
<p>input是1-of-N encoding of the word $w_{i-2}, w_{i-1}$（需要把这两个列向量接在一起变成一个很长的vector放到neuron network中去，有点像CNN中的Flatten）。</p>
<p>output是the probability for each word as the next word $w_i$。</p>
<p>需要注意的是，两个vector对应的维度上对应到neuron network中的同一个neuron的weight是一样的（sharing parameters）。</p>
<h3 id="如何训练"><a href="#如何训练" class="headerlink" title="如何训练"></a>如何训练</h3><p>为了让$weight_{z_1}^{i-2}(1)$和$weight_{z_2}^{i-1}(1)$最终迭代结果相同，一开始就需要赋予相同的初始值，且在更新参数的时候，二者的更新表达式相同，除了Cross Entropy对自己的微分，还要算上Cross Entropy对另外一个权重的微分。</p>
<h3 id="多语言与多领域"><a href="#多语言与多领域" class="headerlink" title="多语言与多领域"></a>多语言与多领域</h3><p>需要事先知道某几对英文单词和中文单词的对应关系，把这个当作输入放到model中去learn，这个训练好的model的功能就是如何把未知的新的中文和英文对应的词汇放到一起，并投射到空间上的同一个点。</p>
<p>同样的英文和中文单词的对应可以转换成单词和图像的对应关系。</p>
<h1 id="Neighbour-Embedding"><a href="#Neighbour-Embedding" class="headerlink" title="Neighbour Embedding"></a>Neighbour Embedding</h1><p>data point可能是在高维空间中的一个manifold，实际上这笔数据完全可以放到低维空间来描述。高维空间中的问题在于如何描述两个数据的距离/相似度，用欧氏距离没有意义。</p>
<p>因而需要manifold learning把高维空间里的数据摊平到低维空间（属于非线性降维），再计算点和点之间的欧氏距离，结合后续的监督学习。</p>
<h2 id="LLE-局部线性嵌入-Locally-Linear-Embedding"><a href="#LLE-局部线性嵌入-Locally-Linear-Embedding" class="headerlink" title="LLE 局部线性嵌入 Locally Linear Embedding"></a>LLE 局部线性嵌入 Locally Linear Embedding</h2><p>原来的空间里面的点之间的关系用weight来表示，<strong>假设某一个点可以通过它的邻居的线性组合而成</strong>，因此我们需要让线性组合后的结果和原点的距离越近越好，也就是最小化所有的点的距离之和。总结：已知高维空间中的数据，求出数据之间的关系weight。</p>
<p><strong>假设从高维空间到低维空间，描述空间里点之间关系的weight是不变的，</strong>因此可以用上面求出来的weight用同样的方式定义一个相似的函数。总结：已知的是数据间的关系weight，求的是低维空间中的数据。</p>
<h2 id="LE-拉普拉斯特征映射-Laplacian-Eigenmap"><a href="#LE-拉普拉斯特征映射-Laplacian-Eigenmap" class="headerlink" title="LE 拉普拉斯特征映射 Laplacian Eigenmap"></a>LE 拉普拉斯特征映射 Laplacian Eigenmap</h2><p>在semi-supervised learning中提出过graph-based approach以及定量描述smoothness相类似，最重要的区别在于有带label的数据项去约束smoothness的表达式。</p>
<p>我们希望close in high density region中的数据投射到低维空间之后数据还是很相近，但是要对投射后的结果加一点constraint，如果一开始的维度是M，那么找出来的那些在低维空间的点做span之后还会恢复成原来数据的M维度（可逆？）。</p>
<h2 id="T-SNE"><a href="#T-SNE" class="headerlink" title="T-SNE"></a>T-SNE</h2><p>T分布随机领域 T-distributed stochastic neighbour embedding</p>
<h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>以上都假设相近的点非线性降维之后都相近，但是却没有说不相近的点非线性降维之后都不相近（有可能不相近的点线性降维之后反而相近了）。</p>
<p>之前都是针对某一个数据locally的相近，如果从整体上看呢？我们要求投影前后的数据的分布distribution相近。</p>
<h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>如何计算？</p>
<p>分别计算出所有投影前数据x之间的similarity（已知），并写出投影后数据z之间的similarity（未知），让这两个值之间的KL distance越小越好，从而可以求出未知的投影后的数据z。</p>
<p>如何定义和选择similarity？</p>
<p>分投影前数据的similarity和投影后数据的similarity考虑。</p>
<p>投影前数据的similarity用负的欧氏距离去exponent，因为距离一大，similarity就会非常小，确保了只有非常相近的点才有值。</p>
<p>投影后数据的similarity有两种方式。可以选择和投影前数据相同的衡量方式，这样总的方法就是SNE；但更好的是选择T-dirtribution中的一种用欧氏距离加上一，整体取个倒数作为similarity，这样总的方法就是T-SNE。</p>
<h1 id="自编码器-auto-encoder"><a href="#自编码器-auto-encoder" class="headerlink" title="自编码器 auto encoder"></a>自编码器 auto encoder</h1><p>想找一个编码器，input是一个比较复杂的东西，encoder就是一个neuron network，它的output就是code，维度远比输入要小实现了类似压缩的效果。</p>
<p>结构如下：input layer — layer1 — layer2 — … bottle… — layer2’  — layer1’  — output layer</p>
<p>input layer到bottle是属于encoder，bottle到output layer属于decoder，bottle的结果就是code。也就是dimension reduction的过程和reconstruct的过程。</p>
<h2 id="TIPS-on-auto-encoder"><a href="#TIPS-on-auto-encoder" class="headerlink" title="TIPS on auto-encoder"></a>TIPS on auto-encoder</h2><h3 id="Add-Noise"><a href="#Add-Noise" class="headerlink" title="Add Noise"></a>Add Noise</h3><p>de-noising auto-encoder，input加上noise之后再去encode，output要和加noise之前的原来的input越近越好。Neuron Network不仅学到了encode这件事，还学到了过滤噪音。</p>
<h3 id="Pre-training"><a href="#Pre-training" class="headerlink" title="Pre-training"></a>Pre-training</h3><p>一般用于参数的initialization，pre-training就能让你找到一组好的初始化参数。</p>
<p>注意一般做auto-encoder的时候，希望coder的dimension要比input dimension小，如果coder的dimensionbiinput dimension大的话，需要加一个很强的regularization，避免auto-encoder直接把input并起来再输出（也就是learn不起来）。每一个步骤得到的weight都fix住，然后再输出结果之后再backpropagation微调fine-tune一下这些weight。</p>
<p>适合于大量unlabeled data存在，少量labeled data的情况。大量unlabeled data用于得出最初的weight，少量labeled data用于fine-tune。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="文本检索-Text-Retrieval"><a href="#文本检索-Text-Retrieval" class="headerlink" title="文本检索 Text Retrieval"></a>文本检索 Text Retrieval</h3><p>把一篇文章压缩成一个code，利用降维将它表示成空间中的一个vector，现在有一个词汇用于查询，把查询的词汇也变成空间中的一个点，计算该查询次和每个document之间的内积，越大的内积代表相似程度最高。</p>
<p>如何把一个document表示成一个vector？</p>
<p>可以使用bag-of-word，vector的size就是所有lexical单词的个数，可以乘上weight代表每个单词的重要性。缺点在于缺失语义，词汇之间没有相关性。</p>
<p>可以使用auto-encoder使语义考虑进来。</p>
<h3 id="类似图像搜索-Similar-Image-Search"><a href="#类似图像搜索-Similar-Image-Search" class="headerlink" title="类似图像搜索 Similar Image Search"></a>类似图像搜索 Similar Image Search</h3><p>如果单纯比较query image和database中image的pixel的相似度的话，结果会很不好。</p>
<p>需要用一个auto-encoder把image变革一个code，再在code上面去搜寻。</p>
<h3 id="CNN-auto-encoder"><a href="#CNN-auto-encoder" class="headerlink" title="CNN auto-encoder"></a>CNN auto-encoder</h3><p>unpooling无池化，记录pooling的位置，把pooling后的值放在这个记录的位置上，其他都放0。或者也不用记录pooling位置，直接全部复制。</p>
<p>deconvolution反卷积，本质也是convolution，只不过weight相反。</p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>无监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度生成模型</title>
    <url>/2020/11/07/generative-model/</url>
    <content><![CDATA[<h1 id="PixelRNN"><a href="#PixelRNN" class="headerlink" title="PixelRNN"></a>PixelRNN</h1><p>图像由pixel构成，在随机给了初始的pixel之后，当作输入放到model中去，output是什么样的pixel，那么就在初始pixel之后补上该输出，然后目前有的pixel都又当作输入进入model，直到完成绘图。</p>
<p>描述一个pixel可以采用RGB表示，每一个pixel就是三维的vector，但是按照上面的描述我们的input pixel是可变的，他把上一次的输出当作了输入，因而需要用到RNN。</p>
<h1 id="VAE-Variational-Auto-encoder"><a href="#VAE-Variational-Auto-encoder" class="headerlink" title="VAE Variational Auto-encoder"></a>VAE Variational Auto-encoder</h1><p>如果把auto-encoder中的NN decoder单独拿出来，通过随机生成一个向量当作该decoder的input code，看能不能输出图像？但是结果不太好。</p>
<p>此时需要VAE，沿用auto-encoder中encoder和decoder两个部分，但是在中间结果中对encoder的输出/decoder的输入做一些变更，训练的目的就是minimize reconstruction error。</p>
<p><img src="/2020/11/07/generative-model/generativemodel.png" alt="generativemodel" style="zoom:50%;"></p>
<p>做那些变更？通过引入一个normal distribution和$\sigma$方差来增加noise。增加noise的目的是让稍微变化了之后的code进入decoder之后还能够还原变化之前的code，有容错能力。</p>
<p>如何minimize reconstruction error？其实就是通过这个loss function找对应的$\sigma$的值。本质上这些变更还是在train一个NN。</p>
<p>为什么loss function是这样的形式？可以看到当$\sigma$取0的时候，前面两项直接就是0，让error最小，相当于什么也没有学到，所以需要一个L2 regularization term，让结果不会overfitting。</p>
<p>局限在于只能模仿，不能创造。</p>
<hr>
<p>VAE是gaussion mixture model distributed representation的版本。</p>
<p>我们从一个normal distribution（这个normal distribution是一大堆gussian distribution的表示）中sample出一个z，这个z接下来会决定某个特定的gaussion distribution的expectation和variance。</p>
<p>如何决定z？相当于z作为input通过了两个function（也就是通过一个NN训练出来），得到了expectation和variance。通过这个特定的高斯分布，就可以获得最终的x的分布。求x的分布就是条件概率分布求解。</p>
<h1 id="GAN-Generative-Adversarial-Network"><a href="#GAN-Generative-Adversarial-Network" class="headerlink" title="GAN Generative Adversarial Network"></a>GAN Generative Adversarial Network</h1><p>Generator和Discriminator协同更新。</p>
<p>第一代generator不知道real data是什么样的，根据随机的输入生成一大堆不是很好的东西。</p>
<p>第一代discriminator在看过real data后，判断generator的生成物是0或1，0判断为这个是假的是生成的，1判断为这个是real的。</p>
<p>genrator为了骗过discriminator根据generator的评判结果不停地优化参数，discriminatior也不不停地优化。</p>
<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p>randomly sample a vector — NN generator  — image — discriminator — score on the image</p>
<p>以上的流程和一个完整的NN是很类似的，只不过在调整generator的参数的时候要fix住discriminator的参数，且要做到让generator的评判结果越来越靠近1。</p>
<h2 id="Discriminator"><a href="#Discriminator" class="headerlink" title="Discriminator"></a>Discriminator</h2><p>辨别器适用于判断生成器的结果是否是真的。生成器会根据辨别器的判断结果去重新调整自己的参数。</p>
<p>整个流程的生成结果是基于discriminator的，问题在于discriminator如果很弱就没有办法达到预期目的。</p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>无监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>支持向量机</title>
    <url>/2020/11/07/svm/</url>
    <content><![CDATA[<h1 id="Linear-SVM-model"><a href="#Linear-SVM-model" class="headerlink" title="Linear SVM model"></a>Linear SVM model</h1><h2 id="Step1-Function-Model"><a href="#Step1-Function-Model" class="headerlink" title="Step1: Function Model"></a>Step1: Function Model</h2><script type="math/tex; mode=display">
f(x) = \sum_{i}{w_ix_i+b} = \begin{bmatrix}w \\ b\end{bmatrix}\cdot \begin{bmatrix}x \\ 1\end{bmatrix}=w^Tx</script><h2 id="Step2-Loss-Function"><a href="#Step2-Loss-Function" class="headerlink" title="Step2: Loss Function"></a>Step2: Loss Function</h2><script type="math/tex; mode=display">
L(f) = \sum_n{l(f(x^n, \hat{y}^n))+\lambda\left\|w\right\|_2} \\
l(f(x^n, \hat{y}^n)) = max(0, 1-\hat{y}^nf(x))</script><p>Loss function的第一项是一个凸函数，第二项也是个凸函数，因此loss function整体也是凸函数。有不可微分的地方，但是可以用梯度下降做优化器。第一项的定义涉及了loss function，也就是Hinge Loss的方法。</p>
<p>第一项中的$\hat{y}^n$是代表属于哪一个class的label，$f(x)$是预测后的分类结果。</p>
<h2 id="Step3-Gradient-Descent"><a href="#Step3-Gradient-Descent" class="headerlink" title="Step3: Gradient Descent"></a>Step3: Gradient Descent</h2><h3 id="第一种理解"><a href="#第一种理解" class="headerlink" title="第一种理解"></a>第一种理解</h3><p>做微分，先不考虑第二项。</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\frac{\partial{l(f(x^n, \hat{y}^n))}}{\partial w_i} &= \frac{\partial{l(f(x^n, \hat{y}^n))}}{\partial{f(x^n)}}\cdot\frac{\partial{f(x^n)}}{\partial w_i}\\
&=\frac{\partial{l(f(x^n, \hat{y}^n))}}{\partial{f(x^n)}}\cdot x_i^n \\
&= c^n(w) \cdot x_i^n
\end{array}</script><p><img src="/2020/11/07/svm/diff.png" alt="diff" style="zoom:60%;"></p>
<h3 id="第二种理解"><a href="#第二种理解" class="headerlink" title="第二种理解"></a>第二种理解</h3><p>用一个极小项$\varepsilon^n$取代损失函数L中的$l(f(x^n, \hat{y}^n))$，我们叫这个极小项是一个slack variable。</p>
<p><img src="/2020/11/07/svm/lossfunctionequal.png" alt="lossfunctionequal" style="zoom:50%;"></p>
<h1 id="Kernel-Method"><a href="#Kernel-Method" class="headerlink" title="Kernel Method"></a>Kernel Method</h1><h2 id="Dual-Representation"><a href="#Dual-Representation" class="headerlink" title="Dual Representation"></a>Dual Representation</h2><p><img src="/2020/11/07/svm/hingeloss.png" alt="hingeloss" style="zoom:50%;"></p>
<p>如果对于之前求出的迭代更新的式子，把$w$初始化为0，式子变成所有数据的线性组合。</p>
<p>线性参数$\alpha_n^{*}$可能是0，因为结合前面在定义Loss function的时候选择了Hinge Loss。也就是$\sum_nc^{n}(w)$有可能就是取0（在fit很好的情况下），有可能不是0（在fit不好的情况下），到最后模型越fit，线性参数线性参数取0越多，越sparse。</p>
<p>support vectors就是那些线性参数$\alpha_n^{*}$不为0的$x^n$。</p>
<p>这样结合的好处是：不是支持向量的数据点（有可能是outlier），去掉（线性参数$\alpha_n^{*}$是0）也不会有多大影响。如果用了Cross Entropy定义loss function，每一笔data对模型参数的迭代结果都有影响。</p>
<h2 id="Kernel-Trick"><a href="#Kernel-Trick" class="headerlink" title="Kernel Trick"></a>Kernel Trick</h2><h3 id="改写函数集为Kernel-Function"><a href="#改写函数集为Kernel-Function" class="headerlink" title="改写函数集为Kernel Function"></a>改写函数集为Kernel Function</h3><p>重新表示模型参数为$w= \sum_n \alpha_nx^n = X\boldsymbol{\alpha}$</p>
<p><img src="/2020/11/07/svm/modelinput.png" alt="modelinput" style="zoom:50%;"></p>
<p>重新表示模型函数集为</p>
<script type="math/tex; mode=display">
f(x) = w^Tx = \boldsymbol{\alpha}^TX^Tx=\sum_na_n(x^n\cdot x)</script><p><img src="/2020/11/07/svm/modeloutput.png" alt="modeloutput" style="zoom:50%;"></p>
<p><strong>把内积$(x^n\cdot x)$写成核方法$K(x^n,x)$就是核函数，称为核技巧。</strong>写成这样的好处就是，不用具体的知道每一个data的向量表示求出内积，我们只需要知道Kernel Function的输出就可以了。</p>
<p>接下来最小化损失函数，也就是训练目的：找一组$\alpha_n$，是loss function最小。好处是只需要知道input data vector之间的内积。</p>
<blockquote>
<p>什么时候用Kernel Trick？</p>
<p>不止用在SVM中。当我们对data的表示比较困难，或者说需要对input data用好几个hidden layer做feature transform，这时候Kernel trick is useful when we transform all x to $\phi(x)$。</p>
<p>我们需要把feature transform后的多个data vector做inner product，因为做feature transform之后维度变大了，所以运算量很大。</p>
<p>而Kernel Trick告诉我们，你直接算原来的data vector，做inner product再平方就可以了，和上面的过程得出的结果是一样的。</p>
</blockquote>
<p>依据核函数的定义方式有很多变化。</p>
<h4 id="Radial-Basis-Function-Kernel"><a href="#Radial-Basis-Function-Kernel" class="headerlink" title="Radial Basis Function Kernel"></a>Radial Basis Function Kernel</h4><p>在一个无穷多维的空间做inner product。推导涉及exp函数的泰勒展开。</p>
<h4 id="Sigmoid-Kernel"><a href="#Sigmoid-Kernel" class="headerlink" title="Sigmoid Kernel"></a>Sigmoid Kernel</h4><script type="math/tex; mode=display">
K(x,z) = tanh(x \cdot z)\\
f(x) = \sum{\alpha_nK(x^n,x)} = \sum{\alpha_n tanh(x^n \cdot z)}</script><p>每一个函数都可以看作一个Neuron Network。原始数据到第一层neuron的weight就是每一个data point$x^n$，neuron的数目就是support vectors的数目。</p>
<p><img src="/2020/11/07/svm/sigmoidkernel.png" alt="sigmoidkernel" style="zoom:50%;"></p>
<h4 id="更多的启发"><a href="#更多的启发" class="headerlink" title="更多的启发"></a>更多的启发</h4><p>直接设计Kernel Function，不用理会x和z的的feature。Kernel Function有点类似于把x和z放到高维之后的相似度。</p>
<p>核函数做了什么？我们要找的这个Kernel Function，把x和z放进去，会得出一个value，这个value代表了x和z在高维上的inner product。</p>
<p>什么样的data适合核方法？When x is structured object like sequence, hard to design its feature transformation function $\phi(x)$。（没有办法直接用以vector来描述）</p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>transfer-learning</title>
    <url>/2020/11/07/transfer-learning/</url>
    <content><![CDATA[<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>Source Data(Not directly related to the task)</p>
<p>Target Data(directly related to the task)</p>
<p>每种data分为labeled和unlabeled。一共有四种情况。Target data量少才需要迁移学习。</p>
<p>one-shot learning: only a few examples in the target domain.</p>
<h1 id="Labeled-Taregt-Data-Labeled-Source-Data"><a href="#Labeled-Taregt-Data-Labeled-Source-Data" class="headerlink" title="Labeled Taregt Data + Labeled Source Data"></a>Labeled Taregt Data + Labeled Source Data</h1><h2 id="Fine-Tune"><a href="#Fine-Tune" class="headerlink" title="Fine-Tune"></a>Fine-Tune</h2><p>用source data训练一个模型，然后用少量的target data去fine tune这个模型，主要是训练出来的模型侧重于target domain做的是否好。</p>
<p>问题是如果source data很少，本来做出来的模型就很烂根本不能在target domain有很好的表现怎么办？提供以下两个技巧。保守训练和层迁移。</p>
<h3 id="保守训练-Consevative-Training"><a href="#保守训练-Consevative-Training" class="headerlink" title="保守训练 Consevative Training"></a>保守训练 Consevative Training</h3><p>大量的source data训练出一个NN1。</p>
<p>用少量的target data去训练一个NN2。</p>
<p>这两个model需要比较类似，但又要有不同。通过加一些regularization让NN2和NN1在面对相同的data的时候输出的结果不同。</p>
<h3 id="层迁移-Layer-Transfer"><a href="#层迁移-Layer-Transfer" class="headerlink" title="层迁移 Layer Transfer"></a>层迁移 Layer Transfer</h3><p>用source data训练出一个NN1。</p>
<p>把这个训练好的NN1种的几个Layer拿出来copy到新的用target data训练的NN2里面去，在训练NN2的时候只需要训练剩下的没有收到copy Layer的那些参数。</p>
<p>如何选择那些layer被transfer？依据不同的task而定。在语音辨识中需要用到最后几层，因为前几层是在判断发音方式（因人而异），后几层就是从发音方式到判断结果了（统一）。在图像中一般选择前几层，因为前几层是在找出最细节的简单图形或纹理，越到后面越复杂。</p>
<h2 id="Multitask-Learning"><a href="#Multitask-Learning" class="headerlink" title="Multitask Learning"></a>Multitask Learning</h2><p>多任务学习中我们同时要求模型在target domain和source domain中表现良好。</p>
<p>有一种情况是taskA和B之间存在共通性并且可以直接表示出来，model的前面几个layer共享参数，后来衍生出分支。</p>
<p>另外一种情况是taskA和B之间共通的input feature没有办法确定，所以一开始model有多个分支的input，通过最初的几层独立的layer把input转移到同一个domain上去（先抽取feature），获得共通性表示之后中间layer共享参数，最后再重新分流。</p>
<h1 id="Unlabeled-Taregt-Data-Labeled-Source-Data"><a href="#Unlabeled-Taregt-Data-Labeled-Source-Data" class="headerlink" title="Unlabeled Taregt Data + Labeled Source Data"></a>Unlabeled Taregt Data + Labeled Source Data</h1><h2 id="Domain-Adversarial-Training"><a href="#Domain-Adversarial-Training" class="headerlink" title="Domain Adversarial Training"></a>Domain Adversarial Training</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>feature extractor — label predictor + domain classifier</p>
<p>feature extractor的任务是把domain的特性去除掉，为了衡量feature extractor做得好不好，要在feature extractor的后面接一个domain classfier，它需要判断这个feature 来自哪一个domain，到最后训练效果很好的话domain classfier肯定不知道feature来自哪一个domain，也就是说最后它一定fail。</p>
<p>但是只有这样的结构就学不起来，因为只要feature总output0，dimain classfier怎么也分不出来。因此要增加featur extractor的任务难度，在它后面接一个label predictor，意思就是要feature extractor在消除domain特性的同时，尽可能保留原来数据feature的特性。</p>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>在做back propagation的时候在feature extractor和domain classifier之间天一个gradient reversal layer，实现负反馈；feature extractor和label predictor之间就是正常的gradient decscent。</p>
<h2 id="Zero-shot-learning零样本学习"><a href="#Zero-shot-learning零样本学习" class="headerlink" title="Zero-shot learning零样本学习"></a>Zero-shot learning零样本学习</h2><p>database中储存所有不同的可能的class和它的特性。</p>
<p>NN的input是数据，output是该数据的特性。然后根据特性查找database对应到具体的class。</p>
<h3 id="attribute-embedding"><a href="#attribute-embedding" class="headerlink" title="attribute embedding"></a>attribute embedding</h3><p>如果attribute非常复杂，考虑attribute embedding。也就是对input和attribute做降维。</p>
<p>有一个embedding space，每一个original input$x^n$和attribute of original input$y^n$都通过NN投射到同一个点或者相近的点$f(x^n), g(y^n)$上。训练这个模型不应该是最小化$f(x^n), g(y^n)$的距离（因为直接就把所有data都投射到同一个点上去了），应该让目$f(x^n), g(y^n)$的距离比所有$f(x^n), g(y^m)$的距离都近，设定一个defined margin k。</p>
<p>当有一个未知的original input，把它投射到embedding space上去，找和哪一个attribute在embedding space上的投影最接近。</p>
<h3 id="attribute-embedding-word-embedding"><a href="#attribute-embedding-word-embedding" class="headerlink" title="attribute embedding+word embedding"></a>attribute embedding+word embedding</h3><p>适用于没有database的情况。</p>
<h3 id="convex-combination-of-semantic-embedding"><a href="#convex-combination-of-semantic-embedding" class="headerlink" title="convex combination of semantic embedding"></a>convex combination of semantic embedding</h3><p>output不决定是哪一个class，只输出可能的class的概率，把这些概率和class vector做线性相加得到一个新的混合后的vector，再看哪一个人class vector和这个新的vector最接近。</p>
<h1 id="Labeled-Taregt-Data-Unlabeled-Source-Data"><a href="#Labeled-Taregt-Data-Unlabeled-Source-Data" class="headerlink" title="Labeled Taregt Data + Unlabeled Source Data"></a>Labeled Taregt Data + Unlabeled Source Data</h1><p>Self-taught learning</p>
<h1 id="Unlabeled-Taregt-Data-Unlabeled-Source-Data"><a href="#Unlabeled-Taregt-Data-Unlabeled-Source-Data" class="headerlink" title="Unlabeled Taregt Data + Unlabeled Source Data"></a>Unlabeled Taregt Data + Unlabeled Source Data</h1><p>Self-taught clustering</p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>迁移学习</tag>
      </tags>
  </entry>
  <entry>
    <title>MLHW2-tips</title>
    <url>/2020/11/08/MLHW2-tips/</url>
    <content><![CDATA[<h1 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h1><p>原始数据给的是CSV格式，但是经过助教整理，解压缩后是不带后缀名的UNIX可执行文件。</p>
<p>如何确定一个文件的类型？在终端使用<code>file &lt;path&gt;</code>命令就可以获得文件类型。终端显示助教给的文件是ASCII text，是用ASCII编码的纯文本文件，可以用任何文本编辑器打开。</p>
<p>同时打开txt文本编辑器，把文件拖动到其中就可以获得文件路径。</p>
<h1 id="从文件提取数据"><a href="#从文件提取数据" class="headerlink" title="从文件提取数据"></a>从文件提取数据</h1><p>首先保存数据路径，再从用<code>with open(Path-for-XY) as f</code>读取数据。</p>
<p>保存数据路径，可以给定路径，也可以用<code>&#123;&#125;</code>表示不定路径，在使用不定路径的时候一定要format语句<code>with open(output_path.format(&#39;logistic&#39;), &#39;w&#39;) as f:</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_test_fpath = <span class="string">&#x27;./Dataset2/X_test&#x27;</span></span><br><span class="line">output_path = <span class="string">&#x27;./output_&#123;&#125;.scv&#x27;</span></span><br></pre></td></tr></table></figure>
<p>读取数据要对数据的换行符和分隔符做处理，才能把数据放到numpy array中。<code>strip</code>在每一笔数据之间删除换行符；<code>split</code>函数在每一笔数据中删除每一个维度/feature上的分隔符。</p>
<p>在读取数据的时候要注意是否存在head，<code>next(f)</code>就是跳过头部。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(X_train_fpath) <span class="keyword">as</span> f:</span><br><span class="line">    next(f)</span><br><span class="line">    <span class="comment"># 跳过第一行的列说明</span></span><br><span class="line">    X_train = np.array([line.strip(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>:] <span class="keyword">for</span> line <span class="keyword">in</span> f], dtype=float)</span><br><span class="line">    <span class="comment"># strip用于忽略换行之类的，split用于根据标记分离单独的数据</span></span><br></pre></td></tr></table></figure>
<h1 id="训练TIPS"><a href="#训练TIPS" class="headerlink" title="训练TIPS"></a>训练TIPS</h1><h2 id="交叉验证集"><a href="#交叉验证集" class="headerlink" title="交叉验证集"></a>交叉验证集</h2><p>利用矩阵的slice实现验证集和交叉集的分割，从<code>dev_ratio</code>获得<code>train_size</code>。</p>
<p>在完成分割后检查一下X_train/Y_train/X_dev/Y_dev的size和dim，调用shape函数，该函数返回一个list。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_size = X_test.shape[<span class="number">0</span>]</span><br><span class="line">data_dim = X_train.shape[<span class="number">1</span>]</span><br><span class="line">print(<span class="string">&#x27;Size of testing set: &#123;&#125;&#x27;</span>.format(test_size))</span><br><span class="line">print(<span class="string">&#x27;Dimension of data: &#123;&#125;&#x27;</span>.format(data_dim))</span><br></pre></td></tr></table></figure>
<h2 id="Shuffling"><a href="#Shuffling" class="headerlink" title="Shuffling"></a>Shuffling</h2><p>目的是把每笔数据的顺序打乱，标签还是对应原来数据的。</p>
<p>最后return的是用一个索引去索引另一个索引。 <code>numpy-array[numpy-array] or numpy-array[list]</code>是可行的，但<code>list[numpy-array]</code>就会报错，索引时尽可能使用numpy数组。</p>
<p>参考<a href="https://blog.csdn.net/tcltyan/article/details/108430613">TypeError: only integer scalar arrays can be converted to a scalar index的处理方法</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_shuffle</span>(<span class="params">X, Y</span>):</span></span><br><span class="line">    randomize = np.arange(len(X))</span><br><span class="line">    np.random.shuffle(randomize)</span><br><span class="line">    <span class="keyword">return</span> (X[randomize], Y[randomize])</span><br><span class="line"><span class="comment"># 如果X和Y都是List，即我们在test它的性能时使用np.array(list-item)作为输入就不会报错</span></span><br><span class="line"><span class="comment"># print(_shuffle(np.array([1,2,3,4]), np.array([1,1,0,4])))</span></span><br><span class="line"><span class="comment"># 用numpy数组去索引List会报错Only integer scalar arrays can be converted to a scalar index</span></span><br><span class="line"><span class="comment"># numpy.random.shuffle会改变传入原来传入的numpy数组</span></span><br><span class="line"><span class="comment"># 一般讲要索引的target转换成numpy数组进行操作，尽可能将数据类型转换为numpy数组处理</span></span><br></pre></td></tr></table></figure>
<h2 id="截断防溢出"><a href="#截断防溢出" class="headerlink" title="截断防溢出"></a>截断防溢出</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.clip(<span class="number">1</span> / (<span class="number">1.0</span> + np.exp(-z)), <span class="number">1e-8</span>, <span class="number">1</span> - (<span class="number">1e-8</span>))</span><br></pre></td></tr></table></figure>
<p>对有逼近/渐近线的函数做截断。</p>
<h2 id="预测输出的转换"><a href="#预测输出的转换" class="headerlink" title="预测输出的转换"></a>预测输出的转换</h2><p>在求解交叉熵的时候用的是最原始的预测输出（也就是通过sigmoid function后的01范围内的概率），但是在计算预测准确度的时候，要把预测输出用round转换为布尔值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_dev_pred = _f(X_dev, w, b)</span><br><span class="line">Y_dev_pred = np.round(y_dev_pred)</span><br><span class="line">dev_acc.append(_accuracy(Y_dev_pred, Y_dev))</span><br><span class="line">dev_loss.append(_cross_entropy_loss(y_dev_pred, Y_dev) / dev_size)</span><br></pre></td></tr></table></figure>
<h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h3><ul>
<li>使用<code>X.T</code>属性，适用于一维和二维数组</li>
<li>使用<code>X.transpose()</code>方法，对于高维数组需要由轴编号组成的元组才能依据轴转置。</li>
</ul>
<h3 id="相乘"><a href="#相乘" class="headerlink" title="相乘"></a>相乘</h3><p><code>np.dot(X1, X2)</code>或者<code>X1.dot(X2)</code></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/iteapoy/article/details/105477848">李宏毅2020机器学习作业2-Classification：年收入二分类</a></p>
<p><a href="https://colab.research.google.com/drive/1JaMKJU7hvnDoUfZjvUKzm9u-JLeX6B2C#scrollTo=UghOxYrUXXPU">课程助教上传的Colab文件</a></p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>ML-Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>利用梯度下降法最优化损失函数</title>
    <url>/2020/11/08/summary-for-loss-function-optimization/</url>
    <content><![CDATA[<h1 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h1><p>$\theta_t$: model parameters at the time step t.</p>
<p>$\nabla L(\theta_t)$ or $g_t$: gradient of loss function at $\theta_t$, for updating $\theta_{t+1}$.</p>
<p>$m_{t+1}$: momentum accumulated for time step 0 to time step t, for updating $\theta_{t+1}$.</p>
<p><img src="/2020/11/08/summary-for-loss-function-optimization/flow.png" alt="flow" style="zoom:50%;"></p>
<h1 id="参数迭代方式"><a href="#参数迭代方式" class="headerlink" title="参数迭代方式"></a>参数迭代方式</h1><p>on-line：一次用一对input&amp;label算损失函数更新参数</p>
<p>off-line：一次用所有input&amp;label算损失函数更新参数</p>
<h1 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h1><p>我们要Minimize Loss Function，梯度代表了增加的方向，往梯度的反方向走，就可以走向最小值。</p>
<p><img src="/2020/11/08/summary-for-loss-function-optimization/sgd.png" alt="sgd" style="zoom:50%;"></p>
<h1 id="SGDM"><a href="#SGDM" class="headerlink" title="SGDM"></a>SGDM</h1><p>定义了一个momentum，初始值为0。本次参数的更新是momentum和上一次迭代参数的矢量和。注意momentum的求解也用到了gradient，并且用lambda考虑了上一次迭代的momentum。</p>
<p><img src="/2020/11/08/summary-for-loss-function-optimization/SGDM.png" alt="SGDM" style="zoom:50%;"></p>
<h1 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h1><p>Adagrad就是把SGD的学习率加上了一个分母。如果前几次迭代中gradient值很大的时候，一开始就会一步跨很大，有了分母的约束之后，如果过去的gradient很大的话（代表比较崎岖的地方），就能让每一步走小一点。</p>
<p>问题在于，分母会越来越大，之后每一步的参数更新会越来越小。要是一开始的gradient就很大，那么没几步就不走了。</p>
<p><img src="/2020/11/08/summary-for-loss-function-optimization/adagrad.png" alt="adagrad" style="zoom:50%;"></p>
<h1 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h1><p>和Adagrad的分母的算法有所不同，同时借用了SGDM的思想。既考虑了gradient，有考虑了momentum，这两者的结合就是下面式子中的v，且用一个参数去权衡这两个的比重，解决了Adagrad的短板。</p>
<p>但是它还是没有办法解决local minima的问题。</p>
<p><img src="/2020/11/08/summary-for-loss-function-optimization/RMSProp.png" alt="RMSProp" style="zoom:50%;"></p>
<h1 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h1><p>Adam就是SGDM+RMSProp。</p>
<p>$\hat{m}_t$就是SGDM中的momentum除以了一个$1-\beta_1^t$，目的是让整个式子不会随着时间变化越来越大。要注意到$\beta_1$的取值是比较接近1但又小于的，在一开始的time step中，$m^t$的值主要是由$\beta_1m_{t-1}$来决定的，本次更新的$m^t$会比上一次的$m_{t-1}$来的小。通过处以一个$1-\beta_1^t$来让momentum不要那么小。</p>
<p>类似的，$\hat{v}_t$就是SGDM中的v除以了一个$1-\beta_2^t$。</p>
<p>一个很小的$\varepsilon$是为了在一开始v为0的时候分母不为0，否则就要无意义且学习率会无穷大。</p>
<p><img src="/2020/11/08/summary-for-loss-function-optimization/Adam.png" alt="Adam" style="zoom:50%;"></p>
<h1 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h1><p>Adapative Learning Rate/Adam： fast training/unstable/larger generalization gap虽然能自适应学习率但是在训练后期表现不是很好。</p>
<p>SDGM：stable but slow/better convergence/smaller generalization gap虽然训练起来很慢但是总是很稳定，因为每一步走的都一样长。</p>
<h1 id="Adam优化"><a href="#Adam优化" class="headerlink" title="Adam优化"></a>Adam优化</h1><h2 id="SWATS"><a href="#SWATS" class="headerlink" title="SWATS"></a>SWATS</h2><p>总的思想：first Adam + After SDGM，结合了Adam和SDGM的长处，追求更好的收敛。</p>
<h2 id="RAdam"><a href="#RAdam" class="headerlink" title="RAdam"></a>RAdam</h2><p>总的思想：apply warm-up to the first learning-rate</p>
<p>为什么需要Warm-up？刚开始你去初始化参数的时候并不能知道这个初始化参数是否好，所以一开始做梯度下降，很有可能参数在乱更新，分布的方差很大，更新的大小很乱且方向也很乱 —— distorted gradient。所以一开始就要让走的步</p>
<p>最简单的warm-up就是给参数更新定一个曲线，直线增加4000个update之后曲线下降。</p>
<h2 id="Lookahead"><a href="#Lookahead" class="headerlink" title="Lookahead"></a>Lookahead</h2><p>K step forward，1 step back.</p>
<h2 id="Nadam"><a href="#Nadam" class="headerlink" title="Nadam"></a>Nadam</h2><p>数学中的Nesterov acclerated gradient/NAG应用到Adam中。</p>
<h1 id="协助优化的技巧"><a href="#协助优化的技巧" class="headerlink" title="协助优化的技巧"></a>协助优化的技巧</h1><h2 id="L2-Regularization"><a href="#L2-Regularization" class="headerlink" title="L2 Regularization"></a>L2 Regularization</h2><p>在定义loss function的时候一般会添加一个L2 Regularization，他也是关于目标参数的一个函数。在做gradient的时候是否要把L2 Regularization当作gradient的一部分放在momentum和gradient中去？</p>
<p>AdamW&amp;SGDW的方法说做微分求momentum和gradient的时候只考虑没有L2 Regularization的loss function，只在最后更新参数的时候把L2 Regularization的微分结果当作一个weight decay项放在learning rate后面。</p>
<h2 id="增加数据随机性"><a href="#增加数据随机性" class="headerlink" title="增加数据随机性"></a>增加数据随机性</h2><h3 id="Shuffling"><a href="#Shuffling" class="headerlink" title="Shuffling"></a>Shuffling</h3><p>数据更换顺序，让每一次的gradient都有变化。</p>
<h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><p>在训练的时候某一些neuron的输出会被丢掉。</p>
<h3 id="Gradient-noise"><a href="#Gradient-noise" class="headerlink" title="Gradient noise"></a>Gradient noise</h3><p>在算完gradient之后加上一个gaussian noise。</p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>ML-Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>循环神经网络</title>
    <url>/2020/11/09/rnn/</url>
    <content><![CDATA[<h1 id="文本预测系统设计"><a href="#文本预测系统设计" class="headerlink" title="文本预测系统设计"></a>文本预测系统设计</h1><p>希望设计一个系统，输入一段词汇，希望他预测接下来的内容。</p>
<h2 id="input-via-word-embedding"><a href="#input-via-word-embedding" class="headerlink" title="input via word embedding"></a>input via word embedding</h2><p>如何用一个向量vector表示一个字词word的意思（word embedding）？以下是获得vector的几种方法。</p>
<hr>
<p>理论上可行的办法有以下几种。</p>
<ul>
<li><p>1-of-N encoding/one-hot encoding</p>
<p>假设一个有N个字的字典，那么每一个字vector长度都是N。一个word出现就占用对应dimension为1。缺点在于需要预先知道所有的字，很占用内存空间。缺少字与字之间的语义关联性。</p>
<p>可以为未知词汇添加一个dimension’other’，于是上面的1-of-N encoding就可以变成1-of-(N+1) encoding。</p>
</li>
<li><p>用word-hashing。a-a-a/a-a-b等原子，用每一个原子去对应word，可以表示所有英文单词。</p>
</li>
<li><p>Bag of Words(BOW)</p>
</li>
</ul>
<p>将句子里的文字变成一个袋子装这些词，不考虑词的次数和顺序/文法。</p>
<hr>
<p>具体训练时可以用skip-gram/CBOW等方法获得word embedding，这些层的参数是否要跟着模型一起训练可以通过fix_embedding的T/F来更改。</p>
<hr>
<h2 id="output-as-probability-distribution"><a href="#output-as-probability-distribution" class="headerlink" title="output as probability distribution"></a>output as probability distribution</h2><p>输出我们希望得到一个probability distribution，代表了预测下一个单词出现在系统给定的每一个slot的概率。</p>
<p>input &amp; output are both sequences with the same length.</p>
<blockquote>
<p>slot就是一句话的语境意义。某个单词属于某个slot就代表这个单词意味着这句话的有效信息。</p>
<p>例如，Taipei是一个destination slot， November 2nd 是一个time of arrival slot。</p>
<p>并不是每一个单词都会属于某个slot，一句话需要提取出有效信息。</p>
</blockquote>
<p>RNN的特殊之处在于，hidden layer中的output都会被存放到memory parameters中去。下一次有input的时候，neuron既会考虑x1/x2，也会考虑memory中存放的数据。因此就算每一次输入相同，输出结果也会不同。</p>
<h1 id="RNN类别"><a href="#RNN类别" class="headerlink" title="RNN类别"></a>RNN类别</h1><h2 id="Elman-Network"><a href="#Elman-Network" class="headerlink" title="Elman Network"></a>Elman Network</h2><p>当前输入的每一个hidden layer的输出，都用作下一个输入的对应hidden layer的输入。</p>
<h2 id="Jordan-Network"><a href="#Jordan-Network" class="headerlink" title="Jordan Network"></a>Jordan Network</h2><p>当前输入的最终output保存在memory中，在下一个timestep的下一个输入作为输入考虑。</p>
<h2 id="Bidirectional-RNN"><a href="#Bidirectional-RNN" class="headerlink" title="Bidirectional RNN"></a>Bidirectional RNN</h2><p>同时训练正向和逆向的model，也就是向前看也向后看。</p>
<p>把两个模型中某个timestep的对应输入的hidden layer参数都考虑，然后决定输出。</p>
<h1 id="如何Memory"><a href="#如何Memory" class="headerlink" title="如何Memory"></a>如何Memory</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>Long short-term Memory(LSTM): 4 input, 1 output.</p>
<p><img src="/2020/11/09/rnn/LSTM.png" alt="LSTM" style="zoom:50%;"></p>
<p>蓝色箭头的<strong>四个输入</strong>都是vector，这四个输入都是不一样的，从同一个原始x做了不同的线性变换（乘以了不同的权重）后得到的，所以x的维度和四个输入的维度都是一样的，等于memory cell的数目。参数量是4倍。</p>
<p>输入中有三个都是<strong>signal control</strong>，包括<strong>input gate/output gate/forget gate</strong>。这三个gate都是由activation function组成的，一般选择sigmoid function，因为它形似0-1开关函数，但是有一个平滑的上升。</p>
<p>输入中有一个是network中的产生memory内容的neuron的输出。</p>
<p>黑色箭头的<strong>一个输出</strong>都是vector：代表了LSTM这个小nueron的输出。</p>
<p><img src="/2020/11/09/rnn/drunk99/machacroissant/source/_posts/2020-11-09-rnn/LSTM2.png" alt="LSTM2" style="zoom:50%;"></p>
<h2 id="实际输入"><a href="#实际输入" class="headerlink" title="实际输入"></a>实际输入</h2><p>但实际在做的时候并不是只有$x^t$和memory cell中存放的值（在这里就是粉色圆圈加号的输出，叫做peephole）放到下一个LSTM中做输入，还会把当前LSTM的输出$y^t/h^t$当作下一个LSTM的输入。</p>
<h1 id="如何训练"><a href="#如何训练" class="headerlink" title="如何训练"></a>如何训练</h1><p>如何定义损失函数？如何表示NN的输出？如何表示实际的输出？</p>
<p>NN的输出$y^t$会和一个reference vector做cross entropy。reference vector的维度就是预先定义的slot的长度，该单词本来属于哪一个slot那么该reference对应的slot取值就是1。NN的输出$y^t$就是input通过NN之后关于slot的vector。</p>
<p>但是问题是当前时间点的一个单词的cross entropy代表的损失函数和最终整个句子的error关系不大（cost &amp; error not always related）。</p>
<hr>
<p>定义好损失函数之后如何最小化损失函数？</p>
<p>Backpropagation throught time</p>
<p>RNN训练的困难之处在于参数很小的变化可能引起gradient巨大的变化，也可能参数很小的变化对gradient影响根本没有。有点类似于函数中那种跳跃型间断点，在不间断的时候特别平缓，间断的时候又是特别剧烈。</p>
<hr>
<p>如何解决损失函数崎岖不平，梯度忽大忽小Gradient Vanishing coexist with Gradient Explode的问题？</p>
<p>Long Short-term Memory can handle gradient vanishing(not gradient explode)</p>
<p>理由：Memory and input are added，受input gate和forget gate同时控制，除非forget gate关掉了，那么前一次的memory cell中的内容不会消失，因此就没有梯度消失的问题。</p>
<h1 id="更多应用"><a href="#更多应用" class="headerlink" title="更多应用"></a>更多应用</h1><ul>
<li><p>Slot Feeding：引入中的例子</p>
</li>
<li><p>Sentiment Analysis：input是sequence的分类问题，所以要用到RNN</p>
</li>
<li><p>Key Term Extraction：input是document sequence</p>
</li>
<li><p>Speech Recognition</p>
<p>input和output都是sequence，但是最终input和output vector的长度不一致。</p>
<p>可能input的好多词都值对应同一个character，那么output需要trimming变成更短的去掉重复内容的character sequence</p>
</li>
<li><p>Machine Translation：input和output都是长度不同的sequences。</p>
</li>
<li><p>Syntactic Parsing：看一个句子得出语义的树状结构，以前要用structure learning。</p>
</li>
<li><p>Sequence-to-sequence auto-encoder — text</p>
</li>
</ul>
<p>input是word sequence，通过RNN变成一个vector — encoder的部分。</p>
<p>把这个vector当作后续decoder的输入，找回一模一样的句子。</p>
<p>如果可以成功做到两个步骤，Encoding的vector就代表这个input sequence的重要的信息，在训练模型的时候就不需要label data了，只需要大量input。</p>
<ul>
<li>Sequence-to-sequence auto-encoder — speech</li>
</ul>
<p>有包含了许多内容的一段语音，你先对他做segmentation切成一段一段，然后用audio segmentation to vector的技术（这里需要用到RNN）把segment变成fixed length vector，这些vector之间的距离代表了他们的相似程度。</p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title>MLHW3-tips</title>
    <url>/2020/11/11/MLHW3-tips/</url>
    <content><![CDATA[<h1 id="Colab使用"><a href="#Colab使用" class="headerlink" title="Colab使用"></a>Colab使用</h1><p>Colab工作于Google Drive，创建完成colab notebook后可以根据<code>修改-笔记本设置-硬件加速</code>来选择GPU加速。</p>
<p>在shell指令前添加<code>!</code>就可以在Ipython中运行任何命令行指令。</p>
<p>可以把colab挂载到google drive从而就可以从云端硬盘中读取文件加载到Colab运行，但是每一次新建笔记本后都要配置挂载。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> google.colab <span class="keyword">import</span> drive</span><br><span class="line">drive.mount(<span class="string">&#x27;/content/drive/&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><a href="https://juejin.im/post/6844903730370838542">更多参考</a></p>
<h1 id="Python-OS-文件-目录方法"><a href="#Python-OS-文件-目录方法" class="headerlink" title="Python OS 文件/目录方法"></a>Python OS 文件/目录方法</h1><p>读取某一个路径下的文件夹目录<code>image_dir = sorted(os.listdir(path))</code> 。</p>
<p>文件夹中的文件数目用<code>(len(image_dir)</code>表示。</p>
<p>遍历该文件夹下的每一个文件<code>for i, file in enumerate(image_dir): img = cv2.imread(os.path.join(path, file))</code></p>
<p>合并路径<code>os.path.join</code></p>
<h1 id="定义数据预处理函数"><a href="#定义数据预处理函数" class="headerlink" title="定义数据预处理函数"></a>定义数据预处理函数</h1><p>数据预处理分训练集和测试集。使用包<code>import torchvision.transforms as transforms</code>。</p>
<p>数据增强是为了防止过拟合的现象，用于数据较少的训练集。通常transforms.Compose将transforms组合在一起构成多次图形变化。</p>
<p>基本步骤</p>
<ul>
<li>将Tensor类转换为PILImage类<code>transforms.ToPILImage(),</code></li>
<li>开始多个图片的翻转、旋转等操作。此步骤对训练集不需要</li>
<li>将PILImage类转换回Tensor类<code>transforms.ToTensor()</code>。</li>
</ul>
<h1 id="自定义数据集"><a href="#自定义数据集" class="headerlink" title="自定义数据集"></a>自定义数据集</h1><p>先用重写Dataset类对数据封装，重写初始化、长度和索引的函数，结合数据预处理的transform。再读入数据，用DataLoader类。</p>
<h2 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h2><p>一个自定义Datasets的基本框架，初始化放在<code>__init__()</code>中，其中<code>__getitem__()</code>和<code>__len__()</code>两个方法是必须重写的。</p>
<p>基本结构如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomDataset</span>(<span class="params">data.Dataset</span>):</span><span class="comment">#需要继承data.Dataset</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># TODO</span></span><br><span class="line">        <span class="comment"># 1. Initialize file path or list of file names.</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="comment"># TODO</span></span><br><span class="line">        <span class="comment"># 1. Read one data from file (e.g. using numpy.fromfile, PIL.Image.open).</span></span><br><span class="line">        <span class="comment"># 2. Preprocess the data (e.g. torchvision.Transform).</span></span><br><span class="line">        <span class="comment"># 3. Return a data pair (e.g. image and label).</span></span><br><span class="line">        <span class="comment">#这里需要注意的是，第一步：read one data，是一个data</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># You should change 0 to the total size of your dataset.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h2><p>实现分批次读取数据、随机读取数据、并行加载数据。</p>
<p>常用操作有：batch_size(每个batch的大小), shuffle(是否进行shuffle操作), num_workers(加载数据的时候使用几个子进程)。</p>
<p><code>Dataloader</code>这个类并不需要我们自己设计代码，我们只需要利用<code>DataLoader</code>类读取我们设计好的<code>Dataset子类</code>即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loader = DataLoader(train_dataset, batch_size=<span class="number">16</span>, num_workers=<span class="number">4</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 按照batch_size来返回特定数量的训练数据的tensor</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义神经网络"><a href="#自定义神经网络" class="headerlink" title="自定义神经网络"></a>自定义神经网络</h2><p>Torch.nn是专门为神经网络设计的模块化接口，需要重新实现构造函数<code>__init__</code>构造函数和<code>forward</code>这两个方法。</p>
<h3 id="自定义神经网络的模版"><a href="#自定义神经网络的模版" class="headerlink" title="自定义神经网络的模版"></a>自定义神经网络的模版</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classifier</span>(<span class="params">nn.Module</span>):</span> <span class="comment"># 自定义神经网络需要继承nn.Module类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span> <span class="comment"># 一般把网络中具有可学习参数的层放在构造函数__init__()中</span></span><br><span class="line">        super(Classifier, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.cnn = nn.Sequential(</span><br><span class="line">        <span class="comment"># 这里用nn.Sequential将提供的各类函数包装起来，注意每次输入输出的维度</span></span><br><span class="line">        <span class="comment"># 形成一个大的CNN模块</span></span><br><span class="line">        )</span><br><span class="line">        self.fullyconnected = nn.sequential(</span><br><span class="line">        <span class="comment"># 这里是另外一个大的全链接层模块</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># 在forward中没有必要把细枝末节拼起来</span></span><br><span class="line">        <span class="comment"># 只需要把每个大的模块拼接起来</span></span><br><span class="line">        <span class="comment"># 同时也要注意输入输出</span></span><br><span class="line">        out = self.cnn(x)</span><br><span class="line">        out = out.view(out.size()[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.fc(out)</span><br></pre></td></tr></table></figure>
<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>一般把网络中具有可学习参数的层（如全连接层、卷积层等）放在构造函数<strong>init</strong>()中，当然也可以把不具有参数的层也放在里面。</p>
<p>一般把不具有可学习参数的层(如ReLU、dropout、BatchNormanation层)可放在构造函数中，也可不放在构造函数中，如果不放在构造函数<strong>init</strong>里面，则在forward方法里面可以使用nn.functional来代替。</p>
<p>forward方法是必须要重写的，它是实现模型的功能，实现各个层之间的连接关系的核心。</p>
<h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>定义参数如模型、损失函数、梯度下降的方法、epoch的次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Classifier().cuda()</span><br><span class="line">loss = nn.CrossEntropyLoss() </span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.001</span>) </span><br><span class="line">num_epoch = <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>for循环每一个epoch，记录每一个epoch的时间，损失，正确率等都要清零。</p>
<p>训练每一笔data的for循环之前一定要开启<code>model.train()</code> 保证自动backpropagation且参数更新。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epoch):</span><br><span class="line">    epoch_start_time = time.time()</span><br><span class="line">    train_acc = <span class="number">0.0</span></span><br><span class="line">    train_loss = <span class="number">0.0</span></span><br><span class="line">    val_acc = <span class="number">0.0</span></span><br><span class="line">    val_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    model.train() </span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        optimizer.zero_grad() <span class="comment"># </span></span><br><span class="line">        train_pred = model(data[<span class="number">0</span>].cuda()) </span><br><span class="line">        batch_loss = loss(train_pred, data[<span class="number">1</span>].cuda()) </span><br><span class="line">        batch_loss.backward() </span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        train_acc += np.sum(np.argmax(train_pred.cpu().data.numpy(), axis=<span class="number">1</span>) == data[<span class="number">1</span>].numpy())</span><br><span class="line">        train_loss += batch_loss.item()</span><br></pre></td></tr></table></figure>
<h2 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h2><p>测试每一笔validation set或者testing set的data之前一定要开启<code>model.eval()</code> 保证不会自动backpropagation参数更新。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epoch):</span><br><span class="line">  epoch_start_time = time.time()</span><br><span class="line">  train_acc = <span class="number">0.0</span></span><br><span class="line">  train_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">  model_best.train()</span><br><span class="line">  <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(train_val_loader):</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    train_pred = model_best(data[<span class="number">0</span>].cuda())</span><br><span class="line">    batch_loss = loss(train_pred, data[<span class="number">1</span>].cuda())</span><br><span class="line">    batch_loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    train_acc += np.sum(np.argmax(train_pred.cpu().data.numpy(), axis=<span class="number">1</span>) == data[<span class="number">1</span>].numpy())</span><br><span class="line">    train_loss += batch_loss.item()</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mrsuncodes.github.io/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/#more">MrSun Blog</a></p>
<p><a href="https://blog.csdn.net/qq_27825451/article/details/90550890?utm_medium=distribute.pc_relevant.none-task-blog-title-2&amp;spm=1001.2101.3001.4242">pytorch教程之nn.Module类详解</a></p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>ML-Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>从谷歌硬盘获取文件</title>
    <url>/2020/11/10/google-download/</url>
    <content><![CDATA[<h1 id="参考教学"><a href="#参考教学" class="headerlink" title="参考教学"></a>参考教学</h1><p><a href="https://colab.research.google.com/drive/1i41Whco5KIb7EuntKYwTVORAkAwCmlkF#scrollTo=EAM_tPQAELh0">台大李宏毅机器学习助教分享</a></p>
<p><a href="https://clay-atlas.com/blog/2020/03/13/python-chinese-note-package-gdown-download-google-drive/">素人技术博主分享</a></p>
<h1 id="使用gdown"><a href="#使用gdown" class="headerlink" title="使用gdown"></a>使用gdown</h1><p>从谷歌分享链接中获取file_id，利用file_id下载。</p>
<p>比如目前有这个链接<code>https://drive.google.com/u/0/uc?id=19CzXudqN58R3D-1G8KeFWk8UDQwlb8is&amp;export=download</code>，提取出id就是<code>id=19CzXudqN58R3D-1G8KeFWk8UDQwlb8is</code>。</p>
<p>如果当前链接里没有id显示怎么办？在当前链接中点击下载图标看新跳出来的网址。</p>
<p>在Colab下输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!gdown --id <span class="string">&#x27;19CzXudqN58R3D-1G8KeFWk8UDQwlb8is&#x27;</span> --output foodpack.zip</span><br><span class="line">!ls</span><br><span class="line">!unzip food<span class="number">-11.</span>zip</span><br></pre></td></tr></table></figure>
<p>在Python中输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gdown</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://drive.google.com/u/0/uc?id=19CzXudqN58R3D-1G8KeFWk8UDQwlb8is&amp;export=download&quot;</span></span><br><span class="line">output = <span class="string">&quot;foodpack.zip&quot;</span></span><br><span class="line">gdown.download(url, output)</span><br></pre></td></tr></table></figure>
<h1 id="使用wget"><a href="#使用wget" class="headerlink" title="使用wget"></a>使用wget</h1><p>wget比较容易在处理大容量档案时卡住不动或报错。</p>
<p>在终端输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget <span class="string">&quot;https://drive.google.com/u/0/uc?id=19CzXudqN58R3D-1G8KeFWk8UDQwlb8is&amp;export=download&quot;</span> -O <span class="string">&quot;foodpack.zip&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>必备技能</category>
      </categories>
      <tags>
        <tag>资源获取</tag>
      </tags>
  </entry>
  <entry>
    <title>集成学习</title>
    <url>/2020/11/11/ensemble/</url>
    <content><![CDATA[<h1 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>有N笔Training Data，从中做sampling，建立多个有相同数据量的dataset。</p>
<p>用一个复杂的模型对这些dataset做learning，可以得到四个训练好的模型。</p>
<p>最后将这四个模型的结果做Average/Voting。</p>
<h2 id="适用于什么情况"><a href="#适用于什么情况" class="headerlink" title="适用于什么情况"></a>适用于什么情况</h2><p>模型复杂，但是bias很小；主要担心overfitting，目的是为了降低variance，将这些用subset训练好（但是只做重采样效果也不一定很好）的子模型做平均/投票。</p>
<p>比如decision tree这样的模型，Random Forest就是决策树做bagging的版本。传统的决策树很容易在训练集上0% error rate。</p>
<p>传统的随机森林是通过之前的重采样的方法做，但是得到的结果是每棵树都差不多（效果并不好）。比较多的是随机的限制一些特征或者问题不能用，这样就能保证就算用同样的dataset，每次产生的决策树也会是不一样的，最后把所有的决策树的结果都集合起来，就会得到随机森林。</p>
<h2 id="如何验证Validate"><a href="#如何验证Validate" class="headerlink" title="如何验证Validate"></a>如何验证Validate</h2><p>如果是用Bagging的方法的话，用out-of-bag可以做验证，不需要把label data划分成training set和validation set。</p>
<p>对于一个function1，用dataset1和dataset2训练；对于function4，用dataset2和dataset4训练。function1和function4做bagging的结果可以用dataset3来做测试。对所有的function的组合做out-of-bag测试，最终的error是这些测试结果的平均。</p>
<h1 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h1><h2 id="适用于什么情况-1"><a href="#适用于什么情况-1" class="headerlink" title="适用于什么情况"></a>适用于什么情况</h2><p>适用于错误率很高的模型，没有办法fit。</p>
<p>Boosting有一个很强的保证：如果你的机器学习算法能产生错误率小于50%的分类器，这个方法可以保证错误率达到0%。</p>
<h2 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h2><ul>
<li>先找一个分类器f1(x)</li>
<li>接下来找一个辅助f1(x)的分类器f2(x)，f2(x)不能和f1(x)很像，f2(x)要能够弥补f1(x)没办法做的事情</li>
<li>之后再找辅助f2(x)分类器的f3(x)，一直到最后</li>
</ul>
<p>注意所有分类器都是按照顺序sequentially得到的。而bagging是没有顺序的，可并行训练。</p>
<h2 id="细节实现"><a href="#细节实现" class="headerlink" title="细节实现"></a>细节实现</h2><h3 id="如何使classifers-—-fk-x-不相同？"><a href="#如何使classifers-—-fk-x-不相同？" class="headerlink" title="如何使classifers — fk(x)不相同？"></a>如何使classifers — fk(x)不相同？</h3><p>要让每个分类器的参数不同，可以让他们在不同的dataset上训练。</p>
<p>为了获得不同的数据集，可以重采样原数据集Resampling，就像bagging做的那样；也可以重新给原数据集中的每一个数据重新分配权重，即Re-weighting。$(x^i, \hat{y}^i, u^i) \quad  u^i=1=&gt;u^i=k$，在实际操作的时候并不要对dataset的封装有什么更改，只是更改cost function为$L(f) = \sum_n{u^n l(f(x^n), \hat{y}^n)}$。</p>
<h3 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a>Adaboost</h3><p>总的想法就是先训练好一个分类器f1(x)，然后再找一组新的training data，让f1(x)在这组data上表现很差（怎么才算表现差？），然后让f2(x)在这组training data上训练。</p>
<p><img src="/2020/11/11/ensemble/adaboost.png" alt="adaboost" style="zoom:50%;"></p>
<p>$\varepsilon_1$就是分类器f1(x)在训练数据上的的error rate，分子是所有训练样本的weight之和，分母是分类正确的训练样本的weight之和，要求error rate小于0.5。</p>
<hr>
<p>将分类器f1(x)中的训练数据的权重变更（要怎么变更？）后，我们要找分类器f2(x)在新权重的训练集上error rate等于0.5。</p>
<p><img src="/2020/11/11/ensemble/adaboost2.png" alt="adaboost2" style="zoom:50%;"></p>
<hr>
<p>如何确定$d_1$？</p>
<p>已知</p>
<script type="math/tex; mode=display">
\begin{split}
\varepsilon_1 &= \frac{\sum_n{u_1^n\delta{(f_x(x^n)\neq \hat{y}^n)}}}{\sum{u_1^n}} \\
\varepsilon_2 &= \frac{\sum_n{u_2^n\delta{(f_x(x^n)\neq \hat{y}^n)}}}{\sum{u_2^n}} \\
&=\frac{\sum_{f_x(x^n)\neq \hat{y}^n}{u_2^n}}{\sum_{f_x(x^n) = \hat{y}^n}{u_2^n} + \sum_{f_x(x^n)\neq \hat{y}^n}{u_2^n} } \\
&= \frac{\sum_{f_x(x^n)\neq \hat{y}^n}{u_1^nd_1}}{\sum_{f_x(x^n) = \hat{y}^n}{u_1^n/d_1} + \sum_{f_x(x^n)\neq \hat{y}^n}{u_1^nd_1} }\\
&= 0.5
\end{split}</script><p>变形获得</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\sum_{f_x(x^n) = \hat{y}^n}{u_1^n/d_1}}{\sum_{f_x(x^n)\neq \hat{y}^n}{u_1^nd_1} } = 1 
\\ 
\frac{1}{d_1} \sum_{f_x(x^n) = \hat{y}^n}{u_1^n} = d_1 \sum_{f_x(x^n) \neq \hat{y}^n}{u_1^n} \\

\frac{1}{d_1} Z_1(1-\varepsilon_1) = d_1 Z_1\varepsilon_1 \\
d_1= \sqrt{(1-\varepsilon_1)/\varepsilon_1} > 1
\end{aligned}</script><h4 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h4><p><img src="/2020/11/11/ensemble/adaboost3.png" alt="adaboost3" style="zoom:50%;"></p>
<ul>
<li>多个模型的sequential训练</li>
</ul>
<p><img src="/2020/11/11/ensemble/adaboost4.png" alt="adaboost4" style="zoom:50%;"></p>
<ul>
<li>将多个训练好的模型组装，两种方式Uniform Weight/Non-uniform Weight。</li>
</ul>
<h4 id="正确性验证"><a href="#正确性验证" class="headerlink" title="正确性验证"></a>正确性验证</h4><p>要保证最后组装起来的模型$H(x)$的error rate会越来越小。</p>
<h5 id="问题转换1"><a href="#问题转换1" class="headerlink" title="问题转换1"></a>问题转换1</h5><p>最终的error rate是有上界的，蓝色的函数就是绿色函数的上界。</p>
<p><img src="/2020/11/11/ensemble/adaboost5.png" alt="adaboost5"></p>
<p>要证明最终的函数$H(x)$的error rate会越来越小的问题就变成了证明蓝色的上界函数会越来越小。</p>
<h5 id="问题转换2"><a href="#问题转换2" class="headerlink" title="问题转换2"></a>问题转换2</h5><p>对蓝色部分的上界函数做一些变形。</p>
<p>用$u^n_{T+1}$的和表示第T+1次训练数据集权重的和$Z_{T+1}$，运用递推关系式将$u^n_{T+1}$转换成关于y_train/y_pred/alpha的exp相关的表达式。这个式子表明训练数据的权重和（也就是红色表达式）会和训练数据的错误率有关系。</p>
<p><img src="/2020/11/11/ensemble/adaboost6.png" alt="adaboost6" style="zoom:50%;"></p>
<p>要证明蓝色的上界函数会越来越小就转化为要证明训练数据的权重和会越来越小。</p>
<h5 id="问题转换3"><a href="#问题转换3" class="headerlink" title="问题转换3"></a>问题转换3</h5><p>对训练数据的权重和做一些变形。</p>
<p>在用第T+1次训练数据集权重的和$Z_{T}$的两种情况分类结果表示第T+1次训练数据集权重的和$Z_{T+1}$</p>
<p><img src="/2020/11/11/ensemble/adaboost7.png" alt="adaboost7" style="zoom:50%;"></p>
<p>最终经过三次转换证明成功。</p>
<h3 id="Gradient-Boosting"><a href="#Gradient-Boosting" class="headerlink" title="Gradient Boosting"></a>Gradient Boosting</h3><p>Gradient Boosting是Boosting更泛化的一个版本。</p>
<p><img src="/2020/11/11/ensemble/gradientboosting8.png" alt="gradientboosting8" style="zoom:50%;"></p>
<p>给定initial function，在每个timestep更新上一个timestep的function，得到最终的output Function。</p>
<p>从梯度的角度考虑loss function，是上面那个式子，更新就是learning rate和对g(x)微分的结果。</p>
<p>从boosting的角度考虑就是要添一个新的函数。</p>
<p>如果这两个同方向就可以最小化损失函数。要让他们同方向就要让这两个式子同符号，把这两个式子的乘积最大化。</p>
<p><img src="/2020/11/11/ensemble/gradientboosting9.png" alt="gradientboosting9" style="zoom:50%;"></p>
<p>Adaboost中就自动分配了一个最好的$\alpha_t$，把$f_t(x)$的价值发挥到最大，很类似于learning rate。也可以把Adaboost看成是在做梯度下降，这个梯度就是一个函数，而且学习率可以通过计算得出最好的。</p>
<p>Gradient Boosting中我们可以自己决定学习率，从而更改目标函数。</p>
<h1 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h1><p>在分类问题中直接对不同结果的模型做Voting并不一定是好的，有的系统比较差。</p>
<p>当然可以采用bagging分配子系统在最终结果中的权重。</p>
<p>提出另一种方法，把子系统的输出结果当作新的特征输入到最终的分类器，这个分类器比较简单。Training Data分成两份，一份用来训练子系统，另一份用来训练最终分类器。</p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>集成学习</tag>
      </tags>
  </entry>
  <entry>
    <title>强化学习</title>
    <url>/2020/11/11/reinforcement-learning/</url>
    <content><![CDATA[<h1 id="interact-with-environment"><a href="#interact-with-environment" class="headerlink" title="interact with environment"></a>interact with environment</h1><p>两种方式</p>
<p>强化学习，机器在和环境互动的过程中，从环境获得reward，学习如何获得更高的reard。</p>
<p>learning by demostration/imitation learning，其中inverse reinforcement learning就是其中一种。</p>
<h1 id="whole-idea"><a href="#whole-idea" class="headerlink" title="whole idea"></a>whole idea</h1><p><code>Action =&gt; Observation/Reward</code></p>
<p>参数更新要Maximize the expected cumulative reward per episode。</p>
<p>训练难点在于Reward delay（如何知道某个action会在将来某个时间点获得正向Reward？），以及Agent’s actions effect the subsequent data it receives.</p>
<p>policy-based: learning an actor; value-based: learning a critic; actor+critic: A3C</p>
<h1 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h1><h2 id="函数描述"><a href="#函数描述" class="headerlink" title="函数描述"></a>函数描述</h2><p>Actor/Policy就是一个function，定义为$Action = \pi(Oberservation)$。</p>
<p>神经网络的输入就是oberservation，可以被表示成一个vector或matrix。</p>
<p>神经网络的输出就是action或probability of taking the action(stochastic)，可以对应到output layer的一个neuron。</p>
<p>Actor/Policy就是神经网络，也就是一个函数。</p>
<h2 id="函数好坏-Goodness-of-Actor"><a href="#函数好坏-Goodness-of-Actor" class="headerlink" title="函数好坏/Goodness of Actor"></a>函数好坏/Goodness of Actor</h2><p>An episode is a series of state/action/reward, named as trajectories. $\tau = \{s_1, a_1, r_1, s_2, a_2, r_2, \cdots ,s_T, a_T, r_T\} $。</p>
<blockquote>
<p>这里的state其实就是前面的observation。</p>
</blockquote>
<p>Reward就是这个episode中所有reward分量的和。$R(\tau) = \sum_{n=1}^{N}r_n$。</p>
<p>对于一个序列${s_1, a_1, r_1}$，Give an actor $\pi_\theta(s)$ with the network parameter  $\theta$. $R_\theta$是total reward，但是这是一个随机变量，我们要让它的期望$E(R_\theta)$最大。</p>
<p>现在要machine玩一个游戏，在一个episode结束之后，才能确定表示它的$\tau$是什么样的。每一种排列组合的$\tau$都有可能被sample，其概率由actor parameter决定$P(\tau|\theta)$。这里假设每一个episode被sample是等概率的，因此最终的期望$\bar{R}_\theta = \sum_{\tau}R(\tau)P(\tau|\theta) \approx \frac{1}{N}\sum_{n=1}^N{R(\tau^n)}$要被最大化。</p>
<h2 id="最大化-Gradient-Ascent"><a href="#最大化-Gradient-Ascent" class="headerlink" title="最大化/Gradient Ascent"></a>最大化/Gradient Ascent</h2><p>在找最小值的时候用Gradient Descent；在找最大值的时候用Gradient Ascent。</p>
<p>对期望$\bar{R}_\theta$做gradient ascent，每次变化都是加。</p>
<h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><script type="math/tex; mode=display">
\begin{aligned}
\bar{R}_\theta = \sum_{\tau}R(\tau)P(\tau|\theta) \\
\nabla{\bar{R}_\theta} = \sum_{\tau}R(\tau)\nabla{P(\tau|\theta)}=\sum_{\tau}R(\tau) P(\tau|\theta) \frac{\nabla{P(\tau|\theta)}}{P(\tau|\theta)}

\end{aligned}</script><p>注意到$R(\tau)$是已经定义好的和$\theta$无关的两，所以不需要对它做微分，can be a black box。</p>
<p>且$\nabla{\log{(f(x))}} = \frac{d \log(f(x))}{d x} = \frac{1}{f(x)} \frac{d f(x)}{dx} = \frac{\nabla{f(x)}}{f(x)}$带入上式可得</p>
<script type="math/tex; mode=display">
\begin{aligned}
\nabla{\bar{R}_\theta} &= \sum_{\tau}R(\tau) P(\tau|\theta) \nabla{\log{P(\tau|\theta)}} \\
&=  \frac{1}{N}\sum_{n=1}^N{R(\tau^n)} \nabla{\log{P(\tau|\theta)}}

\end{aligned}</script><p>问题转换为求</p>
<p><img src="/2020/11/11/reinforcement-learning/gradientascent.png" alt="gradientascent" style="zoom:50%;"></p>
<p>取log之后相乘变相加，做微分之后无关actor的项（黄色部分）都是没有的。</p>
<p>最终更新表达式如下，要注意probability的log做微分之后乘以的是整个episode结束之后的reward，而不是某个action结束之后立马得到的reward。</p>
<p><img src="/2020/11/11/reinforcement-learning/gradientascent2.png" alt="gradientascent2" style="zoom:50%;"></p>
<h3 id="表达式解读"><a href="#表达式解读" class="headerlink" title="表达式解读"></a>表达式解读</h3><p>为什么要做log？为什么不用p的微分直接除以p的几率？为什么要除以p的几率？</p>
<p>即使reward并不大出现频率很高的action会被偏好；即使reward很大，出现频率却很低的action对目标的影响很小。</p>
<p>相当于做了一个normalization。</p>
<hr>
<p>在某一个state我们可以sample到3个action，实际上没sample到的action在做完gradient ascent之后反而会越变越小，其他的action反而无条件的probability增加。</p>
<p>不能让几率无条件增加，所以给$R(\tau^n)$增加一个baseline，只有当当前state的该action的reward比$baseline \, b$大的时候才increase probability。</p>
<h1 id="Critic"><a href="#Critic" class="headerlink" title="Critic"></a>Critic</h1><p>A critic doesn’t determine the action. Given an actor pi, it evaluates how good the actor is.</p>
<h2 id="State-Value-Function-V-pi-s"><a href="#State-Value-Function-V-pi-s" class="headerlink" title="State Value Function $V^{\pi}(s)$"></a>State Value Function $V^{\pi}(s)$</h2><p>When using actor $\pi$, the accumulated reward expects to be obtained after seeing the observation/state s.</p>
<blockquote>
<p>只要有$\cdots, s_t, a_t, r_t, s_{t+1}， s_{t+1}$这样的state的变化，就能计算并更新参数，不需要像actor一样等到episode完全结束。</p>
</blockquote>
<h2 id="State-action-value-function-Q-pi-s-a"><a href="#State-action-value-function-Q-pi-s-a" class="headerlink" title="State-action value function $Q^{\pi}(s, a)$"></a>State-action value function $Q^{\pi}(s, a)$</h2><p>When using actor $\pi$, the accumulated reward expects to be obtained after seeing the observation/state s and action a.</p>
<p>Q-Learning就是给定一个初始actor pi，让这个pi去和environment互动，用Q function找出一个表现比上一次actor pi更好的actor pi’ 。</p>
<script type="math/tex; mode=display">
\pi'(s) = arg \max{Q^{\pi}(s, a)}</script><h1 id="Actor-Critic"><a href="#Actor-Critic" class="headerlink" title="Actor+Critic"></a>Actor+Critic</h1><p>A3C = Asynchronous Advantage Actor Critic</p>
<h1 id="Inverse-Reinforcement-Learning"><a href="#Inverse-Reinforcement-Learning" class="headerlink" title="Inverse Reinforcement Learning"></a>Inverse Reinforcement Learning</h1><p>只有action和environment，没有reward function，也就是规则不明确。目标是随着reward function的不断更新，让teache由弱变强，actor跟着teacher一起变强，但总是弱于teacher。</p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>GAN-theory</title>
    <url>/2020/11/12/GAN-theory/</url>
    <content><![CDATA[<h1 id="MLE"><a href="#MLE" class="headerlink" title="MLE"></a>MLE</h1><h2 id="极大似然估计步骤"><a href="#极大似然估计步骤" class="headerlink" title="极大似然估计步骤"></a>极大似然估计步骤</h2><p><img src="/2020/11/12/GAN-theory/image-20201112211653792.png" alt="image-20201112211653792" style="zoom:30%;"></p>
<p>就是要让真实数据分布中的每一笔data，通过给定参数的新的分布后，所得到的每一笔data概率之积要最大。</p>
<h2 id="最大化求解的转化"><a href="#最大化求解的转化" class="headerlink" title="最大化求解的转化"></a>最大化求解的转化</h2><p><img src="/2020/11/12/GAN-theory/image-20201112211914434.png" alt="image-20201112211914434" style="zoom:30%;"></p>
<p><strong>Maximum Likelihood Esitimation = Minimize KL Divergence</strong></p>
<p>Generative Model所定义的distribution PG要和真实数据的Pdata尽可能地相近似。</p>
<p>为了计算PG，我们要做假设，比如分布服从Gaussian Mixture Model，但是一旦模型复杂了，我们就没办法计算PG。</p>
<h1 id="GAN拆解"><a href="#GAN拆解" class="headerlink" title="GAN拆解"></a>GAN拆解</h1><h2 id="Gnerator在做什么"><a href="#Gnerator在做什么" class="headerlink" title="Gnerator在做什么"></a>Gnerator在做什么</h2><p><img src="/2020/11/12/GAN-theory/image-20201112225517093.png" alt="image-20201112225517093" style="zoom:30%;"></p>
<p>在获得了PG和Pdata也就是两笔数据的分布之后，要最优化Generator。</p>
<p>原始数据分布我们是没有办法完全获得的，这只在理论上现实，因而为了获得分布可以从PG和Pdata中sample一些样本获得样本分布。</p>
<p>要让这两笔数据的差距变小，也就是要最小化这两笔data distribution的Divergence？</p>
<h2 id="从Generator到Discriminator"><a href="#从Generator到Discriminator" class="headerlink" title="从Generator到Discriminator"></a>从Generator到Discriminator</h2><p>Discriminator可以告诉我们这些样本所代表的分布之间的Divergence。V(G,D)很小的时候，代表这两个sample data的distribution的divergence很小，很难分辨；V(G,D)很大的时候，代表这两个sample data的distribution的divergence很小，很容易分辨。</p>
<p><img src="/2020/11/12/GAN-theory/image-20201112230115182.png" alt="image-20201112230115182" style="zoom:30%;"></p>
<h2 id="证明可求最大值-模型可训练"><a href="#证明可求最大值-模型可训练" class="headerlink" title="证明可求最大值/模型可训练"></a>证明可求最大值/模型可训练</h2><p>接下来要证明可以给Example Objective Function for D存在arg max，即可以找到Discriminator的function $D^*$使$arg \max_DV(D, G)$最大。</p>
<p>对于给定的G，意味着generated data的distribution是确定的。这个时候需要找一个$D^*$使得$V(D, G)$最大。</p>
<h3 id="转换1"><a href="#转换1" class="headerlink" title="转换1"></a>转换1</h3><script type="math/tex; mode=display">
\begin{array}{ll}
V &=E_{X \sim P_{data} }[\log D(x)] + E_{X \sim P_{G} }[\log (1-D(x))] \\
&= \int_x P_{data}(x)\log D(x) \, dx + \int_x P_{G}(x)\log (1-D(x)) \,dx \\
&= \int_x [P_{data}(x)\log D(x) + P_{G}(x)\log (1-D(x))] \,dx \\
\end{array}</script><p>也就是要最大化积分表达式中的那个函数。</p>
<h3 id="转换2"><a href="#转换2" class="headerlink" title="转换2"></a>转换2</h3><p>用更简单的表达式来替换复杂的符号，</p>
<script type="math/tex; mode=display">
P_{data}(x) = a \quad P_{G}(x) = b  \quad \log D(x) = D \\</script><p>也就是找一个$D^*$使得$f(D) = a\log(D) + b \log(1-D)$最大。</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\frac{d f(D)}{d D} = a \times \frac{1}{D} - b \times \frac{1}{1-D} = 0 \\
D^* = \frac{a}{a+b} \\
D^* = \frac{P_{data}(x) }{ P_{data}(x) + P_{G}(x)} \in (0, 1)

\end{array}</script><hr>
<p>至此已经找到了能让$V(D, G)$最大的function $D^*$。</p>
<h2 id="Discriminator在做什么"><a href="#Discriminator在做什么" class="headerlink" title="Discriminator在做什么"></a>Discriminator在做什么</h2><p>把得到的$D^*$放进原式子中可以得到</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\max \limits_D V(G, D) \\= V(G, D^*)  \\
= E_{X \sim P_{data} }[\log \frac{P_{data}(x) }{ P_{data}(x) + P_{G}(x)}] + E_{X \sim P_{G} }[\log \frac{P_{G}(x) }{ P_{data}(x) + P_{G}(x)}] \\
= E_{X \sim P_{data} }[\log \frac{ 1/2 * P_{data}(x) }{ P_{data}(x) + P_{G}(x)  \quad / 2}] + E_{X \sim P_{G} }[\log \frac{ 1/2 * P_{G}(x) }{ P_{data}(x) + P_{G}(x) \quad /2}] \\
= 2 \log \frac{1}{2} + E_{X \sim P_{data} }[\log \frac{ P_{data}(x) }{ P_{data}(x) + P_{G}(x)  \quad / 2}] + E_{X \sim P_{G} }[\log \frac{  P_{G}(x) }{ P_{data}(x) + P_{G}(x) \quad /2}] \\
= -2 \log 2 + KL(P_{data} || \frac{P_{data}+P_G}{2}) + KL(P_{G} || \frac{P_{data}+P_G}{2}) \\
= -2 \log 2 + 2JSD(P_{data} || )P_G
\end{array}</script><p>从上式我们可以看出：当我们在train一个discriminator，我们就是在衡量我们sample出来的Pdata和PG两个分布之间的Jensen-Shannon Divergence，也是一个binary classifier。</p>
<p><img src="/2020/11/12/GAN-theory/image-20201113101438147.png" alt="image-20201113101438147" style="zoom:40%;"></p>
<p>GAN的算法本质上就是在解这个min max problem。</p>
<hr>
<p>最后Discriminator会怎么样。</p>
<p>它到底是不是一个Evaluation Function，判断generator的output是好还是坏？Discriminator真的会fail掉变成一个水平线吗？这两个问题其实是矛盾的。</p>
<p>（？）最后Discriminator会在有data分布的地方获得比较小的值，没有data分布的地方获得比较大的值。</p>
<h1 id="GAN算法"><a href="#GAN算法" class="headerlink" title="GAN算法"></a>GAN算法</h1><h2 id="Theoretically"><a href="#Theoretically" class="headerlink" title="Theoretically"></a>Theoretically</h2><script type="math/tex; mode=display">
G ^ * = arg \min\limits_{G} \max\limits_{D}V(G, D)</script><p>To find the best G as $G^*$, we should minimizing the loss function $L(G) = \max\limits_{D} V(G, D)$. </p>
<p>具体过程参考GAN Introduction文章。</p>
<hr>
<p>第一次迭代：</p>
<p><strong>Training D</strong></p>
<p>For Given $G_0$, we have two distribution $P_{data}(x), P_{G_0}(x)$.</p>
<p>Before minimizing loss function, we should determine the best  D as $D^<em>$ to maximiaze the divergence between two distribution which rendering $V(G^0, D_0^</em>)$. </p>
<blockquote>
<p>这个过程也就是找一个discriinator能最大化的看到这两个distribution的差异，分辨能力较强，较为严格。</p>
<p>实际上也可能找不到global maxima，可能停在一个local maxima就结束了关于本参数的多次迭代。Can only find lower bound of $\max\limits_{D}V(G,D)$.</p>
</blockquote>
<p>We <strong>use gradient asent several times</strong> to maximize the JS Divergence function and thus updating $\theta_D$ for $D_0^*$.</p>
<p><img src="/2020/11/12/GAN-theory/image-20201113120129183.png" alt="image-20201113120129183" style="zoom:40%;"></p>
<p><strong>Training G</strong></p>
<p>According to the fixed loss function $L(G) = V(G^0, D_0^<em>)$ at iteration 1, we <em>*use gradient desent just once</em></em> to minimize the loss function and thus updating $\theta_G$ for $G_1$.</p>
<p>可以看出来，之前maximize和现在minimize的function的表达式都是一样的。但是由于固定了D，现在要优化的式子就没有了上面的第一项。</p>
<p><img src="/2020/11/12/GAN-theory/image-20201113120215562.png" alt="image-20201113120215562" style="zoom:40%;"></p>
<p>在实际操作过程中objective function for generator是这个样子。</p>
<p><img src="/2020/11/12/GAN-theory/image-20201113121223701.png" alt="image-20201113121223701" style="zoom:40%;"></p>
<blockquote>
<p>问题是从$V(G_0, D_0^<em>)$到$V(G_1, D_0^</em>)$，我们希望第一代Generator能够Minimize前面第零代Discriminator计算出来的JS Divergence。</p>
<p>但是当我们update $G_0$到$G_1$， 整个原来用于衡量JS Divergence的function其实就已经变了，在$D_0^*$处获得的最大值可能已经不是新函数的最大值了，也就是不再是衡量JS Divergence了。</p>
<p>我们要假设在update $G_0$到$G_1$的时候，参数变动很小，变动前后的function形状变化不大，因此我们只迭代generator一次。</p>
</blockquote>
<hr>
<p>第二次迭代：</p>
<p>For Given $G_1$, we have two distribution $P_{data}(x), P_{G_1}(x)$.</p>
<h2 id="Practically"><a href="#Practically" class="headerlink" title="Practically"></a>Practically</h2><p><img src="/2020/11/12/GAN-theory/image-20201113112731393.png" alt="image-20201113112731393" style="zoom:40%;"></p>
<p>变动是求期望用Sampling来代替。</p>
<p>Discriminator要maximize的式子的过程就是在做一个binary classifier去minimize cross entropy。</p>
]]></content>
      <categories>
        <category>GAN</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>GAN</tag>
      </tags>
  </entry>
  <entry>
    <title>GAN Introduction</title>
    <url>/2020/11/12/GAN-tutorial/</url>
    <content><![CDATA[<h1 id="GAN基础算法"><a href="#GAN基础算法" class="headerlink" title="GAN基础算法"></a>GAN基础算法</h1><ul>
<li><p>Initialize $\theta_g$ for Generator and $\theta_d$ for Discriminator</p>
</li>
<li><p>In each training iteration:</p>
<p><strong>Learning D</strong> Repeat K times</p>
<hr>
<ul>
<li><p>Sample m examples $\{x^1, x^2, \cdots x^m\}$ from database $P_{data}(x)$</p>
</li>
<li><p>Sample m noise examples $\{z^1, z^2, \cdots z^m\}$ from a distribution(Uniform Distribution or Guassion Distribution) $P_{prior}(x)$</p>
</li>
</ul>
<p>这些example用多少维度的vector来表示是需要自己调的。</p>
<hr>
<ul>
<li><p>Obataining generated dara $\tilde{x}^1, \tilde{x}^2, \cdots, \tilde{x}^m$, $\tilde{x}^i = G(z^i)$</p>
</li>
<li><p>Update discriminator parameters  $\theta_d$ to maximize</p>
<p><img src="/2020/11/12/GAN-tutorial/image-20201112114319500.png" alt="image-20201112114319500" style="zoom:40%;"></p>
</li>
</ul>
<p>利用gradient ascent求最大值，本质上和gradient descent一样，只不过function符号正负或者update的时候方向和梯度同向还是反向。</p>
<p>这里用到的function并不是表现最好的，只是最早提出GAN的研究者当时采用的算法。</p>
<p>解读第一项就是把从database中sample出来的real image vector经过Dsicriminator之后评分要越高越好。</p>
<p>解读第二项就是把从某个分布随机生成的vector经过discriminator之后评分要越低越好。</p>
<p>算出两个分布之间的JS Divergence，本质上就是一个binary classifier，can only find lower bound of $\max\limits_{D} V(G, D)$。</p>
<hr>
<p><strong>Learning G</strong> Only Once</p>
<hr>
<ul>
<li><p>Sample another m noise samples  $\{z’^1, z’^2, \cdots z’^m\}$ from a distribution</p>
</li>
<li><p>Update generator parameters  $\theta_g$ to maximize</p>
<p><img src="/2020/11/12/GAN-tutorial/image-20201112114621970.png" alt="image-20201112114621970" style="zoom:40%;"></p>
<p>最里层是random noise的vector，外面套了一个Generator就变成了一个image，利用Discriminator去评判这个Generator是否做得够好，希望评分越高越好。</p>
</li>
</ul>
<hr>
</li>
</ul>
<h1 id="GAN-as-structured-Learning"><a href="#GAN-as-structured-Learning" class="headerlink" title="GAN as structured Learning"></a>GAN as structured Learning</h1><h2 id="结构化学习特征"><a href="#结构化学习特征" class="headerlink" title="结构化学习特征"></a>结构化学习特征</h2><p>机器学习就是：input — function — output。</p>
<p>当output不再是一个简单的scalar/class(one-hot vector)，而要求是sequence(MachineTranslation/Vhat-bot/SpeechRecognition)/tree/graph/matrix(ImageToImage/TextToImage)，那么就是结构化学习。</p>
<p>Structured learning’s output is composed of components with dependency.</p>
<p>结构化学习可以看作极端的one-shot/zero-shot learning，机器在学习如何输出在训练时完全没有见到过的东西。</p>
<h2 id="GAN与结构化学习"><a href="#GAN与结构化学习" class="headerlink" title="GAN与结构化学习"></a>GAN与结构化学习</h2><p>GAN其实就是结构化学习的一种解决方案。</p>
<p>传统的结构化学习方式有两种。一是Bootom-Up — Learn to generate the object at the component level，一个一个组件单独产生问题是没有大局观念；二是Top-Down — Evaluating the whole object, and find the best one，问题是很难做generation.</p>
<p>以上两种方法结合在一起，bottom-up对应generator，top-down对应discriminator就是GAN。</p>
<h1 id="Generator详解"><a href="#Generator详解" class="headerlink" title="Generator详解"></a>Generator详解</h1><p>目标：vectors — NN Generator — image。</p>
<p>要让Generator理解每一层output的component之间的关系，即pixel to pixel relationship，要让网络够深。</p>
<h2 id="NN-Generator-amp-Auto-Decoder"><a href="#NN-Generator-amp-Auto-Decoder" class="headerlink" title="NN Generator &amp; Auto-Decoder"></a>NN Generator &amp; Auto-Decoder</h2><p>在supervised learning中，都给一对vectors/image，但是如何产生这么一对vectors/image，要求我们input vectors和output的特征有某些关系。</p>
<p>由此联想到image — NN Encoder — low-dimension code，但是Encoder不能自己训练，必须要和coder — NN Decoder — image一起训练。可以看出Decoder其实就是Generator。</p>
<h2 id="Auto-Encoder-amp-VAE"><a href="#Auto-Encoder-amp-VAE" class="headerlink" title="Auto-Encoder &amp; VAE"></a>Auto-Encoder &amp; VAE</h2><p>但是用decoder做的generator再遇到自己没有遇到的coder的时候产生的结果不可控，就算是vector a和vector b的线性组合通过decoder这个非线性系统之后产生的结果也是不可控的。</p>
<p>如何解决这个问题？采用VAE — Variational Auto Encoder，给encoder的输出做一个偏移，让Auto-Encoder的输出更稳定一点。</p>
<h2 id="困难点"><a href="#困难点" class="headerlink" title="困难点"></a>困难点</h2><p>Auto-Encoder没有办法考虑每一层input的每个component之间的关系，即pixel-to-pixel relationship，对应的就是structure learning中boottom-up approach的问题，没有全局观念。</p>
<h1 id="Discriminator详解"><a href="#Discriminator详解" class="headerlink" title="Discriminator详解"></a>Discriminator详解</h1><p>Discriminator = Evaluation function = Potential Function = Energy Function</p>
<p>Discriminator更容易去检查pixel-to-pixel relationship，因为它对应的就是structure learning中的top-down approach的优势。</p>
<h2 id="训练方法"><a href="#训练方法" class="headerlink" title="训练方法"></a>训练方法</h2><p>real image就是positive example，但是如何产生比较好的十分接近real image的negative example，让discriminator的评分更严格？</p>
<p>采用iterative training。让discriminator的评分从松散到严格。</p>
<p>第一个周期，由初始discriminator parameter决定了discirminator，该discriminator学习给real image distribution的区域高分，给generated image distribution的区域低分。也就是找到了第一个周期的Discriminator。</p>
<p>第2-n的周期，先用第一个/前一个周期的Discriminator产生negative example（如何找，要解一个argmax problem，要做一些假设），重新学习real image distribution/positive example distribution的区域高分，给generated image distribution/generated image distribution的区域低分。</p>
<p>直到discriminator自己产生的neagtive example distribution和实际的真是的positive example distribution重合，discriminator才会停止迭代。</p>
<h2 id="困难点-1"><a href="#困难点-1" class="headerlink" title="困难点"></a>困难点</h2><p>如何让前一个周期的Discriminator产生negative example？如何找，要解一个argmax problem，要做一些假设，因此效果多少有些差。</p>
<p>把Generator和Discriminator联合起来考虑，用generator来解argmax problem，解决了discriminator的痛点；用discriminator去给generator一个global view。</p>
<h1 id="Advantage"><a href="#Advantage" class="headerlink" title="Advantage"></a>Advantage</h1><p><img src="/2020/11/12/GAN-tutorial/image-20201112172703765.png" alt="image-20201112172703765" style="zoom:30%;"></p>
<h1 id="Conditional-GAN"><a href="#Conditional-GAN" class="headerlink" title="Conditional GAN"></a>Conditional GAN</h1><h2 id="WHY-CGAN"><a href="#WHY-CGAN" class="headerlink" title="WHY CGAN"></a>WHY CGAN</h2><p>可操控输出结果。</p>
<hr>
<p>例如Text-to-Image，可以当成Traditional supervised learning来做。input data对应NN output要和input data label尽可能相近。</p>
<p>问题在于input data/text和input data label/image很有可能是一对多的关系，从而导致模型产生的结果是多张input data label的平均，也就是多张image的平均，所以会特别模糊。</p>
<hr>
<p>同样Image-to-Image的问题，同样一张几何图形要转换成对应的房子，很有可能一张几何图形可以对应到多个房子。</p>
<h2 id="HOW-CGAN"><a href="#HOW-CGAN" class="headerlink" title="HOW CGAN"></a>HOW CGAN</h2><p><img src="/2020/11/12/GAN-tutorial/image-20201112191503388.png" alt="image-20201112191503388" style="zoom:30%;"></p>
<p>generator的input是condtion和从normal distribution中sample出得z，output是image。</p>
<p>discriminator的input是condition和generator的output image，要求判断output image真假的同时，还要判断这个image的内容和condition是否匹配，output是判断real pair or fake pair的scalar。</p>
<blockquote>
<p>为什么discriminator需要也有condition？</p>
<p>假如没有condition作为输入，generator为了骗过discriminator，只要产生real image就行了，根本不用管input condition。</p>
</blockquote>
<h2 id="TIPS-CGAN"><a href="#TIPS-CGAN" class="headerlink" title="TIPS CGAN"></a>TIPS CGAN</h2><p>Stack GAN</p>
<p>Patch GAN</p>
<h1 id="Unsupervised-Conditional-Generation"><a href="#Unsupervised-Conditional-Generation" class="headerlink" title="Unsupervised Conditional Generation"></a>Unsupervised Conditional Generation</h1><p>Transfer an object from one domain to another without paired data(e.g. style transfer)</p>
<h2 id="Direct-Transform"><a href="#Direct-Transform" class="headerlink" title="Direct Transform"></a>Direct Transform</h2><p>Domain X — G{X-&gt;Y} — Domain Y</p>
<h2 id="要求1"><a href="#要求1" class="headerlink" title="要求1"></a>要求1</h2><p>因为没有Domain X 和 Domain Y之间的link，需要用discriminator协助，让generator产生像是Y Domain的图像。</p>
<p><img src="/2020/11/12/GAN-tutorial/image-20201112200052845.png" alt="image-20201112200052845" style="zoom:30%;"></p>
<h2 id="要求2"><a href="#要求2" class="headerlink" title="要求2"></a>要求2</h2><p>问题是如果generator直接产生和Domain X没有关系怎么办？我们必须要求generator的输入和输出必须配对。</p>
<hr>
<p>可以直接无视这个问题，当generator较简单shallow的时候，该generator倾向于不去更改input，那么就不需要做额外的constraint。</p>
<hr>
<p>或者使用一个pre-trained Encoder Network对generator的输入输出的embedding output越相近越好。</p>
<p><img src="/2020/11/12/GAN-tutorial/image-20201112200554189.png" alt="image-20201112200554189" style="zoom:30%;"></p>
<hr>
<p>使用CycleGAN。</p>
<p>Domain X — G{X-&gt;Y} — Domain Y — G{Y -&gt; X} — Domain X，要让经过了两次generator转换前后的Domain X越相近越好，这就是Domain Consistency。</p>
<p>同样可以做双向的CycleGAN。</p>
<p><img src="/2020/11/12/GAN-tutorial/image-20201112201047739.png" alt="image-20201112201047739" style="zoom:30%;"></p>
<hr>
<p>StarGAN</p>
<h2 id="Projection-to-Common-Space"><a href="#Projection-to-Common-Space" class="headerlink" title="Projection to Common Space"></a>Projection to Common Space</h2><p>Domain X — Encoder of domain X —Common Attribute at latent space— Decoder of domain Y — Domian Y</p>
<h3 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h3><p><img src="/2020/11/12/GAN-tutorial/image-20201112202530838.png" alt="image-20201112202530838" style="zoom:30%;"></p>
<h3 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h3><h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><p><img src="/2020/11/12/GAN-tutorial/image-20201112202648604.png" alt="image-20201112202648604" style="zoom:30%;"></p>
<p>训练Encoder和Decoder就是要Minimizing Reconstruction Error，可以在Decoder的output之后接一个Discriminator of X domain/ Y domain，让Decoder的output不那么模糊。</p>
<p>EncoderX — DecoderX — DiscriminatorX = VAE GAN1</p>
<p>EncoderY — DecoderY — DiscriminatorY = VAE GAN2</p>
<h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><p>问题是红色的training和蓝色的training是两个没有交集的训练路径，完全独立的，训练完之后你发现images with the same attribute may not project to the same position in the latent space。</p>
<p><img src="/2020/11/12/GAN-tutorial/image-20201112203116517.png" alt="image-20201112203116517" style="zoom:30%;"></p>
<hr>
<p>解决办法1</p>
<p>sharing the parameters of encoders and decoders. Encoder共享最后几层的参数，Decoder共享前面几层的参数。</p>
<hr>
<p>解决办法2</p>
<p>给latent space加一个Domain Discriminator去判断这个code vector是来自EncoderX还是EncoderY。</p>
<p><img src="/2020/11/12/GAN-tutorial/drunk99/machacroissant/source/_posts/2020-11-12-GAN-tutorial/image-20201112203451877.png" alt="image-20201112203451877" style="zoom:30%;"></p>
<hr>
<p>解决办法3</p>
<p>Cycle Consistency，类似于CycleGAN，算Image和Image之间的consistency。</p>
<p><img src="/2020/11/12/GAN-tutorial/image-20201112203706067.png" alt="image-20201112203706067" style="zoom:30%;"></p>
<hr>
<p>解决办法4</p>
<p>Semantic Consistency考虑在latent space上的consistency。</p>
<p><img src="/2020/11/12/GAN-tutorial/image-20201112203847559.png" alt="image-20201112203847559" style="zoom:30%;"></p>
]]></content>
      <categories>
        <category>GAN</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>GAN</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel-density-estimation</title>
    <url>/2020/11/14/kernel-density-estimation/</url>
    <content><![CDATA[<h1 id="What-is-KDE"><a href="#What-is-KDE" class="headerlink" title="What is KDE"></a>What is KDE</h1><p>Kernel Density Estimation is a way of estimating an unkonwn probability density function given some data, similar to histogram.</p>
<p>Basic idea is you define a kernel function and you center a kernel function $K$ on each sampledata point $x_i$, and then you sum these functions together, and then you have a kernel density estimate $\hat{f}(x) = \frac{1}{N}\sum\limits_{i=1}\limits^{N} K(x-x_i)$.</p>
<h1 id="Choice-of-Kernel"><a href="#Choice-of-Kernel" class="headerlink" title="Choice of Kernel"></a>Choice of Kernel</h1><h2 id="Attribute-of-Kernel"><a href="#Attribute-of-Kernel" class="headerlink" title="Attribute of Kernel"></a>Attribute of Kernel</h2><p>The kernel function $K$ istypically</p>
<ul>
<li><p>Non-negative: $K(x) \geq 0$ for every $x$，因为描述的是概率</p>
</li>
<li><p>Symmetric: $K(x) = K(-x)$ for every $x$</p>
</li>
<li><p>Decreasing: $K’(x) \leq 0 $ for every $x$，随着x的增大值靠近0</p>
</li>
<li><p>can be bounded support or not，例如高斯核函数就是渐进0但是不为0，而三角和函数就是直接为0。</p>
</li>
</ul>
<h2 id="Four-kinds-of-kernel"><a href="#Four-kinds-of-kernel" class="headerlink" title="Four kinds of kernel"></a>Four kinds of kernel</h2><p>Guassian/Box/Triangle/Triweight</p>
<p><img src="/2020/11/14/kernel-density-estimation/image-20201114225150884.png" alt="image-20201114225150884" style="zoom:40%;"></p>
<p>Choice of Kernel is not that important because as data grows large the final function estimation will look as same. Gaussian will be fine.</p>
<h2 id="Choice-of-Bandwidth"><a href="#Choice-of-Bandwidth" class="headerlink" title="Choice of Bandwidth"></a>Choice of Bandwidth</h2><p>Use $h$ to control for the bandwidth of</p>
<script type="math/tex; mode=display">
\hat{f}(x) = \frac{1}{Nh}\sum\limits_{i=1}\limits^{N} K(\frac{x-x_i}{h})</script><p>感觉bandwidth就是决定了对于每一个数据的核函数的分布函数的分散程度$\sigma$。</p>
<h3 id="Silverman’s-rule-of-thumb"><a href="#Silverman’s-rule-of-thumb" class="headerlink" title="Silverman’s rule of thumb"></a>Silverman’s rule of thumb</h3><p>computes an optimal $h$ by assuming that the data is normally distributed.</p>
<h3 id="Improved-Sheater-Jones-ISJ"><a href="#Improved-Sheater-Jones-ISJ" class="headerlink" title="Improved Sheater Jones(ISJ)"></a>Improved Sheater Jones(ISJ)</h3><p>Multimodel, seveal modes, such as two noraml distributions.</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="Weighting-data"><a href="#Weighting-data" class="headerlink" title="Weighting data"></a>Weighting data</h3><p>it is possible to add weights $w_i$ to data points $x_i$ by writing</p>
<script type="math/tex; mode=display">
\hat{f}(x) = \frac{1}{h}\sum\limits_{i=1}\limits^{N}  w_iK(\frac{x-x_i}{h}), \, where \, \sum\limits_{i=1}\limits^{N}w_i=1</script><h3 id="Bounded-domains"><a href="#Bounded-domains" class="headerlink" title="Bounded domains"></a>Bounded domains</h3><p>A simple trick to overcome bias at boundries is to mirror the data.</p>
<p>在分界处间断点如何确定值？把一侧的数据镜像到另一侧，然后两个分布相加后获得的新的original+mirrored distribution在间断点处做切割，做了mirror的那个部分全为概率0，original的部分采用新的original+mirrored distribution。</p>
<h1 id="Extension-to-d-dimensions"><a href="#Extension-to-d-dimensions" class="headerlink" title="Extension to d dimensions"></a>Extension to d dimensions</h1><p>An approach to $d$-dimensional estiamtes is to wirte</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\hat{f}(x) = \frac{1}{h^d}\sum\limits_{i=1}\limits^{N}  w_iK(\frac{\|x-x_i\|_p}{h}), \, where \, \sum\limits_{i=1}\limits^{N}w_i=1 \\
\|x\|_p := (\sum_{i=1}|x_i|^p)^{1/p}
\end{array}</script><h2 id="the-choice-of-norm"><a href="#the-choice-of-norm" class="headerlink" title="the choice of norm"></a>the choice of norm</h2><p>The shape of kernel functions in higher dimensions depend on the value of <em>p</em>​ in the <em>p</em> norm.</p>
<p>As the number of samples grow, the choice of both kernel <em>K</em> and norm <em>p</em> becomes unimportant. The bandwidth <em>H</em> is still important.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.youtube.com/watch?v=x5zLaWT5KPs&amp;ab_channel=webelod">Intro to Kernel Density Estimation</a></p>
]]></content>
      <tags>
        <tag>ML</tag>
        <tag>Statistics</tag>
      </tags>
  </entry>
  <entry>
    <title>十一月观影总结</title>
    <url>/2020/11/15/my-Nov-films/</url>
    <content><![CDATA[<h1 id="曼达洛人"><a href="#曼达洛人" class="headerlink" title="曼达洛人"></a>曼达洛人</h1><p>第二季来了！制作水平真的好高，有种媲美电影的质感了。</p>
<p>和男朋友讨论剧情，我说“这部剧就是一个曼达洛人带着尤达宝宝一路打怪升级，就是他有任务在身，为了完成这个任务，要找人寻找信息，为了获得信息，要帮人家做事情……”，男朋友听完，直接就和我说你们女的谈剧情真是啰啰嗦嗦，哼。</p>
<h1 id="卡罗尔"><a href="#卡罗尔" class="headerlink" title="卡罗尔"></a>卡罗尔</h1><p>和燃烧女子的肖像一样讲的同性之爱，但是刻画都很粗暴，强行把男人的戏份让一个女的来演的感觉。</p>
<p>卡罗尔的面部特征与身材特征都过于男性化，攻击的一方，连带着在性爱中也是。</p>
<p>售货员小姑娘就像完全被牵着走，服从。</p>
<p>对于两位的关系的进展也很俗套，粗糙。</p>
<p>相比之下更喜欢燃烧女子的肖像中两位女主互相试探、互相牵制、互相吸引的那种感觉。</p>
<h1 id="The-Queen’s-Gambit"><a href="#The-Queen’s-Gambit" class="headerlink" title="The Queen’s Gambit"></a>The Queen’s Gambit</h1><p>Netflix出品，实属爽剧。Elizabeth真的眼睛超大，但是化浓妆好显老，具体请参考E06的末尾。</p>
<p>看完没有学会任何下棋的招数，只知道什么反西西里、后翼弃兵这些神乎其神的招式。</p>
<h1 id="一个叫欧维的男人决定去死"><a href="#一个叫欧维的男人决定去死" class="headerlink" title="一个叫欧维的男人决定去死"></a>一个叫欧维的男人决定去死</h1><p>男朋友给推荐的电影，优酷可以免费观看。一直记成了穿条纹睡衣的男孩，还后还因为记错了和男朋友生了莫名其妙的气，女人啊。</p>
<p>可以说电影就是欧维的一生，以老年丧妻后的生活为起点，回顾了他的少年和中年，少年时期的父亲，中年时期与妻子的爱情，未能降世的宝宝，前半生的所有光都是来自妻子。后来新邻居的到来给欧维的生活带来了一些改变，也让他赴死的决定有了变化。</p>
<p>人生就是陪伴与理解。</p>
<h1 id="大黄蜂Bubblebee"><a href="#大黄蜂Bubblebee" class="headerlink" title="大黄蜂Bubblebee"></a>大黄蜂Bubblebee</h1><p>很美式、很爆米花、很院线的一部电影。我实在是太喜欢大黄蜂那水汪汪的大眼睛了，激起少女心简直不要太容易。</p>
<h1 id="新世纪福音战士"><a href="#新世纪福音战士" class="headerlink" title="新世纪福音战士"></a>新世纪福音战士</h1><p>在Netflix看完了修复版的E01～E24开始看剧场版Air以及真心为你，算是完整了一下故事线。</p>
<p>和男友讨论了挺多隐喻与映射，模糊的呈现虽然能来多样化的解读，但另一方面却不能形成一个完成的体系。很多隐喻没有办法一一对应地从集合A到集合B，边界模糊，令人头疼。</p>
<p>观看的过程也相当于是解读的过程，所以看起来很累，并没有多少娱乐度。</p>
<h1 id="播客"><a href="#播客" class="headerlink" title="播客"></a>播客</h1><p>最近开始听播客了，契机是ActNormal这位b站up主组合，但是他们已经一个月没更新啦，因为大雪回国了，希望Maymay和大雪能再次合体ActNormal。</p>
<p>听播客感觉是接受信息的一个很好的渠道，尤其是在吃饭、运动、走路的时候。</p>
<ul>
<li><p>文化有限</p>
<p>有男女主播一起，能够提供多性视角。观点性较强。</p>
</li>
<li><p>ActNormal来都来了</p>
<p>我爱大雪和Maymay！与其说是评论，他们更多是在分享</p>
</li>
<li><p>路人抓马</p>
<p>和男友讨论了一期内容，是拒绝闲聊语境下其中一位女主播的相亲故事，男朋友还吐槽了该女主播的处事方式。</p>
</li>
<li><p>喷嚏</p>
<p>感觉更像两位女导演之间经历的分享，观点性较弱。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>好好生活</category>
      </categories>
      <tags>
        <tag>观影</tag>
        <tag>审美</tag>
      </tags>
  </entry>
  <entry>
    <title>Feature Extraction with GAN</title>
    <url>/2020/11/17/GANwithfeatureextraction/</url>
    <content><![CDATA[<h1 id="InfoGAN"><a href="#InfoGAN" class="headerlink" title="InfoGAN"></a>InfoGAN</h1><p>InfoGAN希望输入数据的每一个维度代表着输出图像的某个特定特征，改变输入数据的某个维度，输出图像会同时有某一特征的改变，即解决input feature对output影响不明显的问题。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>和普通的GAN主要由两个地方的不同。</p>
<p>第一，input vector被分成了两个部分，第一个部分c代表了输出图像的特征的集合，z‘代表了纯粹随机的无法解释的部分。</p>
<p>第二，generator的输出被添加到两个路径，一个是到discriminator，一个是到classifier。classifier的作用是能根据generator的output x反推获得generator的input中代表特征的那个部分。但是如果没有discriminator，generator可能就偷懒直接把input c的部分直接放到output x，然后让classifier很方便就读出来。discriminator要让generator去创造。</p>
<p><img src="/2020/11/17/GANwithfeatureextraction/image-20201118084308113.png" alt="image-20201118084308113" style="zoom:40%;"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>input characteristic c must have a clear influence on x; The classifier can recover c from x.</p>
<h1 id="GAN-AutoEncoder"><a href="#GAN-AutoEncoder" class="headerlink" title="GAN + AutoEncoder"></a>GAN + AutoEncoder</h1><p>应用在Interactive Photo Enditing中。</p>
<p>第一步，对于给一张image，投射到image embedding space中，变成一个code。</p>
<p>第二步，在这个code的向量空间内稍作移动就可以实现更改了某一特征（user给的constraint），但总体与原来的image相似的图片。</p>
<h2 id="image-back-to-vector"><a href="#image-back-to-vector" class="headerlink" title="image back to vector"></a>image back to vector</h2><p>有三种实现方式。</p>
<p><img src="/2020/11/17/GANwithfeatureextraction/image-20201118110058575.png" alt="image-20201118110058575" style="zoom:50%;"></p>
<h2 id="Editing-photos"><a href="#Editing-photos" class="headerlink" title="Editing photos"></a>Editing photos</h2><p>要找一个满足三个条件的图片。</p>
<p>第一个是user constraint，即要改变图片的某个feature。</p>
<p>第二个是要求计算两个图片的距离相近，即与原图片类似。</p>
<p>第三个是用discriminator来判断图片是否足够real。</p>
<p><img src="/2020/11/17/GANwithfeatureextraction/image-20201118110212780.png" alt="image-20201118110212780" style="zoom:50%;"></p>
<h1 id="VAE-GAN"><a href="#VAE-GAN" class="headerlink" title="VAE-GAN"></a>VAE-GAN</h1><h2 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h2><p><img src="/2020/11/17/GANwithfeatureextraction/image-20201118085429788.png" alt="image-20201118085429788" style="zoom:40%;"></p>
<p>Encoder的任务就是Minimize reconstruction error，并且让output z close to normal(Variational Auto-Encoder)。</p>
<p>Generator as Decoder的任务也是Minimize reconstruction error，并且cheat discriminator。</p>
<p>Discriminator的任务是Discriminate real, generated and reconstructed images。</p>
<blockquote>
<p>注意这里有三种image，一个是real image，一个是generator as decoder的generated image，另一个是decoder as generator的reconstrcuted image。</p>
</blockquote>
<h2 id="WHY-VAE-GAN"><a href="#WHY-VAE-GAN" class="headerlink" title="WHY VAE-GAN"></a>WHY VAE-GAN</h2><p>一方面，从VAE考虑。VAE希望reconstruction error越小越好，也就是希望input x of encoder和output x of decoder as generator越接近越好，但问题是VAE的output不一定会realistic，会很模糊，因为无法衡量loss。</p>
<p>另一方面，从GAN考虑。原来在train GAN，Generator没有看过真正的image长什么样，需要很多时间去调参数。但是加上encoder，他知道真正的image长什么样。</p>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><ul>
<li><p>Initialize En, De, Dis</p>
</li>
<li><p>In each iteration:</p>
<ul>
<li><p>Sample M images $x^1, x^2, \cdots, x^M$ from database</p>
</li>
<li><p>Generate M codes $\tilde{z}^1, \tilde{z}^2, \cdots, \tilde{z}^M$ from encoder $\tilde{z}^i = En(x^i)$</p>
<p>此处是encoder从real image输出的code</p>
</li>
<li><p>Generate M images $\tilde{x}^1, \tilde{x}^2, \cdots, \tilde{x}^M$ from decoder $\tilde{x}^i = De(\tilde{z}^i)$</p>
<p>此处是decoder从encoder的code输出的reconstructed image</p>
<p>以上是auto-encoder的操作流程。</p>
<hr>
</li>
<li><p>Sample M codes $ z^1,z^2, \cdots ,z^M$ from prior $P(z)$</p>
</li>
<li><p>Generate M images $\hat{x}^1, \hat{x}^2, \cdots, \hat{x}^M$ from decoder/generator $\hat{x}^i = De(z^i)$</p>
<p>此处是用从normal distribution中sample出得随机的一个vector当作generator的输入。</p>
<p>以上是GAN的generator部分的操作流程。</p>
<hr>
</li>
<li><p>Update En to decrease $|\tilde{x}^i-x^i|$, decrease $KL(P(\tilde{z}^i|x^i)|P(z))$</p>
</li>
<li><p>Update De to decrease $|\tilde{x}^i-x^i|$, increase $Dis(\tilde{x}^i)$ and $Dis(\hat{x}^i)$</p>
</li>
<li><p>Update Dis to increase $Dis(x^i)$, decrease $Dis(\tilde{x}^i)$ and $Dis(\hat{x}^i)$</p>
</li>
</ul>
</li>
</ul>
<h1 id="BiGAN"><a href="#BiGAN" class="headerlink" title="BiGAN"></a>BiGAN</h1><p>BiGAN也是VAE-GAN的一种变形，还是建立在Encoder/Decoder/Discriminator这三者之上。只不过这些基本单元的连接方式有所不同。</p>
<h2 id="架构-2"><a href="#架构-2" class="headerlink" title="架构"></a>架构</h2><p><img src="/2020/11/17/GANwithfeatureextraction/image-20201118093923976.png" alt="image-20201118093923976" style="zoom:40%;"></p>
<p>和VAE-GAN不同，BiGAN的Encoder和Decoder不再有一个real image和generated image的比较。Encoder和Decoder互相独立。</p>
<p>那如何训练这两者？这个任务在于Discriminator。对于每一对image x和code z的pair，discriminator要判断他来自encoder还是decoder。</p>
<h2 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h2><p>Encoder的输入和输出构成一个disribution，记做$P(x,z)$</p>
<p>Decoder的输入和输出构成一个disribution，记做$Q(x,z)$</p>
<p>Discriminator的作用是evaluate the difference between P and Q</p>
<p>到最后P和Q会是一样的。</p>
<p><img src="/2020/11/17/GANwithfeatureextraction/image-20201118095142014.png" alt="image-20201118095142014" style="zoom:40%;"></p>
<h2 id="Alogorithm"><a href="#Alogorithm" class="headerlink" title="Alogorithm"></a>Alogorithm</h2><ul>
<li><p>Initialize En, De, Dis</p>
</li>
<li><p>In each iteration:</p>
<ul>
<li><p>Sample M images $x^1, x^2, \cdots, x^M$ from database</p>
</li>
<li><p>Generate M codes $\tilde{z}^1, \tilde{z}^2, \cdots, \tilde{z}^M$ from encoder $\tilde{z}^i = En(x^i)$</p>
<p>Encoder生成一个pair</p>
<hr>
</li>
<li><p>Sample M codes $ z^1,z^2, \cdots ,z^M$ from prior $P(z)$</p>
</li>
<li><p>Generate M images $\tilde{x}^1, \tilde{x}^2, \cdots, \tilde{x}^M$ from decoder/generator $\tilde{x}^i = De(z^i)$</p>
<p>Decoder/generater生成一个pair</p>
<hr>
</li>
<li><p>Update Dis to increase $Dis(x^i, \tilde{z}^i)$, decrease $Dis(\tilde{x}^i,  \tilde{z}^i)$ </p>
</li>
<li><p>Update En and De to decrease $Dis(x^i, \tilde{z}^i)$, increase $Dis(\tilde{x}^i,  \tilde{z}^i)$ </p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>同样的还有Triple GAN</p>
</blockquote>
<h1 id="Domain-adversarial-training"><a href="#Domain-adversarial-training" class="headerlink" title="Domain-adversarial training"></a>Domain-adversarial training</h1><p>Testing data and training data are in different domains. How to extract feature of the same distribution via generator.</p>
<p><img src="/2020/11/17/GANwithfeatureextraction/image-20201118100926623.png" alt="image-20201118100926623" style="zoom:40%;"></p>
<h2 id="架构-3"><a href="#架构-3" class="headerlink" title="架构"></a>架构</h2><p><img src="/2020/11/17/GANwithfeatureextraction/image-20201118101225140.png" alt="image-20201118101225140" style="zoom:40%;"></p>
<p>主要由三个部分组成，generator的作用是domain extractor，discriminator的作用是domain classifier，判断feature来自哪个domain。同时需要另外一个class label classifier。</p>
<p>这三个部分可以一起learn，也可以不一起learn。</p>
<blockquote>
<p>simultaneous training还是iterative training？其实fGAN中提出了一种将GAN simultaneous training的方法，但是会不太稳；原始GAN中还是iterative training。</p>
</blockquote>
<h2 id="Feature-Disentangle"><a href="#Feature-Disentangle" class="headerlink" title="Feature Disentangle"></a>Feature Disentangle</h2><h3 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h3><p><img src="/2020/11/17/GANwithfeatureextraction/image-20201118103718044.png" alt="image-20201118103718044" style="zoom:40%;"></p>
<p>在encoder的时候单纯的把input segment输出成一个code，那么这个code可能包含了很多信息，例如phonetic information, speaker information.</p>
<p>如果我们一开始就把code利用feature分开来，细化每一个encoder的任务，那么结果丢进encoder去test的时候reconstruct的效果会更好。</p>
<h3 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h3><p><img src="/2020/11/17/GANwithfeatureextraction/image-20201118103955694.png" alt="image-20201118103955694" style="zoom:40%;"></p>
<p>利用一个speaker classifier当作discriminator来训练前面两个不同“domain”的encoder。</p>
]]></content>
      <categories>
        <category>GAN</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>GAN</tag>
      </tags>
  </entry>
  <entry>
    <title>fGAN+WGAN+EBGAN</title>
    <url>/2020/11/17/fGAN-WGAN-EBGAN/</url>
    <content><![CDATA[<h1 id="f-GAN"><a href="#f-GAN" class="headerlink" title="f-GAN"></a>f-GAN</h1><p>不仅是KL Divergence，其实任何Divergence都可以放到GAN中去Optimize。</p>
<h2 id="Definition-of-f-divergence"><a href="#Definition-of-f-divergence" class="headerlink" title="Definition of f-divergence"></a>Definition of <em>f-divergence</em></h2><script type="math/tex; mode=display">
D_f(P\|Q) = \int_x q(x)f(\frac{p(x)}{q(x)})dx</script><p>where $f$ is convex and $f(x)= 1$. This function evaluates the difference of P and Q. As to how to evaluates depends on the choice of $f$.</p>
<p>当你选择$f = x\log x$，其实就是KL Divergence。</p>
<p>当你选择$f = -\log x$，其实就是Reverse KL。</p>
<h2 id="Fenchel-Conjugate"><a href="#Fenchel-Conjugate" class="headerlink" title="Fenchel Conjugate"></a>Fenchel Conjugate</h2><p>因为<em>f-divergence</em>中的function $f$是convex，所以他有conjugate function(共轭函数)。</p>
<p><img src="/2020/11/17/fGAN-WGAN-EBGAN/image-20201117095651200.png" alt="image-20201117095651200" style="zoom:40%;"></p>
<p>上面的括号里，意思就是给定了p(x)/q(x)/f*()，我们要穷举所有的t，来让括号内的式子最大。</p>
<h2 id="Conjugate-f-divergence-amp-GAN"><a href="#Conjugate-f-divergence-amp-GAN" class="headerlink" title="Conjugate f-divergence &amp; GAN"></a>Conjugate f-divergence &amp; GAN</h2><p>现在由于我们有了Discriminator，我们就不需要去穷举t去解这个max-problem。</p>
<p>虽然任意一个Discriminator不能和上式画等号。</p>
<p><img src="/2020/11/17/fGAN-WGAN-EBGAN/image-20201117100141272.png" alt="image-20201117100141272" style="zoom:40%;"></p>
<p>但是我们找到的那个最好的Discriminator就可以解决这个问题。</p>
<p><img src="/2020/11/17/fGAN-WGAN-EBGAN/image-20201117100218719.png" alt="image-20201117100218719" style="zoom:40%;"></p>
<p>我们在之前的GAN模型</p>
<p><img src="/2020/11/17/fGAN-WGAN-EBGAN/drunk99/machacroissant/source/_posts/2020-11-17-fGAN-WGAN-EBGAN/image-20201117100454088.png" alt="image-20201117100454088" style="zoom:40%;"></p>
<h2 id="Solution-to-Mode-Dropping"><a href="#Solution-to-Mode-Dropping" class="headerlink" title="Solution to Mode Dropping"></a>Solution to Mode Dropping</h2><p>Mode Collapse：Gnerator产生的图看起来都一样。PG的分布与Pdata中的某一个距离过近。</p>
<p>Mode Dropping：Gnerator产生的图都是某一类图，也就是PG的分布与Pdata中的某一类距离过近。Generator switches mode during training。</p>
<p>以上问题出现的一个猜测就是我们的KL divergence选得不够好，选择不同的divergence可能会减轻以上问题，所以这就是<em>f-divergence</em>的应用意义。</p>
<p>或者直接Ensemble，每一个generator发生mode collapse产生一张图。</p>
<h1 id="WHY-improving-GAN"><a href="#WHY-improving-GAN" class="headerlink" title="WHY improving GAN"></a>WHY improving GAN</h1><p>在原始GAN里面，我们用JS divergence/binary classfier衡量两个distribution的相似度。</p>
<p>一方面如果两个分布没有overlap，那么JS divergence总是log2。从直觉上来看，JS Divergence就是一个binary classifier，如果两个分布没有overlap，那么分类器总能把他们分辨开，即100% accuracy。</p>
<p>另一方面，low-dim manifold in high-dim space，数据分布的overlap几乎是可以被忽略的的；就算他们有overlap，我们在对Pdata做sampling的时候如果做的不好PG和Pdata依然会没有overlap。</p>
<h1 id="Least-Square-GAN-LSGAN"><a href="#Least-Square-GAN-LSGAN" class="headerlink" title="Least Square GAN(LSGAN)"></a>Least Square GAN(LSGAN)</h1><p>在Discriminator是一个Binary Classifier的时候，我们的output会经过一个Sigmoid Function，如下图所示。</p>
<p><img src="/2020/11/17/fGAN-WGAN-EBGAN/image-20201117114326905.png" alt="image-20201117114326905" style="zoom:40%;"></p>
<p>蓝色的数据点就代表PG，绿色的数据点就代表Pdata。我们的generator要让蓝色的数据点往右移动与绿色的数据点尽可能重合。问题是这个Sigmoid Function在一开始微分很小，难以移动。</p>
<p>解决办法就是Replace Sigmoid with Linear(replace classification with regression)</p>
<p><img src="/2020/11/17/fGAN-WGAN-EBGAN/image-20201117114616901.png" alt="image-20201117114616901" style="zoom:40%;"></p>
<h1 id="Wasserstein-GAN-WGAN"><a href="#Wasserstein-GAN-WGAN" class="headerlink" title="Wasserstein GAN(WGAN)"></a>Wasserstein GAN(WGAN)</h1><p>WGAN用Earth Mover‘s Distance/Wasserstein Distance来衡量PG和Pdata两个分布的距离。（但不是<em>f-divergence</em>的一种）</p>
<h2 id="W-Distance"><a href="#W-Distance" class="headerlink" title="W Distance"></a>W Distance</h2><p>现在有两堆土，你把一堆土铲倒目标位置去所走的平均距离就是W Distance。</p>
<p>铲土的方法有很多种，哪一个才是最好的？穷举所有possible “moving plans”, Using the “moving plan” with the smallest average distance to define the earth mover’s distance.</p>
<p><img src="/2020/11/17/fGAN-WGAN-EBGAN/image-20201117115807976.png" alt="image-20201117115807976" style="zoom:40%;"></p>
<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>Evaluate Wassertein distance between Pdata and PG</p>
<p><img src="/2020/11/17/fGAN-WGAN-EBGAN/image-20201117120600885.png" alt="image-20201117120600885" style="zoom:40%;"></p>
<p>下面有约束条件D必须是一个Lipschitz Function，这要求D足够的平滑smooth enough。</p>
<p><img src="/2020/11/17/fGAN-WGAN-EBGAN/image-20201117120713059.png" alt="image-20201117120713059" style="zoom:40%;"></p>
<p>1-Lipschitz constraint要求Discriminator这个函数输出的变化不能大于输入的变化。</p>
<h2 id="如何实现1-Lipschitz-Constraint"><a href="#如何实现1-Lipschitz-Constraint" class="headerlink" title="如何实现1-Lipschitz Constraint"></a>如何实现1-Lipschitz Constraint</h2><h3 id="Weight-Clipping"><a href="#Weight-Clipping" class="headerlink" title="Weight Clipping"></a>Weight Clipping</h3><p>原始W-GAN中做法，用gradient asent去train。</p>
<p><img src="/2020/11/17/fGAN-WGAN-EBGAN/image-20201117121328299.png" alt="image-20201117121328299" style="zoom:40%;"></p>
<h3 id="Improved-WGAN-WGAN-GP"><a href="#Improved-WGAN-WGAN-GP" class="headerlink" title="Improved WGAN(WGAN-GP)"></a>Improved WGAN(WGAN-GP)</h3><h4 id="Approximation1"><a href="#Approximation1" class="headerlink" title="Approximation1"></a>Approximation1</h4><p>将1-Lipschitz constraint等价成(if and only if)另一个不等式。这个不等式的意思是我们要D是一个满足1-Lipschitz的function，就相当于对于任何一个x，D对x的微分的norm都要小于等于1。</p>
<p>在原来的V后面加一个penalize的项，如果gradient的norm大于1的话，积分出有结果有penalty，如果graident的norm小于1的话，被积分的那个式子就是0，结果没有penalty。</p>
<p><img src="/2020/11/17/fGAN-WGAN-EBGAN/image-20201117152236486.png" alt="image-20201117152236486" style="zoom:30%;"></p>
<h4 id="Approximation2"><a href="#Approximation2" class="headerlink" title="Approximation2"></a>Approximation2</h4><p>问题在于我们不可能对所有x做积分，因为我们是在做sampling。</p>
<p>再做一次近似，假设x是从某一个事先定义好的distribution P-penalty里sample出来的，我们只保证1-Lipschitz constraint只在P-penalty这个distribution里面成立。</p>
<p><img src="/2020/11/17/fGAN-WGAN-EBGAN/image-20201117153055104.png" alt="image-20201117153055104" style="zoom:50%;"></p>
<hr>
<p>那么如何确定P-penalty的distribution呢？</p>
<p>从Pdata中sample一个点，从PG中sample一个点，在这两个点的连线上做一个random sample，这个sample出来的x就当作是从P-penalty中sample出来的。</p>
<p><img src="/2020/11/17/fGAN-WGAN-EBGAN/image-20201117153645013.png" alt="image-20201117153645013" style="zoom:30%;"></p>
<p>为什么只在蓝色部分给penalty可行？我们希望PG中的点慢慢往左移动到Pdata的位置，generator是看着discriminator给出的gradient的方向update参数的。Only give gradient constraint to the region between Pdata and PG because they influence how PG moves to Pdata 。</p>
<h4 id="Approximation3"><a href="#Approximation3" class="headerlink" title="Approximation3"></a>Approximation3</h4><p><img src="/2020/11/17/fGAN-WGAN-EBGAN/image-20201117154405563.png" alt="image-20201117154405563" style="zoom:30%;"></p>
<h3 id="Spectrum-Norm"><a href="#Spectrum-Norm" class="headerlink" title="Spectrum Norm"></a>Spectrum Norm</h3><p>Keep gradient norm smaller than 1 everywhere</p>
<h2 id="W-GAN-Algorithm"><a href="#W-GAN-Algorithm" class="headerlink" title="W-GAN Algorithm"></a>W-GAN Algorithm</h2><p>一共要更改四个地方。</p>
<p>训练Discriminator的时候，目标函数改成从两个分布的期望相减。可增加penalty或者weight clipping来满足1-Lipschtz constraint。对于D的输出，没有sigmoid，用linear。</p>
<p>训练Generator的时候，目标函数对应修改。</p>
<p><img src="/2020/11/17/fGAN-WGAN-EBGAN/image-20201117155157601.png" alt="image-20201117155157601" style="zoom:50%;"></p>
<h1 id="Energy-based-GAN-EBGAN"><a href="#Energy-based-GAN-EBGAN" class="headerlink" title="Energy-based GAN(EBGAN)"></a>Energy-based GAN(EBGAN)</h1><p>Using an auto-encoder as discriminator D。</p>
<p><img src="/2020/11/17/fGAN-WGAN-EBGAN/image-20201117160028165.png" alt="image-20201117160028165" style="zoom:40%;"></p>
<p>Auto-encoder作为discriminator的一个想法就是丢一张image进去，它的reconstruction error可以通过autoencoder算出来。一张图片越容易被reconstruct就说明它是一张high quality image。</p>
<h2 id="WHY-EBGAN"><a href="#WHY-EBGAN" class="headerlink" title="WHY EBGAN"></a>WHY EBGAN</h2><p>EBGAN的意义在于用auto-encoder实现的discriminator可以用positive examples被pre-train，一开始的discriminator就会很强。</p>
<p>我们一开始用binary-classfier实现discriminator的问题在于要train好一个二元分类器，你要同时拥有好的negative example和positive example。在一开始generator生成的negative example很弱，得到的discriminator也很弱；discriminator要等generator慢慢变强后，才能够变强。</p>
<h2 id="Training-TIPs"><a href="#Training-TIPs" class="headerlink" title="Training TIPs"></a>Training TIPs</h2><p>discriminator的output reconstruction error越靠近0说明图片质量越好，就是要让他们的output越大越好（注意结果经过了一个负号）。</p>
<p>但是你要注意不能让generated example的output越小越好。对于那些output不靠近0的图片，难道图片质量很差，我们就要让他变成很大的negative的值吗？这些很大的negative的值会拖着靠近0的值往下走，因为要求discriminator平滑。我们的训练目的不是minimize reconstruction error。</p>
<p><img src="/2020/11/17/fGAN-WGAN-EBGAN/image-20201117162308824.png" alt="image-20201117162308824" style="zoom:40%;"></p>
<p>所以我们设定一个threshold，告诉discriminator当一张图片的reconstruction error小于这个therehold的时候，就可以了。</p>
]]></content>
      <categories>
        <category>GAN</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>GAN</tag>
      </tags>
  </entry>
  <entry>
    <title>衡量Generator的好坏的方法</title>
    <url>/2020/11/19/outputGANevaluation/</url>
    <content><![CDATA[<h1 id="Likelihood"><a href="#Likelihood" class="headerlink" title="Likelihood"></a>Likelihood</h1><p>传统衡量Generator的方法是用Likelihood。</p>
<p>实现方法就是，目前有一大堆real data(not observed during training)，需要计算通过Generator产生这些指定的data的Log Likelihood。</p>
<h2 id="用Likelihood衡量Generator的问题"><a href="#用Likelihood衡量Generator的问题" class="headerlink" title="用Likelihood衡量Generator的问题"></a>用Likelihood衡量Generator的问题</h2><p>Log Likelihood: $L = \frac{1}{N}\sum\limits_i \log P_G(x^i)$。但是问题是对于指定的$x^i$，我们无法计算$P_G(x^i)$。我们只能说输入一个Prior Distribution from normal distribution z，让它通过generator产生一笔data。</p>
<p>如果我们的Generator只是一个比较简单的Gaussian Mixture Model，那么对于给定data的产生机率是可以比较简单的计算出来的。但是我们又不希望Generator这么简单，我们的模型是十分复杂的。</p>
<h2 id="Kernel-Density-Estimation"><a href="#Kernel-Density-Estimation" class="headerlink" title="Kernel Density Estimation"></a>Kernel Density Estimation</h2><p>先让Generator生成一堆data。假设Each sample is the mean of a Gaussian with the same covariance，然后用KDE去fit这些data，获得实际data分布的一个approximation，然后用每一个real data代入这个distribution获得likelihood。</p>
<h2 id="Likelihood-v-s-Quality"><a href="#Likelihood-v-s-Quality" class="headerlink" title="Likelihood v.s. Quality"></a>Likelihood v.s. Quality</h2><p>但是问题是likelihood和generator的quality没有必然联系。</p>
<ul>
<li>Low likelihood and high quality</li>
</ul>
<p>会发生在Generater产生十分清晰的图像（high quality），但都和做evaluation时用的数据无关，用likelihood来算的时候就是low likelihood。但是你并不能说generator做的不好。</p>
<ul>
<li>High likelihood, low quality</li>
</ul>
<p>G1估测出产生给定图片的likelihood很高，G2产生99%概率的noise，1%概率的好的图片，这些差异在经过Log Likelihood的计算后差距不会很大。</p>
<h1 id="Using-classifier"><a href="#Using-classifier" class="headerlink" title="Using classifier"></a>Using classifier</h1><p>用一个已经训练好的classfier来判断这个object的好坏。</p>
<p>Inception Score就是由以下两个部分组成的。</p>
<p><img src="/2020/11/19/outputGANevaluation/image-20201119201914840.png" alt="image-20201119201914840" style="zoom:50%;"></p>
<h2 id="每张图片的output-distribution越集中越好"><a href="#每张图片的output-distribution越集中越好" class="headerlink" title="每张图片的output distribution越集中越好"></a>每张图片的output distribution越集中越好</h2><p><img src="/2020/11/19/outputGANevaluation/image-20201119200933234.png" alt="image-20201119200933234" style="zoom:40%;"></p>
<p>GAN是在image领域的，那我们就拿一个已经训练好的off-the-shelf image classifier，他的输入是generator的输出的某一张图，他的输出是一个基于输入图像的分布。这个classifier要判断generator的输出属于哪一类图像。如果某一个class的分布越大，说明generator效果越好。</p>
<h2 id="对所有class做平均后的output-distribution越平滑越好"><a href="#对所有class做平均后的output-distribution越平滑越好" class="headerlink" title="对所有class做平均后的output distribution越平滑越好"></a>对所有class做平均后的output distribution越平滑越好</h2><p><img src="/2020/11/19/outputGANevaluation/image-20201119201508854.png" alt="image-20201119201508854" style="zoom:40%;"></p>
<p>机器能产生很清晰的一类图，但是也只限于这一类图。依然需要衡量generator的diversity，要让机器能够产生多个class的图。</p>
<h1 id="No-memory-GAN"><a href="#No-memory-GAN" class="headerlink" title="No memory GAN"></a>No memory GAN</h1><p>我们不希望generator的输出是从database中本来就有的东西。</p>
<h1 id="Mode-Dropping"><a href="#Mode-Dropping" class="headerlink" title="Mode Dropping"></a>Mode Dropping</h1><p>Generator产生的东西多样性不够。</p>
<h2 id="Mini-batch-Discrimination"><a href="#Mini-batch-Discrimination" class="headerlink" title="Mini-batch Discrimination"></a>Mini-batch Discrimination</h2><p>让Discriminator一次性check一把image，那么这样discriminator不仅要关注每一张image各自是否是real的，还需要关注每一张image之间有没有类似。</p>
]]></content>
      <categories>
        <category>GAN</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>GAN</tag>
      </tags>
  </entry>
  <entry>
    <title>Improve Sequence Generation by GAN</title>
    <url>/2020/11/19/sequence-generation/</url>
    <content><![CDATA[<h1 id="Improving-Supervised-Seq2Seq-Model"><a href="#Improving-Supervised-Seq2Seq-Model" class="headerlink" title="Improving Supervised Seq2Seq Model"></a>Improving Supervised Seq2Seq Model</h1><h2 id="Reinforcement-Learning"><a href="#Reinforcement-Learning" class="headerlink" title="Reinforcement Learning"></a>Reinforcement Learning</h2><p>利用Chat-bot Example来讲解Reinforcement Learning在Seq2Seq Model中的实际应用。</p>
<h3 id="Maximum-Likelihood"><a href="#Maximum-Likelihood" class="headerlink" title="Maximum Likelihood"></a>Maximum Likelihood</h3><p>利用MLE来训练Seq2Seq的model存在问题。使用Maximum Likelihood本质就是在Minimize Cross Entropy。</p>
<p>how are you我们希望chat-bot回答I’m fine但是实际对话中如果一个chat-bot有可能回答not bad和I’m Jone，从人的感觉来看not bad是更好的，但从我们定义的MLE来看，第一个单词I’m和正确回答相匹配，那么I’m Jone这个概率会更好。</p>
<h3 id="Reinforcement-Learning-1"><a href="#Reinforcement-Learning-1" class="headerlink" title="Reinforcement Learning"></a>Reinforcement Learning</h3><p>那我们应该用什么方法来判断？Maximizing Expected Reward。Chat-bot是一个系统，和Chat-bot对话的人也是一个系统。Chat-bot依据人给出的Reward反馈update自己的参数，也就是Machine obtains feedback from user。</p>
<p><img src="/2020/11/19/sequence-generation/image-20201119092032885.png" alt="image-20201119092032885" style="zoom:40%;"></p>
<p>整个系统重新连接一下，可以得到以下的形式。</p>
<p><img src="/2020/11/19/sequence-generation/image-20201119092140775.png" alt="image-20201119092140775" style="zoom:40%;"></p>
<p>目标是去调整encoder和generator的参数（也就是Seq2Seq model的参数），使得Human的function R的output越大越好。分为两个步骤，如何定义R的output，以及如何去最大化这个output。</p>
<h4 id="定义Reward-Function-output"><a href="#定义Reward-Function-output" class="headerlink" title="定义Reward Function output"></a>定义Reward Function output</h4><p>如何计算Reward function R的output？对于给定的$\theta$，我们计算reward的期望值。</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\bar{R}_{\theta} &= \sum\limits_cP(c)\sum\limits_xR(c,x)P_{\theta}(x|c)\\
&= E_{c\sim P(c)}[E_{x\sim P_{\theta}(x|c)}R(c,x)] 
\end{array}</script><p>summation over all input c，因为各种各样的input出现的几率各不相同。</p>
<p>summation over all feedback given certain output of chat-bot。由于每次给同样的input，对应的output不一定是一样的，对于给定的c，我们得到的x是不一样的，是一个x的probability，chatbot的output本质上就是一个distribution $P_{\theta}(x|c)$。</p>
<h4 id="最大化Reward-Function-output"><a href="#最大化Reward-Function-output" class="headerlink" title="最大化Reward Function output"></a>最大化Reward Function output</h4><p>Maximizing expected reward就是找一组Seq2Seq模型的参数$\theta$，使得上面定义的Reward Function output 最大。</p>
<script type="math/tex; mode=display">
\theta^{\star} = arg \max_{\theta} \bar{R}_{\theta}</script><p>改写上一步骤中的式子，写成分布的形式。</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\bar{R}_{\theta} 
&= E_{c\sim P(c)}[E_{x\sim P_{\theta}(x|c)}R(c,x)] \\
&= E_{c\sim P(c), x\sim P_{\theta}(x|c) }R(c,x) \\
&\approx \frac{1}{N} \sum\limits_{i=1}^NR(c^i, x^i)
\end{array}</script><p>虽然目标是要取期望值，但是我们没办法真正获得disribution来获得期望值。我们需要一次approximation，从database里做sample，sample出N笔data，即$(c^1, x^1), (c^2,x^2), \cdots, (c^N, x^N)$。</p>
<p>等我们做完approximation之后，发现要去update参数theta，但是最后的式子中哪里有theta？theta的值会影响我们从database中sample的N笔data，没法算gradient。</p>
<hr>
<p>实际操作中先对原式子做gradient，再去做approximation，这样就能把theta保留在我们要去maximize的式子中。</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\nabla\bar{R}_{\theta}  &= \sum\limits_cP(c)\sum\limits_xR(c,x) \nabla P_{\theta}(x|c) \\
&= \sum\limits_cP(c)\sum\limits_xR(c,x)P_{\theta}(x|c) \frac{\nabla P_{\theta}(x|c)}{P_{\theta}(x|c)} \\
&= \sum\limits_cP(c)\sum\limits_xR(c,x)P_{\theta}(x|c) \nabla \log P_{\theta}(x|c) \\
&= E_{c\sim P(c), x\sim P_{\theta}(x|c) } [R(c,x) \nabla \log P_{\theta}(x|c)] \\
&\approx \frac{1}{N} \sum\limits_{i=1}^NR(c^i, x^i)\nabla \log P_{\theta}(x|c_i)
\end{array}</script><p>更新参数的操作如下。</p>
<p><img src="/2020/11/19/sequence-generation/image-20201119100146718.png" alt="image-20201119100146718" style="zoom:40%;"></p>
<p>每次update参数之后，需要和使用者互动N次获得N笔sampling data的reward之后，再去做policy gradient。</p>
<h3 id="两种比较"><a href="#两种比较" class="headerlink" title="两种比较"></a>两种比较</h3><p><img src="/2020/11/19/sequence-generation/image-20201119100944313.png" alt="image-20201119100944313" style="zoom:40%;"></p>
<h4 id="Traning-Data"><a href="#Traning-Data" class="headerlink" title="Traning Data"></a>Traning Data</h4><p>Maximum Likelihood中都是人为标注的label，是全部正确的。</p>
<p>Reinforcement Learning中的的数据都是机器自己产生的，有些答案可能是错的。</p>
<h4 id="Gradient"><a href="#Gradient" class="headerlink" title="Gradient"></a>Gradient</h4><p>ML中每一笔Traning Data的weight都是一样的。</p>
<p>RL中每一个x和c的pair都乘以了一个Reward，意思就是每一笔Traning Data都有weight。如果data中machine的回答是正确的，那么给它一个positive weight；如果data中machine的回答是错误的，那么给它一个negative weight。</p>
<blockquote>
<p>weight有没有可能都是正的？我们希望reward有正有负，一般会对所有正的weight减去一个threshold。</p>
<p>不可能sample到所有的x，对于在一次iteration中没有被sample到的data，他们被sample到的概率会在一次iteration结束后降低。因为总概率总是1，其他被sample到且reward比较大的，被选择的概率就变大了。</p>
</blockquote>
<h2 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h2><p>Reinforcement Learning中为了实现一个较好的machine，需要机器与人互动上万次。时间成本与人力成本过高。</p>
<p>因此引入GAN，human中的feedback由Discriminator来给。类似于Conditional GAN。</p>
<p><img src="/2020/11/19/sequence-generation/image-20201119102742821.png" alt="image-20201119102742821" style="zoom:40%;"></p>
<h3 id="无法微分的三种解决办法"><a href="#无法微分的三种解决办法" class="headerlink" title="无法微分的三种解决办法"></a>无法微分的三种解决办法</h3><p>由于有sampling process，无法将Seq2Seq Model和Discriminator接起来的时候对整个network进行微分。</p>
<h4 id="Gumbel-softmax"><a href="#Gumbel-softmax" class="headerlink" title="Gumbel-softmax"></a>Gumbel-softmax</h4><h4 id="Continuous-Input-for-Discriminator"><a href="#Continuous-Input-for-Discriminator" class="headerlink" title="Continuous Input for Discriminator"></a>Continuous Input for Discriminator</h4><p>Use the distribution as the input of discriminator to avoid sampling process.</p>
<h4 id="Reinforcement-Learning-2"><a href="#Reinforcement-Learning-2" class="headerlink" title="Reinforcement Learning"></a>Reinforcement Learning</h4><h5 id="What"><a href="#What" class="headerlink" title="What"></a>What</h5><p>Consider the output of discriminator as reward </p>
<ul>
<li><p>Update generator to increase discriminator = to get maximum reward</p>
</li>
<li><p>Using the formulation of policy gradient, replace reward R(c,x) with discriminator output D(c,x)</p>
</li>
</ul>
<p>Different from typical RL in that the discriminator would update</p>
<h5 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h5><p><img src="/2020/11/19/sequence-generation/image-20201119104915932.png" alt="image-20201119104915932" style="zoom:40%;"></p>
<p>分为两个步骤，一个是训练generator g-step，与前面RL中的训练方法类似；另一个是训练discriminator d-step，要结合实际对话与机器产生的对话。</p>
<p>但是在g-step中每个iteration的objective function在进行update参数之后，目标是要让log函数的概率变低，也就是说我们要让chat-bot对于某个输入x，不怎么好的输出c的概率降低。问题在于这个概率是对整个句子的概率的衡量，而整个句子的概率是通过每一个短语的条件概率相乘/log相加获得的。如果要decrease整个句子，那每个短语的概率也要decrease？</p>
<p><img src="/2020/11/19/sequence-generation/image-20201119112453832.png" alt="image-20201119112453832" style="zoom:40%;"></p>
<p>我们希望在计算的时候machine知道整个句子虽然是不好的，但是实际increase或decrease的时候需要句子的某些部分。</p>
<p><img src="/2020/11/19/sequence-generation/image-20201119112857282.png" alt="image-20201119112857282" style="zoom:40%;"></p>
<p>因而我们需要修改objective function，换成在每一个timestamp做evaluation，而不是对整个句子做evaluation。</p>
<p><img src="/2020/11/19/sequence-generation/image-20201119113321481.png" alt="image-20201119113321481" style="zoom:40%;"></p>
<h1 id="Unsupervised-Conditional-Sequence-Generation"><a href="#Unsupervised-Conditional-Sequence-Generation" class="headerlink" title="Unsupervised Conditional Sequence Generation"></a>Unsupervised Conditional Sequence Generation</h1><h2 id="Text-Style-Transfer"><a href="#Text-Style-Transfer" class="headerlink" title="Text Style Transfer"></a>Text Style Transfer</h2><p>之前看过Image和Voice之间style transfer的例子。对应到text中，可以把positive sentences对应transfer到negative transfer。</p>
<p>用CycleGAN实现。但是还存在discrete无法gradient ascent的问题。需要把对word sequence做word embedding，就变成连续的了。</p>
<p>用Projection to Common Space。</p>
<p>以上都参考GAN Introduction中的内容。</p>
<h2 id="Unsupervised-Absractive-Summarization"><a href="#Unsupervised-Absractive-Summarization" class="headerlink" title="Unsupervised Absractive Summarization"></a>Unsupervised Absractive Summarization</h2><p>supervised的方法需要收集百万笔的labelled traning data（document1 — summary1），否则machine连产生自己的句子都不能实现（从文章中拿句子当作summary并不算一个好的summarizer）。</p>
<p>所以我们需要unsupervised的方式。利用和CycleGAN差不多的架构。</p>
<p><img src="/2020/11/19/sequence-generation/image-20201119115647507.png" alt="image-20201119115647507" style="zoom:40%;"></p>
<p>实际上看下面需要Minimize the reconstruction error的部分，本质上是a Seq2Seq2Seq auto-encoder。这个部分找到了document — word sequence — document的一个满足的映射。</p>
<p>这个映射人类是否能读懂呢？需要Discriminator来做限制。</p>
<blockquote>
<p>supervised learning是unsupervised learning的upper bound。</p>
<p>我们采用unsupervised的方法的意义在只需要于supervised的方式的data数量的一半就可以达成和supervised的一样的效果。</p>
</blockquote>
<h2 id="Unsupervised-Translation"><a href="#Unsupervised-Translation" class="headerlink" title="Unsupervised Translation"></a>Unsupervised Translation</h2><p>利用CycleGAN可以把两种不同的语言间可以直接unsupervised做翻译。</p>
<p>类似的也可以应用到语音辨识中。</p>
]]></content>
      <categories>
        <category>GAN</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>GAN</tag>
      </tags>
  </entry>
  <entry>
    <title>React数据管理之Hooks与Redux</title>
    <url>/2020/12/04/redux-hooks/</url>
    <content><![CDATA[<h1 id="React-Component-Review"><a href="#React-Component-Review" class="headerlink" title="React Component Review"></a>React Component Review</h1><h2 id="class-component"><a href="#class-component" class="headerlink" title="class component"></a>class component</h2><p>在React的Class组件，主要由四个部分组成。</p>
<p>第一部分是constructor(props){}，在这里声明这个类拥有的全部状态。这一部分属于data/state类别。</p>
<p>第二部分是组件内部用于修改状态的函数，一般都被赋予一个变量，在其他地方被调用。</p>
<p>第三部分是生命周期函数，用于控制该组件在渲染过程的不同阶段会执行什么样的动作，也是一个函数。这一部分属于actions类别。</p>
<p>第四部分也就是render(){}部分，return部分使用JSX表达式，告诉浏览器要如何渲染上面定义的组件。这一部分属于view/UI类别。</p>
<h2 id="function-component"><a href="#function-component" class="headerlink" title="function component"></a>function component</h2><p>函数组件更像是只关心class组件的第四部分，也就是UI部分。不考虑数据与数据的变化。本质上就是DOM createElement的语法糖。</p>
<p>我们在构建网页的时候，一开始只考虑UI，也就是把静态网页先搭建出来，这个时候我们只需要使用函数组件。但是随着功能的复杂化，一开始的函数组件可能需要开始拥有自己的状态与数据了，这个时候需要把函数组件包装到class组件中去，或者重构代码将函数组件重写成class组件；而class组件可能又要被包裹到更高级别的组件中去，这样子层层嵌套十分麻烦。虽然引入了单项数据流的概念，管理与检查错误还是十分麻烦。</p>
<p>因此出现了用于增强函数组件的HOOKs。通过hooks在函数组件内部实现state和action，可能在函数组件之间实现共享state和action。这样一来，功能性上函数组件与HOOKs等同于class组件。</p>
<h1 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h1><blockquote>
<p>Hooks are functions that let you “hook into” React state and lifecycle features from function components.</p>
</blockquote>
<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p><code>useState</code> is a Hook that lets you add React state to function components.</p>
<p>有了useState Hook之后，在一个函数组件被创建且你发现它需要添加状态时，就不需要再把它转换为class组件了。相当于替代了class组件中的第一部分constructor以及第二部分修改状态的函数。</p>
<p>使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">  &#x2F;&#x2F; Declare a new state variable, which we&#39;ll call &quot;count&quot;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br></pre></td></tr></table></figure>
<p>单看等号右边的useState()就相当于声明了一个状态变量，他接受一个初始状态值作为参数。</p>
<p>看等号左边的一个数组，有两个值，第一个是当前状态，第二个是用于更新状态的函数。类比一下class组件，这就相当于this.sate.current_state1和this.setState{current_state1: }这两个语句。</p>
<p>右边赋值给左边用到了array destructing语法，把useState的第一个返回值当前状态赋值给array索引为0的count，把用于更新状态的函数赋值给array索引为1的setCount。</p>
<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><blockquote>
<p>By using useEffect Hook, you tell React that your component needs to do something after render.</p>
</blockquote>
<p>有了useEffect Hook以后，在一个函数组件被创建且每一次的DOM渲染都有可能要执行一些其他动作的时候，就不需要把它转换为class组件并且在class组件内部多次调用生命周期函数了。相当于替代了class组件中第三部分生命周期函数。</p>
<p>需要注意的是不同的业务逻辑的副作用可以用不同的useEffectHook来表现，而在生命周期函数中无论什么业务逻辑都按照生命周期的流程在区分。我们希望<strong>split the code based on what it is doing</strong> rather than a lifecycle method name.。</p>
<p>使用方法如下：</p>
<p>useEffect函数会在每一次render渲染更新的时候运行。不像生命周期函数分为多个mounting和updating之类的多个阶段，他只是run after render。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    function handleStatusChange(status) &#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="effects-with-cleanup"><a href="#effects-with-cleanup" class="headerlink" title="effects with cleanup"></a>effects with cleanup</h3><p>如果在每次渲染并且施加effect之后还需要cleanup this effect，可以在useEffect函数中添加一个return语句，<strong>指明需要cleanup</strong>。类比到class组件就是ComponentDidMount与ComponentWillUnmount这两个生命周期。</p>
<p>在每一次apply the effect之后都会在有一个cleanup this effect；否则不会在调用另一个apply the effect。（？存疑）</p>
<h3 id="useEffect-on-Condition"><a href="#useEffect-on-Condition" class="headerlink" title="useEffect on Condition"></a>useEffect on Condition</h3><p>但是每一次重新渲染都cleaning up or applying the effect会导致性能问题，tell React to <em>skip</em> applying an effect if certain values haven’t changed between re-renders，因此给useEffect函数传入第二个参数，这个参数的形式是由函数内部变量组成的数组，告诉react只在这个内部变量变化时进行effect。在class组件中，通常是在ComponentDidUpdate中进行值的比较，如state或者props。</p>
<h3 id="multiple-effects-to-Separate-Concerns"><a href="#multiple-effects-to-Separate-Concerns" class="headerlink" title="multiple effects to Separate  Concerns"></a>multiple effects to Separate  Concerns</h3><p>由于<strong>useEffect在函数组件内部被调用</strong>，这样useEffect函数就可以访问到函数组件内部的状态，也就是说每一次的after render effect都是不同的state变化引起的不同的effect。</p>
<h2 id="Rules-of-Hooks"><a href="#Rules-of-Hooks" class="headerlink" title="Rules of Hooks"></a>Rules of Hooks</h2><ul>
<li><p>Don’ t call Hooks inside loops, conditions, or nested functions. <strong>Only Call Hooks at the Top Level</strong>.不要在循环、条件、嵌套中使用。</p>
<p>因为每一个hook都有他相关的数据管理域，react通过识别hook的调用顺序来匹配相关数据管理区域。如果有条件或者嵌套，这种顺序就会被打乱。</p>
<blockquote>
<p>As long as the order of the Hook calls is the same between renders, React can associate some local state with each of them.</p>
</blockquote>
</li>
<li><p><strong>Don’ t call Hooks from regular JavaScript functions.</strong>只在函数组件、自定义hook中调用hook。</p>
</li>
<li><p>自定义hook的明明遵循useHook的书写规范。</p>
</li>
</ul>
<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p>Redux是基于React的一个数据/状态管理库。</p>
<p><strong>Redux is a pattern and library for managing and updating application state, using events called “actions”.</strong> </p>
<h2 id="状态-数据管理面临的挑战"><a href="#状态-数据管理面临的挑战" class="headerlink" title="状态/数据管理面临的挑战"></a>状态/数据管理面临的挑战</h2><p>在React的组件中，有两种组件模式。第一种是传统的class组件，通过组件嵌套，state到props的抽象完成数据管理。第二种是函数组件，通过HOOKs API的useState()与useEffect()实现和传统class组件相同的功能。</p>
<p>他们都被称作self-contained app。主要由三个部分组成：</p>
<ul>
<li>The <strong>state</strong>, the source of truth that drives our app;</li>
<li>The <strong>view</strong>, a declarative description of the UI based on the current state</li>
<li>The <strong>actions</strong>, the events that occur in the app based on user input, and trigger updates in the state</li>
</ul>
<p>当我们需要在组件之间共享状态/数据时该怎么做？React核心概念中提出了lifting state up to parent components状态提升至父组件。那这又涉及到抽象与嵌套，state到props的转变，不停地在变换多种组件构成的树component tree，十分麻烦。</p>
<p>一个方法就是把这些所有需要共享的数据/状态抽取出来集中管理，与component tree割裂开来。这也就是Redux的核心思想——This is the basic idea behind Redux: a single centralized place to contain the global state in your application, and specific patterns to follow when updating that state to make the code predictable.</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hooks</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>React+Redux App同步数据流</title>
    <url>/2020/12/06/redux-react-app-example/</url>
    <content><![CDATA[<h1 id="feature-k-Slice"><a href="#feature-k-Slice" class="headerlink" title="feature-k Slice"></a>feature-k Slice</h1><p>首先从某个feature的Slice定义开始。</p>
<h2 id="src下创建文件夹"><a href="#src下创建文件夹" class="headerlink" title="src下创建文件夹"></a>src下创建文件夹</h2><p>在src文件夹下新建一个features文件夹，然后再用具体的该特征feature1为名创建一个子文件夹，最后创建feature1slice.js。整个过程就是src =&gt; features =&gt; feature-k =&gt; feature-kSlice.js。</p>
<p>All of the code related to feature-k should go in the feature-k folder.</p>
<h2 id="initialState与createSlice的export"><a href="#initialState与createSlice的export" class="headerlink" title="initialState与createSlice的export"></a>initialState与createSlice的export</h2><p>在feature-kSlice.js中，使用createSlice API创建reducer function。reducer function需要一些initial data 传入，因为在初次加载的时候store中的数据才有会值，才方便我们做UI component。</p>
<ol>
<li><p>用const和数组创建用来描述这部分数据的fake object，取名为initialState，并把它传入createSlice去。</p>
</li>
<li><p>用createSlice创建feature-kSlice变量，主要是name，initialState，reducers。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createSlice &#125; from &#39;@reduxjs&#x2F;toolkit&#39;</span><br><span class="line"></span><br><span class="line">const initialState &#x3D; [</span><br><span class="line">  &#123; id: &#39;1&#39;, title: &#39;First Post!&#39;, content: &#39;Hello!&#39; &#125;,</span><br><span class="line">  &#123; id: &#39;2&#39;, title: &#39;Second Post&#39;, content: &#39;More text&#39; &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const postsSlice &#x3D; createSlice(&#123;</span><br><span class="line">  name: &#39;posts&#39;,</span><br><span class="line">  initialState,</span><br><span class="line">  reducers: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default postsSlice.reducer</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>在feature-kSlice.js中吧reducer function部分export出去<code>export default postsSlice.reducer</code>，从app/store.js中import这个文件<code>import postsReducer from &#39;../features/posts/postsSlice&#39;</code>，并在configureStore中添加该reducer。</p>
<hr>
<p>完成以上几个步骤之后，运行这个程序并用redux devtools检查工具是可以看到state标签中给出的初始化数据initialState的。</p>
</li>
</ol>
<blockquote>
<p>createSlice的export分为两个部分，第一个是在定义createSlice的reducer时同步生成的action的export，第二个是整体reducer的export到App.js。因为这里最初还没有添加actions和reducers，所以没有export actions。</p>
</blockquote>
<h1 id="feature-k-UI-component"><a href="#feature-k-UI-component" class="headerlink" title="feature-k UI component"></a>feature-k UI component</h1><p>因为我们在这个feature中已经有了一些initial state/fake object array，因此在该feature下开始考虑UI component。由于UI component本身也分层级，我们最最顶层的postList.js开始考虑。</p>
<p>在import完了必要的API之后，export const UI1 = () =&gt; {}会跟一个箭头函数，这个函数内部会涉及store数据取用，html相关UI描述，最后return的内容就是整体UI模块。</p>
<h2 id="使用selector从redux-store获取data"><a href="#使用selector从redux-store获取data" class="headerlink" title="使用selector从redux store获取data"></a>使用selector从redux store获取data</h2><p>为了从redux store获得data，需要使用useSelector Hook。useSelector Hook会使用Provider包裹起来的所有组件部分都能够访问到作为参数传入进去的全局数据store。在UI组件中调用他，只会返回被该组件需要的特定数据。</p>
<p> The “selector functions” that you write will be called with the entire Redux <code>state</code> object as a parameter, and should return the specific data that this component needs from the store.</p>
<h2 id="写UI"><a href="#写UI" class="headerlink" title="写UI"></a>写UI</h2><p>在获取了数据之后就可以使用map等循环语句开始制作html相关代码块。当最终需要的代码块由多个子模块组成的时候，可以先const定义多个子模块，最后在return()内部组装这些模块。</p>
<h1 id="在顶层APP添加UI"><a href="#在顶层APP添加UI" class="headerlink" title="在顶层APP添加UI"></a>在顶层APP添加UI</h1><p>在结束添加特定UI之后，需要在顶层App.js文件中import该UI，并且修改路由，这个部份涉及路由问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  BrowserRouter as Router,</span><br><span class="line">  Switch,</span><br><span class="line">  Route,</span><br><span class="line">  Redirect</span><br><span class="line">&#125; from &#39;react-router-dom&#39;</span><br><span class="line"></span><br><span class="line">import &#123; PostsList &#125; from &#39;.&#x2F;features&#x2F;posts&#x2F;PostsList&#39;</span><br><span class="line"></span><br><span class="line">function App()&#123;</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Switch&gt;</span><br><span class="line">                &lt;Route </span><br><span class="line">                    exact</span><br><span class="line">            		path&#x3D;&quot;&#x2F;&quot;</span><br><span class="line">            		render&#x3D;&#123;() &#x3D;&gt; (</span><br><span class="line">              		&lt;React.Fragment&gt;</span><br><span class="line">               		&lt;PostsList &#x2F;&gt;</span><br><span class="line">              		&lt;&#x2F;React.Fragment&gt;)&#125;</span><br><span class="line">                &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Switch&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;Router&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>以上涉及的知识静态UI的创建，他的数据都是放在store里面的，并且目前为止reducer是空的。</p>
<p>如果浏览器客户端产生了动态数据该如何处理？比如我们要在原来的postList的UI之上创建一个AddPostForm的UI，这个UI会因为用户的交互产生数据呢？如何做到UI compoennt一方的数据和store一方的数据保持一致呢？</p>
<h1 id="UI-component内部数据管控"><a href="#UI-component内部数据管控" class="headerlink" title="UI component内部数据管控"></a>UI component内部数据管控</h1><p>这里所说的UI component内部数据管控是什么意思呢？这是因为当用户在客户端浏览器对UI进行输入，修改，点击等操作的时候，作用的对象都是UI component。UI component内部应当有管理这些数据的函数，这就需要用到React Hook中的useState API。在UI component中首先需要启用useState()产生data1和setdata1函数。</p>
<p>每一次绑定了data1数据的UI发生变更的时候，放在UI component的onClick/onChange属性中的监听函数就会发现这个变更，调用回调函数ondata1Changed，而回调函数函数本身就是由useState hook的setdata1构成。这个监听函数就被放在。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> import React, &#123; useState &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">export const AddPostForm &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [title, setTitle] &#x3D; useState(&#39;&#39;)</span><br><span class="line"></span><br><span class="line">  const onTitleChanged &#x3D; e &#x3D;&gt; setTitle(e.target.value)</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">      &lt;h2&gt;Add a New Post&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label htmlFor&#x3D;&quot;postTitle&quot;&gt;Post Title:&lt;&#x2F;label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type&#x3D;&quot;text&quot;</span><br><span class="line">          id&#x3D;&quot;postTitle&quot;</span><br><span class="line">          name&#x3D;&quot;postTitle&quot;</span><br><span class="line">          value&#x3D;&#123;title&#125;</span><br><span class="line">          onChange&#x3D;&#123;onTitleChanged&#125;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">        &lt;button type&#x3D;&quot;button&quot;&gt;Save Post&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;form&gt;</span><br><span class="line">    &lt;&#x2F;section&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程概述为：</p>
<p>用户对input UI进行输入</p>
<p>=&gt; onChange事件监听函数检测到input change </p>
<p>=&gt; 调用该事件监听函数的回调函数 </p>
<p>=&gt; 回调函数内部通过e.target/event target对象读取UI的value，配合useState在函数UI组件内部调用setdata1，最终完成data1的更新。</p>
<h1 id="UI-component与store通信"><a href="#UI-component与store通信" class="headerlink" title="UI component与store通信"></a>UI component与store通信</h1><p>在完成UI组件内部的数据用useState Hook更新储存之后，这些数据要传递到store。有可能UI组件内部储存的数据无条件的同步到store，也有可能用户的某个行为，如保存/确认/发送，出发了UI组件与store的同步。</p>
<blockquote>
<p>需要注意的是useState总是动态追踪变化，比如一个input的内容，在用户输入的过程中，useState也会更随着更新；而将数据同步到store的都是最终数据，global的数据，the latest values for the input fields。</p>
</blockquote>
<h2 id="useDispatch实现UI向store传递数据"><a href="#useDispatch实现UI向store传递数据" class="headerlink" title="useDispatch实现UI向store传递数据"></a>useDispatch实现UI向store传递数据</h2><p>为了实现UI component和store的通信，首先在方法上需要添加useDispatch()方法，以及store中包含的某个reducer。该reducer作为参数传入useDispatch()方法，而该reducer的参数就是UI component需要传递到store的数据，至于传入是多个参数还是一个payload对象需要看creatSlice中reducer的定义方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const AddPostForm &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const dispatch &#x3D; useDispatch()</span><br><span class="line">    const onSavePostClicked &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    if (title &amp;&amp; content) &#123;</span><br><span class="line">      dispatch(</span><br><span class="line">        postAdded(&#123;</span><br><span class="line">          id: nanoid(),</span><br><span class="line">          title,</span><br><span class="line">          content</span><br><span class="line">        &#125;)</span><br><span class="line">      &#x2F;&#x2F; 这里传入的顺序就是createSLice方法中reducer的payload</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      setTitle(&#39;&#39;)</span><br><span class="line">      setContent(&#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">      &lt;h2&gt;Add a New Post&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &#123;&#x2F;* omit form inputs *&#x2F;&#125;</span><br><span class="line">        &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;onSavePostClicked&#125;&gt;</span><br><span class="line">          Save Post</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;form&gt;</span><br><span class="line">    &lt;&#x2F;section&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用createSlice中actionCreator的postAdded传入的是一个对象，这个对象中包含了UI component利用useState存放的数据。actionCreator内部把这个对象用action.payload来引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const postsSlice &#x3D; createSlice(&#123;</span><br><span class="line">  name: &#39;posts&#39;,</span><br><span class="line">  initialState,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    postAdded(state, action) &#123;</span><br><span class="line">      state.push(action.payload)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="action-payload的两种写法"><a href="#action-payload的两种写法" class="headerlink" title="action payload的两种写法"></a>action payload的两种写法</h2><h3 id="默认在reducer中使用action-payload"><a href="#默认在reducer中使用action-payload" class="headerlink" title="默认在reducer中使用action.payload"></a>默认在reducer中使用action.payload</h3><p>以上两个代码块的定义与调用是基于默认的把reducer在UI中作为{}包裹的对象传递到slice中去，在slice的reducer中使用action.payload访问。操作的形式都是对象。</p>
<h3 id="手写action-creator与payload自定义"><a href="#手写action-creator与payload自定义" class="headerlink" title="手写action creator与payload自定义"></a>手写action creator与payload自定义</h3><p>Right now, we’re generating the ID and creating the payload object in our React component, and passing the payload object into <code>postAdded</code>. </p>
<hr>
<p>手写actioncreators的一个好处就是可以自定义action的payload。需要注意的是这个id的生成不能在reducer中去生成，不然数据流都是不可预测的。在上面的例子中，id的随机生成是在UI component中完成的。在下面的例子中因为手写了action creator所以能够自定义payload。</p>
<blockquote>
<p>If an action needs to contain a unique ID or some other random value, always generate that first and put it in the action object. <strong>Reducers should never calculate random values</strong>, because that makes the results unpredictable.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; hand-written action creator</span><br><span class="line">function postAdded(title, content) &#123;</span><br><span class="line">  const id &#x3D; nanoid()</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &#39;posts&#x2F;postAdded&#39;,</span><br><span class="line">    payload: &#123; id, title, content &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然createSlice只要写了reducer就能自动生成action creator，但是我们如何在给自动生成的action creator定义我们想要的payload呢？玩意需要传递的数据十分复杂呢？</p>
<h3 id="createSlice中自定义payload的prepare-callback-function"><a href="#createSlice中自定义payload的prepare-callback-function" class="headerlink" title="createSlice中自定义payload的prepare callback function"></a>createSlice中自定义payload的prepare callback function</h3><p>createSlice允许我们在reducer对象的某个特定reducer中给该reducer和action creator定义payload，只需要在定义reducer的同时定义prepare callback function即可，即define a “prepare callback” function when we write a reducer。</p>
<p>prepare函数的定义时传入的参数就和手写action creator传入的参数是一样的，都是从UI component处获得的。该函数返回一个payload filed对象，里面就是该reducer与action creator的payload。</p>
<blockquote>
<p>The “prepare callback” function can take multiple arguments, generate random values like unique IDs, and run whatever other synchronous logic is needed to decide what values go into the action object. It should then return an object with the <code>payload</code> field inside. </p>
</blockquote>
<p>当我们在UI component中调用这个action creator的时候，传入reducer函数的参数就是多个组成payload的元素，而不再是一个对象。</p>
<h3 id="两种定义方式的比较"><a href="#两种定义方式的比较" class="headerlink" title="两种定义方式的比较"></a>两种定义方式的比较</h3><h4 id="默认action-payload"><a href="#默认action-payload" class="headerlink" title="默认action.payload"></a>默认action.payload</h4><p>createSlice定义reducer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const postsSlice &#x3D; createSlice(&#123;</span><br><span class="line">  name: &#39;posts&#39;,</span><br><span class="line">  initialState,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    postAdded: &#123;</span><br><span class="line">      reducer(state, action) &#123;</span><br><span class="line">        state.push(action.payload)</span><br><span class="line">      &#125;,</span><br><span class="line">      prepare(title, content, userId) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          payload: &#123;</span><br><span class="line">            id: nanoid(),</span><br><span class="line">            title,</span><br><span class="line">            content,</span><br><span class="line">            user: userId</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; other reducers</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>UI组件调用reducer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const onSavePostClicked &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    if (title &amp;&amp; content) &#123;</span><br><span class="line">      dispatch(postAdded(title, content, userId))</span><br><span class="line">      setTitle(&#39;&#39;)</span><br><span class="line">      setContent(&#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="prepare-callbackfunction"><a href="#prepare-callbackfunction" class="headerlink" title="prepare callbackfunction"></a>prepare callbackfunction</h4><p>createSlice定义reducer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这部分内容包裹在postSlice中</span><br><span class="line">postUpdated(state, action)&#123;</span><br><span class="line">            const &#123; id, title, content &#125; &#x3D; action.payload</span><br><span class="line">            const existingPost &#x3D; state.find(post &#x3D;&gt; post.id &#x3D;&#x3D;&#x3D; id)</span><br><span class="line">            if(existingPost)&#123;</span><br><span class="line">                existingPost.title &#x3D; title</span><br><span class="line">                existingPost.content &#x3D; content</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>
<p>UI组件调用reducer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const onSavePostClicked &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        if(title &amp;&amp; content)&#123;</span><br><span class="line">            dispatch(postUpdated(&#123;id: postId, title, content&#125;))</span><br><span class="line">            history.push(&#96;&#x2F;posts&#x2F;$&#123;postId&#125;&#96;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="多个单页UI-component与路由"><a href="#多个单页UI-component与路由" class="headerlink" title="多个单页UI component与路由"></a>多个单页UI component与路由</h1><p>在完成了某个具备单独成页性质的UI component之后，需要在顶层文件App.js中将它import并使用Route API添加。</p>
<p>其次需要查看页面间路由，比如从列表页到详情页，需要在列表页添加到详情页的Link API。感觉Link API就有点像href。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>简书项目复刻问题集合</title>
    <url>/2020/12/02/react-project-summary/</url>
    <content><![CDATA[<h1 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a>iconfont</h1><p>iconfont也就是把icon当font来用，通过自定义font-face实现。线上有许多iconfont库可供使用。</p>
<p>一般iconfont解压缩后的文件夹都会放在整个项目的静态资源文件夹中，即src文件夹下的statics中，这涉及到了webpack在生产环境下打包静态资源的问题，与其他图片字体的引用一致，具体参考<a href="https://juejin.cn/post/6844903502720794638">李熠 从React脚手架工具学习React项目的最佳实践（上）：前端基础配置</a>。</p>
<h2 id="阿里图标库"><a href="#阿里图标库" class="headerlink" title="阿里图标库"></a>阿里图标库</h2><ul>
<li>在线链接引入</li>
<li>下载项目到本地</li>
</ul>
<p>需要注意的是一次性最好把想要添加的图标全罗列进去，否则以后再添加还需要重新替换本地文件。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>由于历史因素使用i标签容纳无语义图标，但是自己在用的时候使用了span元素。</p>
<p>iconfont本意是将icon当作font来使用，所以也可以像字体一样设置颜色color，大小font-size。</p>
<blockquote>
<p>需要注意的是下载的icon的空白部分是透明的还是有背景白色的；也就是要注意边框与实体。</p>
<p><img src="/2020/12/02/react-project-summary/image-20201202174727098.png" alt="image-20201202174727098" style="zoom:50%;"></p>
</blockquote>
<h2 id="icon-a"><a href="#icon-a" class="headerlink" title="icon+a"></a>icon+a</h2><p>当iconfont和超链接a href一起使用的时候，一定要先给a元素width和height，否则a元素就是个没有宽高的空元素，显示不出来。</p>
<h1 id="文字对齐"><a href="#文字对齐" class="headerlink" title="文字对齐"></a>文字对齐</h1><p>这里的文字除了一般文字，还包括iconfont。</p>
<p>以想要对齐的对象为基准。它的父元素，需要设置text-align；它本身，可能需要设置vertical-align。</p>
<h1 id="盒子性质"><a href="#盒子性质" class="headerlink" title="盒子性质"></a>盒子性质</h1><p>由最基础的inline，block，flex，table衍生出了各种混合属性。这些基本盒子性质都是针对于盒子本身及其内容来说的。比如inline的性质就是内容决定盒子，padding和margin都不可以设置，通过设定内容的大小来决定盒子的大小；block的性质就是盒子就是一整行，通过设定盒子本身的大小以及盒子的margin和padding来决定盒子的大小。</p>
<p>而混合属性，比如inline-block，这个属性inline性质代表的是这个元素在上下文中是inline的性质，他不会占据一整行，可以和其他元素一起排列在一行；block性质代表的是这个元素对于自己内部的内容是block性质，可以设置padding，margin等属性把盒子撑开来。</p>
<p>从树的角度来理解，基础属性就只是从父节点出发去审视子节点，但是混合属性就设计了从该节点去向上看父节点，向下看子节点。我们在谈盒子性质，其实是在谈两个元素/标签之间的关系。</p>
<h1 id="定位方式"><a href="#定位方式" class="headerlink" title="定位方式"></a>定位方式</h1><p>此处视角以我们想要让它的位置从正常文档流中脱离的对象来看。应当涉及元素本身和元素的父元素。</p>
<h2 id="absolute-float"><a href="#absolute-float" class="headerlink" title="absolute+float"></a>absolute+float</h2><p>第一步： 在父元素上使用position: absolute，同时确定top bottom left right等值。明确盒子性质最基础的inline/block还是较为复杂的inline-block/flex，以及盒子的属性/box-sizing。</p>
<p>第二步： 在元素上使用float属性。如果该元素和他的相邻的元素之间想要同在一行，那么他们之间是inline的关系；如果该元素和他的相邻元素不想在同一行，那么他们之间是block关系。</p>
<p>第三步： 如有必要，清除该浮动元素对后续元素的影响，使用clear。</p>
<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>第一步： 在父元素上使用display: flex，决定是flex-direction是row还是columnn，是wrap还是nowrap，对于给定width和height的子元素使用align-items和vertical-align进行对齐。</p>
<p>第二步： 在每个子元素上使用flex: XX，这里的单位可以是百分比也可以是数字，用来说明子元素占用父元素的份额。子元素如果有内容的话（其是相对来说该内容也像子元素），还需要自己设置内容居中。</p>
<blockquote>
<p>关于flex布局中flex父元素的子元素定位的问题，好像align-items和vertical-align只支持头尾中这些方式，如果想要特定高度的话，依据百分比自动调节的话还是需要传统定位方式。参考react简书项目login页面的下载app这个flex子元素。</p>
</blockquote>
<h1 id="0或负"><a href="#0或负" class="headerlink" title="0或负"></a>0或负</h1><p>span的图标想放到block的元素内部去，可以先将span设置为inline/inline-block，然后把margin取负值，至于是左还是右看需要。</p>
<div align="center">
<img src="/2020/12/02/react-project-summary/image-20201202223902177.png" alt="image-20201202223902177" style="zoom:30%;"><img src="/2020/12/02/react-project-summary/image-20201202223931227.png" alt="image-20201202223931227" style="zoom:30%;"><img src="/2020/12/02/react-project-summary/image-20201202224019977.png" alt="image-20201202224019977" style="zoom:30%;">
</div>



<p>bottom为0似乎也能实现底部效果。</p>
<h1 id="去除浏览器默认样式"><a href="#去除浏览器默认样式" class="headerlink" title="去除浏览器默认样式"></a>去除浏览器默认样式</h1><p>一般会在src下创建一个全局样式表，是为了消除浏览器客户端的user agent style。要将这个样式添加在APP组件中，然后在index.js中去渲染。</p>
<h1 id="styled-component使用"><a href="#styled-component使用" class="headerlink" title="styled-component使用"></a>styled-component使用</h1><h2 id="教程Reference"><a href="#教程Reference" class="headerlink" title="教程Reference"></a>教程Reference</h2><p><a href="https://medium.com/simply/2-styled-components-9ded1afa8c18">#2: Why I prefer Styled components to build React apps</a></p>
<p><a href="https://styled-components.com/">官方文档</a></p>
<p><a href="https://github.com/hengg/styled-components-docs-zh">中文文档</a></p>
<p><a href="https://juejin.cn/post/6844903589907808269">styled-components：一本通</a></p>
<h2 id="react-router-dom的Link样式"><a href="#react-router-dom的Link样式" class="headerlink" title="react-router-dom的Link样式"></a>react-router-dom的Link样式</h2><p>因为Link标签最终还是被解析为a标签，所以会自带下划线和点击过后的变蓝色，将Link样式化后变成StyledLink使用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">import &#123; Link &#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">import styled from &#x27;styled-components&#x27;;</span><br><span class="line"></span><br><span class="line">const StyledLink = styled(Link)`</span><br><span class="line">    <span class="selector-tag">text-decoration</span>: <span class="selector-tag">none</span>;</span><br><span class="line">    &amp;<span class="selector-pseudo">:focus</span>, &amp;<span class="selector-pseudo">:hover</span>, &amp;<span class="selector-pseudo">:visited</span>, &amp;<span class="selector-pseudo">:link</span>, &amp;<span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">        <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure>
<p>需要记住a标签与Link标签本质上是行内元素，对他设置margin和padding都没有用，通过给a标签与Link标签添加display: block使它变成块级元素后才能实现padding和margin。</p>
<h2 id="待解决的问题"><a href="#待解决的问题" class="headerlink" title="待解决的问题"></a>待解决的问题</h2><p>代码优化与简洁。一开始创建主要是styled的基础使用与模版字符串，至于嵌套等高级性质还没有看，代码较为冗长。 </p>
<h1 id="数据流管理"><a href="#数据流管理" class="headerlink" title="数据流管理"></a>数据流管理</h1><h2 id="slice书写规范"><a href="#slice书写规范" class="headerlink" title="slice书写规范"></a>slice书写规范</h2><p>如果不使用createEntityAdapter来管理store中的数据，而选择手写数据的话，需要注意<strong>数据本身一定是数组</strong>而不是对象构成的，所以在对store中数据修改的时候才能用concat/push这一类的方法。由于数据本身可能还需要描述数据状态的元数据，所以就多了其他的field，从而构成了一个对象。</p>
<p>使用<code>createSlice</code> API自动创建action以及action creators一定会有三个<code>name: &#39;&#39;, initialState, reducers:&#123;&#125;</code>这三个field，而<code>extraReducers:&#123;&#125;</code> 存在与否取决于slice本身以及slice负责的UI是否有异步数据管理的需求。</p>
<hr>
<p><code>reducer</code> field中的数据一定要注意的是：</p>
<ul>
<li>这里的state是指这个slice所管理的state，而不是store全体。</li>
<li>reducer对象中的每一个函数其实都是对应该action/action creator的回调函数，一定要弄明白是<strong>在原state的基础之上增删改</strong>，还是<strong>通过直接return语句覆盖原state</strong>。在initialState定义为{posts: ‘’, id: ‘’, desc: ‘’}对象的情况下,直接的赋值语句state.posts = action.payload会在state对象下重新生成一了posts field来访数据，而不会覆盖初始initialState（当时因为这个调试了好久！）</li>
<li>reducer对象中的回调函数一定要export对应的slice.actions。</li>
<li>reducer对象本身一定也要export default slice到store中去生成全体store。</li>
</ul>
<hr>
<h2 id="从数据store中随机选取数据"><a href="#从数据store中随机选取数据" class="headerlink" title="从数据store中随机选取数据"></a>从数据store中随机选取数据</h2><p>对应到项目中就是推荐作者一栏的换一换，采用的是洗牌算法，对store中的所有数据进行洗牌操作，然后选取(0,5)即可，也可以生成一个随机数，然后加上5。</p>
<p>采用Knuth-Durstenfeld Shuffle，<strong>每次从未处理的数组中随机取一个元素，然后把该元素放到数组的尾部，即数组的尾部放的就是已经处理过的元素</strong>。</p>
<p>算法步骤：</p>
<ol>
<li>选取数组(长度n)中最后一个元素(arr[length-1])，将其与n个元素中的任意一个交换，此时最后一个元素已经确定</li>
<li>选取倒数第二个元素(arr[length-2])，将其与n-1个元素中的任意一个交换</li>
<li>重复第 1 2 步，直到剩下1个元素为止</li>
</ol>
<p>es6实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = arr.length, random;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>!=n)&#123;</span><br><span class="line">        random =  (<span class="built_in">Math</span>.random() * n--) &gt;&gt;&gt; <span class="number">0</span>; <span class="comment">// 无符号右移位运算符向下取整</span></span><br><span class="line">        [arr[n], arr[random]] = [arr[random], arr[n]] <span class="comment">// ES6的结构赋值实现变量互换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异步数据管理"><a href="#异步数据管理" class="headerlink" title="异步数据管理"></a>异步数据管理</h2><p>本项目因为使用了Redux Toolkit，所以在操作异步数据的时候会使用<code>createAsyncThunk</code> API，结合<code>axios</code>一起使用的话流程如下：</p>
<p>在slice中定义异步操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; productSlice.js</span><br><span class="line">import &#123; createSlice,createSelector,PayloadAction,createAsyncThunk,&#125; from &quot;@reduxjs&#x2F;toolkit&quot;;</span><br><span class="line">export const fetchProducts &#x3D; createAsyncThunk(</span><br><span class="line">  &quot;products&#x2F;fetchProducts&quot;, async (_, thunkAPI) &#x3D;&gt; &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">        &#x2F;&#x2F;const response &#x3D; await fetch(&#96;url&#96;); &#x2F;&#x2F;where you want to fetch data</span><br><span class="line">        &#x2F;&#x2F;Your Axios code part.</span><br><span class="line">        const response &#x3D; await axios.get(&#96;url&#96;);&#x2F;&#x2F;where you want to fetch data</span><br><span class="line">        return await response.json();</span><br><span class="line">      &#125; catch (error) &#123;</span><br><span class="line">         return thunkAPI.rejectWithValue(&#123; error: error.message &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const productsSlice &#x3D; createSlice(&#123;</span><br><span class="line">   name: &quot;products&quot;,</span><br><span class="line">   initialState: &#123;</span><br><span class="line">      products: [],</span><br><span class="line">      loading: &quot;idle&quot;,</span><br><span class="line">      error: &quot;&quot;,</span><br><span class="line">   &#125;,</span><br><span class="line">   reducers: &#123;&#125;,</span><br><span class="line">   extraReducers: (builder) &#x3D;&gt; &#123;</span><br><span class="line">      builder.addCase(fetchProducts.pending, (state) &#x3D;&gt; &#123;</span><br><span class="line">        state. products &#x3D; [];</span><br><span class="line">          state.loading &#x3D; &quot;loading&quot;;</span><br><span class="line">      &#125;);</span><br><span class="line">      builder.addCase(</span><br><span class="line">         fetchProducts.fulfilled, (state, &#123; payload &#125;) &#x3D;&gt; &#123;</span><br><span class="line">            state. products &#x3D; payload;</span><br><span class="line">            state.loading &#x3D; &quot;loaded&quot;;</span><br><span class="line">      &#125;);</span><br><span class="line">      builder.addCase(</span><br><span class="line">        fetchProducts.rejected,(state, action) &#x3D;&gt; &#123;</span><br><span class="line">            state.loading &#x3D; &quot;error&quot;;</span><br><span class="line">            state.error &#x3D; action.error.message;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export const selectProducts &#x3D; createSelector(</span><br><span class="line">  (state) &#x3D;&gt; (&#123;</span><br><span class="line">     products: state.products,</span><br><span class="line">     loading: state.products.loading,</span><br><span class="line">  &#125;), (state) &#x3D;&gt;  state</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">export default productsSlice;</span><br></pre></td></tr></table></figure>
<p>在component中使用异步操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; useSelector, useDispatch &#125; from &quot;react-redux&quot;;</span><br><span class="line"></span><br><span class="line">import &#123;</span><br><span class="line">  fetchProducts,</span><br><span class="line">  selectProducts,</span><br><span class="line">&#125; from &quot;path&#x2F;productSlice.js&quot;;</span><br><span class="line"></span><br><span class="line">const dispatch &#x3D; useDispatch();</span><br><span class="line">const &#123; products &#125; &#x3D; useSelector(selectProducts);</span><br><span class="line">React.useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">   dispatch(fetchProducts());</span><br><span class="line">&#125;, [dispatch]); </span><br></pre></td></tr></table></figure>
<p>这里的定义与使用分别在slice和component中是因为异步数据的产生是在server端的，也就是我们要从服务器，或者在本项目中是提前准备好的public文件下的mock数据。如果异步数据的产生是通过用于与UI交互生成的，那么createAsyncThunk的生成就应该在UI中进行。</p>
<p>代码来源<a href="https://stackoverflow.com/questions/60220514/redux-toolkit-and-axios">StackOverflow- redux toolkit and axios</a>。</p>
<h1 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h1><h2 id="两个基本模式"><a href="#两个基本模式" class="headerlink" title="两个基本模式"></a>两个基本模式</h2><p>路由管理采用react-router-dom，基本模式有两个。</p>
<p>第一个模式就是在App顶层组件中使用BrowseRouter包裹Switch再包裹Router与Redirect。一般Router中会有参数传递。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  BrowserRouter as Router,</span><br><span class="line">  Switch,</span><br><span class="line">  Route,</span><br><span class="line">  Redirect,</span><br><span class="line">&#125; from &#39;react-router-dom&#39;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route exact path&#x3D;&quot;&#x2F;&quot;</span><br><span class="line">            render&#x3D;&#123;() &#x3D;&gt; (</span><br><span class="line">              &lt;React.Fragment&gt;</span><br><span class="line">              &#x2F;&#x2F; 此处可以多个组件组合，但是不可传递参数</span><br><span class="line">              &lt;&#x2F;React.Fragment&gt;</span><br><span class="line">            )&#125;</span><br><span class="line">          &#x2F;&gt;</span><br><span class="line">          &lt;Route exact path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;&#125; &#x2F;&gt;</span><br><span class="line">          &lt;Redirect to&#x3D;&quot;&#x2F;&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;Switch&gt;</span><br><span class="line">   &lt;&#x2F;Router&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二个模式就是在组件内部要进行跳转，使用Link标签包括所有能够通过点击到达另一个页面的内容，记得传递参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 某个UI的return部分</span><br><span class="line">&lt;Link to&#x3D;&#123;&#96;&#x2F;posts&#x2F;$&#123;post.id&#125;&#96;&#125; className&#x3D;&quot;button muted-button&quot;&gt; View Post&lt;&#x2F;Link&gt;</span><br></pre></td></tr></table></figure>
<h2 id="参数的传递与获取"><a href="#参数的传递与获取" class="headerlink" title="参数的传递与获取"></a>参数的传递与获取</h2><p>Router的参数传递与Link的参数传递有所不同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route exact path&#x3D;&quot;&#x2F;posts&#x2F;:postId&quot; component&#x3D;&#123;SinglePostPage&#125; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;Link to&#x3D;&#123;&#96;&#x2F;posts&#x2F;$&#123;post.id&#125;&#96;&#125; className&#x3D;&quot;button muted-button&quot;&gt; View Post&lt;&#x2F;Link&gt;</span><br></pre></td></tr></table></figure>
<p>但是对接受这些参数传递的页面的组件来说，处理方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const SinglePostPage &#x3D; ( &#123; match &#125;) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;这里用花括号是因为match是一个对象，包含URL</span><br><span class="line">    const &#123; postId &#125; &#x3D; match.params</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>path和to指向的连接整体会作为一个对象传入UI的函数组件中作为参数，为了提取其中的参数，使用url.params方法，注意这里返回的对象都是字符串类型的。</p>
<p>一般得到链接里的参数后，就会将这个参数作为一个搜寻条件去匹配redux store中的所有数据。这里需要注意，如果redux中的数据id是number类型，而恰巧在useSelector中又使用了全等===符号，那么最后选择出来的结果绝对是undefined。所以<strong>一定要注意url参数和redux store的数据类型匹配</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; UI中选择id匹配的数据</span><br><span class="line">const post &#x3D; useSelector(state &#x3D;&gt; selectPostById(state,postId)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; slice文件</span><br><span class="line">export const selectPostById &#x3D; (state, postId) &#x3D;&gt; state.posts.posts.find(post &#x3D;&gt; post.id &#x3D;&#x3D;&#x3D; postId)</span><br><span class="line">&#x2F;&#x2F; 这写slector中作为参数的state是root redux object，因为这个函数最终是要传入useSelector的，而useSelector的作用对象是全体store。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>iconfont</tag>
        <tag>css布局</tag>
        <tag>styled-component</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux的同步数据流</title>
    <url>/2020/12/06/redux-sync-data-flow/</url>
    <content><![CDATA[<h1 id="Redux-Store"><a href="#Redux-Store" class="headerlink" title="Redux Store"></a>Redux Store</h1><blockquote>
<p>Create a Redux store using the Redux Toolkit <code>configureStore</code> API</p>
</blockquote>
<p>在使用Redux管理React全体数据/状态的时候，可以将全体数据按该app功能function/特征features来划分成不同的Redux Slice，这些数据块被包裹在configureStore方法中，被保存在store.js中。通过顶层文件访问state.redux-slice-name来访问数据块。</p>
<h2 id="什么样的数据才需要放到store中"><a href="#什么样的数据才需要放到store中" class="headerlink" title="什么样的数据才需要放到store中"></a>什么样的数据才需要放到store中</h2><p>Global state that is needed across the app should go in the Redux store. State that’s only needed in one place should be kept in component state.</p>
<p><strong>In a React + Redux app, your global state should go in the Redux store, and your local state should stay in React components.</strong></p>
<h2 id="redux-slice"><a href="#redux-slice" class="headerlink" title="redux slice"></a>redux slice</h2><blockquote>
<p><strong>A “slice” is a collection of Redux reducer logic and actions for a single feature in your app</strong>, typically defined together in a single file. </p>
</blockquote>
<h3 id="configureStore实现redux-slice"><a href="#configureStore实现redux-slice" class="headerlink" title="configureStore实现redux slice"></a>configureStore实现redux slice</h3><p>在文件树中store.js和features/functions这个文件夹在同一层，features/functions文件夹中又是各种redux slices的子文件夹，这些子文件夹的命名就是configureStore中reducer对象的key。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; configureStore &#125; from &#39;@reduxjs&#x2F;toolkit&#39;</span><br><span class="line">import usersReducer from &#39;..&#x2F;features&#x2F;users&#x2F;usersSlice&#39;</span><br><span class="line">import postsReducer from &#39;..&#x2F;features&#x2F;posts&#x2F;postsSlice&#39;</span><br><span class="line">import commentsReducer from &#39;..&#x2F;features&#x2F;comments&#x2F;commentsSlice&#39;</span><br><span class="line"></span><br><span class="line">export default configureStore(&#123;</span><br><span class="line">  reducer: &#123;</span><br><span class="line">    users: usersReducer,</span><br><span class="line">    &#x2F;&#x2F;  Since usersReducer is responsible for updating the state.users slice, we refer to it as a &quot;slice reducer&quot; function.</span><br><span class="line">    &#x2F;&#x2F; reducer对象的key就是features文件夹中的子文件夹名</span><br><span class="line">    posts: postsReducer,</span><br><span class="line">    comments: commentsReducer</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="configureStore手写"><a href="#configureStore手写" class="headerlink" title="configureStore手写"></a>configureStore手写</h3><hr>
<p>以上调用了redux中的configureStore，这是一个封装好的函数。<strong>configureStore内部实现</strong>是怎样的呢？</p>
<p>当我们把花括号包裹起来的{}reducer object传入给configureStore的reducer中去之后，他会把这个对象在传递给combineReducer函数用来生成一个RootReducer。</p>
<hr>
<p>如何<strong>实现手写configureStore</strong>？</p>
<p>configureStore的本质就是把各个slice结合起来RootReducer，这个RootReducer的参数就是普通reducer所要求的state和action，只不过这个state是全体数据的state。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function rootReducer(state &#x3D; &#123;&#125;, action) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    users: usersReducer(state.users, action),</span><br><span class="line">    posts: postsReducer(state.posts, action),</span><br><span class="line">    comments: commentsReducer(state.comments, action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RootReducer也可以通过调用combineReducers这个方法来写。他接受一个包含slice reducers的对象作为参数，返回的就是root reducer函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const rootReducer &#x3D; combineReducers(&#123;</span><br><span class="line">  users: usersReducer,</span><br><span class="line">  posts: postsReducer,</span><br><span class="line">  comments: commentsReducer</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以把这个RootReducer直接传入到configureStore中去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const store &#x3D; configureStore(&#123;</span><br><span class="line">  reducer: rootReducer</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h1><p>Actions本质上就是对象object。这个对象中包括：值为字符串的type field，能够返回action的action creator functions。</p>
<h2 id="手写Actions"><a href="#手写Actions" class="headerlink" title="手写Actions"></a>手写Actions</h2><p>定义各种Actions是复杂且无聊的，因为多个action可能就属于一个功能块。比如论坛中的post板块，可能有post/postUpdated，也可能有post/postDeleted等多个actions。</p>
<p>因此Redux写了一个API把这些工作都集合了起来，这就是createSlice。</p>
<h2 id="使用createSlice写Actions"><a href="#使用createSlice写Actions" class="headerlink" title="使用createSlice写Actions"></a>使用createSlice写Actions</h2><p>Redux Toolkit has a function called <code>createSlice</code>, which takes care of the work of generating action type strings, action creator functions, and action objects. </p>
<p>在createSlice内部需要用字符串定义name，用reducer functions组成的对象定义reducers。同时定义initalstate，因为需要给createSlice传递一个初始状态值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createSlice &#125; from &#39;@reduxjs&#x2F;toolkit&#39;</span><br><span class="line"></span><br><span class="line">export const counterSlice &#x3D; createSlice(&#123;</span><br><span class="line">  name: &#39;  &#39;,</span><br><span class="line">  initialState: &#123; &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    action1: state &#x3D;&gt; &#123; &#125;,</span><br><span class="line">    action2: state &#x3D;&gt; &#123; &#125;,</span><br><span class="line">    action3: (state, action) &#x3D;&gt; &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export const &#123; action1, action2, action3 &#125; &#x3D; counterSlice.actions</span><br><span class="line"></span><br><span class="line">export default counterSlice.reducer</span><br></pre></td></tr></table></figure>
<p>调用createSlice就会自动生成对应的action code。在createSlice中生成的action code的type就从createSlice的name以及每个reducer function的key name而来。比如， <code>&quot;counter&quot;</code> name + the <code>&quot;increment&quot;</code> reducer function generated an action type of <code>&#123;type: &quot;counter/increment&quot;&#125;</code>. </p>
<h2 id="redux-reducer规则"><a href="#redux-reducer规则" class="headerlink" title="redux reducer规则"></a>redux reducer规则</h2><ul>
<li><p>必须是state+action=》state的形式</p>
<p>They should only calculate the new state value based on the <code>state</code> and <code>action</code> arguments</p>
</li>
<li><p>immutable updates/ No mutating states/ 不可以部分数据更新，必须全体更新</p>
<p>They are not allowed to modify the existing <code>state</code>. Instead, they must make <em>immutable updates</em>, by copying the existing <code>state</code> and making changes to the copied values.</p>
<p>但是实现imuutable update每次都需要原来数据的copy，copy的更改，用copy替换原来的数据这三个步骤，十分麻烦。</p>
<p>createSlice和createRedux通过使用Immer library实现了”mutable” update，Immer承担了copy&amp;return的工作，我们只需要关心update和change即可。</p>
<blockquote>
<p>Immer uses a special JS tool called a <code>Proxy</code> to wrap the data you provide, and lets you write code that “mutates” that wrapped data. But, <strong>Immer tracks all the changes you’ve tried to make, and then uses that list of changes to return a safely immutably updated value</strong></p>
</blockquote>
</li>
<li><p>不含异步逻辑</p>
<p>They must not do any asynchronous logic or other “side effects”</p>
</li>
</ul>
<h1 id="异步数据"><a href="#异步数据" class="headerlink" title="异步数据"></a>异步数据</h1><p>同步逻辑的操作流程如下：</p>
<ol>
<li>Actions are dispatched</li>
<li>the store runs the reducers and calculates the new state</li>
<li>the dispatch function finishes. </li>
</ol>
<p>但是当我们需要从一个API获取数据的时候需要使用异步逻辑。</p>
<h2 id="使用thunk实现异步"><a href="#使用thunk实现异步" class="headerlink" title="使用thunk实现异步"></a>使用thunk实现异步</h2><p>使用thunk需要把redux-thunk middleware添加到新建的redux store中。</p>
<hr>
<h3 id="为什么需要middleware？"><a href="#为什么需要middleware？" class="headerlink" title="为什么需要middleware？"></a>为什么需要middleware？</h3><p>因为reducer的设计规则不允许我们把异步逻辑放在里面，之所以要把异步逻辑放在reducer去是因为能够访问到store数据。那异步逻辑放在哪里呢？</p>
<p>如果我们能访问到store，那么书写异步逻辑就不是问题。访问store，并且把disptach的逻辑放到异步函数promise/setTimeout之类的就行。那么这涉及到import store into other files，但这也是不可行的，因为redux的设计不允许这种import store的行为。</p>
<p>解决办法就是用middleware去拓展redux store，让store拥有其他的功能。The Redux store can be extended with “middleware”, which are a kind of add-on or plugin that can add extra abilities.</p>
<hr>
<h3 id="middleware的两个主要功能："><a href="#middleware的两个主要功能：" class="headerlink" title="middleware的两个主要功能："></a>middleware的两个主要功能：</h3><ul>
<li>让使用middleware的代码块有异步逻辑的同时也能访问全体store。</li>
<li>修改普通的dispatch函数，让它可以接受functions or Promises，为不实普通的action objects。The Redux Thunk middleware modifies the store to let you pass functions into <code>dispatch</code>.</li>
</ul>
<hr>
<h3 id="thunk详解"><a href="#thunk详解" class="headerlink" title="thunk详解"></a>thunk详解</h3><p>当使用configureStore创建redux store时，configureStore API会自动配置好thunk。</p>
<blockquote>
<p>A <strong>thunk</strong> is a specific kind of Redux function that can contain asynchronous logic. Thunks are written using two functions:</p>
<ul>
<li><p>An inside thunk function, which gets <code>dispatch</code> and <code>getState</code> as arguments</p>
<p>内部的thunkfunction本质上就是异步函数带有promise或者async之类</p>
</li>
<li><p>The outside creator function, which creates and returns the thunk function</p>
<p>外部的creator function会传入一个从服务器获得的数据</p>
</li>
</ul>
</blockquote>
<h1 id="UI-component访问store"><a href="#UI-component访问store" class="headerlink" title="UI component访问store"></a>UI component访问store</h1><p>The <a href="https://react-redux.js.org/">React-Redux library</a> has <a href="https://react-redux.js.org/api/hooks">a set of custom hooks that allow your React component to interact with a Redux store</a>.</p>
<h2 id="访问state"><a href="#访问state" class="headerlink" title="访问state"></a>访问state</h2><p>最常见的就是用useSelector Hook从全体数据的store中获取你想要的那一部分数据（extract whatever pieces of data it needs from the Redux store state）。</p>
<h3 id="手写slector"><a href="#手写slector" class="headerlink" title="手写slector"></a>手写slector</h3><p>一个功能是允许从state中获取某个值的函数就叫selector。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const selectCount &#x3D; state &#x3D;&gt; state.counter.value</span><br></pre></td></tr></table></figure>
<p>如果我们的UI component能够访问store中的数据，就可以在UI component中如下调用selector函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const count &#x3D; selectCount(store.getState())</span><br><span class="line">console.log(count)</span><br><span class="line">&#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>
<p>问题就在于Our components can’t talk to the Redux store directly, because we’re not allowed to import it into component files. 也就是store不能被import。因此就需要useSelector Hook作为中介与Redux store对话。</p>
<h3 id="使用useSelector-Hook实现"><a href="#使用useSelector-Hook实现" class="headerlink" title="使用useSelector Hook实现"></a>使用useSelector Hook实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const posts &#x3D; useSelector( state &#x3D;&gt; state.posts)</span><br></pre></td></tr></table></figure>
<p>useSelector总会在一个action被dispatched切redux store更新之后重新运行，并比较前后选择的值。如果前后值不相同，useSelector会让相关的组件用新的数据/状态重新渲染。</p>
<h2 id="访问action"><a href="#访问action" class="headerlink" title="访问action"></a>访问action</h2><p>在UI component中，如果用户做了什么行为，会触发action store中的某个action creator，那么我们就能把它当作eventListener一样使用。</p>
<p>但是问题是UI component本身是没有办法访问store的，这个时候需要使用useDispatch Hook。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const dispatch &#x3D; useDispatch()</span><br><span class="line"></span><br><span class="line">render(&#123;</span><br><span class="line">&lt;button</span><br><span class="line">  className&#x3D;&#123;styles.button&#125;</span><br><span class="line">  aria-label&#x3D;&quot;Increment value&quot;</span><br><span class="line">  onClick&#x3D;&#123;() &#x3D;&gt; dispatch(increment())&#125;</span><br><span class="line">&gt;</span><br><span class="line">  +</span><br><span class="line">&lt;&#x2F;button&gt;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Hook如何定位store"><a href="#Hook如何定位store" class="headerlink" title="Hook如何定位store"></a>Hook如何定位store</h2><p>虽然UI子组件可以通过useSelector和useDispatch访问redux store，但是这些hook如何知道他们要访问的store是哪个store？</p>
<p>方法就是在app的入口文件index.js中引入Provider，并把我们希望访问的store作为参数传入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;</span><br><span class="line">import &#39;.&#x2F;index.css&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line"></span><br><span class="line">import store from &#39;.&#x2F;app&#x2F;store&#39;</span><br><span class="line">import &#123; Provider &#125; from &#39;react-redux&#39;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">    &lt;App &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;Provider&gt;,</span><br><span class="line">  document.getElementById(&#39;root&#39;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>redux</tag>
        <tag>slice</tag>
        <tag>store</tag>
        <tag>thunk</tag>
      </tags>
  </entry>
  <entry>
    <title>十二月观影记录</title>
    <url>/2020/12/07/my-dec-films/</url>
    <content><![CDATA[<h1 id="杀马特我爱你"><a href="#杀马特我爱你" class="headerlink" title="杀马特我爱你"></a>杀马特我爱你</h1><p>中午刚听完文化有限关于美国工厂的一期播客，晚上就在男朋友的推荐下看了纪录片杀马特我爱你。感觉可以从以下几个角度看。</p>
<ul>
<li>工厂流水线与工人个性化</li>
</ul>
<p>工厂流水线要求人像机器一样不间歇工作，工资按照做多少零件，每个零件多少钱来算。为了多赚钱，只能多做，不停地做。好像你呆在这个工厂不要出去也没有关系，你所有的一切在这个工厂都可以完成。高强度高密集的工作是对人性的压榨，这种工作模式下人的个性是无法伸展的，没有生活，没有个性。</p>
<p>杀马特的出路，就是用头发来宣誓自己，在极度缺乏安全感的情况下吸引别人的注意力。</p>
<ul>
<li>亚文化与主流文化的冲突</li>
</ul>
<p>杀马特群体本身是自爱的，而不是像网络上描述的那样是自黑和自嘲。我记得影片中戴眼镜穿的西装革履的小哥说，大概是12年还是13年开始，网络上开始出现对杀马特圈子的围剿，可是明明我们只是安守一隅，为什么不能有空间留给我们呢，就那么一片就好。</p>
<p>主流文化的党同伐异，让亚文化在中国社会上存活地异常困难。</p>
<ul>
<li>工作与生活的关系</li>
</ul>
<p>一个刘海姑娘谈起自己妈妈对自己说的话：“哪里需要休假，我一天都在上班也没有关系。”杀马特不想像自己的父辈母辈一样只看着钱。但其实父辈母辈为了赚钱也只是养家糊口，供家庭生计和子女读书，为他人而工作。而在子女一代，他们更希望为自己做些什么。</p>
<ul>
<li>城市与农村的分化</li>
</ul>
<p>罗福兴说：“在城市我都不敢看高楼的，那和我没什么关系。”刚进城打工的时候，可能这个小朋友连自己租的房子都找不到。</p>
<p>农民工与城市没有任何连接，甚至城市本身都是不欢迎不能作为廉价劳动力的农民工的。</p>
<ul>
<li>留守儿童与城市童工</li>
</ul>
<p>杀马特的主要群体都是农民工与农民工二代。刚进城市，心智尚未成熟，可能刚下车行李就被偷了，可能走在路上还要被人骗钱，他们走在城市的街上，面对隐藏在街道上的威胁，他们的内心其实是害怕的，因此他们用上冲的、五颜六色的头发来武装自己。</p>
<h1 id="进击的巨人"><a href="#进击的巨人" class="headerlink" title="进击的巨人"></a>进击的巨人</h1><p>最终季来了！但是时间线还是需要捋一捋。</p>
<h1 id="三和人才市场"><a href="#三和人才市场" class="headerlink" title="三和人才市场"></a>三和人才市场</h1><p>NHK拍的纪录片，反映了一些广东三和地区的社会问题。</p>
<p>看了这么多之后听了这么多之后，发现现状就是在处理问题的时候，往往是解决提出问题的这个人，而不是去解决问题本身。</p>
<h1 id="阳光普照"><a href="#阳光普照" class="headerlink" title="阳光普照"></a>阳光普照</h1><p>感觉节奏有点慢了，后面1.5倍速观看的。比较值得称赞的是配乐和场景。配乐很好听也很应景；很多场面都拍的很日式，看到片头跟焦好像是个日本人。</p>
<p>还有，颜值担当许光汉的嘴为啥是歪的。</p>
<h1 id="十二公民"><a href="#十二公民" class="headerlink" title="十二公民"></a>十二公民</h1><p>男朋友推荐的，改编自十二怒汉的十二公民。3号陪审员也是绝了，演的太好了。</p>
<h1 id="新世纪福音战士剧场版1-11-2-22-3-33"><a href="#新世纪福音战士剧场版1-11-2-22-3-33" class="headerlink" title="新世纪福音战士剧场版1.11/2.22/3.33"></a>新世纪福音战士剧场版1.11/2.22/3.33</h1><p>导演有钱了之后，拍出来的感觉果然也不一样了啊，使徒的形态与攻击方式都变化了很多。期待明年一月的4.44。</p>
<h1 id="窝头会馆"><a href="#窝头会馆" class="headerlink" title="窝头会馆"></a>窝头会馆</h1><p>北京人艺的话剧，在youtube上看的录像。这算是我第一次正儿八经看话剧吧，体验太不一样了。我对话剧的印象还停留在雷雨，就是高中课本上那阴沉沉凄惨惨的讲述家庭人伦的雷雨，就是没啥意思。但是窝头会馆是真的不太一样，台词十分有意思，演员也十分有意思。</p>
<p>总的来说就是——老戏骨集会，一幕背景从头用到尾，台词蹦跶蹦跶隐喻意味还特别强。最喜欢耶稣、关老爷、释加牟尼三足鼎立那一段，笑岔气了；关公双手执刀拿钱和皇上的隐喻也有意思。</p>
<h1 id="钢的琴"><a href="#钢的琴" class="headerlink" title="钢的琴"></a>钢的琴</h1><p>我实在是太喜欢这部片子了！配乐一流！构图一流！色彩一流！演员一流！看这部片子觉得自己就是精神东北人。</p>
<p>看完这部片子的当天，就让男朋友唱了一首心恋给我听，好家伙，他原来是听过这首歌的，只不过到那时候才知道是叫心恋。</p>
<h1 id="白日焰火"><a href="#白日焰火" class="headerlink" title="白日焰火"></a>白日焰火</h1><p>关于演员的演技，我没什么高深的简介。一个演员有多大的能耐让观众投入他的角色，这就是他的演技。我在看廖凡饰的主人公张自力，至少能被他带入那个角色。记得最清楚的是他在雪地里喝得烂醉被人摩托换单车；在摩天轮上桂纶镁和他的对手戏，光影之间的场面；酒桌上推杯换盏后的无奈与心酸。对于我来说记忆的点都是他演的出彩的点。</p>
<p>桂纶镁确实越看越好看啊，一开始觉得不咋地，看到后来就有那清冷出挑的意思了。</p>
<h1 id="hello树先生"><a href="#hello树先生" class="headerlink" title="hello树先生"></a>hello树先生</h1><p>男朋友称这是王宝强演技巅峰之作。怎么说呢，感觉王宝强演技有点流于形式了，就是说精神有问题就一个走路走不出个人样，感觉卡住了弯不过来一样。</p>
<p>可以看出导演想拍很多东西，前半段过于缓慢了，铺垫过多了，反而后半段主人公精神出现了问题之后才显得有看头。</p>
<h1 id="让子弹飞"><a href="#让子弹飞" class="headerlink" title="让子弹飞"></a>让子弹飞</h1><p>绝了！绝了！绝了！台词一流，演技一流。</p>
<h1 id="活着"><a href="#活着" class="headerlink" title="活着"></a>活着</h1><p>色彩太可以了！巩俐太漂亮了！</p>
<h1 id="疯狂的石头"><a href="#疯狂的石头" class="headerlink" title="疯狂的石头"></a>疯狂的石头</h1><p>感觉并不幽默。</p>
<h1 id="无人区"><a href="#无人区" class="headerlink" title="无人区"></a>无人区</h1><p>还是宁浩的片子，个人觉得比疯狂的石头好看。</p>
<p>我发现作为观众我并不讨厌好人坏人泾渭分明，而是讨厌被告诉这是好人坏人，通过自己感知演员演出的角色，从而体会出这是好人这是坏人的感觉并不赖，毕竟这部片子中卖隼的那个坏人是被演的彻彻底底、完完全全的坏。</p>
<h1 id="辩护人"><a href="#辩护人" class="headerlink" title="辩护人"></a>辩护人</h1>]]></content>
      <categories>
        <category>好好生活</category>
      </categories>
      <tags>
        <tag>观影</tag>
        <tag>审美</tag>
      </tags>
  </entry>
  <entry>
    <title>redux-toolkit介绍</title>
    <url>/2020/12/10/redux-toolkit/</url>
    <content><![CDATA[<p>在使用redux toolkit之前需要在项目中安装依赖包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @reduxjs/toolkit</span><br></pre></td></tr></table></figure>
<p>由于redux toolkit本身已经是依赖于redux/redux-thunk/reselect这些依赖包的抽象集合，所以可以不再使用这些基础依赖包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall redux redux-thunk reselect</span><br></pre></td></tr></table></figure>
<p>这些基础依赖包提供的API都能在redux-toolkit中找到。</p>
<h1 id="Store-Setup"><a href="#Store-Setup" class="headerlink" title="Store Setup"></a>Store Setup</h1><h2 id="手写store基础配置"><a href="#手写store基础配置" class="headerlink" title="手写store基础配置"></a>手写store基础配置</h2><p>在redux fundamentals与redux essentials的教程中都涉及了最底层的创建redux store的流程。</p>
<p>为了创建一个redux store，需要经历以下几个步骤：</p>
<ul>
<li>import各个slices中的reducers到rootReducer文件中，combine形成rootReducer</li>
<li>将rootReducer文件中的rootReducer添加到store file中</li>
<li>在store file中import用于配置thunk middleware/applyMiddleware等方法</li>
<li>将多个配置方法使用composeWithDevTools组合起来形成唯一的一个composed store enhancer</li>
<li>调用createStore并传入root reducer和composed store enhancer</li>
</ul>
<h2 id="使用configureStore"><a href="#使用configureStore" class="headerlink" title="使用configureStore"></a>使用configureStore</h2><p>Redux Toolkit提供了<strong>configureStore API</strong>简化以上五个步骤。</p>
<p>configureStore为我们直接提供了以下功能：</p>
<ul>
<li>默认combine slice reducers为rootReducer</li>
<li>跳过rootReducer直接创建redux store</li>
<li>自动添加thunk middleware</li>
<li>自动添加其他一些能够检查mutating updates的middleware，如果我们在slice内部的reducer中进行了mutable updates就会报错</li>
<li>自动将store连接到Redux DevTools Extension</li>
</ul>
<h1 id="Writing-Slices"><a href="#Writing-Slices" class="headerlink" title="Writing Slices"></a>Writing Slices</h1><p>redux store要求对state的变更必须是immutable的，因此在书写slices的时候，需要一遍一遍地先copy原来的obj，再修改原来的obj，再整体return obj。</p>
<p>而且reducer的书写是以switch/case的形式书写的，每一次都需要传入action type进行匹配。</p>
<p>Redux Toolkit提供了createSlice API简化reducer logic and actions。</p>
<h2 id="createSlice优点"><a href="#createSlice优点" class="headerlink" title="createSlice优点"></a>createSlice优点</h2><p>createSlice为我们直接提供了以下功能：</p>
<ul>
<li>直接在reducers对象内部以函数的形式书写case reducers，不需要使用switch/case</li>
</ul>
<blockquote>
<p>We write case reducer functions inside the <code>reducers</code> object, and give them readable names</p>
</blockquote>
<ul>
<li>由于Immer Library的配置，可以在createSlice内部写”mutable update logic”</li>
</ul>
<blockquote>
<p><strong><code>createSlice</code> allows us to safely “mutate” our state!</strong></p>
</blockquote>
<ul>
<li>action creator会因为reducer function的定义而自动生成</li>
</ul>
<blockquote>
<p><strong><code>createSlice</code> will automatically generate action creators</strong> that correspond to each case reducer function we provide</p>
<p>可以通过访问slice.actions.reducerFunctionName来访问自动生成的actioncreator。</p>
<p>action creator的action type就是name filed + reducer field里的function name</p>
</blockquote>
<h2 id="使用createSlice"><a href="#使用createSlice" class="headerlink" title="使用createSlice"></a>使用createSlice</h2><p>createSlice()参数接受一个含有三个主要fielde的对象：</p>
<ul>
<li>name field是自动生成的action creator的action type的前缀</li>
<li>initialState field是reducer的初始状态</li>
<li>reducers field是一个key为string，value为case reducer functions的函数。</li>
</ul>
<hr>
<p>每次一完成createSlice的定义后都有两行需要export的内容。</p>
<p>第一行是需要被import到redux store的reducer整体：<code>export default todosSlice.reducer</code>。</p>
<p>第二行是需要被import到UI component的、自动生成的reducer.actions：<code>export const &#123; todoAdded, todoToggled &#125; = todosSlice.actions</code>。</p>
<hr>
<p>如何为reducer field中的reducer function传递更多的参数？在UI component中调用dispatch的时候传递给dispatch的action的参数是和slice中定义的action.payload是形式上是一致的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; slice file中定义在createSlice的reducer field里的reducer function</span><br><span class="line">reactionAdded(state, action) &#123;const &#123; postId, reaction &#125; &#x3D; action.payload&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; UI component</span><br><span class="line">&lt;button key&#x3D;&#123;name&#125; </span><br><span class="line">        type&#x3D;&quot;button&quot; </span><br><span class="line">        className&#x3D;&quot;muted-button reaction-button&quot;</span><br><span class="line">        onClick&#x3D;&#123;() &#x3D;&gt; dispatch(reactionAdded(&#123;postId: post.id, reaction: name&#125;))&#125;&gt;&#123;emoji&#125; &#123;post.reactions[name]&#125;&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
<p>数据都是以对象的形式，按照key和value的形式一一对应传递的。</p>
<hr>
<p>如果遇到从UI component传入多个参数需要经过某些preparation logic（也就是UI传入的数据要做一些额外的变换）才能作为该action的payload传递到reducer function的情况下，该怎么办？</p>
<p>createSlice提供了为该reducer function添加一个prepare callback function field，用于把UI传过来的数据处理一下，在作为action.payload传递到reducer function中去运行。</p>
<p>在reducers field中将带有prepare callback的函数放在该reducer function名字的对象下，该对象有prepare field和reducer field。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; reducer中createSlice的reducers field</span><br><span class="line">todoColorSelected: &#123;</span><br><span class="line">      reducer(state, action) &#123;</span><br><span class="line">        const &#123; color, todoId &#125; &#x3D; action.payload</span><br><span class="line">        state.entities[todoId].color &#x3D; color</span><br><span class="line">      &#125;,</span><br><span class="line">      prepare(todoId, color) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          payload: &#123; todoId, color &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<blockquote>
<p>When we call the generated action creator, the <code>prepare</code> function will be called with whatever parameters were passed in. It should then create and return an object that has a <code>payload</code> field (or, optionally, <code>meta</code> and <code>error</code> fields)</p>
</blockquote>
<h1 id="Writing-Thunks"><a href="#Writing-Thunks" class="headerlink" title="Writing Thunks"></a>Writing Thunks</h1><p><strong>Redux Toolkit has a <code>createAsyncThunk</code> API that will generate these thunks for us.</strong></p>
<h2 id="createAsyncThunk定义与使用方法"><a href="#createAsyncThunk定义与使用方法" class="headerlink" title="createAsyncThunk定义与使用方法"></a>createAsyncThunk定义与使用方法</h2><p>createAsyncThunk接受两个参数：</p>
<ul>
<li>第一个参数是string类型，作为自动生成的action的action type</li>
<li>第二个参数是返回Promise对象的payload creator callback function。通常用async/await语法书写。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const Thunk1 &#x3D; createAsyncThunk(&#39;feature&#x2F;Thunk1&#39;, async () &#x3D;&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>createAsyncThunk内部会自动生成：三个action creators以及对应的action types，一个在（该thunk function）被调用的时候自动dispatch这些actions的thunk function。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">createAsyncThunk.pending: feature&#x2F;createAsyncThunk&#x2F;pending</span><br><span class="line">createAsyncThunk.fulfilled: feature&#x2F;createAsyncThunk&#x2F;fulfilled</span><br><span class="line">createAsyncThunk.rejected: feature&#x2F;createAsyncThunk&#x2F;rejected</span><br></pre></td></tr></table></figure>
<h2 id="Thunk-generated-action-in-extraReducers"><a href="#Thunk-generated-action-in-extraReducers" class="headerlink" title="Thunk generated action in extraReducers"></a>Thunk generated action in extraReducers</h2><p>注意在我们的slice文件中thunk都是被书写在createSlice外部的，因此createSlice内部的状态是无法监听createSlice本身之外定义的action type的。</p>
<p>为了监听其他地方定义的action type，createSlice提供了extraReducers field。</p>
<p><strong><code>createSlice</code> also accepts an <code>extraReducers</code> option, where we can have the same slice reducer listen for other action types</strong></p>
<p>该field就是一个callback function with a buidler parameter。当我们需要createSlice去监听其他的action type的时候，只要在callback function内部调用<code>builder.addCase(actionCreator, caseReducer)</code>即可。</p>
<h1 id="Normalizing-State"><a href="#Normalizing-State" class="headerlink" title="Normalizing State"></a>Normalizing State</h1><p>normalizing state的好处就是可以用ID寻找任何一项数据本身，而不需要循环整个数组。与其用数组来储存数据本身，不如用对象想储存数据，以及数据相关的元数据，以及错误信息。</p>
<p><strong>Redux Toolkit includes a <code>createEntityAdapter</code> API that has prebuilt reducers for typical data update operations with normalized state</strong>. </p>
<h2 id="createEntityAdapter的内置方法"><a href="#createEntityAdapter的内置方法" class="headerlink" title="createEntityAdapter的内置方法"></a>createEntityAdapter的内置方法</h2><p>Calling <code>createEntityAdapter</code> gives us an “adapter” object that contains several premade reducer functions, including:</p>
<ul>
<li><code>addOne</code> / <code>addMany</code>: add new items to the state</li>
<li><code>upsertOne</code> / <code>upsertMany</code>: add new items or update existing ones</li>
<li><code>updateOne</code> / <code>updateMany</code>: update existing items by supplying partial values</li>
<li><code>removeOne</code> / <code>removeMany</code>: remove items based on IDs</li>
<li><code>setAll</code>: replace all existing items</li>
</ul>
<hr>
<p>以上都是和增删state value相关的操作。</p>
<ul>
<li><code>getInitialState</code>: returns an object that looks like <code>&#123; ids: [], entities: &#123;&#125; &#125;</code>, for storing a normalized state of items along with an array of all item IDs</li>
</ul>
<p>一般getInitialState可以作为createSlice的initialState field的参数传入。</p>
<ul>
<li><code>getSelectors</code>: generates a standard set of selector functions。</li>
</ul>
<p>getSelectors默认自动生成两个selector：返回所有items的数组的selectAll；以及返回一个item的selectById。但是由于这个通用的名称是不具有语境的，我们可以把它换名字变成当前slice语境下的函数。使用array destructing为selector重命名。</p>
<p>由于getSelector不知道应该在redux state tree中的那个分支找这个slice的数据，所以需要传递一个小小的selector来告诉getSelector，要找所有state中的当前slice的state。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; todos slice in whole redux store</span><br><span class="line">export const &#123;</span><br><span class="line">  selectAll: selectTodos,</span><br><span class="line">  selectById: selectTodoById</span><br><span class="line">&#125; &#x3D; todosAdapter.getSelectors(state &#x3D;&gt; state.todos)&#x2F;&#x2F; this slice</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT介绍</title>
    <url>/2020/12/14/JWT-explaination/</url>
    <content><![CDATA[<p>JWT，JSON Web Token，是用户身份认证/authentication的一种方式。JWT通过将用户的登录状态和登陆数据用加密后JSON的格式储存在客户端，服务端依靠这个字符串认定用户身份。</p>
<h1 id="背景与两种认证方式介绍"><a href="#背景与两种认证方式介绍" class="headerlink" title="背景与两种认证方式介绍"></a>背景与两种认证方式介绍</h1><p>传统的认证方式是基于session的用户认证，即session-based authentication。</p>
<p>下图是session认证过程，包括初次建立认证以及后续使用该认证。</p>
<p> <img src="/2020/12/14/JWT-explaination/in-depth-introduction-jwt-session-based-authentication.png" alt="in-depth-introduction-jwt-session-based-authentication" style="zoom:50%;"></p>
<p>在初次建立认证的过程中，一个用户登录到一个网站，server就会为该用户生成session；在本地服务器的数据库中储存该session；返回一个SessionId给client/也就是浏览器，储存到浏览器的cookie中。</p>
<p>server上的session是有expiration time，因此在失效后用户必须重新登录并重新生成另一个session。</p>
<p>在后续使用该认证的过程中，只要生成的session是有效的，每一次client为用户发送一个http请求，包含了SessionId的cookie总会被发送到server。server通过比较http请求中的SessionId和本地数据库中的session进行用户认证，然后返回相应的数据。</p>
<p>基于session的认证存在问题是平台限制。cookie是客户端浏览器拥有的特性，当从手机端native app去访问服务器的时候是没有cookie的，而为了不同的平台去开发多个服务器显然是不划算的，因此就有了Token-based Authentication。</p>
<h1 id="JWT工作原理"><a href="#JWT工作原理" class="headerlink" title="JWT工作原理"></a>JWT工作原理</h1><p>Token-based Authentication初次建立用户认证时，用户登录状态被server编译encoded为一个JSON Web Token，并返回到client去。JWT的储存从server端转移到了client端，server端不再需要去储存用户登录相关的信息。基于client端是手机端还是PC端有区别，基于手机系统也有区别，比如在浏览器当中就是Local Storage，在IOS中就是KeyChain，在Android中就是Shared Preferences。</p>
<p>在后续使用该认证时，client只需要把储存在本地的JWT附送在http请求一并发送（一般都是在http报文的头部）。server会验证JWT并返回response。</p>
<p><img src="/2020/12/14/JWT-explaination/in-depth-introduction-jwt-token-based-authentication.png" alt="in-depth-introduction-jwt-token-based-authentication" style="zoom:50%;"></p>
<p>JWT本身并不是在Encrypt data，可以从下一节JWT的生成看出他只是在Encode data。JWT的目的是证明data是被一个可信任的源产生的。如果有攻击方拿到了JWT数据，照样可以获得用户信息，因此需要使用HTTPS encrpytion。</p>
<h1 id="JWT构成与生成"><a href="#JWT构成与生成" class="headerlink" title="JWT构成与生成"></a>JWT构成与生成</h1><p>JWT本质上就是JSON数据格式，也就是JavaScript对象，由Header，Payload，Signature三部分组成。</p>
<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>Header一般用于说明Token type是JWT，以及使用什么算法来产生后续的Signature，代表了Message authentication code。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><p>Payload用于储存我们想要储存在JWT中用于用户验证的相关信息，如username，userId，email，以及一些standard fields（有点像说明数据meta data）。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;userId&quot;</span>: <span class="string">&quot;abcd12345ghijk&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;bezkoder&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;contact@bezkoder.com&quot;</span>,</span><br><span class="line">  <span class="comment">// standard fields</span></span><br><span class="line">  <span class="attr">&quot;iss&quot;</span>: <span class="string">&quot;zKoder, author of bezkoder.com&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;iat&quot;</span>: <span class="number">1570238918</span>,</span><br><span class="line">  <span class="attr">&quot;exp&quot;</span>: <span class="number">1570238992</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h2><p>Signature的生成是基于前面的payload和header的，分为三个步骤。</p>
<ol>
<li>首先，把header和payload两部分encode，并且用dot拼接起来。<code>const data = Base64UrlEncode(header) + &#39;.&#39; + Base64UrlEncode(payload);</code> </li>
<li><p>其次，对拼接好的前两部分做hash运算，至于用什么加密算法，是在header中alg字段定义好的。<code>const hashedData = Hash(data, secret);</code></p>
</li>
<li><p>最后，对hashing result进行encode，得到Signature。<code>const signature = Base64UrlEncode(hashedData);</code></p>
</li>
</ol>
<h2 id="Combine-three-parts"><a href="#Combine-three-parts" class="headerlink" title="Combine three parts"></a>Combine three parts</h2><p>把上面生成的三个部分用JWT的标准格式拼接起来的到最终的结果<code>header.payload.signature</code>。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">const encodedHeader = base64urlEncode(header);</span><br><span class="line"><span class="comment">/* Result */</span></span><br><span class="line"><span class="string">&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&quot;</span></span><br><span class="line"></span><br><span class="line">const encodedPayload = base64urlEncode(payload);</span><br><span class="line"><span class="comment">/* Result */</span></span><br><span class="line"><span class="string">&quot;eyJ1c2VySWQiOiJhYmNkMTIzNDVnaGlqayIsInVzZXJuYW1lIjoiYmV6a29kZXIiLCJlbWFpbCI6ImNvbnRhY3RAYmV6a29kZXIuY29tIn0&quot;</span></span><br><span class="line"></span><br><span class="line">const data = encodedHeader + &quot;.&quot; + encodedPayload;</span><br><span class="line">const hashedData = Hash(data, secret);</span><br><span class="line">const signature = base64urlEncode(hashedData);</span><br><span class="line"><span class="comment">/* Result */</span></span><br><span class="line"><span class="string">&quot;crrCKWNGay10ZYbzNG3e0hfLKbL7ktolT7GqjUMwi3k&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// header.payload.signature</span></span><br><span class="line">const JWT = encodedHeader + &quot;.&quot; + encodedPayload + &quot;.&quot; + signature;</span><br><span class="line"><span class="comment">/* Result */</span></span><br><span class="line"><span class="string">&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJhYmNkMTIzNDVnaGlqayIsInVzZXJuYW1lIjoiYmV6a29kZXIiLCJlbWFpbCI6ImNvbnRhY3RAYmV6a29kZXIuY29tIn0.5IN4qmZTS3LEaXCisfJQhrSyhSPXEgM1ux-qXsGKacQ&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://bezkoder.com/react-redux-jwt-auth/">Bezkoder.com</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6导入导出声明</title>
    <url>/2020/12/15/import-export-es6/</url>
    <content><![CDATA[<p>模块是自动运行在严格模式下且没有办法退出运行的JavaScript代码。</p>
<p>import和export都是静态关键字。模块的导入和导出有一个重要的限制/原则，必须在在其他语句和函数之外使用，不能动态的通过if语句之类的语法去进行导入导出。</p>
<h1 id="导出语法"><a href="#导出语法" class="headerlink" title="导出语法"></a>导出语法</h1><p>可以导出任何该js文件中的变量、函数、类。</p>
<h2 id="定义时导出声明"><a href="#定义时导出声明" class="headerlink" title="定义时导出声明"></a>定义时导出声明</h2><p>这种导出方法要求导出的函数或者类声明有名称。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件底部导出引用"><a href="#文件底部导出引用" class="headerlink" title="文件底部导出引用"></a>文件底部导出引用</h2><p>这种导出方法要求导出的函数或者类有名称。这里导出的不是声明，而是引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1*num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> multiply;</span><br></pre></td></tr></table></figure>
<h2 id="重命名导出"><a href="#重命名导出" class="headerlink" title="重命名导出"></a>重命名导出</h2><p>使用as关键字来指定函数在模块外应该被称为什么名称。在导入的时候就需要使用as关键字后面跟着的名称来导入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1*num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;multiply <span class="keyword">as</span> mul&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; mul &#125; <span class="keyword">from</span> <span class="string">&#x27;./example.js&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="默认值导出"><a href="#默认值导出" class="headerlink" title="默认值导出"></a>默认值导出</h2><p>模块的默认值是指通过default关键字指定的单个变量、函数、或者类，只能为每一个模块设置一个默认的导出值。在某一个模块中多次使用default关键字导出是语法错误。</p>
<hr>
<ol>
<li>导出匿名函数或类</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上把function作为默认值导出了，且该函数没有名称，也就是说可以用匿名函数导出了。</p>
<p>为什么可以不给函数命名？因为函数被模块所代表了，因此它需要一个名称。</p>
<hr>
<ol>
<li>先定义函数或类，在导出为默认值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1*num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> multiply;</span><br></pre></td></tr></table></figure>
<hr>
<ol>
<li>使用重命名语法结合as导出默认值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1*num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; multiply <span class="keyword">as</span> <span class="keyword">default</span>&#125;</span><br></pre></td></tr></table></figure>
<p>经常用于在一条导出语句中同时指定多个导出内容（包括默认导出）。</p>
<h2 id="导出一切"><a href="#导出一切" class="headerlink" title="导出一切"></a>导出一切</h2><p>导出该模块中的所有值（包括默认值和所有命名导出值/非默认值），使用<code>*</code>模式。有可能影响导出内容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./example.js&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="导入语法"><a href="#导入语法" class="headerlink" title="导入语法"></a>导入语法</h1><p>在模块A中导出的功能通过import 关键字在模块B中访问，import语句主要由两部分组成：要导入的标识符，标识符要从哪个模块倒入。</p>
<h2 id="语法解释"><a href="#语法解释" class="headerlink" title="语法解释"></a>语法解释</h2><p><code>import &#123; identifier &#125; from &#39;./example.js&#39;</code></p>
<p>import语句有一个原则，不管在import语句中把一个模块写了多少次，该模块总是执行一次。也就是<code>from &#39;./example.js&#39;</code>总是只执行一次。</p>
<p>原因在于每一条导入模块的代码执行后，实例化过的模块被保存在内存中。只要另一个import语句引用了该模块，就重复使用储存在内存中的实例化的模块。如果整个应用程序中有其他模块也使用了<code>./example.js</code>，那么这些模块都共同使用内存中的加载过的模块。</p>
<h3 id="需要导入的标识符-identifier"><a href="#需要导入的标识符-identifier" class="headerlink" title="需要导入的标识符 { identifier }"></a>需要导入的标识符 <code>&#123; identifier &#125;</code></h3><p><strong>关键字import后面的大括号表示</strong>从给定模块导入的绑定(binding)。</p>
<h3 id="从哪个模块导入-39-example-js-39"><a href="#从哪个模块导入-39-example-js-39" class="headerlink" title="从哪个模块导入 &#39;./example.js&#39;"></a>从哪个模块导入 <code>&#39;./example.js&#39;</code></h3><p>关键字from表示要从哪个模块导入，其后的<strong>字符串</strong>指定了该导入模块的路径。</p>
<p>指定路径的字符串需要<strong>文件扩展名</strong>。原因有二：第一，浏览器使用的路径格式与传给<code>&lt;script&gt;</code>元素的相同，在script元素中做引用的时候是跟着js扩展的；第二，Node.js基于文件系统前缀区分本地文件和包。例如，example是一个包，但./example.js就是一个本地文件。</p>
<p>指定路径的字符串之前需要<strong>包含<code>/</code>,<code>../</code>, <code>./</code></strong>，目的是更好地兼容多个浏览器和Node.js环境。</p>
<h2 id="导入一或多个绑定"><a href="#导入一或多个绑定" class="headerlink" title="导入一或多个绑定"></a>导入一或多个绑定</h2><p>普通的绑定都需要放在花括号中{}。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;sum&#125; <span class="keyword">from</span> <span class="string">&#x27;./example.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;sum, multiply&#125; <span class="keyword">from</span> <span class="string">&#x27;./example.js&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="导入整个模块-命名空间导入"><a href="#导入整个模块-命名空间导入" class="headerlink" title="导入整个模块/命名空间导入"></a>导入整个模块/命名空间导入</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> example <span class="keyword">from</span> <span class="string">&#x27;./example.js&#x27;</span></span><br><span class="line">example.multiply(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>可以把<code>./example.js</code>整个模块的模块A都导入进模块B作为单一对象<code>example</code>使用，整个模块的所有导出都可以作为对象的属性来使用。</p>
<p>这个导入格式也被称为命名空间导入(namespace import)，因为<code>./example.js</code>文件中并不存在<code>example</code>对象，故而<code>example</code>是作为example.js文件中所有导出成员的命名空间对象被创建的。</p>
<h2 id="重命名导入"><a href="#重命名导入" class="headerlink" title="重命名导入"></a>重命名导入</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mul <span class="keyword">as</span> numti &#125; <span class="keyword">from</span> <span class="string">&#x27;./example.js&#x27;</span></span><br><span class="line">multi(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="默认值导入"><a href="#默认值导入" class="headerlink" title="默认值导入"></a>默认值导入</h2><p>注意<strong>导入默认值是不需要添加花括号</strong>，import后面的不带花括号的名称是当前模块B的<strong>本地名称sum</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sum, &#123; color &#125; <span class="keyword">from</span> <span class="string">&#x27;./example.js&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在同时导入默认值和非默认值的时候，需要<strong>用逗号将默认的本地名称与大括号包裹的非默认值隔开</strong>；且<strong>import语句中，默认值必须排在非默认值之前</strong>。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>import</tag>
        <tag>export</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析中的数据预处理</title>
    <url>/2020/12/17/data-preprocessing/</url>
    <content><![CDATA[<h1 id="数据预处理步骤"><a href="#数据预处理步骤" class="headerlink" title="数据预处理步骤"></a>数据预处理步骤</h1><h2 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h2><p>主要通过填补缺失值、光滑噪声数据、平滑或删除离群点来解决数据的不一致性问题。</p>
<h3 id="缺失值的处理"><a href="#缺失值的处理" class="headerlink" title="缺失值的处理"></a>缺失值的处理</h3><p>先用pandas.isnull.sum()检测出变量的缺失比例，考虑删除或者填充，若需要填充的变量是连续型，一般采用均值法和随机插值进行填充，若变量是离散型，通常采用中位数或哑变量进行填充。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>变量的缺失率较高大于80%、覆盖率较低、重要性较低，删除。</p>
<h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><p>定值填充： 用-9999替代。</p>
<p>统计量填充： 缺失率较低且重要性较低，根据数据的分布情况填充——均匀分布就使用均值填补缺失，倾斜分布就使用中位数进行填补。</p>
<p>插值法填充：包括随机插值，多重差补法，热平台插补，拉格朗日插值，牛顿插值等。</p>
<p>模型填充：使用回归、贝叶斯、随机森林、决策树等模型对缺失数据进行预测。</p>
<p>哑变量填充：变量是离散的、不同值类型较少，可以换成哑变量，例如性别SEX变量，存在male,fameal,NA三个不同的值，可将该列转换成 IS_SEX_MALE, IS_SEX_<em>FEMALE, IS_SEX_NA。</em>三列，用0/1真假值替代。如果某个变量存在几十个不同的值，根据每个值的频数，将较小频数的数据都归类为other，降低维度。</p>
<h3 id="离群点的处理"><a href="#离群点的处理" class="headerlink" title="离群点的处理"></a>离群点的处理</h3><p>将离群点看作影响数据质量的异常点。</p>
<h4 id="检测离群点"><a href="#检测离群点" class="headerlink" title="检测离群点"></a>检测离群点</h4><p><strong>简单统计分析</strong>：根据箱线图、各分位点判断是否存在异常，例如pandas的describe函数可以快速发现异常值。</p>
<p>正态分布的数据应用3-sigma原则</p>
<p>基于绝对离差中位数MAD</p>
<h4 id="处理离群点"><a href="#处理离群点" class="headerlink" title="处理离群点"></a>处理离群点</h4><ul>
<li><p>根据异常点的数量和影响，考虑是否删除这条记录</p>
</li>
<li><p>如果数据做了log-scale对数变换之后消除了异常值，就应用变换后的值</p>
</li>
<li><p>用平均值或中位数代替异常点</p>
</li>
</ul>
<h4 id="噪声处理"><a href="#噪声处理" class="headerlink" title="噪声处理"></a>噪声处理</h4><p>噪声是变量的随机误差和方差，是观测点和真实点之间的误差。</p>
<p>第一种处理办法：对数据进行分箱操作，等频或等宽分箱，然后用每个箱的平均数，中位数或者边界值（不同数据分布，处理方法不同）代替箱中所有的数，起到平滑数据的作用。</p>
<p>第二张处理办法：建立该变量和预测变量的回归模型，根据回归系数和预测变量，反解出自变量的近似值。</p>
<h2 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h2><p>数据集成将多个数据源中的数据结合成、存放在一个一致的数据存储，如数据仓库中。这些源可能包括多个数据库、数据方或一般文件。</p>
<ol>
<li><p>实体识别问题：</p>
<p>数据分析者或计算机如何才能确信一个数 据库中的 <em>customer_id</em> 和另一个数据库中的<em>cust_number</em> 指的是同一实体？利用元数据，也就是描述数据的数据来比避免冗余。</p>
</li>
<li><p>数据冗余问题：</p>
<p>数据库中表的范式相关，第二范式。 用相关性检测冗余：数值型变量可计算相关系数矩阵，标称型变量可计算卡方检验。</p>
</li>
<li><p>数据值的冲突处理：规范化去重。</p>
</li>
</ol>
<h2 id="数据规约"><a href="#数据规约" class="headerlink" title="数据规约"></a>数据规约</h2><p>数据归约技术可以用来得到数据集的归约表示，它小得多，但仍接近地保持原数据的完整性。 这样，在归约后的数据集上挖掘将更有效，并产生相同(或几乎相同)的分析结果。</p>
]]></content>
      <categories>
        <category>DataScience</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>数据预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>终端从bash到zsh与终端代理</title>
    <url>/2020/12/19/bash-to-zsh/</url>
    <content><![CDATA[<p>一个冷知识，zsh该怎么读，我一直读z-s-h三个字母，后来发现应该读z-shell。</p>
<h1 id="从bash到zsh"><a href="#从bash到zsh" class="headerlink" title="从bash到zsh"></a>从bash到zsh</h1><p>参考<a href="https://segmentfault.com/a/1190000021216800">macos上的zsh配置</a>。</p>
<h2 id="shell脚本切换"><a href="#shell脚本切换" class="headerlink" title="shell脚本切换"></a>shell脚本切换</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br><span class="line">chsh -s /bin/bash</span><br></pre></td></tr></table></figure>
<h2 id="查看当前系统默认shell"><a href="#查看当前系统默认shell" class="headerlink" title="查看当前系统默认shell"></a>查看当前系统默认shell</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>
<h2 id="默认zsh安装-升级"><a href="#默认zsh安装-升级" class="headerlink" title="默认zsh安装/升级"></a>默认zsh安装/升级</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zsh --version</span><br><span class="line"></span><br><span class="line">brew install zsh zsh-completions</span><br></pre></td></tr></table></figure>
<h2 id="保留bash脚本"><a href="#保留bash脚本" class="headerlink" title="保留bash脚本"></a>保留bash脚本</h2><p>命令行输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;source ~/.bash_profile&quot; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>但是会出现\和[和]和英文字母数字掺杂的情况，待解决。</p>
<blockquote>
<p>类unix文件命名规则：</p>
<ul>
<li>在类unix系统中常用缩略语rc是runcom/run command的简写。rc一般会跟在任何类脚本文件名的最后，这些脚本通常在程序的启动阶段被调用。例如，.bashrc是在bash shell启动后运行的脚本，/etc/rc是linux启动的主角本。</li>
<li>~波浪号代表当前用户的home目录，在OS X下位于/Users/用户名/</li>
<li>.点是类unix下的隐藏文件，在GUI文件管理器和ls的默认设置下不会显示出来，但ls -a命令可以显示英藏文件</li>
</ul>
</blockquote>
<h1 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh my zsh"></a>安装oh my zsh</h1><p>官方推荐的curl方式以及wget方式在终端输入的时候会一直显示443拒绝连接！一开始以为是hosts的问题，需要像以前那样修改主机地址<code>sudo vim /etc/hosts</code>并添加github相关ip，但是发现依然没用！</p>
<p>后来发现需要设置终端代理，分两种情况，针对当前终端窗口的代理设置；针对当前shell配置文件的永久设置。</p>
<h1 id="终端代理"><a href="#终端代理" class="headerlink" title="终端代理"></a>终端代理</h1><p>以使用Clash X代理客户端为例，对Clash X客户端进行“复制终端代理命令”的操作。</p>
<p><img src="/2020/12/19/bash-to-zsh/image-20201219101143203.png" alt="image-20201219101143203" style="zoom:33%;"></p>
<p>然后Copy到终端为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890</span><br></pre></td></tr></table></figure>
<p>之后执行oh my zsh的命令就没有443问题了。这种方法只在当前终端有效，关闭或者新建终端窗口将失效。</p>
<hr>
<p>如果希望长期有效，将命令添加在shell配置文件<code>.bash_profile</code>或者<code>.zshrc</code>中。</p>
<ol>
<li>终端进入配置文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi ~/.zshrc # 进入配置文件，输入密码</span><br></pre></td></tr></table></figure>
<ol>
<li>添加shell配置文件</li>
</ol>
<p>如果没有vim使用经验需要查看一下vim操作，按下i从默认的正常模式变为编辑模式。</p>
<p>在文件末尾添加以下命令，注意host：127.0.0.1和port：7890需要匹配Clash X客户端复制终端代理命令的相关数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias setproxy=&quot;export https_proxy=http://127.0.0.1:7890;export http_proxy=http://127.0.0.1:7890;export all_proxy=socks5://127.0.0.1:7890;echo \&quot;Set proxy successfully\&quot; &quot;</span><br><span class="line">alias unsetproxy=&quot;unset http_proxy;unset https_proxy;unset all_proxy;echo \&quot;Unset proxy successfully\&quot; &quot; </span><br></pre></td></tr></table></figure>
<p>继续vim操作，esc变为正常模式，按下冒号:并输入wq会保存并退出，由此回到终端。</p>
<ol>
<li>应用shell配置文件</li>
</ol>
<p>在终端执行以下命令让配置生效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.bash_profile</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>
<ol>
<li>应用代理命令</li>
</ol>
<p>直接在终端输入<code>setproxy</code>即可。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><p><a href="https://github.com/FatliTalk/blog/issues/131">macOS终端使用代理网络</a></p>
</li>
<li><p><a href="https://jerrysun.org/skill/2020/02/19/proxy/">关于终端代理</a></p>
</li>
</ol>
<h2 id="无法PING"><a href="#无法PING" class="headerlink" title="无法PING"></a>无法PING</h2><p>在设置完代理之后，使用ping方法依然无法成功。因为ping方法是基于网络层的ICMP协议，而代理协议socks和http分别基于OSI模型的会话层和应用层。详细解释看这里<a href="https://hackcraker.github.io/2020/03/11/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%87%8C%E8%AE%BE%E4%BB%A3%E7%90%86/">如何在命令行里设代理</a>。可以使用curl方法访问外网网站。</p>
<h2 id="curl-ip依然显示实际地理位置"><a href="#curl-ip依然显示实际地理位置" class="headerlink" title="curl ip依然显示实际地理位置"></a>curl ip依然显示实际地理位置</h2><p>在设置完代理之后，使用curl方法获得地理位置信息<code>curl cip.cc</code>，可能依然显示实际地理位置，注意查看参考1中给出的前提条件是Clash X代理客户端开启全局模式，如果是规则判断依然会出现实际地理位置。</p>
<h2 id="npm-yarn设置代理"><a href="#npm-yarn设置代理" class="headerlink" title="npm/yarn设置代理"></a>npm/yarn设置代理</h2><p>为npm和yarn设置包管理工具的初衷是出现network error。一般情况下，会建议切换国内源，但是国内源切换了也还是没办法的话就试试设置代理。</p>
<p>参考<a href="https://juejin.cn/post/6844904160513490957">如何为git,npm,yarn设置代理</a>。</p>
<h3 id="查看代理命令"><a href="#查看代理命令" class="headerlink" title="查看代理命令"></a>查看代理命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config list</span><br><span class="line">yarn config list</span><br></pre></td></tr></table></figure>
<h3 id="设置代理命令"><a href="#设置代理命令" class="headerlink" title="设置代理命令"></a>设置代理命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set proxy  http://127.0.0.1:7890</span><br><span class="line">npm config set https-proxy http://127.0.0.1:7890</span><br><span class="line"></span><br><span class="line">yarn config set https-proxy http://127.0.0.1:7890</span><br><span class="line">yarn config set proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果走了代理，就可以把源设置为国外默认源了。</p>
<ol>
<li>查看国外源</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br><span class="line">yarn config get registry</span><br></pre></td></tr></table></figure>
<ol>
<li>设置国外源</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry=http://registry.npmjs.org</span><br><span class="line">yarn config set registry https://registry.yarnpkg.com</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="取消代理命令"><a href="#取消代理命令" class="headerlink" title="取消代理命令"></a>取消代理命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config delete proxy</span><br><span class="line">npm config delete https-proxy</span><br><span class="line"></span><br><span class="line">yarn config delete proxy</span><br><span class="line">yarn config delete https-proxy</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>必备技能</category>
      </categories>
      <tags>
        <tag>踩坑记录</tag>
        <tag>shell</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass学习</title>
    <url>/2020/12/19/learn-sass/</url>
    <content><![CDATA[<h1 id="预处理器Sass的功能"><a href="#预处理器Sass的功能" class="headerlink" title="预处理器Sass的功能"></a>预处理器Sass的功能</h1><h2 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h2><p>用<code>$variable</code>语法表示一个变量，一般在文件顶部定义并存放一个数值或颜色值。</p>
<h2 id="Nesting"><a href="#Nesting" class="headerlink" title="Nesting"></a>Nesting</h2><p>通过indent/tab嵌套多种选择器实现父子样式继承。</p>
<h2 id="Partials"><a href="#Partials" class="headerlink" title="Partials"></a>Partials</h2><p>Partials就是文件名以下划线开头的SCSS文件，类似<code>_patrial.css</code>。Partials一般不直接被预处理器编译为css，而是被import到主要的scss文件后，与主文件一同被编译。</p>
<h2 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h2><p>使用<code>@import</code>语法把所有Partials文件导入主文件。</p>
<h2 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h2><p>使用<code>@mixin</code>语法包裹可多次重复利用的代码块，一般结合Varibales一起使用，实现一个基本的传参函数。</p>
<h2 id="Extend"><a href="#Extend" class="headerlink" title="Extend"></a>Extend</h2><p>使用<code>@extend</code>语法实现样式的继承与自定义，适用情况类似于要设计一组颜色各异的button，extend来的是通用button样式，而extend语法本身的样式明确各个颜色。</p>
<h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><p>在scss文件中使用基本数学运算。</p>
<h1 id="终端使用sass命令compile文件"><a href="#终端使用sass命令compile文件" class="headerlink" title="终端使用sass命令compile文件"></a>终端使用sass命令compile文件</h1><h2 id="基本步骤与命令"><a href="#基本步骤与命令" class="headerlink" title="基本步骤与命令"></a>基本步骤与命令</h2><p>新建一个<code>.scss</code>文件，例如名为<code>style.scss</code>，编辑内容并储存。</p>
<p>在终端先进入该<code>.scss</code>文件所在文件夹，然后执行<code>sass style.scss:style.css</code>。冒号后面的内容就是输出文件名。</p>
<p>执行完成后当前列表新增除了<code>.scss</code>文件以外的三个文件，分别是a source map(<code>.css.map</code>)，a regular <code>.css</code> file，a <code>sass.cache</code> directory.</p>
<h2 id="修饰命令"><a href="#修饰命令" class="headerlink" title="修饰命令"></a>修饰命令</h2><p>如果需要实时对<code>.scss</code>文件的修改同步编译到<code>.css</code>文件，可以使用<code>sass —watch</code>命令。</p>
<p>压缩<code>.css</code>文件，使输出的css文件能够更快加载。<code>--style compressed</code>命令。</p>
<h1 id="如何组织一个SCSS项目"><a href="#如何组织一个SCSS项目" class="headerlink" title="如何组织一个SCSS项目"></a>如何组织一个SCSS项目</h1><p>sass主文件夹下有：</p>
<ul>
<li>base文件夹，用于存放全局varibales以及mixins，文件名都是以下划线开头的Partials。</li>
<li>components文件夹，用于存放依据组件需求生成的样式表，文件名都是以下划线开头的Partials。</li>
<li>main.scss文件，用于将所有子文件夹中的partials都import</li>
</ul>
<p>最后<code>sass</code>命令编译的对象是整个main.scss文件。输出到与sass文件夹同层级的css文件夹下的<code>.css</code>文件即可。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Vue3做一些demo的总结</title>
    <url>/2020/12/23/vue-demo-conclusion/</url>
    <content><![CDATA[<h1 id="使用Vue-CLI创建项目"><a href="#使用Vue-CLI创建项目" class="headerlink" title="使用Vue CLI创建项目"></a>使用Vue CLI创建项目</h1><p>在命令行输入，接着会提示进入一个设置Vue的preset的界面，依据需要选择默认的活着手动设置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue create Vue3-demo1</span><br></pre></td></tr></table></figure>
<p>在完成创建后进入项目所在文件夹，并运行<code>npm run server</code>启动项目。</p>
<p>我使用VS code的时候装插件装了一个名为Sass/Less/Stylus/Typescript/Javascript/Jade/Pug Compile Hero的插件，每次修改保存文件以后都会在当前目录自动打包一个 dist/[name].dev.js ，只需要禁用该文件就可以了。</p>
<h1 id="vue文件架构"><a href="#vue文件架构" class="headerlink" title="vue文件架构"></a>vue文件架构</h1><p>一般有vue脚手架自动生成的使用默认配置vue+babel+eslint的文件一般有public文件夹，src文件夹，其他单个配置文件组成。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>数组相关知识点总结</title>
    <url>/2020/12/26/list-method-key/</url>
    <content><![CDATA[<h1 id="数组变更方法与替换方法总结"><a href="#数组变更方法与替换方法总结" class="headerlink" title="数组变更方法与替换方法总结"></a>数组变更方法与替换方法总结</h1><p>变更并返回原数组。使用变更方法时在原数组上通过点访问法调用变更方法，如<code>example1.items.push(&#123; message: &#39;Baz&#39; &#125;)</code></p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
<hr>
<p>不会变更原始数组，而<strong>总是返回一个新数组</strong>。在使用替换方法时使用赋值语句用新数组替换旧数组，如<code>example1.items = example1.items.filter(item =&gt; item.message.match(/Foo/))</code></p>
<ul>
<li><code>filter()</code></li>
<li><code>concat()</code> </li>
<li><code>slice()</code></li>
</ul>
<h1 id="key和index的区别"><a href="#key和index的区别" class="headerlink" title="key和index的区别"></a>key和index的区别</h1><p>index是数组的索引，标记从0到n-1的长度为n的数组中的每个元素。index的特点是不会不区别list item，只要元素出现在该数组的第i个索引，那么就确认它的位置。<strong>一个list item和一个list index不是强绑定的关系</strong>，当前list index上的list item被删除了，会有下一个list item被顶上来填充这个空了的list index。</p>
<p>key一般是一个用于唯一区别list item的标记，一般都是list item对象自己保有的一部分。<strong>一个list item和一个list item key是强绑定的关系</strong>，如果list item被删除了，那么用list item key去查找数组是不可能再找到这个list item的。</p>
<p>key和index是从两个方面去描述list item的方法。当list是固定不变的时候，也就是不会对这个list有任何增删改的操作的时候，也就是这个list只用于查找的时候，key和index是可以等价的，直接将index给予key。当list是有变动的时候，也就是可以增删改也可以查找的时候，key和index绝对不等价，增删改item会带走item key但不带走index。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS数组方法</tag>
        <tag>key和index</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex学习</title>
    <url>/2020/12/24/vuex-summary/</url>
    <content><![CDATA[<p>Vuex is a state management pattern + library for Vue.js application.</p>
<p>vuex提供一个中心化的store全体供所有的components使用。</p>
<blockquote>
<p>It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion.</p>
</blockquote>
<h1 id="为什么要用vuex-想法与redux类似"><a href="#为什么要用vuex-想法与redux类似" class="headerlink" title="为什么要用vuex/想法与redux类似"></a>为什么要用vuex/想法与redux类似</h1><p>对于一个self-contained app来说，state/view/actions的很容易维持（one-way data flow），但是当许多组件components需要共享一个state的时候这个三角关系就很容易被打破：有很多view依赖于同一块state，有很多view发出的actions可以变更同一块state。</p>
<p>当然可以通过passing props来解决父子组件间的这个问题，但是当components的层级关系越来越深，这个变更就很不好操作；但是兄弟组件sibling components如果要共享同一块数据，passing props的方法并不能解决问题。</p>
<p>因此vuex的出现就是extract the shared state out of the components, and manage it in a global singleton。数据/state/data应当成为单独管理的一棵树，view/UI/components应当也是单独的一棵树。</p>
<p><img src="/2020/12/24/vuex-summary/vuex-data-flow.png" alt="vuex-data-flow" style="zoom:50%;"></p>
<h1 id="vuex-store"><a href="#vuex-store" class="headerlink" title="vuex store"></a>vuex store</h1><h2 id="任何store有两个约定："><a href="#任何store有两个约定：" class="headerlink" title="任何store有两个约定："></a>任何store有两个约定：</h2><ul>
<li>vuex store是响应式reactive的，当有vue组件向他拿state来用时，如果store state有所变动，vue组件中这些引用都会自动更新</li>
<li>vue组件不能直接变更store state，唯一的mutate store state的方法就是by explictly committing mutations（为了保证留下track-able record）.</li>
</ul>
<h2 id="创建store"><a href="#创建store" class="headerlink" title="创建store"></a>创建store</h2><p>store本质上就是一个object，使用<code>createStore()</code>方法，向里面传入一个包含state field/mutation object/actions obejct等其他field的object。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(&#123;</span><br><span class="line">  	state: &#123;&#125;,</span><br><span class="line">    mutations: &#123;&#125;,</span><br><span class="line">    actions: &#123;&#125;,</span><br><span class="line">    modules: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="使用store"><a href="#使用store" class="headerlink" title="使用store"></a>使用store</h2><p>在main.js中createApp()调用完成之后以<code>.user(store)</code> plugin的形式注册vuex store实例。</p>
<p>这个操作inject store into all child components from the root component through Vue’s plugin system，因此在组件内部可以通过<code>this.$store</code>访问global store的所有field。</p>
<h1 id="state-field"><a href="#state-field" class="headerlink" title="state field"></a>state field</h1><p>在createStore的state field中储存的data，本质上和vue实例中的data property function是一样的作用。</p>
<p>从store中取出最直接/不经加工的数据在ui/components中使用有以下几个方法：</p>
<h2 id="使用state-computed-field-store-state"><a href="#使用state-computed-field-store-state" class="headerlink" title="使用state computed field+store.state"></a>使用state computed field+<code>store.state</code></h2><p>在组件内部的computed field通过引用<code>store.state.</code>访问store中state field的里某个对象，并返回该对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>该方法只能在一个app中的所有组件都依赖于gloabal state的情况下适用。</p>
<h2 id="使用state-computed-field-mapState"><a href="#使用state-computed-field-mapState" class="headerlink" title="使用state computed field+mapState"></a>使用state computed field+mapState</h2><p>当有多个store state需要在computed field中被使用的时候，可以使用<code>mapState</code> helper which generates computed getter functions for us.</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">computed: mapState(&#123;// 感觉mapState像是提供了一个前往store的通道</span><br><span class="line">    <span class="comment">// 有点useSelector的意思了，但是是在component中适用的useSlector</span></span><br><span class="line">    count: state =&gt; state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// passing the string value &#x27;count&#x27; is same as `state =&gt; state.count`</span></span><br><span class="line">    countAlias: &#x27;count&#x27;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// to access local state with `this`, a normal function must be used</span></span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      return state.count + this.localCount</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// map this.count to store.state.count</span></span><br><span class="line">    <span class="comment">// 这种方法只在mapped computed property is the same as a state sub tree name时使用</span></span><br><span class="line">    &#x27;count&#x27;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>如果要和组件自己的local state融合，还需要用到spread syntax。</p>
<h1 id="getters-field"><a href="#getters-field" class="headerlink" title="getters field"></a>getters field</h1><p>前面提到state和view有一对多的关系，如果有多个component要用到这个state，总不能在每个view的computed field里面都走一遍mapState或者this.$store吧？因此就有了getters函数，这个函数就像react里面定义在slice文件里面的Select函数，作为参数传递给component中的useSelector hook。</p>
<h2 id="定义getters"><a href="#定义getters" class="headerlink" title="定义getters"></a>定义getters</h2><h3 id="一般函数定义与参数传递-property-style-access"><a href="#一般函数定义与参数传递-property-style-access" class="headerlink" title="一般函数定义与参数传递 property-style access"></a>一般函数定义与参数传递 property-style access</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在定义getters函数的时候，不仅仅可以用当前store的state作为第一个参数；还可以利用当前store的getters作为第二个参数，通过点访问法访问同一个getters field中的其他getters。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  doneTodosCount (state, getters) &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="箭头函数定义-method-style-access"><a href="#箭头函数定义-method-style-access" class="headerlink" title="箭头函数定义 method-style access"></a>箭头函数定义 method-style access</h3><p>以上都是依据一般函数来定义getters的，当然也可以用arrow function来定义getters，这样可以实现在不同的地方按需求传递参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getTodoById: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从store中取出经过加工/选择的数据在ui/components中使用有以下几个方法：</p>
<h2 id="使用getters"><a href="#使用getters" class="headerlink" title="使用getters"></a>使用getters</h2><h3 id="computed-field-store-getters"><a href="#computed-field-store-getters" class="headerlink" title="computed field + store.getters"></a>computed field + <code>store.getters</code></h3><p>在component/ui/view中利用getters提取数据可以通过引用<code>store.getters</code>，并点访问对应的getter函数。</p>
<h3 id="computed-field-mapGetters"><a href="#computed-field-mapGetters" class="headerlink" title="computed field + mapGetters"></a>computed field + mapGetters</h3><p>需要使用spread syntax与原组件的自有computed融合。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    <span class="comment">// mix the getters into computed with object spread operator</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;anotherGetter&#x27;</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// map `this.doneCount` to `this.$store.getters.doneTodosCount`</span></span><br><span class="line">  	   doneCount: <span class="string">&#x27;doneTodosCount&#x27;</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="mutations-field"><a href="#mutations-field" class="headerlink" title="mutations field"></a>mutations field</h1><blockquote>
<p>The only way to actually change state in a Vuex store is by committing a mutation. </p>
</blockquote>
<p>mutation field中不能包含异步操作，因为在使用devtool debug需要跟踪before&amp;after snapshots of the state，一个mutation被commit了但是异步操作的callback function还没有被调用，这样子state就完全是不可预测的了。</p>
<h2 id="不带payload的mutation定义与调用"><a href="#不带payload的mutation定义与调用" class="headerlink" title="不带payload的mutation定义与调用"></a>不带payload的mutation定义与调用</h2><p>vuex mutation和events十分相似，每一个mutation都需要一个string type和一个handler。</p>
<p>在mutations field内部的每一个函数都是一个mutation handler。mutation handler内部是实现actual state modifications的地方，它接收state作为第一个参数。那么string type是什么？就是这个函数的名字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">   increment (state) &#123;</span><br><span class="line">     <span class="comment">// mutate state</span></span><br><span class="line">     state.count++</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>但是mutation handler不能被直接调用，需要走一遍事件注册的流程。我们希望有以下流程：”When a mutation with type <code>increment</code> is triggered, call this handler.” 我们通过调用<code>store.commit</code>函数并传入handler function的string type来实现这个流程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果需要在component中commit mutations，需要使用<code>this.$store.commit()</code>，或者<code>mapMutations</code> helper。</p>
<h2 id="带payload的mutation定义与调用"><a href="#带payload的mutation定义与调用" class="headerlink" title="带payload的mutation定义与调用"></a>带payload的mutation定义与调用</h2><p>mutation handler function除了接受state作为第一个参数，也可以把当前mutation的payload作为第二个参数传入，只需要在commit函数中同步传入第二个参数即可。如果payload是多个数据，直接用对象表示payload，并用点访问法访问。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="object-style-commit-with-type-field"><a href="#object-style-commit-with-type-field" class="headerlink" title="object-style commit with type field"></a>object-style commit with type field</h2><p>既然都用到对象了，为什么不把mutation type一起放到payload的对象中去呢？这就是obejct-style commit，也就是commit a mutation is by directly using an object that has a <code>type</code> property。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: <span class="string">&#x27;increment&#x27;</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="为mutation-type定义constants"><a href="#为mutation-type定义constants" class="headerlink" title="为mutation type定义constants"></a>为mutation type定义constants</h2><p>在flux中，一般会把当前store所有mutation都放到同一个<code>mutation-type.js</code>文件中export const，然后再当前store中import {}，使用computed property name作为function name。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">&#x27;SOME_MUTATION&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">&#x27;./mutation-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// we can use the ES2015 computed property name feature</span></span><br><span class="line">    <span class="comment">// to use a constant as the function name</span></span><br><span class="line">    [SOME_MUTATION] (state) &#123;</span><br><span class="line">      <span class="comment">// mutate state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="actions-field"><a href="#actions-field" class="headerlink" title="actions field"></a>actions field</h1><p>actions和mutations其实类似，区别在于</p>
<ul>
<li>action一般不直接变更state，因为有mutation field存在，因此action可以通过commit mutation或dispatch action来实现state field的变更。</li>
<li>action可以包含任何异步逻辑。</li>
</ul>
<h2 id="定义action-handler与destructing语法"><a href="#定义action-handler与destructing语法" class="headerlink" title="定义action handler与destructing语法"></a>定义action handler与destructing语法</h2><p>通常action handlers会接受一个context obejct，该context obejct把同样的store instance都暴露给（但context object本身不是the store instance itself，感觉更向copy）当前action handlers，因此可以在action handler function内部访问到当前store的state/getters等field。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为conetxt本来就是copy当前store instance的object，但是我们又不需要用到这个object里面所有的内容，因此可以用ES6的数组结构获取需要的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用action-handler"><a href="#使用action-handler" class="headerlink" title="使用action handler"></a>使用action handler</h2><p>使用方法与mutations类似，通过<code>store.dispatch()</code>方法，不带payload、带payload、objecy-style dispatch都可以。</p>
<p>在组件内部通过<code>this.$store.dispatch()</code>或者<code>mapActions</code> helper实现调用。在传递给<code>mapActions()</code> 参数的时候可以是一个对象，也可以是一个数组，内部的action type都是string类型。</p>
<h1 id="模块-modules"><a href="#模块-modules" class="headerlink" title="模块 modules"></a>模块 modules</h1><p>把全体store分成不同的模块，每个模块管理自己的state/mutations/actions/getters field。这有点类似redux中的每个slice。</p>
<h2 id="当前模块state与rootState"><a href="#当前模块state与rootState" class="headerlink" title="当前模块state与rootState"></a>当前模块state与rootState</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = createStore(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">store.state.a <span class="comment">// -&gt; `moduleA`&#x27;s state</span></span><br></pre></td></tr></table></figure>
<p>在每一个模块内部，muations filed和getters field接受的第一个参数state就变成了当前模块的local state（也就是只属于这个slice的state）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">        <span class="comment">// `state` is the local module state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">getters: &#123;</span><br><span class="line">    doubleCount (state) &#123;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>action field接受的第一个参数context，这个<code>context.state</code>暴露的是当前local store实例，而全体global store的实例要通过<code>context.rootState</code>来实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在getters field中，rootState也被作为第三个参数使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">    sumWithRootCount (state, getters, rootState) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="namespacing-命名空间"><a href="#namespacing-命名空间" class="headerlink" title="namespacing 命名空间"></a>namespacing 命名空间</h2><p>默认所有的actions和mutations都是在global namespace下被注册的。但是当modules变多了，很难保证两个modules中的函数命名没有冲突，因此就需要把当前模块的所有方法都放在固定的命名空间。通过在创建module的时候添加<code>namespaced: true</code>来实现命名空间化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    account: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// module assets</span></span><br><span class="line">      state: <span class="function">() =&gt;</span> (&#123; ... &#125;), <span class="comment">// module state is already nested and not affected by namespace option</span></span><br><span class="line">      getters: &#123;</span><br><span class="line">        isAdmin () &#123; ... &#125; <span class="comment">// -&gt; getters[&#x27;account/isAdmin&#x27;]</span></span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// nested modules</span></span><br><span class="line">      modules: &#123;</span><br><span class="line">        <span class="comment">// inherits the namespace from parent module</span></span><br><span class="line">        myPage: &#123;</span><br><span class="line">          state: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">          getters: &#123;</span><br><span class="line">            profile () &#123; ... &#125; <span class="comment">// -&gt; getters[&#x27;account/profile&#x27;]</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>
<h3 id="在子模块内部访问global-assets"><a href="#在子模块内部访问global-assets" class="headerlink" title="在子模块内部访问global assets"></a>在子模块内部访问global assets</h3><p>If you want to use global state and getters, <code>rootState</code> and <code>rootGetters</code> are passed as the 3rd and 4th arguments to getter functions, and also exposed as properties on the <code>context</code> object passed to action functions.</p>
<p>在getter field中，使用getters点访问当前模块的其他getters，使用rootGetters点访问root store中定义的getter或方括号访问其他模块中定义的getter。actions field同理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    namespaced: <span class="literal">true</span>,<span class="comment">//该模块已经被namespaced了</span></span><br><span class="line"></span><br><span class="line">    getters: &#123;</span><br><span class="line">      <span class="comment">// `getters` is localized to this module&#x27;s getters</span></span><br><span class="line">      <span class="comment">// you can use rootGetters via 4th argument of getters</span></span><br><span class="line">      someGetter (state, getters, rootState, rootGetters) &#123;</span><br><span class="line">        getters.someOtherGetter <span class="comment">// -&gt; &#x27;foo/someOtherGetter&#x27;</span></span><br><span class="line">        rootGetters.someOtherGetter <span class="comment">// -&gt; &#x27;someOtherGetter&#x27;</span></span><br><span class="line">        rootGetters[<span class="string">&#x27;bar/someOtherGetter&#x27;</span>] <span class="comment">// -&gt; &#x27;bar/someOtherGetter&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherGetter: <span class="function"><span class="params">state</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    actions: &#123;</span><br><span class="line">      <span class="comment">// dispatch and commit are also localized for this module</span></span><br><span class="line">      <span class="comment">// they will accept `root` option for the root dispatch/commit</span></span><br><span class="line">      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;</span><br><span class="line">        getters.someGetter <span class="comment">// -&gt; &#x27;foo/someGetter&#x27;</span></span><br><span class="line">        rootGetters.someGetter <span class="comment">// -&gt; &#x27;someGetter&#x27;</span></span><br><span class="line">        rootGetters[<span class="string">&#x27;bar/someGetter&#x27;</span>] <span class="comment">// -&gt; &#x27;bar/someGetter&#x27;</span></span><br><span class="line"></span><br><span class="line">        dispatch(<span class="string">&#x27;someOtherAction&#x27;</span>) <span class="comment">// -&gt; &#x27;foo/someOtherAction&#x27;</span></span><br><span class="line">        dispatch(<span class="string">&#x27;someOtherAction&#x27;</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; &#x27;someOtherAction&#x27;</span></span><br><span class="line"></span><br><span class="line">        commit(<span class="string">&#x27;someMutation&#x27;</span>) <span class="comment">// -&gt; &#x27;foo/someMutation&#x27;</span></span><br><span class="line">        commit(<span class="string">&#x27;someMutation&#x27;</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; &#x27;someMutation&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherAction (ctx, payload) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在子模块内部添加global-assets"><a href="#在子模块内部添加global-assets" class="headerlink" title="在子模块内部添加global assets"></a>在子模块内部添加global assets</h3><p>If you want to register global actions in namespaced modules, you can mark it with <code>root: true</code> and place the action definition to function <code>handler</code>. </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">      actions: &#123;</span><br><span class="line">        someAction: &#123;</span><br><span class="line">          root: <span class="literal">true</span>,</span><br><span class="line">          <span class="comment">// 在foo模块下定义的action handler是全局的</span></span><br><span class="line">          handler (namespacedContext, payload) &#123; ... &#125; <span class="comment">// -&gt; &#x27;someAction&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="在component内部访问使用模块"><a href="#在component内部访问使用模块" class="headerlink" title="在component内部访问使用模块"></a>在component内部访问使用模块</h3><p>每次都得把模块说明白，如果有多层嵌套就得有很多斜杠和模块名。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">&#x27;some/nested/module/foo&#x27;</span>, <span class="comment">// -&gt; this[&#x27;some/nested/module/foo&#x27;]()</span></span><br><span class="line">    <span class="string">&#x27;some/nested/module/bar&#x27;</span> <span class="comment">// -&gt; this[&#x27;some/nested/module/bar&#x27;]()</span></span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面这种写法还好些</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions(<span class="string">&#x27;some/nested/module&#x27;</span>, [</span><br><span class="line">    <span class="string">&#x27;foo&#x27;</span>, <span class="comment">// -&gt; this.foo()</span></span><br><span class="line">    <span class="string">&#x27;bar&#x27;</span> <span class="comment">// -&gt; this.bar()</span></span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>createNamespacedHelpers</code>helper将当前component绑定到特定的的模块去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapActions &#125; = createNamespacedHelpers(<span class="string">&#x27;some/nested/module&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// look up in `some/nested/module`</span></span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue3</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖函数</title>
    <url>/2020/12/28/debouce-explaination/</url>
    <content><![CDATA[<h1 id="为什么需要防抖函数"><a href="#为什么需要防抖函数" class="headerlink" title="为什么需要防抖函数"></a>为什么需要防抖函数</h1><p>在浏览器中，触发频繁的事件，如window的onresize、鼠标的mousemove、滚轮的wheel、文本输入框的验证等，因为这些事件被频繁触发，有可能导致大量的计算或者服务器资源消耗极大的操作，event handler就没有必要每一次触发都执行。</p>
<p>因此就有了函数防抖的概念，让事件触发的n秒内只执行一次，防止event handler多次调用，如果连续触发就重新计算事件。</p>
<p><a href="https://github.com/YvetteLau/Step-By-Step/issues/10">Github上找到的关于防抖函数的讨论</a></p>
<h1 id="vue中的防抖的相关实现"><a href="#vue中的防抖的相关实现" class="headerlink" title="vue中的防抖的相关实现"></a>vue中的防抖的相关实现</h1><h2 id="v-model与lazy修饰符"><a href="#v-model与lazy修饰符" class="headerlink" title="v-model与lazy修饰符"></a>v-model与lazy修饰符</h2><p>vue提供了输入框数据的双向绑定v-model指令，该指令默认每一次用户的输入都让vue重新计算重新渲染，当用户输入很长一段内容的时候这是极大的渲染负担。因此引入了.lazy修饰符，但.lazy修饰符的局限在于只有当用户focus out才渲染，对于比较小的输入会比较方便，但是大的文本输入情况下不适用。</p>
<h2 id="v-bind-value与event-handler"><a href="#v-bind-value与event-handler" class="headerlink" title="v-bind:value与event handler"></a>v-bind:value与event handler</h2><p>v-bind指令与v-model指令的区别在于，v-bind是实现用户输入流向vue的单向绑定（需要绑定在value上），如果要让vue的数据去流向用户（也就是渲染），需要用到事件处理函数，每一次用户的输入，我都利用事件去update一下，相当于手动实现了v-model的双向绑定。</p>
<p>这样的实现方式与v-model相比，可以更细致化的去定义事件处理函数如何去处理如何去渲染。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里使用了tailwind css --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;w-full h-full&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">:value</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">click</span>=<span class="string">&quot;update&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      text: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    update(e) &#123;</span><br><span class="line">      <span class="built_in">this</span>.text = e.target.value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="update延迟调用"><a href="#update延迟调用" class="headerlink" title="update延迟调用"></a>update延迟调用</h2><p>前面提到我们不希望每一次用户的输入都导致一次渲染，因此需要对update函数进行一个延迟调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">update(e) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="built_in">this</span>.text = e.target.value;&#125;, <span class="number">500</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>以上函数表示，我们希望当用户停止输入经过500ms，vue要去依据输入框中的value值更新vue的data中储存的数据。但是具体去输入的时候，又会发现所有的更新都好像是即时的、instant update，为什么会出现这种情况？因为只要每一次update，都会有一个setTimeout被执行，多次的输入带来的就是多个setTimeout，本质上和上一段中的update函数没区别。</p>
<p>为了解决这个问题，我们在每一次运行setTimeout的时候，都希望vue去check一下是否之前就已经存在了其他的setTimeout，在每一次update前都清理一下之前就有的setTimeout。因此我们需要在data field中定义一个string变量来存储已有的setTimeout。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      text: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      timeput: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    update(e) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.timeout);</span><br><span class="line">      <span class="built_in">this</span>.timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.text = e.target.value;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象出debounce函数"><a href="#抽象出debounce函数" class="headerlink" title="抽象出debounce函数"></a>抽象出debounce函数</h2><p>抽象后的debounce函数是一个工具性质的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  update(e) &#123;</span><br><span class="line">    <span class="keyword">const</span> task = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.text = e.target.value;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.debounce(task, <span class="number">500</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  debounce(func, wait = <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.timeout);</span><br><span class="line">    <span class="built_in">this</span>.timeout = <span class="built_in">setTimeout</span>(func, wait);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="使用mixins在page中导入工具函数"><a href="#使用mixins在page中导入工具函数" class="headerlink" title="使用mixins在page中导入工具函数"></a>使用mixins在page中导入工具函数</h2><p>vue实例有一个可选的<code>mixins</code> field，可以用于不同的vue实例之间融合merge他们共有的field。如果当前vue实例中已经存在了导入vue实例中的某个变量、方法，那么当前vue实例会覆盖导入vue实例的变量、方法。</p>
<p>vue实例在使用融合后的其他vue实例的变量、方法的时候，直接使用this来调用，仿佛这就是本来定义在当前vue实例中的一样。</p>
<p>详细实现参考vue3-demo3的<code>src/pages/Markdown.vue</code>文件以及<code>src/utilities/mixins/debounce.js</code>文件。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>debounce</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue虚拟DOM</title>
    <url>/2020/12/28/virtual-dom/</url>
    <content><![CDATA[<h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h1><p><a href="https://v3.vuejs.org/guide/optimizations.html#virtual-dom">Vue3官方文档对此的解释</a></p>
<p><a href="https://codepen.io/sdras/pen/RwwQapa">官方文档中动画演示源代码，用于看解释</a></p>
<p><a href="https://www.youtube.com/watch?v=e-E0UB-YDRk&amp;ab_channel=Bitfumes">Bitfumes Vue3教程中的Vue Virtual DOM解释</a></p>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>虚拟DOM是浏览器DOM的一份JavaScript复制。虚拟DOM是一个轻量级的JavaScript对象。</p>
<p>当用JavaScript去update html DOM的时候，这个操作十分expensive，但是用JavaScript对JavaScript DOM去update相对cheap。</p>
<p>找出每一个DOM节点并更新是一个十分缓慢的过程，因此不如在虚拟DOM中把所有要更新的DOM节点都找出来，然后vue去比较虚拟DOM和浏览器DOM之间的区别，然后batch calls to re-render/一次完成所有节点更新。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>virtual-dom</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3新特性Composition API</title>
    <url>/2021/01/02/composition-api/</url>
    <content><![CDATA[<p>在之前的vue学习过程中，主要是通过定义vue组件的各种field，例如data function，computed object， methods object等来组织vue组件的逻辑。但是当逻辑越来越复杂的时候，这种组织vue组件的方式就不太可行。</p>
<p>setup component option是一个在vue组件被创建之前就被执行的函数，因此在setup option内部是没有this的，该函数内部职能访问props，该组件的方法、计算属性、state等都不可以访问。</p>
<p>那么setup函数就相当于替代了生命周期函数中的created和beforeCreate这两个周期函数。</p>
<p>在setup内部需要定义数据，并返回一个对象，对象包括在vue组件的template中需要用到的数据的集合。</p>
<h1 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h1><h2 id="const-ref"><a href="#const-ref" class="headerlink" title="const+ref"></a>const+ref</h2><p>const数据的定义就相当于原来组件的data field，但是由于setup内部就是普通的JavaScript语句，不会实现reactive response，因此需要用到ref，常见的定义形式为<code>const newHeroRef = ref(&quot;&quot;);</code>。</p>
<p>在使用ref包裹的const时，需要时调用<code>newHeroRef.value</code>获取引用本身，否则<code>newHeroRef</code>只是一个对象。</p>
<p>什么时候使用ref？当我们需要在setup中时刻监听<strong>某一个数据</strong>的时候。</p>
<h2 id="const-state-reactive"><a href="#const-state-reactive" class="headerlink" title="const state+reactive"></a>const state+reactive</h2><p>const+ref的替换就是<code>const state = reactive(&#123;&#125;)</code>，对象内部就是响应式数据。这么做的好处在于更新数据时只需要state.data更新，并且从setup function返回的时候只需要返回state全体对象。</p>
<p>什么时候使用reactive？当我们需要在setup中时刻监听<strong>某一批数据</strong>的时候。</p>
<h1 id="computed-get-set"><a href="#computed-get-set" class="headerlink" title="computed+get+(set)"></a>computed+get+(set)</h1><p>const数据同样可以用来定义computed field。具体定义方式为<code>const heroCount = computed(&#123; get: () =&gt; &#123;return dcHeros.value.length;&#125;, &#125;);</code>，传入对象，对象内部有getter和setter（自定义）。</p>
<h1 id="function"><a href="#function" class="headerlink" title="function"></a>function</h1><p>function的定义就相当于原来组件的methods field中除了生命周期函数的部分。同样需要在setup return语句中返回该函数。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>composition-api</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一下VSCode快捷键</title>
    <url>/2021/01/03/vscode-shortcut/</url>
    <content><![CDATA[<p><code>option+鼠标点击</code>：在鼠标点击的各个位置插入多个光标</p>
<p><code>cmd+上下方向键</code>：转到当前文件的最开始或者最结尾</p>
<p><code>cmd+左右方向键</code>：转到当前行的最开始或者最结尾</p>
<p><code>option+左右方向键</code>：向前或者向后移动一个单词为单位的光标</p>
<p><code>option+上下方向键</code>：移动当前行的所有内容到下一行或上一行</p>
<p><code>shift+cmd/option+左右方向键</code>：从当前光标开始以cmd行为单位/以option单词为单位选中内容；可以结合copy&amp;patse进行代码移动/复制/粘贴</p>
<p><code>option+·</code>打开终端</p>
<p><code>cmd+shift+p</code>转到vscode工具</p>
<p><code>cmd+p</code>转到当前文件夹的某个目标文件</p>
<p><code>cmd+b</code>打开或关闭侧边栏</p>
]]></content>
      <categories>
        <category>必备技能</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Heroku部署网站</title>
    <url>/2021/01/04/heroku-app-deploy/</url>
    <content><![CDATA[<p>本来想在Netlify上部署网站的，结果无论如何都没办法重定向到github，并且总是网页无法打开，就转用heroku了。</p>
<h1 id="Vue-CLI项目部署"><a href="#Vue-CLI项目部署" class="headerlink" title="Vue-CLI项目部署"></a>Vue-CLI项目部署</h1><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://gist.github.com/hone/24b06869b4c1eca701f9">VueCLI官方给出的部署教程</a></p>
<p><a href="https://www.binarcode.com/blog/deploying-vue-apps-to-heroku-the-right-way/">BinarCode上的部署教程</a></p>
<p><a href="https://devcenter.heroku.com/articles/getting-started-with-nodejs">Heroku官方基于Heroku CLI的Node.js应用部署文档</a></p>
<p><a href="https://stackoverflow.com/a/59658200/9853144">StackOverflow上比较好的回答1</a></p>
<p><a href="https://stackoverflow.com/a/65056203/9853144">StackOverflow上比较好的回答2</a></p>
<h2 id="部署操作"><a href="#部署操作" class="headerlink" title="部署操作"></a>部署操作</h2><p>需要在heroku上创建账号，创建app。在进入app后有一排工具栏，可以查看对应的信息。</p>
<p><img src="/2021/01/04/heroku-app-deploy/image-20210104130207252.png" alt="image-20210104130207252" style="zoom:50%;"></p>
<p>Deploy一栏是初次部署的时候显示的页面，在这里关联github的特定项目。</p>
<p>Activity一栏可以查看build log，如果部署不成功需要去查找错误。</p>
<p>Settings一栏可以<strong>配置环境变量</strong>。在<a href="https://github.com/MachaCroissant/vue3-demo3">vue3-demo3</a>中用到了.env配置环境变量，需要在部署的时候添加到heroku去。</p>
<p>如果部署中出现报错<code>npm ERR! missing script: start</code>，意思是在<code>package.json</code>中没有找到start相关的script，因为vue-cli默认只有serve/build/lint。这时需要自定义start脚本的内容。</p>
<blockquote>
<p>这里涉及一些npm脚本的知识。<a href="https://juejin.cn/post/6844903957228158983">掘金上关于npm的知识点汇总</a></p>
<p>npm脚本常用的几个缩写分别是：</p>
<ul>
<li><p><code>npm start</code> short for <code>npm run start</code></p>
</li>
<li><p><code>npm test</code> short for <code>npm run test</code></p>
</li>
<li><p><code>npm stop</code> short for <code>npm run stop</code></p>
</li>
</ul>
<p>如下，当执行npm run start指令的时候，实际上执行的就是start在scripts中的脚本 node server.js。</p>
<p>第一个指令缩写可以解释为什么create-react-app中运行指令是npm start了。</p>
</blockquote>
<p>在脚手架的<code>package.json</code>文件中添加<code>&quot;start&quot;: &quot;node server.js&quot;,</code>指令，如下：</p>
<p><img src="/2021/01/04/heroku-app-deploy/image-20210104131030319.png" alt="image-20210104131030319" style="zoom:50%;"></p>
<p>这个指令的意思是在node环境下执行server.js文件。server.js文件是需要在当前应用文件夹的最顶层，和package.json处于同一级的自建文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> history = <span class="built_in">require</span>(<span class="string">&quot;connect-history-api-fallback&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> serveStatic = <span class="built_in">require</span>(<span class="string">&quot;serve-static&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> enforce = <span class="built_in">require</span>(<span class="string">&quot;express-sslify&quot;</span>);</span><br><span class="line"><span class="comment">// require()中涉及的字符串都是需要预先安装的npm包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();<span class="comment">//该app使用express</span></span><br><span class="line"></span><br><span class="line">app.use(enforce.HTTPS(&#123; <span class="attr">trustProtoHeader</span>: <span class="literal">true</span> &#125;)); <span class="comment">// 要求使用http链接</span></span><br><span class="line">app.use(serveStatic(__dirname + <span class="string">&quot;/dist&quot;</span>));</span><br><span class="line"><span class="comment">// 要求部署的最终代码都放在heroku生成的__dirname下的dist文件夹中</span></span><br><span class="line">app.use(history());</span><br><span class="line">app.listen(process.env.PORT || <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>踩坑记录</tag>
        <tag>前端</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS基础知识</title>
    <url>/2020/10/16/css-tips/</url>
    <content><![CDATA[<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p><img src="/2020/10/16/css-tips/rendering.svg" alt="rendering"></p>
<p>浏览器拉取到CSS之后会进行解析，根据选择器的不同类型（比如element、class、id等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id选择器等）应用在对应的DOM的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。</p>
<p>如果一个浏览器在解析你所书写的CSS规则的过程中遇到了无法理解的属性或者值，在你书写了错误的CSS代码（或者误拼写），又或者当浏览器遇到对于它来说很新的还没有支持的CSS代码的时候，它会忽略这些并继续解析下面的CSS声明。</p>
<h1 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h1><p>浏览器的默认行为太丑就需要改变浏览器对于该元素的默认行为。可以具体的在该选择器下的元素，或者通过全局选择器<code>*</code>，应用属性值为<code>none</code>的样式。</p>
<p>为了避免重复的 CSS，一种常见的做法是给基本元素定义通用样式，然后给不同的元素创建对应的类。</p>
<p>CSS语言有规则来控制在发生碰撞时哪条规则将获胜 — 这些规则称为级联规则和专用规则。<strong>cascade</strong>, 和它密切相关的概念是 <strong>specificity</strong>，决定在发生冲突的时候应该使用哪条规则。</p>
<h2 id="Cascade层叠"><a href="#Cascade层叠" class="headerlink" title="Cascade层叠"></a>Cascade层叠</h2><ul>
<li>css规则的顺序很重要。</li>
<li>当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。</li>
</ul>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><h3 id="衡量一个选择器的优先级的标准"><a href="#衡量一个选择器的优先级的标准" class="headerlink" title="衡量一个选择器的优先级的标准"></a>衡量一个选择器的优先级的标准</h3><ul>
<li>一个元素选择器不是很具体 — 会选择页面上该类型的所有元素 — 所以它的优先级就会低一些。</li>
<li>一个类选择器稍微具体点 — 它会选择该页面中有特定 <code>class</code> 属性值的元素 — 所以它的优先级就要高一点。</li>
</ul>
<h3 id="具体浏览器计算优先级"><a href="#具体浏览器计算优先级" class="headerlink" title="具体浏览器计算优先级"></a>具体浏览器计算优先级</h3><p>本质上，不同类型的选择器有不同的分数值，把这些分数相加就得到特定选择器的权重，然后就可以进行匹配。注意不允许进位计算，例如无论多少个类选择器的权重叠加，都不会超过一个 ID 选择器。</p>
<ol>
<li><strong>千位</strong>： 如果声明在 <code>style</code> 的属性<strong>（内联样式）</strong>则该位得一分。这样的声明没有选择器，所以它得分总是1000。(一般很少用)</li>
<li><strong>百位</strong>： 选择器中包含<strong>ID选择器</strong>则该位得一分。</li>
<li><strong>十位</strong>： 选择器中包含<strong>类选择器</strong>、<strong>属性选择器</strong>或者<strong>伪类</strong>则该位得一分。</li>
<li><strong>个位</strong>：选择器中包含<strong>元素</strong>、<strong>伪元素选择器</strong>则该位得一分。</li>
</ol>
<p><strong>注</strong>: 通用选择器 (<code>*</code>)，组合符 (<code>+</code>, <code>&gt;</code>, <code>~</code>, ‘ ‘)，和否定伪类 (<code>:not</code>) 不会影响优先级。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>一些设置在父元素上的css属性是可以被子元素继承的，有些则不能。</p>
<p>CSS为了控制继承提供了四个特殊的通用属性值，每个CSS属性都能接收这些值。</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inherit"><code>inherit</code></a></li>
</ul>
<p>设置该属性会使子元素属性和父元素相同。实际上，就是 “开启继承”.</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/initial"><code>initial</code></a></li>
</ul>
<p>设置属性值和浏览器默认样式相同。如果浏览器默认样式中未设置且该属性是自然继承的，那么会设置为 <code>inherit</code> 。</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/unset"><code>unset</code></a></li>
</ul>
<p>将属性重置为自然值，也就是如果属性是自然继承那么就是 <code>inherit</code>，否则和 <code>initial</code>一样。</p>
<ul>
<li><code>revert</code></li>
</ul>
<p>新属性，很少有浏览器支持。</p>
<p>CSS 的 shorthand 属性 <code>all</code> 可以用于同时将这些继承值中的一个<strong>应用于在该选择器选中的元素的（几乎）所有属性</strong>。它的值可以是其中任意一个(<code>inherit</code>, <code>initial</code>, <code>unset</code>, or <code>revert</code>)。这是一种撤销对样式(选择<code>unset</code>属性)所做更改的简便方法，以便回到之前已知的起点。</p>
<h1 id="速记属性"><a href="#速记属性" class="headerlink" title="速记属性"></a>速记属性</h1><p>速记属性如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font"><code>font</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>, and <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a> ，允许一行设定多个属性值。</p>
<blockquote>
<p> In 4-value shorthands like padding and margin, the values are applied in the order top, right, bottom, left (clockwise from the top). There are also other shorthand types, for example 2-value shorthands, which set padding/margin for top/bottom, then left/right.</p>
</blockquote>
<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="块级盒子-block-box"><a href="#块级盒子-block-box" class="headerlink" title="块级盒子 block box"></a>块级盒子 block box</h3><ul>
<li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽</li>
<li>每个盒子都会换行</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 属性可以发挥作用</li>
<li>内边距（padding）, 外边距（margin） 和 边框（border） 会将其他元素从当前盒子周围“推开”</li>
</ul>
<h3 id="内联盒子-inline-box"><a href="#内联盒子-inline-box" class="headerlink" title="内联盒子 inline box"></a>内联盒子 inline box</h3><ul>
<li>盒子不会产生换行。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 属性将不起作用。</li>
<li>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 <code>inline</code> 状态的盒子推开。</li>
<li>水平方向的内边距、外边距以及边框会被应用而且也会把其他处于 <code>inline</code> 状态的盒子推开。</li>
</ul>
<h2 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a><code>display</code>属性</h2><h3 id="inline-block"><a href="#inline-block" class="headerlink" title="inline/block"></a><code>inline</code>/<code>block</code></h3><p>块盒子和内联盒子区别在于会在页面流page flow和元素之间的关系上表现出不同的行为，使用<code>display</code>属性设置为<code>inline</code>或者<code>block</code>来控制盒子的<strong>外部显示类型</strong>。</p>
<blockquote>
<p>外部显示类型 V.S. 内部显示类型</p>
<p>注意这里的盒子模型是外部显示类型，用于决定盒子时块级还是内联。但是盒子模型本身还有一个内部显示类型，决定盒子内部元素如何布局。</p>
</blockquote>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a><code>flex</code></h3><p>可以通过使用类似 <code>flex</code> 的 <code>display</code> 属性值来更改<strong>内部显示类型</strong>。 如果设置 <code>display: flex</code>，在一个元素上，外部显示类型是 <code>block</code>，但是内部显示类型修改为 <code>flex</code>。</p>
<h3 id="inline-block-1"><a href="#inline-block-1" class="headerlink" title="inline-block"></a><code>inline-block</code></h3><p><code>display</code>属性有一个特殊值，用来表现内联盒块之间的一个中间状态，即<code>inline-block</code>。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><p>不希望一个项目切换到新行，但希望可是达成块盒子的部分效果。</p>
</li>
<li><p>添加内边距来使连接具有更大的命中区域</p>
</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>设置width和height属性会生效</li>
<li>padding/margin/border会推开其他元素</li>
</ul>
<h2 id="盒模型-1"><a href="#盒模型-1" class="headerlink" title="盒模型"></a>盒模型</h2><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><h4 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h4><ul>
<li>Content Box用于显示内容(width/height)</li>
<li>Padding Box包围在内容外部的空白区域(padding)</li>
<li>Border Box包裹内边距和内容(border)</li>
<li>Margin Box描述盒子与其他元素之间的空白区域，影响的还是盒子的外部空间。(margin)</li>
</ul>
<p><img src="/2020/10/16/css-tips/drunk99/machacroissant/source/_posts/2020-10-16-css-tips/box-model.png" alt="box-model"></p>
<blockquote>
<p>一个常见误区</p>
<p>给盒子设置<code>width</code>和<code>height</code>实际设置的是content box，padding和border再加上设置的width和height才是整个盒子的大小。</p>
<p>盒子的范围到border为止，不会延伸到margin。</p>
</blockquote>
<h4 id="替代盒模型"><a href="#替代盒模型" class="headerlink" title="替代盒模型"></a>替代盒模型</h4><p>标准盒模型的盒子大小需要计算才能获得，十分麻烦。使用替代盒模型的好处在于所有宽度都是可见宽度，内容宽度是该关度减去边框和填充部分。</p>
<p>浏览器默认使用标准盒模型，如果要使用替代盒模型，要设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing"><code>box-sizing</code></a> 属性为 <code>border-box</code>。</p>
<p>如果要使所有元素都使用替代模型，设置<code>box-sizing</code>在<code>&lt;html&gt;</code>元素上。</p>
<h4 id="属性margin-border-padding"><a href="#属性margin-border-padding" class="headerlink" title="属性margin/border/padding"></a>属性<code>margin</code>/<code>border</code>/<code>padding</code></h4><ol>
<li>外边距margin</li>
</ol>
<p>可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a>属性一次控制一个元素的所有边距。顺序为<strong>top-right-bottom-left顺时针</strong>。</p>
<p>无论使用标准模型还是替代模型，外边距总是在计算可见部分后额外添加。</p>
<p>会把其他元素从盒子旁边推开。 <strong>外边距属性值可以为正也可以为负</strong>。设置负值会导致和其他内容重叠。</p>
<p><strong>外边距折叠margin collapsing</strong>是指有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小，而不是两个外边距的综合。</p>
<ol>
<li>边框border</li>
</ol>
<p>可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>属性一次设置所有四个边框的宽度width、颜色color和样式style（注意书写顺序）。</p>
<p>圆角<code>border-radius</code>可使用长度或百分比作为值，第一个值定义水平半径，第二个值对应垂直半径。</p>
<ol>
<li>内边距padding</li>
</ol>
<p>内边距只能是0或正数。</p>
<p>内边距用于将内容推离边框。</p>
<blockquote>
<p> 以上这些属性完全适用于块盒子。但是内联盒子不一定使用，有一些设定会直接被忽略。</p>
</blockquote>
<p>另一种方法是用<code>em</code>值设定字体大小。<code>em</code> 值的大小是动态的。当定义或继承font-size属性时，1em等于该元素的字体大小。如果你在网页中任何地方都没有设置文字大小的话，那它将等于浏览器默认文字大小，通常是16px。<code>em = 希望得到的像素大小 / 父元素字体像素大小</code></p>
<p><code>color</code>CSS属性设置<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value">颜色值</a>的前景色以及<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-decoration">文本装饰</a>，可以用name-coclor，hsla，rgba，global index。</p>
<h1 id="display"><a href="#display" class="headerlink" title="display"></a>display</h1><p>用于定义元素的默认显示方式。</p>
<p>块级元素，默认填充满整个一行，如<code>div</code> <code>p</code> <code>ul</code> <code>li</code> ，自带<code>display: block</code>属性。</p>
<p>行内元素，默认大小由内容撑开，如<code>a</code> <code>span</code> <code>input</code>，自带<code>display: inline</code>属性。</p>
<h1 id="选择器-selector"><a href="#选择器-selector" class="headerlink" title="选择器 selector"></a>选择器 selector</h1><p>将命中的样式应用到对应的元素上。选择器所选择的元素，叫做“选择器的对象”。</p>
<p>如果你有多个使用相同样式的CSS选择器，那么这些<strong>单独的选择器</strong>可以被混编为一个“选择器列表” — <strong>将选择器组合起来，在它们之间加上一个逗号并另起一行</strong> — 这样，规则就可以应用到所有的单个选择器上了。</p>
<p>当你使用选择器列表时，如果任何一个选择器无效 (存在语法错误)，那么整条规则都会被忽略。</p>
<h2 id="确定样式的几种情况"><a href="#确定样式的几种情况" class="headerlink" title="确定样式的几种情况"></a>确定样式的几种情况</h2><h3 id="根据元素在文档中的位置确定样式"><a href="#根据元素在文档中的位置确定样式" class="headerlink" title="根据元素在文档中的位置确定样式"></a>根据元素在文档中的位置确定样式</h3><ul>
<li>设置某一个标签元素的后代元素的样式，利用包含选择器，在两个选择器之间加空格。</li>
<li>设置直接出现在某个标签元素后面并且与该标签元素具有相同层级的另一标签元素的样式，利用相邻选择符<code>+</code>。</li>
</ul>
<h3 id="根据状态确定样式"><a href="#根据状态确定样式" class="headerlink" title="根据状态确定样式"></a>根据状态确定样式</h3><p>最直观的例子就是<code>&lt;a&gt;</code>标签，在标签后面直接跟上<code>:status</code>。</p>
<h2 id="选择器种类"><a href="#选择器种类" class="headerlink" title="选择器种类"></a>选择器种类</h2><h3 id="类型-类-ID选择器"><a href="#类型-类-ID选择器" class="headerlink" title="类型/类/ID选择器"></a>类型/类/ID选择器</h3><ol>
<li>类选择器以<code>.</code>开头，会选择文档中应用了这个类的所有物件。</li>
</ol>
<ul>
<li><p>指向特定元素的类：通过没有空格地附加类的欲选择元素的选择器<code>h1.className</code>。</p>
</li>
<li><p>某个元素含有多个类：为了匹配带有所有这些类的元素，我们可以将这些类不加空格地连成一串。</p>
</li>
</ul>
<ol>
<li>ID选择器以<code>#</code>开头，由于在一篇文档中，一个id只能使用一次，将id选择器放在类选择之前缩小范围。</li>
</ol>
<h3 id="标签属性选择器"><a href="#标签属性选择器" class="headerlink" title="标签属性选择器"></a>标签属性选择器</h3><p>根据一个元素上的某个标签的属性的以下其中情况进行选择。</p>
<ul>
<li><code>[attr]</code> Matches elements with <strong>an <em>attr</em> attribute</strong> (whose name is the value in square brackets).</li>
<li><code>[attr=value]</code> Matches elements with an <em>attr</em> attribute whose value is <strong>exactly <em>value</em> — the string inside the quotes</strong>.</li>
<li><code>[attr~=value]</code> Matches elements with an <em>attr</em> attribute whose value is <strong>exactly <em>value</em></strong>, or <strong>contains <em>value</em> in its (space separated) list of values</strong>.</li>
<li><code>[attr|=value]</code> Matches elements with an <em>attr</em> attribute whose value is <strong>exactly <em>value</em></strong> or <strong>begins with <em>value</em> immediately followed by a hyphen.</strong></li>
<li><code>[attr^=value]</code>Matches elements with an <em>attr</em> attribute (whose name is the value in square brackets), whose value <strong>begins with <em>value</em>.</strong>(RegExp)</li>
<li><code>[attr$=value]</code>Matches elements with an <em>attr</em> attribute whose value <strong>ends with <em>value</em></strong>.(RegExp)</li>
<li><code>[attr*=value]</code>Matches elements with an <em>attr</em> attribute whose value <strong>contains <em>value</em> anywhere within the string</strong>.</li>
<li>Case Insentivity: Use the <strong>value <code>i</code> before the closing bracket.</strong> This flag tells the browser to match ASCII characters case-insensitively.</li>
</ul>
<h3 id="伪类-伪元素"><a href="#伪类-伪元素" class="headerlink" title="伪类/伪元素"></a>伪类/伪元素</h3><h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><p>伪类用于样式化一个元素的特定状态，直接跟一个冒号。它们选中你的文档中处于某种状态的那部分，表现得就像是你<em>已经向你的HTML加入类一样</em>。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements">参考</a></p>
<h5 id="位置决定样式"><a href="#位置决定样式" class="headerlink" title="位置决定样式"></a>位置决定样式</h5><p><code>:first-child</code> <code>:last-child</code> <code>nth-child</code> <code>nth-of-type</code></p>
<p><code>:only-child</code></p>
<p><code>:invalid</code></p>
<h5 id="用户行为伪类"><a href="#用户行为伪类" class="headerlink" title="用户行为伪类"></a>用户行为伪类</h5><p><code>:hover</code> <code>:focus</code> <code>:checked</code>等</p>
<h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><p>伪元素选择元素的某一个部分而不是元素自己，后面跟两个冒号。表现得是像你往标记文本中<em>加入全新的HTML元素一样</em>，而<em>不是向现有的元素上应用类</em>。</p>
<h5 id="生成带有伪类-before和-after的属性content-生成内容"><a href="#生成带有伪类-before和-after的属性content-生成内容" class="headerlink" title="生成带有伪类::before和::after的属性content//生成内容"></a>生成带有伪类<code>::before</code>和<code>::after</code>的属性<code>content</code>//生成内容</h5><ul>
<li><p>插入图标作为视觉提示，并且不希望屏幕阅读器读出它。</p>
</li>
<li><p>插入空字符串，而后像页面上的其他元素一样被样式化。</p>
</li>
</ul>
<h3 id="关系选择器Combinator"><a href="#关系选择器Combinator" class="headerlink" title="关系选择器Combinator"></a>关系选择器Combinator</h3><p>关系选择器在选择器之间，或选择器与文档内容的位置之间，建立了一种有用的关系。</p>
<h4 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h4><p>用单个空格（<code> </code>）字符组合两个选择器。</p>
<h4 id="子代关系选择器"><a href="#子代关系选择器" class="headerlink" title="子代关系选择器"></a>子代关系选择器</h4><p>子代关系选择器是个大于号（<code>&gt;</code>），只会在选择器选中直接子元素的时候匹配。（父亲节点与孩子节点/注意容易误区以为只能）</p>
<p>例如<code>article &gt; p</code>可以选择article元素的初代子元素。</p>
<h4 id="邻接选择器"><a href="#邻接选择器" class="headerlink" title="邻接选择器"></a>邻接选择器</h4><p>邻接兄弟选择器（<code>+</code>）用来选中恰好处于另一个在继承关系上同级的元素旁边的物件（紧跟/兄弟节点）。</p>
<h4 id="通用兄弟选择器"><a href="#通用兄弟选择器" class="headerlink" title="通用兄弟选择器"></a>通用兄弟选择器</h4><p>选中一个元素的兄弟元素，即使它们不直接相邻，你还是可以使用通用兄弟关系选择器（<code>~</code>）。（任何/兄弟节点）</p>
<p>全局选择器<code>*</code>，单用的话选中文档中的所有内容，如果和其他选择器组合的话放在后面就是选中父亲元素的所有内容。当组合选择器时，使用全局选择器会让选择器更加易读，更明显表明他们的作用。</p>
<h1 id="rules"><a href="#rules" class="headerlink" title="@ rules"></a>@ rules</h1><blockquote>
<p><strong>At-rules</strong> are <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Syntax#CSS_statements">CSS statements</a> that instructs CSS how to behave.</p>
</blockquote>
<p>最常见的就是@media，允许使用媒体查询来应用css。该查询将根据视口宽度更改样式。这符合响应式设计(Responsive Design)，能够让网站针对不同浏览器和设备呈现不同显示效果。</p>
<h1 id="背景样式"><a href="#背景样式" class="headerlink" title="背景样式"></a>背景样式</h1><ul>
<li><p><code>background-color</code></p>
</li>
<li><p><code>background-image</code></p>
<p>可设置url()，多个图像用逗号分开</p>
<p>可设置渐变背景</p>
</li>
<li><p><code>background-attachment</code></p>
<p>当有内容要滚动且想要设置页面滚动时，背景如何滚动</p>
<p>有scroll/fixed/local</p>
</li>
<li><p><code>background-repeat</code>可设置no-repeat/repeat-x/repeat-y/repeat</p>
</li>
<li><p><code>background-size</code>可设置长度或百分比值，关键字cover/contain</p>
</li>
<li><p><code>background-position</code></p>
<p>选择背景图像显示在其应用到的盒子中的位置。</p>
<p>可以使用(是<code>background-position-x</code>和<code>background-position-y</code>的缩写)水平坐标值紧跟垂直坐标值/关键字top、right、bottom、left、center/长度值/百分比。4-value语法可以指示到盒子的某些边的距离。</p>
</li>
</ul>
<h1 id="书写模式和方向"><a href="#书写模式和方向" class="headerlink" title="书写模式和方向"></a>书写模式和方向</h1><p>为什么需要谈到书写模式和方向？</p>
<p>新的书写模式对盒模型的各个属性有何影响？之前介绍的属性是属于物理属性还是逻辑属性？</p>
<p>如何让盒模型的各个属性适应任何书写模式？如何寻找一种通用的盒模型表示形式？</p>
<h2 id="writing-mode属性"><a href="#writing-mode属性" class="headerlink" title="writing-mode属性"></a><code>writing-mode</code>属性</h2><p>可以指定文本的排列方向是横向还是纵向。有三个取值<code>horizontal-tb</code>/<code>vertical-rl</code>/<code>vertical-lr</code>。</p>
<p>切换书写模式时，块和内联文本的方向也被改变了。此时，块维度指的总是块在页面书写模式下的显示方向。而内联维度指的总是文本方向。 </p>
<blockquote>
<p>这里存在一个问题，我们的内联和块的文本方向被改变了，也就是box的content布局改变了，但是content的width和height是横向模式下固定的。</p>
<p>也就是说，尽管盒子的物理方向因为我们设置了writing-mode属性有了变化，盒子的物理属性仍然是默认书写模式的物理属性。</p>
<p>因此需要把横向模式下的width和height对应到纵向模式下的XXX，或者任何书写模式下通用的XXX？</p>
</blockquote>
<h3 id="解决不同书写方向的盒模型适应问题"><a href="#解决不同书写方向的盒模型适应问题" class="headerlink" title="解决不同书写方向的盒模型适应问题"></a>解决不同书写方向的盒模型适应问题</h3><p>用逻辑<code>logical</code>和相对变化<code>flow relative</code>来代替<code>width</code>和<code>height</code>一样的物理属性。</p>
<p><code>width</code>映射成<code>inline-size</code>，表示内联维度的尺寸。</p>
<p><code>height</code>映射成<code>block-size</code>，表示块级维度的尺寸。</p>
<p>同样的，margin/border/padding都有对应的映射后的属性。</p>
<p><code>margin-top</code>映射成<code>margin-block-start</code>，表示块级维度开始处的边距。</p>
<p><code>border-bottom</code>映射成<code>border-block-end</code>，表示块级维度结尾处的边框。</p>
<p><code>padding-left</code>映射成<code>padding-inline-start</code>，表示内联开始方向上的内边距。</p>
<h1 id="调整大小"><a href="#调整大小" class="headerlink" title="调整大小"></a>调整大小</h1><h2 id="固有尺寸"><a href="#固有尺寸" class="headerlink" title="固有尺寸"></a>固有尺寸</h2><p>元素的固有尺寸由其包含的内容决定。</p>
<p>如果给一个块级元素如div不添加任何内容，设置border，会出现横跨页面一整行的一条线，那是边框被压缩后的效果，欣慰内部没有内容撑开它。表现出横跨一整行是因为这是一个块级元素。</p>
<p>如果放置一个内联元素img，表现出来就会是一个正方形。也是压缩后的效果。</p>
<h2 id="设置尺寸"><a href="#设置尺寸" class="headerlink" title="设置尺寸"></a>设置尺寸</h2><p>给元素指定尺寸时，我们称之为外部尺寸，无论放什么内容进去，该尺寸恒定；如果内容超出了该指定尺寸的容纳空间，就发生内容溢出。</p>
<h3 id="使用具体的数值"><a href="#使用具体的数值" class="headerlink" title="使用具体的数值"></a>使用具体的数值</h3><h3 id="使用百分数"><a href="#使用百分数" class="headerlink" title="使用百分数"></a>使用百分数</h3><p>要注意这个百分数是什么的百分数，一般都是指父级容器的百分数。百分数是以包含盒子的块为根据解析的。</p>
<blockquote>
<p>This is because percentages resolve against the size of the containing block. With no percentage applied our <code>&lt;div&gt;</code> would take up 100% of the available space, as it is a block level element. If we give it a percentage width, this becomes a percentage of the space it would normally fill.</p>
</blockquote>
<p><code>width</code>设置百分数参考父级元素。</p>
<p><code>margins</code>和<code>padding</code>设置百分数，值以内联尺寸inline-size为依据进行计算(therefore the width when working in a horizontal language)，通过给他们设置相同的百分数可以让盒子周围的内外边距大小相同。</p>
<h3 id="使用min-和max-尺寸"><a href="#使用min-和max-尺寸" class="headerlink" title="使用min-和max-尺寸"></a>使用min-和max-尺寸</h3><p>给定一个元素的最大或最小尺寸。</p>
<p>Min-height的常见用法为：盒子中有变化容量的内容，想让它有一个确定的高度。盒子就会一直保持大于这个最小高度，但是如果有比这个盒子在最小高度状态下所能容纳的更多内容，那么盒子就会变大。</p>
<p>max-width的常见用法为：在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。（响应式设计）</p>
<h2 id="视口单位"><a href="#视口单位" class="headerlink" title="视口单位"></a>视口单位</h2><p>与视口尺寸相关的度量单位，即意为视口宽度的<code>vw</code>单位，以及意为视口高度的 <code>vh</code>单位。</p>
<p><code>1vh</code>等于视口高度的1%，<code>1vw</code>则为视口宽度的1%。你可以用这些单位约束盒子的大小，还有文字的大小，他们会一起变化。</p>
<h1 id="溢出-overflow"><a href="#溢出-overflow" class="headerlink" title="溢出 overflow"></a>溢出 overflow</h1><p><strong>Overflow happens when there is too much content to fit in a box.</strong> </p>
<p>下面介绍几种处理CSS溢出的方法。</p>
<h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a><code>overflow</code></h2><p>告诉浏览器如果发生了溢出，该怎么处理溢出的内容。</p>
<blockquote>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/overflow"><code>overflow</code></a> property is how you take control of an element’s overflow. It is the way you instruct the browser how it should behave.</p>
</blockquote>
<ul>
<li><p>The <strong>default value</strong> of overflow is <strong><code>visible</code></strong>. With this default, we can see content when it overflows.</p>
</li>
<li><p>To <strong>crop content</strong> when it overflows, you can set <strong><code>overflow: hidden</code>.</strong> This does exactly what it says: it hides overflow. Beware that this can make some content invisible. </p>
</li>
<li><p>Add scrollbars when content overflows, Using <strong><code>overflow: scroll</code>,</strong> browsers with visible scrollbars will always display them—even if there is not enough content to overflow. </p>
</li>
<li><p>可以直接向属性传入两个以上列出的参数值，分别对应水平和垂直方向。</p>
</li>
</ul>
<p>scroll on the x axis using <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-x"><code>overflow-x</code></a>.</p>
<p>scroll on the <code>y</code> axis using  <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-y"><code>overflow-y</code></a>.</p>
<ul>
<li>If you only want scrollbars to appear when there is more content than can fit in the box, use <code>overflow: auto</code></li>
</ul>
<p>当发生a small box with a long word（就是一句话中有很长一个单词直接超出了content范围）时，不适合用overflow。如果hidden会导致data loss，如果scroll不利于展示，建议使用<code>word-break</code>或<code>overflow-wrap</code>属性。这二者都是对一句话进行断句，区别在于利用空格考虑单词完整性断句。</p>
<blockquote>
<p> In contrast to <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/word-break"><code>word-break</code></a>, <code>overflow-wrap</code> will only create a break if an entire word cannot be placed on its own line without overflowing.</p>
</blockquote>
<h1 id="CSS的值"><a href="#CSS的值" class="headerlink" title="CSS的值"></a>CSS的值</h1><div class="table-container">
<table>
<thead>
<tr>
<th>数值类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>integer</td>
<td>整数</td>
</tr>
<tr>
<td>number</td>
<td>小数，也可以是没有小数部分的整数</td>
</tr>
<tr>
<td>dimension</td>
<td>有附加单位的number，包括许多特定的类型，比如length</td>
</tr>
<tr>
<td>percentage</td>
<td>百分比值</td>
</tr>
</tbody>
</table>
</div>
<h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><h3 id="绝对长度"><a href="#绝对长度" class="headerlink" title="绝对长度"></a>绝对长度</h3><p>与其他任何东西都没有关系，总是相同大小。cm/mm/px/pt，常用于打印。</p>
<h3 id="相对长度"><a href="#相对长度" class="headerlink" title="相对长度"></a>相对长度</h3><p>相对于其他一些东西，比如父亲元素的字体大小，或者视图端口的大小。</p>
<p>例如<code>em</code>在 font-size 中的基准是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width。如果样式应用在某个标签上，这个标签中存在其他标签，那么这个样式会<strong>嵌套应用，逐级变大</strong>。</p>
<p><code>rem</code>单位的意思是以根元素的字体大小为基准。每一个连续的嵌套层都不会不断变大。</p>
<h2 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h2><p>百分比是总相对于其他值设置的。</p>
<p>在font-size中使用百分比，会让嵌套标签内容从父级继承并<strong>嵌套应用，逐级变小</strong>。</p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>不添加任何单位的数字。例如不透明度属性(opacity)，取值控制在0～1。</p>
<h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>position数据类型表示一组2D坐标，用于定位一个元素。</p>
<h2 id="字符串和标志符"><a href="#字符串和标志符" class="headerlink" title="字符串和标志符"></a>字符串和标志符</h2><p>标志符就是被用作值的关键字。表示一个CSS可以理解的特殊值，不需要被引号扩起来，因为它们不被当作字符串。</p>
<p>字符串一般在指定生成内容时使用<code>content:&quot;&quot;</code>。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数也易属性值的形式存在于CSS中，在颜色部分用到的rgb()/hsl()/url()/calc()都是函数。 </p>
<h1 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value">颜色取值</a></p>
<h2 id="十六进制RGB"><a href="#十六进制RGB" class="headerlink" title="十六进制RGB"></a>十六进制RGB</h2><p>对应红色、绿色和蓝色。</p>
<h2 id="RGB和RGBA"><a href="#RGB和RGBA" class="headerlink" title="RGB和RGBA"></a>RGB和RGBA</h2><p>都是函数，接受0～255之间的十进制数字。A代表透明度。</p>
<blockquote>
<p>区别opacity和RGBA中的A的区别：使用不透明度会让元素和他里面的所有东西都不透明，但是RGBA只会让指定的颜色不透明。</p>
</blockquote>
<h2 id="HSL和HSLA"><a href="#HSL和HSLA" class="headerlink" title="HSL和HSLA"></a>HSL和HSLA</h2><p>都是函数，接受色调、饱和度、亮度值作为参数。</p>
<p>色调是颜色的底色，参考色轮0～360。</p>
<p>饱和度范围为0～100%，0代表无颜色显示为灰色阴影，100%代表全色饱和度。</p>
<p>亮度范围为0～100%，0代表没有光，显示全黑色，100%代表完全亮，显示为白色。</p>
<h1 id="图像和视频"><a href="#图像和视频" class="headerlink" title="图像和视频"></a>图像和视频</h1><p>图像和视频被描述为替换元素(replaced element)。这些元素是一种外部对象，他们的内容不受当前文档的样式的影响。CSS只能影响可替换元素的位置，但不能影响它自身的内容。</p>
<h2 id="调整图像大小-amp-溢出问题"><a href="#调整图像大小-amp-溢出问题" class="headerlink" title="调整图像大小&amp;溢出问题"></a>调整图像大小&amp;溢出问题</h2><h2 id="max-width"><a href="#max-width" class="headerlink" title="max-width"></a>max-width</h2><p>将max-width设置为100%，使图片尺寸上小于但不大于盒子。</p>
<h2 id="object-fit"><a href="#object-fit" class="headerlink" title="object-fit"></a>object-fit</h2><p>目的是使替换元素以多种方式被调整到合乎盒子的大小。</p>
<ul>
<li>cover维持比例地缩小图像，可部分填充盒子，一部分会被剪裁。</li>
<li>contain维持比例缩放图像，必须整个填充盒子，会产生空白。</li>
<li>fill不维持比例缩放图像，完全填充盒子。</li>
</ul>
<blockquote>
<p>需要注意布局中的替换元素会有默认的不同的行为。例如在flex或grid布局中，其他元素会默认拉伸充满整个区域，但图像不会被拉伸，只会被对齐到网格区域或弹性容器起始处。</p>
</blockquote>
<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h2 id="样式化表单的预处理"><a href="#样式化表单的预处理" class="headerlink" title="样式化表单的预处理"></a>样式化表单的预处理</h2><p>在一些浏览器中表单元素默认不会继承字体样式，为了确保表单填入区域中使用body或者父亲元素中定义的字体，需要添加规则<code>font-family:inherit/font-size:100%</code>。</p>
<p>样式化表单时采用<code>box-sizing</code>属性中的<code>border-box</code>，且将所有元素的内外边距设置为0，在单独进行样式化控制式加回来。</p>
<p>在<code>textarea</code>上设置<code>overflow:auto</code>可以避免IE在不需要滚动条的时候显示滚动条。</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span>, </span><br><span class="line"><span class="selector-tag">input</span>, </span><br><span class="line"><span class="selector-tag">select</span>, </span><br><span class="line"><span class="selector-tag">textarea</span> &#123; </span><br><span class="line">  <span class="attribute">font-family</span>: inherit; </span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">100%</span>; </span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box; </span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>; <span class="attribute">margin</span>: <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">textarea</span> &#123; </span><br><span class="line">  <span class="attribute">overflow</span>: auto; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在有许多通用样式表确保你在开始自己的CSS作业之前跨浏览器的任何事情都会被设定成统一的样式。以上的操作也是一个简单的通用样式的设计。</p>
</blockquote>
<h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h2><p>通过 <code>table-layout: fixed</code>，您可以根据列标题的宽度来规定列的宽度，然后适当地处理它们的内容。结合一个100%的<code>width</code>组合在一起，这意味着该表将填充它放入的任何容器，并且能很好的响应。</p>
<p>使用 <code>border-collapse: collapse;</code> ，让表元素边框合为一条。</p>
<p>在<code>th</code>和<code>td</code>元素上设置了一些<code>padding</code>使数据项有了一些空间，使表看起来更加清晰。设置<code>letter-spacing</code>，有助于提高可读性。<code>text-align</code>对其文本内容。</p>
<h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><p>样式化文本内容需要从字体样式和文本布局风格两方面考虑。</p>
<blockquote>
<p>网络字体使用</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 由于字体要预先下载，把该文件放在CSS文件的最上面最初导入</span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;XXXX&#x27;</span>;</span><br><span class="line">    // 之后在font-family属性中要用到该值</span><br><span class="line">    src: url(&#x27;fonts/....woff2&#x27;) format(&#x27;woff2&#x27;);</span><br><span class="line">    // 建议倒入多种格式以支持不同浏览器。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h2><ul>
<li>color</li>
<li>font-family(using font stack)</li>
<li>font-size(px/em/rem)当调整你的文本大小时，预处理将文档(document)的基础 <code>font-size</code> 设置为10px，所需要的 (r)em 值就是想得到的像素的值除以 10，而不是 16。建议在样式表的指定区域列出所有<code>font-size</code>的规则集，这样它们就可以很容易被找到。</li>
<li>font-style斜体/font-weight粗体/text-tansform大小写/text-decoration上中下划线多取值</li>
<li>text-shadow可有多个阴影值，一个阴影值有四个值。</li>
</ul>
<h2 id="文本布局风格"><a href="#文本布局风格" class="headerlink" title="文本布局风格"></a>文本布局风格</h2><ul>
<li>text-align</li>
<li>line-height通常1.5～2</li>
<li>letter-spacing/word-spacing</li>
</ul>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h2 id="列表间距"><a href="#列表间距" class="headerlink" title="列表间距"></a>列表间距</h2><p>考虑列表在文档上下文中的一致性，通过设定每个段落和列表之间的上下间距line-height和字体大小font-size。</p>
<p>考虑列表内部的形式一致性，通过设定列表项的行高。</p>
<h2 id="列表项目符号"><a href="#列表项目符号" class="headerlink" title="列表项目符号"></a>列表项目符号</h2><p><code>list-style-type/position/image</code>分别用于</p>
<ul>
<li><p>设置列表项目符号的类型(none)</p>
</li>
<li><p>列表项目符号的位置是在列表项内还是列表项外inside/outside</p>
</li>
<li><p>允许自定义图片为项目符号，图像的设置参考background-image，结合type为none。</p>
</li>
</ul>
<p>有序列表的编号控制</p>
<ul>
<li>从<code>ol</code>设定可以设定<code>start=&quot;x&quot;</code> <code>reversed</code></li>
<li>从<code>li</code>设定可以设定<code>value=&quot;?&quot;</code></li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="链接状态"><a href="#链接状态" class="headerlink" title="链接状态"></a>链接状态</h3><p>:link</p>
<p>:vistied</p>
<p>:hover</p>
<p>:focus</p>
<p>:active</p>
<p>对于链接样式的设置要从上面五个状态分别设置规则集进行考虑。</p>
<h2 id="链接-—-按钮"><a href="#链接-—-按钮" class="headerlink" title="链接 — 按钮"></a>链接 — 按钮</h2><p>通常使链接被样式化之后看起来效果和按钮差不多。例如网站菜单栏，标记为一个列表，列表中包含链接。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML基础知识</title>
    <url>/2020/10/19/html-revision/</url>
    <content><![CDATA[<h1 id="头部元素"><a href="#头部元素" class="headerlink" title="头部元素"></a>头部元素</h1><p><code>&lt;head&gt;</code>标签中包括了哪些内容？</p>
<h2 id="lt-title-gt"><a href="#lt-title-gt" class="headerlink" title="&lt;title&gt;"></a><code>&lt;title&gt;</code></h2><ul>
<li>与<code>h1</code>的区别在于<code>&lt;title&gt;</code>是为整个HTML文档添加标题，会在添加书签的时候建议用做书签名。<code>h1</code>主要是为<code>&lt;body&gt;</code>添加标题的。</li>
</ul>
<h2 id="lt-meta-gt"><a href="#lt-meta-gt" class="headerlink" title="&lt;meta&gt;"></a><code>&lt;meta&gt;</code></h2><p>元数据就是描述数据的数据。</p>
<p><code>charset</code>属性规定了文档中的字符编码。</p>
<p><code>name</code>指定了meta元素类型，可以去取<code>author</code> <code>description</code> 等值； <code>content</code>属性指定了实际的元数据内容。</p>
<h2 id="lt-link-gt"><a href="#lt-link-gt" class="headerlink" title="&lt;link&gt;"></a><code>&lt;link&gt;</code></h2><p><code>rel</code> <code>href</code>属性，用于添加页面自定义图标或样式表</p>
<h2 id="script"><a href="#script" class="headerlink" title="script"></a><code>script</code></h2><p>专门用于在HTML页面中应用JavaScript。</p>
<h1 id="文字处理"><a href="#文字处理" class="headerlink" title="文字处理"></a>文字处理</h1><ul>
<li><code>p</code>段落</li>
<li><code>h1</code>标题</li>
<li>有序列表<code>&lt;ol&gt;</code>/无序列表 <code>&lt;ul&gt;</code>/ 列表元素<code>&lt;li&gt;</code> /嵌套列表/描述列表(description list)<code>&lt;dl&gt;</code> — 描述术语 <code>&lt;dt&gt;</code> — 描述列表的描述部分 <code>&lt;dd&gt;</code> 会产生缩进。</li>
<li><code>&lt;em&gt;</code>表示强调/<code>&lt;strong&gt;</code>表示非常重要/可以被嵌套在其他标签中</li>
<li><code>&lt;b&gt;</code> <code>&lt;i&gt;</code> <code>&lt;u&gt;</code>仅仅影响表现且没有语义，是表象元素(presentational element)。</li>
</ul>
<p>二者区别在于<strong>语义</strong>。<code>&lt;em&gt;</code> <code>&lt;strong&gt;</code>会表现出斜体/加粗是因为这是浏览器默认行为，是可以被更改的，用这个标签不是为了获得斜体风格。<code>&lt;b&gt;</code> <code>&lt;i&gt;</code> <code>&lt;u&gt;</code>就是纯粹为了表现出特定的风格。</p>
<ul>
<li>引用 块引用<code>&lt;blockquote cite=&quot;&quot;&gt;&lt;/blockquote&gt;</code> — 行内引用<code>&lt;q cite=&quot;&quot;&gt;&lt;/q&gt;</code>。注意<code>cite</code>属性不会被显示，如果需要显示该引用来源，直接用<code>&lt;cite&gt;</code>标签包裹住内容，并在外层嵌套一个<code>&lt;a href&gt;</code>超链接。</li>
<li><code>&lt;address&gt;</code>标记联系方式。</li>
<li><code>&lt;sup&gt; &lt;sub&gt;</code>标记上下标。</li>
<li><code>&lt;time datetime=&quot;&quot;&gt;&lt;/time&gt;</code>提供机器可识别的时间和日期。</li>
</ul>
<h1 id="布局元素"><a href="#布局元素" class="headerlink" title="布局元素"></a>布局元素</h1><h2 id="有语义"><a href="#有语义" class="headerlink" title="有语义"></a>有语义</h2><ul>
<li><code>&lt;main&gt;</code>一个页面上用一次，直接位于<code>&lt;body&gt;</code>中。</li>
<li><code>&lt;article&gt;</code> 存放与页面其他布局元素无关的文章。</li>
<li><code>&lt;section&gt;</code> 适用于组织页面使其按功能分块。</li>
<li><code>&lt;aside&gt;</code>侧边栏，补充信息。</li>
<li><code>&lt;header&gt;</code> 作<code>body</code>的子元素就是网站的全局页眉；如果是<code>&lt;article&gt;</code>或者<code>&lt;section&gt;</code>的子元素就是这部分特有的页眉。注意和<code>&lt;head&gt;</code>标题区分。</li>
<li><code>&lt;nav&gt;</code>页面主导航功能。</li>
<li><code>&lt;footer&gt;</code>包含了页面的页脚。</li>
</ul>
<h2 id="无语义"><a href="#无语义" class="headerlink" title="无语义"></a>无语义</h2><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>之前有语义的元素无法对应</li>
<li>只想将一组元素作为一个单独的实体来修饰响应单一的CSS和JavaScript。</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>内联无语义元素<code>&lt;span&gt;</code></p>
<p>块级无语义元素<code>&lt;div&gt;</code></p>
<h1 id="多媒体元素"><a href="#多媒体元素" class="headerlink" title="多媒体元素"></a>多媒体元素</h1><p>有时被称为替换元素，因为这个元素的内容和尺寸由外部资源所定义，而不是元素自身。</p>
<p>元素自身属于空元素，没有闭合标签，标签内容为空。</p>
<h2 id="img"><a href="#img" class="headerlink" title="img"></a><code>img</code></h2><ul>
<li><code>src</code> 想要引入的图片的绝对路径或相对路径</li>
<li><code>alt</code> 备选文本，值是对该图片的文字描述</li>
<li><code>width height</code> 设置图片大小</li>
<li><code>title</code>鼠标悬停在图片上会有提示信息</li>
</ul>
<p><code>&lt;figure&gt;</code> <code>&lt;figcaption&gt;</code>为图片提供一个语义容器，在</p>
<p>HTML图片是具有语义的，而用CSS构建的图片只是为了起装饰作用。</p>
<h2 id="video-audio"><a href="#video-audio" class="headerlink" title="video/audio"></a><code>video</code>/<code>audio</code></h2><ul>
<li><code>src</code></li>
<li><code>controls</code>没有取值，是一个布尔变量，使其包含浏览器提供的控制界面。也可以使用JS API自定义控件界面。</li>
<li>video标签的内容是后备内容，当浏览器不支持<code>&lt;video&gt;</code>标签时就会显示这段内容。</li>
<li>在video标签内容中提供多个<code>&lt;source&gt;</code>播放源以提高兼容性。</li>
</ul>
<p>媒体文件的内容有多种形式，类似于MP3、MP4、WebM这些属于叫做容器格式，它们定义了生成媒体文件的音频轨道/视频轨道/文本轨道的储存结构，一些描述性的元数据，和编码译码器。</p>
<p>因为浏览器支持的coder-decoder有所不同，为了兼容不同的浏览器，需要利用<code>&lt;source&gt;</code>标签提供不同格式的源文件。</p>
<ul>
<li><code>autoplay</code> 自动播放，不建议。</li>
<li><code>loop</code> 循环播放，不建议。</li>
<li><code>muted</code>播放时默认关闭声音。</li>
<li><code>poster</code>视频封面。</li>
<li><code>preload</code>缓冲较大文件。</li>
<li><code>&lt;track&gt;</code>标签的<code>src</code>属性是<code>.vtt</code>文件，<code>kind</code>属性可以取值subtitles/captions/descriptions，<code>srclang</code>属性高速浏览器你编写文件的语言。</li>
</ul>
<h2 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a><code>iframe</code></h2><p>能够将其他Web文档嵌入到当前文档中，适用于将第三方内容嵌入网站，存在安全隐患。</p>
<ul>
<li><p><code>allowfullscreen</code> 布尔变量。</p>
</li>
<li><p><code>frameborder=&quot;&quot;</code></p>
</li>
<li><p><code>src=&quot;&quot;</code></p>
</li>
<li><p><code>width=&quot;&quot; height=&quot;&quot;</code></p>
</li>
<li><p><code>sandbox</code> 布尔变量，建议始终使用sandbox属性。</p>
<p>沙盒定义：一个允许包含在其里的代码以适当的方式执行或者用于测试，但不能对其他代码库（意外或恶意）造成任何损害的容器。</p>
</li>
</ul>
<h2 id="object和embed"><a href="#object和embed" class="headerlink" title="object和embed"></a><code>object</code>和<code>embed</code></h2><p>嵌入各种形式的插件。</p>
<h2 id="svg"><a href="#svg" class="headerlink" title="svg"></a><code>svg</code></h2><h3 id="图片类型"><a href="#图片类型" class="headerlink" title="图片类型"></a>图片类型</h3><h4 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h4><p>用像素网格定义，精确包含每个像素的位置和它的色彩信息。有<code>.bitmap .png .jpg .gif</code>。</p>
<h4 id="矢量图"><a href="#矢量图" class="headerlink" title="矢量图"></a>矢量图</h4><p>用算法定义，包含图形和路径的定义，电脑根据定义计算出该如何呈现。有SVG格式。</p>
<h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>SVG是描述矢量图像的XML语言，用于标记图形。</p>
<h3 id="将矢量图添加到HTML"><a href="#将矢量图添加到HTML" class="headerlink" title="将矢量图添加到HTML"></a>将矢量图添加到HTML</h3><p>利用<code>&lt;img&gt;</code></p>
<p>直接复制SVG代码，并内联到HTML文件中</p>
<p>使用<code>&lt;iframe&gt;</code></p>
<h2 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h2><p>一种可以在不同的屏幕尺寸和分辨率设备上良好工作的图片。涉及到美术设计问题和分辨率切换问题。</p>
<p>分辨率切换可以通过<code>&lt;img&gt;</code>元素的<code>srcset</code>和<code>sizes</code>两个属性来实现。</p>
<p>美术设计可以通过<code>&lt;pictures&gt;</code>元素来实现。</p>
<h3 id="lt-img-gt"><a href="#lt-img-gt" class="headerlink" title="&lt;img&gt;"></a><code>&lt;img&gt;</code></h3><h4 id="适用于不同图片尺寸的方案srcset-sizes"><a href="#适用于不同图片尺寸的方案srcset-sizes" class="headerlink" title="适用于不同图片尺寸的方案srcset+sizes"></a>适用于不同图片尺寸的方案<code>srcset</code>+<code>sizes</code></h4><p><code>srcset</code>定义允许选择的图像集，双引号内用逗号分隔。每一个可选项包括：文件名+空格+以<code>w</code>为单位的图像的固有宽度。</p>
<p><code>sizes</code>定义一组媒体条件，双引号内用逗号分隔。每一个可选媒体条件包括：带括号的媒体条件（不要忘了冒号）+空格+媒体条件为真时图像将填充的槽的宽度。最后一个逗号后面只有槽的宽度，是默认匹配。</p>
<p>浏览器行为：查看设备宽度 — 查询<code>sizes</code>匹配合适的媒体条件 — 找到对应的媒体条件的槽的大小 — 依据已知槽的大小去选择最接近该槽大小的<code>srcset</code>列表中的图像。</p>
<h4 id="适用于相同图片尺寸不同分辨率的方案srcset-x语法"><a href="#适用于相同图片尺寸不同分辨率的方案srcset-x语法" class="headerlink" title="适用于相同图片尺寸不同分辨率的方案srcset+x语法"></a>适用于相同图片尺寸不同分辨率的方案<code>srcset</code>+x语法</h4><p><code>srcset</code>定义允许选择的图像集，可选项包括：文件名+空格+以<code>x</code>为单位的数据。</p>
<p>浏览器行为：计算出当前显示器的分辨率 — 从 <code>srcset</code>中找出最合适的引用图片。</p>
<h3 id="lt-picture-gt"><a href="#lt-picture-gt" class="headerlink" title="&lt;picture&gt;"></a><code>&lt;picture&gt;</code></h3><p>为不同的布局提供不同裁剪的图片，不同的图片突出的细节不同。</p>
<p>可以在<code>&lt;picture&gt;</code>标签中包含<code>&lt;source&gt;</code>标签以及必须有的带有<code>src</code>和<code>alt</code>属性的<code>&lt;img&gt;</code>标签。</p>
<h4 id="media"><a href="#media" class="headerlink" title="media"></a><code>media</code></h4><p>该属性取值为一个媒体条件，注意媒体条件的写法。</p>
<h4 id="srcset"><a href="#srcset" class="headerlink" title="srcset"></a><code>srcset</code></h4><p>包含显示图片的路径。</p>
<h3 id="为什么需要在HTML中实现响应式图片"><a href="#为什么需要在HTML中实现响应式图片" class="headerlink" title="为什么需要在HTML中实现响应式图片"></a>为什么需要在HTML中实现响应式图片</h3><p>浏览器最先加载的就是HTML文件中的内容，主解析器开始加载CSS和JavaScript之后。HTML中的响应式图片主要是为了应对不同设备对该网页的可访问性，我们不可能在页面上只放一张照片，等页面加载出来在用JavaScript去替换成合适的照片。</p>
<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><p>HTML表单主要用于收集数据并将这些数据发送到服务器，需要有一个Web服务器来接收和处理数据。</p>
<h2 id="lt-form-gt"><a href="#lt-form-gt" class="headerlink" title="&lt;form&gt;"></a><code>&lt;form&gt;</code></h2><p>定义了表单和确定表单属性的行为。是创建一切HTML表单的开始。</p>
<h3 id="action"><a href="#action" class="headerlink" title="action"></a><code>action</code></h3><p>定义了提交表单的时候，这里收集到的键/值形式的数据送往那个URL，可以是一个PHP文件。</p>
<h3 id="method"><a href="#method" class="headerlink" title="method"></a><code>method</code></h3><p>定义发送数据的HTTP方法时get还是post，无论使用哪一种方法，服务器接收到的都是一个字符串。</p>
<h3 id="enctype"><a href="#enctype" class="headerlink" title="enctype"></a><code>enctype</code></h3><p>默认情况下该属性值为<code>application/x-www-form-urlencoded</code>，意思是已编码为URL参数的表单数据。</p>
<p>如果要发送文件，需要将值设置为<code>multipart/form-data</code>。同时包含file picker小部件。</p>
<h2 id="lt-fieldset-gt"><a href="#lt-fieldset-gt" class="headerlink" title="&lt;fieldset&gt;"></a><code>&lt;fieldset&gt;</code></h2><p>用于创建具有相同目的的小部件组的方式，相当于功能相同一起打包，方便后续一起添加样式或者语义。</p>
<p>在其开口标签之后添加<code>&lt;legend&gt;&lt;/legend&gt;</code>来描述这个小部件组的用途。</p>
<h3 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h3><ul>
<li>包裹着一组单选按钮。</li>
<li>对长表单进行分段，使之可以放在不同的页面上，提高可用性。</li>
</ul>
<h2 id="小部件"><a href="#小部件" class="headerlink" title="小部件"></a>小部件</h2><p>一般使用<code>&lt;div&gt;</code> <code>&lt;fieldset&gt;</code> <code>&lt;section&gt;</code> <code>h</code>标题 <code>&lt;p&gt;</code>标签同时包装标签和对应的的小部件，可以构造更复杂的表单。例如section&gt;h2+p的组合。</p>
<h3 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h3><p><code>autofocus</code>布尔属性，加载时自动聚焦</p>
<p><code>disabled</code>布尔属性，表示用户不能与元素交互。继承。</p>
<p><code>name</code>元素名称，和数据一起提交。</p>
<p><code>value</code>元素初始值。</p>
<h3 id="lt-label-gt"><a href="#lt-label-gt" class="headerlink" title="&lt;label&gt;"></a><code>&lt;label&gt;</code></h3><p><code>&lt;label&gt;</code>的<code>for</code>属性值和<code>&lt;input&gt;</code>的<code>id</code>属性值相匹配。</p>
<p><code>&lt;label&gt;</code>的内容就是该输入框的名字。</p>
<p>完成绑定之后，可以将该输入框名字和该输入框相匹配，点击该输入框名字可以激活后面的输入框。</p>
<h3 id="lt-input-gt"><a href="#lt-input-gt" class="headerlink" title="&lt;input&gt;"></a><code>&lt;input&gt;</code></h3><p>通用规范包括<code>readonly</code> <code>disabled</code>(输入值永远不会和表单数据的其余部分一起发送) <code>size</code>(框的物理尺寸) <code>maxlength</code>(可输入的最大字符数目) <code>placeholder</code>(文本库中出现的文本，用来粗略描述输入框目的)</p>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a><code>type</code></h4><p><code>&lt;type&gt;</code>是<code>&lt;input&gt;</code>最重要的属性，定义了接收数据的格式。注意<code>&lt;input&gt;</code>是一个空标签。</p>
<ul>
<li><p><code>text</code>是<code>&lt;type&gt;</code>的默认值和备用值，用于创建单行文本框。</p>
</li>
<li><p><code>password</code>属性值用于创建密码框。</p>
</li>
<li><p><code>email</code>属性值用于创建邮件地址框。</p>
</li>
<li><p><code>search</code>属性值用于创建搜索框，样式上会呈现出圆角以及‘x’清除。</p>
</li>
<li><p><code>tel</code>属性值用于创建电话号码栏。</p>
</li>
<li><p>可选中项的创建基于： <code>checked</code>布尔属性+<code>type=???</code>取值</p>
<p>发送数据时的行为与其他表单小部件不同。表单发送时，只有在选中该选项时，才会提交选中的<code>value</code>和<code>name</code>，不选择是不发送的。</p>
<ul>
<li><code>type=&quot;checkbox&quot;</code>属性值用于复选框</li>
<li><code>type=&quot;radio&quot;</code>属性值用于创建单选按钮</li>
</ul>
</li>
</ul>
<h4 id="value"><a href="#value" class="headerlink" title="value"></a><code>value</code></h4><p>因为<code>input</code>是空标签，所以定义它的的初始值要用<code>value</code>属性来实现。</p>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a><code>id</code></h4><p><code>id</code>属性是为了和<code>&lt;label&gt;</code>的<code>for</code>属性值匹配。</p>
<h4 id="name"><a href="#name" class="headerlink" title="name"></a><code>name</code></h4><p>用于告诉浏览器这个数据的名称是什么，从而通过HTTP报文发送过去后服务器端可以按照名称收集并处理数据块。</p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a><code>list</code></h4><p>该属性值和<code>&lt;datalist&gt;</code>元素的<code>id</code>值相同，绑定之后提供提供数据列表(<code>datalist&gt;option*n</code>)。</p>
<h3 id="lt-textarea-gt"><a href="#lt-textarea-gt" class="headerlink" title="&lt;textarea&gt;"></a><code>&lt;textarea&gt;</code></h3><p>多行文本框，允许用户包含硬换行符(按回车)。</p>
<p>有开始标签和结束标签，和<code>&lt;input&gt;</code>区别在于文本默认值的设定。</p>
<h3 id="lt-select-gt"><a href="#lt-select-gt" class="headerlink" title="&lt;select&gt;"></a><code>&lt;select&gt;</code></h3><p>用于创建单选框下拉窗口，其中有一个或多个<code>&lt;option&gt;</code>元素作为子元素。</p>
<p>多选选择框的创建就是将<code>multiple</code>属性添加到<code>&lt;select&gt;</code>中，直接显示的不是下拉窗口而是所有列表。</p>
<h4 id="lt-option-gt"><a href="#lt-option-gt" class="headerlink" title="&lt;option&gt;"></a><code>&lt;option&gt;</code></h4><p><code>&lt;option&gt;</code>元素还可以作为子元素嵌套在<code>&lt;optgroup&gt;</code>中。<code>&lt;option&gt;</code>的<code>&lt;value&gt;</code>规定了表单提交时应该发送的数据。</p>
<h3 id="lt-button-gt"><a href="#lt-button-gt" class="headerlink" title="&lt;button&gt;"></a><code>&lt;button&gt;</code></h3><p>按钮，  <code>type</code>属性有三种取值。这三个取值也可以在<code>&lt;input&gt;</code>的<code>type</code>属性中设置，技术上同样可以实现按钮。</p>
<ul>
<li><p><code>submit</code>取值会将表单数据发送到<code>&lt;form&gt;</code>里<code>action</code>属性定义的网页中。</p>
</li>
<li><p><code>reset</code>重置为默认值。</p>
</li>
<li><p><code>button</code>不会发生任何事，可以用JavaScript构建定制按钮。</p>
</li>
</ul>
<h2 id="表单样式"><a href="#表单样式" class="headerlink" title="表单样式"></a>表单样式</h2><h3 id="字体和文本"><a href="#字体和文本" class="headerlink" title="字体和文本"></a>字体和文本</h3><p>为了让表单的字体外观和其他内容保持一致使用</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123;</span><br><span class="line">  <span class="attribute">font-family </span>: inherit;</span><br><span class="line">  <span class="attribute">font-size   </span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>每个小部件都有自己的边框，填充和边距的规则，如果统一所有小部件的风格，需要使用到<code>box-sizing</code>属性。</p>
<blockquote>
<p><strong>This is because each widget has their own rules for border, padding and margin.</strong> To give the same size to several different widgets, you can use the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing"><code>box-sizing</code></a> property along with some consistent values for other properties</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span>, <span class="selector-tag">textarea</span>, <span class="selector-tag">select</span>, <span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">width </span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">-webkit-box-sizing</span>: border-box; <span class="comment">/* For legacy WebKit based browsers */</span></span><br><span class="line">     <span class="attribute">-moz-box-sizing</span>: border-box; <span class="comment">/* For legacy (Firefox &lt;29) Gecko based browsers */</span></span><br><span class="line">          <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p><code>&lt;legend&gt;</code>元素最容易定位，总是存在于父元素<code>fieldset</code>的内部，默认是在上边框的最顶端。如果想要把它放在<code>fieldset</code>的内部其他地方，需要先对<code>fieldset</code>定位，在对<code>legend</code>定位。</p>
<p><code>&lt;textarea&gt;</code>元素被浏览器默认为display: inline-block，与文本底线对齐。</p>
<h3 id="“ugly”-elements"><a href="#“ugly”-elements" class="headerlink" title="“ugly” elements"></a>“ugly” elements</h3><blockquote>
<p>Including drop-down boxes, complex control types like <code>color</code> and <code>datetime-local</code>, and feedback—oriented controls like  <code>&lt;progress&gt;</code> <code>&lt;meter&gt;</code>.</p>
<p>The problem is that these elements have very different default looks across browsers, and while you can style them in some ways, some parts of their internals are literally impossible to style.</p>
</blockquote>
<h3 id="appearance-controlling-OS-level-styling"><a href="#appearance-controlling-OS-level-styling" class="headerlink" title="appearance: controlling OS-level styling"></a>appearance: controlling OS-level styling</h3><p>浏览器内核引擎大致有Gecko(Firefox)、Webkit(Safari/Chrome)，每个引擎默认的网页排版都不一样，所以需要加前缀指定特定浏览器内核下的样式。</p>
<p>为了使浏览器特有的样式失效，可以使用<code>appearance</code>和带前缀的<code>appearance</code>(是非标准属性)，使其值为<code>none</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">select</span>, <span class="selector-tag">option</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-appearance </span>: none; <span class="comment">/* To gain control over the appearance on WebKit/Chromium */</span></span><br><span class="line">  <span class="attribute">-moz-appearance </span>: none; <span class="comment">/* To gain control over the appearance on Gecko */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* To gain control over the appearance on and Trident (IE)</span></span><br><span class="line"><span class="comment">     Note that it also works on Gecko and has partial effects on WebKit */</span>  </span><br><span class="line">  <span class="attribute">background </span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="required元素属性-伪类-optinal-required"><a href="#required元素属性-伪类-optinal-required" class="headerlink" title="required元素属性+伪类:optinal :required"></a><code>required</code>元素属性+伪类<code>:optinal</code> <code>:required</code></h3><p>属于简单的客户端表单验证</p>
<h2 id="其他表单部件"><a href="#其他表单部件" class="headerlink" title="其他表单部件"></a>其他表单部件</h2><p>基于<code>input</code>元素，<code>type</code>属性取值+其他辅助属性。</p>
<ul>
<li>数字 number + min + max + step</li>
<li>滑块 range + min + max + step</li>
<li>本地时间 datetime-local + min + max</li>
<li>月 month + min + max</li>
<li>时间 time + min + max</li>
<li>星期 week + min + max</li>
<li>拾色器 color</li>
<li>文件接收 file + accept(约束文件类型的属性) + multiple(允许接收多个文件的属性)</li>
<li>不可见隐藏内容 hidden + name +value</li>
<li>图像按钮 image (提交表单时提交的数据是相对于图像的XY坐标，形式为<code>name.x/name.y</code>，常用于构建热图)</li>
</ul>
<p>进度条，基于<code>progress</code>元素。</p>
<p>仪表，基于<code>meter</code>元素。</p>
<h1 id="使用JavaScript发送表单"><a href="#使用JavaScript发送表单" class="headerlink" title="使用JavaScript发送表单"></a>使用JavaScript发送表单</h1><p>HTML表单只负责收集用户输入，当用户尝试发送数据时，应用程序在后台采取控制并异步地传输数据，只更新UI中需要更改的部分。</p>
<p>异步地发送任何数据被称为<code>AJAX(Asynchronous JavaScript and XML)</code>。</p>
<p>AJAX就是在不刷新当前页面的情况下，使用<code>XMLHttpRequest(XHR)</code> DOM对象和服务器进行通信（发送HTTP请求，接收服务器数据），可以使用的数据格式有JSON、XML、HTML和text文本。</p>
<h2 id="构建XMLHttpRequest发送表单数据"><a href="#构建XMLHttpRequest发送表单数据" class="headerlink" title="构建XMLHttpRequest发送表单数据"></a>构建XMLHttpRequest发送表单数据</h2><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ol>
<li><p>新建一个<code>XMLHttpRequest</code>对象</p>
</li>
<li><p>告诉XMLhttp请求对象的<code>onreadystatechange</code>属性命名为请求状态改变时调用的函数，这里只是一个引用赋值，并不是调用，此函数需要提前声明。或者直接使用匿名函数响应处理的操作。</p>
</li>
<li><p>声明接到响应后要做什么。发送一个实际的请求，通过调用HTTP请求对象的<code>open()</code>和<code>send()</code>方法。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">httpRequest.open(<span class="string">&#x27;GET/POST/HEAD&#x27;</span>, URL, <span class="literal">true</span>-by-<span class="keyword">default</span>-<span class="keyword">for</span>-synchroneous);</span><br><span class="line">httpRequest.send(what-you-want-to-send-to-the-server);</span><br></pre></td></tr></table></figure>
<ol>
<li>回调函数处理服务器响应的步骤：检查请求状态，即服务器是否收到了请求并且没有问题<code>httpRequest.readyState === XMLHttpRequest.DONE</code>；其次判断响应码范围<code>if(request.status &gt;= 200 &amp;&amp; request.status &lt; 400)</code>；利用<code>httpRequest.responseText/responseXML</code>获取返回数据。</li>
</ol>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ul>
<li>对空格的处理</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Combine the pairs into a single string and replace all %-encoded spaces to </span></span><br><span class="line"><span class="comment">// the &#x27;+&#x27; character; matches the behaviour of browser form submissions.</span></span><br><span class="line">urlEncodedData = urlEncodedDataPairs.join( <span class="string">&#x27;&amp;&#x27;</span> ).replace( <span class="regexp">/%20/g</span>, <span class="string">&#x27;+&#x27;</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器请求状态readyState与响应状态status作区分</li>
<li>对于POST方法需要设定HTTP header</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add the required HTTP header for form data POST requests</span></span><br><span class="line">  XHR.setRequestHeader( <span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span> );</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="XMLHttpRequest-FormData"><a href="#XMLHttpRequest-FormData" class="headerlink" title="XMLHttpRequest+FormData"></a>XMLHttpRequest+FormData</h2><p>引入新的<code>FormData</code>对象，只可写(write only)can change them but not retrive their contents。</p>
<ul>
<li>新建空的FormData对象<code>const FD = new FormData()</code>，后续利用<code>appen()</code>更新。</li>
<li>将FormData对象与HTML表单form元素绑定<code>const FD = new FormData(form)</code> </li>
</ul>
<h2 id="二进制数据处理"><a href="#二进制数据处理" class="headerlink" title="二进制数据处理"></a>二进制数据处理</h2><p>哪里获得二进制数据？FileReader API、Canvas API、 WebRTC API。</p>
<p>直接利用formData的append()方法。</p>
<p>如果出现多种类型的表单数据，需要手动构建。需要定义一个分隔符来定义请求的每一个部分，该分隔符前面有其他符号，分隔符后面有换行。每一个类型的数据再放入data字符串时要有metada+data两个部分。</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux异步数据流与性能优化</title>
    <url>/2020/12/08/redux-async-data-flow/</url>
    <content><![CDATA[<h1 id="异步逻辑"><a href="#异步逻辑" class="headerlink" title="异步逻辑"></a>异步逻辑</h1><p>Redux store本身是不能处理异步逻辑的。为了使异步逻辑与Redux store产生交互，引入Redux middleware。</p>
<p>The most common reason to use middleware is to allow different kinds of async logic to interact with the store.</p>
<p>最常用的异步逻辑中间件就是redux-thunk。</p>
<h1 id="使用thunk前的准备"><a href="#使用thunk前的准备" class="headerlink" title="使用thunk前的准备"></a>使用thunk前的准备</h1><p>为了使用thunk，首先要让redux store支持thunk middleware。由于Redux Toolkit的configureStore API自动配置好了thunk middleware，所以将thunk作为用redux书写异步逻辑的标准形式。</p>
<p><img src="/2020/12/08/redux-async-data-flow/ReduxAsyncDataFlowDiagram-d97ff38a0f4da0f327163170ccc13e80.gif" alt="ReduxAsyncDataFlowDiagram-d97ff38a0f4da0f327163170ccc13e80" style="zoom:50%;"></p>
<h1 id="thunk的特质以及手写thunk"><a href="#thunk的特质以及手写thunk" class="headerlink" title="thunk的特质以及手写thunk"></a>thunk的特质以及手写thunk</h1><h2 id="能够在store中调用thunk"><a href="#能够在store中调用thunk" class="headerlink" title="能够在store中调用thunk"></a>能够在store中调用thunk</h2><p>Once the thunk middleware has been added to the Redux store, it allows you to pass <em>thunk functions</em> directly to <code>store.dispatch</code>.</p>
<h2 id="能够dispatch-plain-action-creators"><a href="#能够dispatch-plain-action-creators" class="headerlink" title="能够dispatch plain action creators"></a>能够dispatch plain action creators</h2><p>A thunk function will always be called with <code>(dispatch, getState)</code> as its arguments, and you can use them inside the thunk as needed.</p>
<h2 id="手写thunk-action"><a href="#手写thunk-action" class="headerlink" title="手写thunk action"></a>手写thunk action</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; my-app&#x2F;src&#x2F;app&#x2F;store.js</span><br><span class="line"></span><br><span class="line">const store &#x3D; configureStore(&#123; reducer: counterReducer &#125;)</span><br><span class="line"></span><br><span class="line">const exampleThunkFunction &#x3D; (dispatch, getState) &#x3D;&gt; &#123;</span><br><span class="line">  const stateBefore &#x3D; getState()</span><br><span class="line">  &#x2F;&#x2F; 能够和其他reducer一样读取store中的状态&#x2F;数据</span><br><span class="line">  console.log(&#96;Counter before: $&#123;stateBefore.counter&#125;&#96;)</span><br><span class="line">  dispatch(increment())</span><br><span class="line">  &#x2F;&#x2F; dispatch的是一个action creator</span><br><span class="line">  const stateAfter &#x3D; getState()</span><br><span class="line">  console.log(&#96;Counter after: $&#123;stateAfter.counter&#125;&#96;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch(exampleThunkFunction)</span><br></pre></td></tr></table></figure>
<h2 id="手写thunk-action-creators"><a href="#手写thunk-action-creators" class="headerlink" title="手写thunk action creators"></a>手写thunk action creators</h2><p>类比普通的action和action creators，把箭头函数的部分放到return语句中去，并且将参数传入整体creators。这样的一个好处就是可以给thunk action中要dispatch的action传入参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const logAndAdd &#x3D; amount &#x3D;&gt; &#123;</span><br><span class="line">  return (dispatch, getState) &#x3D;&gt; &#123;</span><br><span class="line">    const stateBefore &#x3D; getState()</span><br><span class="line">    console.log(&#96;Counter before: $&#123;stateBefore.counter&#125;&#96;)</span><br><span class="line">    dispatch(incrementByAmount(amount))</span><br><span class="line">    const stateAfter &#x3D; getState()</span><br><span class="line">    console.log(&#96;Counter after: $&#123;stateAfter.counter&#125;&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch(logAndAdd(5))</span><br></pre></td></tr></table></figure>
<p>但在实际写代码的过程中，会把thunk action/thunk action creators放在slice文件中，而我们在书写slice时使用的createSlice本身是不支持定义thunks的，因此他们作为独立的函数和createSlice一同存在于slice文件中。</p>
<h1 id="使用thunk对server-API进行AJAX-calls"><a href="#使用thunk对server-API进行AJAX-calls" class="headerlink" title="使用thunk对server API进行AJAX calls"></a>使用thunk对server API进行AJAX calls</h1><h2 id="request的阶段与手写thunk"><a href="#request的阶段与手写thunk" class="headerlink" title="request的阶段与手写thunk"></a>request的阶段与手写thunk</h2><p>以下三个步骤不是必须的，但都是commonly used。</p>
<ul>
<li>a “start” action is dispatched before the requst, to indicate that the request is in progress.常用于追踪loading状态，然后让UI同时显示在加载中。</li>
<li>The async request is made</li>
<li>Depending on the request result, the async logic dispatches either a “success” action containing the result data, or a “failure” action containing error details. </li>
</ul>
<hr>
<p>这三个步骤即相当于三个action，我们如果手写thunk就需要先定义好这三个步骤的type和error，最后用一个含有异步逻辑async/await的函数，以及try catch语句把这些步骤拼接起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getRepoDetailsStarted &#x3D; () &#x3D;&gt; (&#123;</span><br><span class="line">  type: &#39;repoDetails&#x2F;fetchStarted&#39;</span><br><span class="line">&#125;)</span><br><span class="line">const getRepoDetailsSuccess &#x3D; repoDetails &#x3D;&gt; (&#123;</span><br><span class="line">  type: &#39;repoDetails&#x2F;fetchSucceeded&#39;,</span><br><span class="line">  payload: repoDetails</span><br><span class="line">&#125;)</span><br><span class="line">const getRepoDetailsFailed &#x3D; error &#x3D;&gt; (&#123;</span><br><span class="line">  type: &#39;repoDetails&#x2F;fetchFailed&#39;,</span><br><span class="line">  error</span><br><span class="line">&#125;)</span><br><span class="line">const fetchIssuesCount &#x3D; (org, repo) &#x3D;&gt; async dispatch &#x3D;&gt; &#123;</span><br><span class="line">  dispatch(getRepoDetailsStarted())</span><br><span class="line">  try &#123;</span><br><span class="line">    const repoDetails &#x3D; await getRepoDetails(org, repo)</span><br><span class="line">    dispatch(getRepoDetailsSuccess(repoDetails))</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    dispatch(getRepoDetailsFailed(err.toString()))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么不用Promise.then?而是使用async/await关键字呢？因为阶段的最后我们需要捕捉错误信息，也就是使用try/catch模块，而它不能Promise.then一起使用。</p>
<hr>
<h2 id="使用createAsyncThunk定义thunk"><a href="#使用createAsyncThunk定义thunk" class="headerlink" title="使用createAsyncThunk定义thunk"></a>使用createAsyncThunk定义thunk</h2><p>手写fetching data的问题在于每个action都要定义，或者说为每个action都定义action creators很麻烦。所以createAsyncThunk API抽象出了这三个步骤，最终产生了一个能够自动处理这三个步骤的thunk。</p>
<p>createAsyncThunk接受两个参数：</p>
<ul>
<li><p>A <strong>string</strong> that will be used as the <strong>prefix for the generated action types</strong></p>
<p>本质上thunk function也是action creator，只不过是异步的。</p>
</li>
<li><p>A “payload creator” callback function that should return a <code>Promise</code> containing some data, or a rejected <code>Promise</code> with an error</p>
<p>这部分承担了发出AJAX请求的工作，返回的是Promise from the AJAX call，或者是some data from the API response。</p>
<p>一般使用JS async/await关键字，而不是一般的somePromise.then()语法，为了能够结合try/catch逻辑一起使用。</p>
</li>
</ul>
<p>使用createAsyncThunk API创建thunk function的实例。在使用createAsyncThunk创建hunk function之后，该函数会返回pending/fulfilled/rejected三种action creators（对应到上一个章节就是request的三个阶段），这个在后续与createSlice中extraReducer的互动中会使用到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const fetchPosts &#x3D; createAsyncThunk(&#39;posts&#x2F;fetchPosts&#39;, async () &#x3D;&gt; &#123;</span><br><span class="line">  const response &#x3D; await client.get(&#39;&#x2F;fakeApi&#x2F;posts&#39;)</span><br><span class="line">  return response.posts</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="tracking-request-states"><a href="#tracking-request-states" class="headerlink" title="tracking request states"></a>tracking request states</h2><p>总共有四个可能的请求状态。</p>
<p>When we make an API call, we can view its progress as a small state machine that can be in one of four possible states:</p>
<ul>
<li>The request hasn’t started yet</li>
<li>The request is in progress</li>
<li>The request succeeded, and we now have the data we need</li>
<li>The request failed, and there’s probably an error message</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  status: &#39;idle&#39; | &#39;loading&#39; | &#39;succeeded&#39; | &#39;failed&#39;,</span><br><span class="line">  &#x2F;&#x2F; 名称都是可以自己定义的，例如pending&#x3D;loading&#x2F;complete&#x3D;succeeded。</span><br><span class="line">  error: string | null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用createAsyncThunk自动产生的三个action creators来显示request的状态。</p>
<p><code>createAsyncThunk</code> accepts a “payload creator” callback that should return a <code>Promise</code>, and generates <code>pending/fulfilled/rejected</code> action types automatically。</p>
<p>上面这段话的意思应该是虽然createAsyncThunk会自动产生action type，但是这个action的具体内容，他的行为是需要我们去定义的。当AJAX calls在pending的状态时，我们希望在什么数据区域做出什么样的动作。这个数据区域可能就是某个feature中，也有可能是全局redux store中，更有可能是在UI component中。</p>
<h3 id="Why-tracking"><a href="#Why-tracking" class="headerlink" title="Why tracking"></a>Why tracking</h3><p>一方面，这些状态信息信息可以背被UI使用，比如在loading的时候可以UI显示转圈圈；另一方面，这些meta data可以是我们的fetch data行为只进行一次，而不是在每一次该UI重新渲染的时候都rerender一下。</p>
<p>但是问题是request状态信息pending/fulfilled/rejected都是由thunk本身的promise对象保存着的。而这个信息要从slice流通到UI去，需要另外考虑。</p>
<h3 id="How-tracking"><a href="#How-tracking" class="headerlink" title="How tracking"></a>How tracking</h3><h4 id="Thunk-gt-extraReducers-gt-initialState-gt-store-gt-UI-component"><a href="#Thunk-gt-extraReducers-gt-initialState-gt-store-gt-UI-component" class="headerlink" title="Thunk=&gt;extraReducers=&gt;initialState=&gt;store=&gt;UI component"></a>Thunk=&gt;extraReducers=&gt;initialState=&gt;store=&gt;UI component</h4><p>createAsyncThunk写在slice文件中，同时slice文件中的initialState也需要有一个key status来指示数据从第三方API获得数据进展到了哪一步，这样的话我们就能决定UI在request进行的过程中该如何显示。</p>
<p>为了追踪dispatch AJAX calls的状态，也就是track AJAX calls states，一个好的模式就是在该slice的数据结构中有一个state section。也就是tracking request states in slices。</p>
<p>We <em>could</em> track the request status in slice file using a second loading enum if we wanted to.</p>
<p>定义部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; postsSlice中initialState的定义</span><br><span class="line">const initialState &#x3D; &#123;</span><br><span class="line">  posts: [],</span><br><span class="line">    &#x2F;&#x2F; 数据实体</span><br><span class="line">  status: &#39;idle&#39;,</span><br><span class="line">    &#x2F;&#x2F; 这里的status更像是一个窗口，连通了thunk function和UI component</span><br><span class="line">  error: null</span><br><span class="line">&#125;</span><br><span class="line">export const fetchPosts &#x3D; createAsyncThunk(&#39;posts&#x2F;fetchPosts&#39;, async () &#x3D;&gt; &#123;</span><br><span class="line">  const response &#x3D; await client.get(&#39;&#x2F;fakeApi&#x2F;posts&#39;)</span><br><span class="line">  return response.posts</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const postsSlice &#x3D; createSlice(&#123;</span><br><span class="line">  name: &#39;posts&#39;,</span><br><span class="line">  initialState,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    &#x2F;&#x2F; omit existing reducers here</span><br><span class="line">  &#125;,</span><br><span class="line">  extraReducers: &#123;</span><br><span class="line">    &#x2F;&#x2F; 并不是所有的状态都需要考虑，忽略pending就是什么不都不做</span><br><span class="line">    [fetchPosts.pending]: (state, action) &#x3D;&gt; &#123;</span><br><span class="line">      state.status &#x3D; &#39;loading&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    [fetchPosts.fulfilled]: (state, action) &#x3D;&gt; &#123;</span><br><span class="line">      state.status &#x3D; &#39;succeeded&#39;</span><br><span class="line">      &#x2F;&#x2F; Add any fetched posts to the array</span><br><span class="line">      state.posts &#x3D; state.posts.concat(action.payload)</span><br><span class="line">    &#125;,</span><br><span class="line">    [fetchPosts.rejected]: (state, action) &#x3D;&gt; &#123;</span><br><span class="line">      state.status &#x3D; &#39;failed&#39;</span><br><span class="line">      state.error &#x3D; action.error.message</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>调用部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;postList.js</span><br><span class="line">export const PostsList &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const dispatch &#x3D; useDispatch()</span><br><span class="line">  const posts &#x3D; useSelector(selectAllPosts)</span><br><span class="line"></span><br><span class="line">  const postStatus &#x3D; useSelector(state &#x3D;&gt; state.posts.status)</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (postStatus &#x3D;&#x3D;&#x3D; &#39;idle&#39;) &#123;</span><br><span class="line">      dispatch(fetchPosts())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [postStatus, dispatch])</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; omit rendering logic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Thunk-gt-UI-component-gt-statusEnum-gt-try-catch-disptach"><a href="#Thunk-gt-UI-component-gt-statusEnum-gt-try-catch-disptach" class="headerlink" title="Thunk=&gt;UI component=&gt;statusEnum=&gt;try/catch/disptach"></a>Thunk=&gt;UI component=&gt;statusEnum=&gt;try/catch/disptach</h4><p>首先add a loading status enum field as a React <code>useState</code> hook，这个loading status enum就类似于之前slice中initialState对象中的status field。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; UI component</span><br><span class="line">export const AddPostForm &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; other datas</span><br><span class="line">  const [addRequestStatus, setAddRequestStatus] &#x3D; useState(&#39;idle&#39;)</span><br></pre></td></tr></table></figure>
<p>在try模块中，先将enum的状态设置为pending，然后开始dispatch thunk function，由于createAsyncThunk在函数内部处理错误，所以我们不能获取rejected message，这不利于catch模块输出错误信息。</p>
<p><code>createAsyncThunk</code> handles any errors internally, so that we don’t see any messages about “rejected Promises” in our logs. </p>
<p>为了解决错误信息的问题，Redux Toolkit拥有一个功能函数，名为unwrapResult，他让dispatch后的thunk action creator有两种表现：如果是fulfilled action就返回action.payload，如果是rejected action就报错，这样就能在try/catch模块中使用了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; UI component</span><br><span class="line">const onSavePostClicked &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">    if (canSave) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        setAddRequestStatus(&#39;pending&#39;)</span><br><span class="line">          </span><br><span class="line">        const resultAction &#x3D; await dispatch(</span><br><span class="line">          addNewPost(&#123; title, content, user: userId &#125;)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        unwrapResult(resultAction)</span><br><span class="line">          </span><br><span class="line">        setTitle(&#39;&#39;)</span><br><span class="line">        setContent(&#39;&#39;)</span><br><span class="line">        setUserId(&#39;&#39;)</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        console.error(&#39;Failed to save the post: &#39;, err)</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        setAddRequestStatus(&#39;idle&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="在UI中调用thunk"><a href="#在UI中调用thunk" class="headerlink" title="在UI中调用thunk"></a>在UI中调用thunk</h2><p>首先从对应slice中import thunk至想要使用它的UI component。</p>
<p>thunk也是属于action creator的一种，我们需要dispatch，因此需要添加useDispatch hook。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const PostsList &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const dispatch &#x3D; useDispatch()</span><br><span class="line">  const posts &#x3D; useSelector(selectAllPosts)</span><br><span class="line"></span><br><span class="line">  const postStatus &#x3D; useSelector(state &#x3D;&gt; state.posts.status)</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (postStatus &#x3D;&#x3D;&#x3D; &#39;idle&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这样可以避免re-render的时候也重新fetch data</span><br><span class="line">      dispatch(fetchPosts())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [postStatus, dispatch])</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; omit rendering logic</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="createSlice对非createSlice-API定义action的响应"><a href="#createSlice对非createSlice-API定义action的响应" class="headerlink" title="createSlice对非createSlice API定义action的响应"></a>createSlice对非createSlice API定义action的响应</h1><p>There are times when <strong>a slice reducer needs to respond to <em>other</em> actions that weren’t defined as part of this slice’s <code>reducers</code> field</strong>. We can do that using the slice <code>extraReducers</code> field instead.</p>
<p>a slice reducer可能需要对thunk这个action creator产生的action或者createAction产生的action进行相应，为了实现这个目的在createSlice API中设立了一个extraReducers field。</p>
<p> <code>extraReducers</code> allows <code>createSlice</code> to respond to other action types besides the types it has generated.  It’s particularly useful for working with actions produced by <code>createAction</code> and <code>createAsyncThunk</code>.</p>
<h2 id="extraReducers-field的action-type"><a href="#extraReducers-field的action-type" class="headerlink" title="extraReducers field的action type"></a>extraReducers field的action type</h2><p>在extraReducers中定义的action createor产生的action不会被自动地添加到createSliceAPI的action field中去。<code>extraReducers</code> are meant to reference “external” actions, they will not have actions generated in <code>slice.actions</code>.</p>
<h3 id="方式一：引号内action-type"><a href="#方式一：引号内action-type" class="headerlink" title="方式一：引号内action type"></a>方式一：引号内action type</h3><p>keys in extraReducer Object就是redux action type strings，类似于<code>&#39;counter/increment&#39;</code>，因为key中含有斜杠/，所以要用单引号扩起来。</p>
<h3 id="方式二：-计算属性"><a href="#方式二：-计算属性" class="headerlink" title="方式二： 计算属性"></a>方式二： 计算属性</h3><p>但是Redux Toolkit有一个性质就是如果调用actionCreator.toString()函数，他会自动返回action type。因此可以可以把action creator用ES6计算属性的方式传入extraReducer object field。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; increment &#125; from &#39;..&#x2F;features&#x2F;counter&#x2F;counterSlice&#39;</span><br><span class="line"></span><br><span class="line">const postsSlice &#x3D; createSlice(&#123;</span><br><span class="line">  name: &#39;posts&#39;,</span><br><span class="line">  initialState,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    &#x2F;&#x2F; slice-specific reducers here</span><br><span class="line">  &#125;,</span><br><span class="line">  extraReducers: &#123;&#x2F;&#x2F; 这个extraReducer本质也是一个object</span><br><span class="line">    [increment]: (state, action) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; normal reducer logic to update the posts slice</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="方式三：-builder-callback"><a href="#方式三：-builder-callback" class="headerlink" title="方式三： builder callback"></a>方式三： builder callback</h3><p>将builder callback function传入extraReducers，而不是传入一个对象。builder callback function接受builder作为参数，对builder调用addCase就可以添加action creators。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; increment &#125; from &#39;..&#x2F;features&#x2F;counter&#x2F;counterSlice&#39;</span><br><span class="line"></span><br><span class="line">const postsSlice &#x3D; createSlice(&#123;</span><br><span class="line">  name: &#39;posts&#39;,</span><br><span class="line">  initialState,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    &#x2F;&#x2F; slice-specific reducers here</span><br><span class="line">  &#125;,</span><br><span class="line">  extraReducers: builder &#x3D;&gt; &#123;</span><br><span class="line">    builder.addCase(&#39;counter&#x2F;decrement&#39;, (state, action) &#x3D;&gt; &#123;&#125;)</span><br><span class="line">    builder.addCase(increment, (state, action) &#x3D;&gt; &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="extraReducers的action-creator内容"><a href="#extraReducers的action-creator内容" class="headerlink" title="extraReducers的action creator内容"></a>extraReducers的action creator内容</h2><p>也就是(state, action) =&gt; {}箭头函数里面的内容，应当都是对createSlice中的数据域进行操作。描述外部的某个action creator引起的某个action对本slice内部的数据产生了什么影响。</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>React DevTools中的Prolifier可以协助查看用户在某个行为前后UI渲染的情况。需要先录制，然后做出行为，然后结束录制。就可以看到在该动作发生前后React各个组件的渲染行为。</p>
<h2 id="extracting-selectors-from-UI"><a href="#extracting-selectors-from-UI" class="headerlink" title="extracting selectors from UI"></a>extracting selectors from UI</h2><p>在书写代码的过程中，一开始总是建议现在UI中使用useSelector选取希望获得的数据。因为虽然extracting selectors可以在更新slice中数据形式的时候简便一点，但这也意味着更多需要去维护的代码。</p>
<p>不是每一个UI都必须要写通用的selectors。<strong>Don’t feel like you need to write selectors for every single field of your state</strong>.</p>
<p>这种抽象适合这个sleectors在多个UI中被多次重复使用。Try <strong>starting without any selectors</strong>, and add some later when you find yourself looking up the <strong>same values in many parts of your application code</strong>。</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>我们一般认为在UI中访问redux store的数据就是要在UI中使用useSelector。这样处理的问题在于如果我们要从redux store中获取的那部分数据变化了，也就是说在slice中定义的数据形式变化了，相应地又要转到使用了该<strong>slice中的数据</strong>的<strong>多个UI</strong>中去进行变动。</p>
<p>解决该问题的方式就是在slice文件中定义可以被export且可以被重复使用的selector functions。</p>
<p>One way to avoid this is to <strong>define reusable selector functions in the slice files</strong>, and have the components use those selectors to extract the data they need instead of repeating the selector logic in each component. That way, if we do change our state structure again, we only need to update the code in the slice file.</p>
<h3 id="定义方式如下"><a href="#定义方式如下" class="headerlink" title="定义方式如下"></a>定义方式如下</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;features&#x2F;posts&#x2F;postsSLice.js</span><br><span class="line">export const selectAllPosts &#x3D; state &#x3D;&gt; state.posts</span><br></pre></td></tr></table></figure>
<p>注意这里的state时redux store整体的state。 </p>
<p>The <code>state</code> parameter for these selector functions is the <strong>root Redux state object</strong>, as it was <strong>for the inlined anonymous selectors</strong> we wrote directly inside of <code>useSelector</code>.</p>
<h3 id="使用方式如下"><a href="#使用方式如下" class="headerlink" title="使用方式如下"></a>使用方式如下</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;features&#x2F;posts&#x2F;PostList.js</span><br><span class="line">import &#123; selectAllPosts &#125; from &#39;.&#x2F;postsSlice&#39;</span><br><span class="line"></span><br><span class="line">export const PostsList &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const posts &#x3D; useSelector(selectAllPosts)</span><br><span class="line">  &#x2F;&#x2F; omit component contents</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="create-“memoized”-selectors"><a href="#create-“memoized”-selectors" class="headerlink" title="create “memoized” selectors"></a>create “memoized” selectors</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>useSelectors的特点就是只要app中一个行为发生了，他就会重新运行，只要他的return value是a new refernce value，那么它迫使组件重新渲染。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; UI component中</span><br><span class="line">const postsForUser &#x3D; useSelector(state &#x3D;&gt; &#123;</span><br><span class="line">    const allPosts &#x3D; selectAllPosts(state)</span><br><span class="line">    return allPosts.filter(post &#x3D;&gt; post.user &#x3D;&#x3D;&#x3D; userId)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>如果return value返回的对象总是无条件的是a new refernce value，比如filter函数，就算filter函数的内容都是一样的，reference都是不同，也就是说无论如何都会重新渲染一遍。</p>
<p>我们希望useSelector函数每重新运行一次，都保存先后两次select出来的value，如果发生了变化，在渲染，如果没有变化，就还是不渲染。这种想法就是memoize。</p>
<h3 id="Memoizing-Selector-functions"><a href="#Memoizing-Selector-functions" class="headerlink" title="Memoizing Selector functions"></a>Memoizing Selector functions</h3><p>Reselect <strong>is a library for creating memoized selector functions</strong>, and was specifically designed to be used with Redux. It has a <code>createSelector</code> function that generates memoized selectors that will only recalculate results when the inputs change.</p>
<p>想要使用createSelector，只需要先从Redux Toolkit中import它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; slice中</span><br><span class="line">import &#123; createSlice, createAsyncThunk, createSelector &#125; from &#39;@reduxjs&#x2F;toolkit&#39;</span><br></pre></td></tr></table></figure>
<p>createSelector接受多个input selector function，以及一个output selector function作为参数。给createSelector传入的参数是input selector function的参数，而output selector function的参数是input selestor function的return value。如果传递给output selector function的value前后都没有变化，那么output selector function就不会re-run。</p>
<p>When we call <code>selectPostsByUser(state, userId)</code>, <code>createSelector</code> will pass all of the arguments into each of our input selectors. Whatever those input selectors return becomes the arguments for the output selector.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const selectAllPosts &#x3D; state &#x3D;&gt; state.posts.posts</span><br><span class="line"></span><br><span class="line">export const selectPostById &#x3D; (state, postId) &#x3D;&gt;</span><br><span class="line">  state.posts.posts.find(post &#x3D;&gt; post.id &#x3D;&#x3D;&#x3D; postId)</span><br><span class="line"></span><br><span class="line">export const selectPostsByUser &#x3D; createSelector(</span><br><span class="line">  [selectAllPosts, (state, userId) &#x3D;&gt; userId],</span><br><span class="line">  (posts, userId) &#x3D;&gt; posts.filter(post &#x3D;&gt; post.user &#x3D;&#x3D;&#x3D; userId)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>为什么要给input selector functions加括号呢？联系array destructing，这就相当于把input selector function运行并把返回值作为一组array，能够传递给下一个output selector function。</p>
<h2 id="Solving-cascade-re-render"><a href="#Solving-cascade-re-render" class="headerlink" title="Solving cascade re-render"></a>Solving cascade re-render</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>React的渲染行为是级联的，只有父亲组件重新渲染了，那么父亲组件内部的所以儿子组件都会重新渲染。</p>
<p><a href="https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/"><strong>React’s default behavior is that when a parent component renders, React will recursively render all child components inside of it!</strong></a>. </p>
<h3 id="memo"><a href="#memo" class="headerlink" title="memo()"></a>memo()</h3><p>wrap the sub component in <a href="https://reactjs.org/docs/react-api.html#reactmemo"><code>React.memo()</code></a>, which will ensure that the component inside of it only re-renders if the props have actually changed. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let PostExcerpt &#x3D; (&#123; post &#125;) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; omit logic</span><br><span class="line">&#125;</span><br><span class="line">PostExcerpt &#x3D; React.memo(PostExcerpt)</span><br></pre></td></tr></table></figure>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>子组件如果要进行条件渲染，那么就要从store中获取更多的信息，储存前后信息，并比较。</p>
<p>并且组件获取信息尽量不要基于内容本身获取信息，最好每一条信息都有一个识别符id。</p>
<h3 id="数据ID与Normalized-Data"><a href="#数据ID与Normalized-Data" class="headerlink" title="数据ID与Normalized Data"></a>数据ID与Normalized Data</h3><p>之前一直都是手动维护一个ID field，用array.find来匹配希望获得的ID。其实这本质上就是一个lookup table，如果我们能通过id寻找到一条信息，而不是通过循环数组匹配来实现，那么这个过程就是normalization。能够实现这种模式的数据称为Normalized State Structure。</p>
<h4 id="Normalized-State-Structure"><a href="#Normalized-State-Structure" class="headerlink" title="Normalized State Structure"></a>Normalized State Structure</h4><p>具有以下特质的数据被称为normalized state structure。</p>
<ul>
<li>We only have one copy of each particular piece of data in our state, so there’s <strong>no duplication</strong></li>
<li>Data that has been normalized is <strong>kept in a lookup table</strong>, where the <strong>item IDs are the keys</strong>, and the <strong>items themselves are the values</strong>.</li>
<li>There may also be an array of all of the IDs for a particular item type</li>
</ul>
<p>JavaScript Objects就可以被表示称lookup table，一个object中有两个field，一个是ids，另一个是entities。ids的组成是一个数组，数组中的每一个值又是entities中的key，也就是数据id对应到数据实体。</p>
<p>Redux Toolkit提供了一个操作normalized state structure的create EntityAdapter API，它将某个slice中的数据都按照<code>&#123; ids: [], entities: &#123;&#125; &#125;</code> 的形式存放。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  createEntityAdapter</span><br><span class="line">  &#x2F;&#x2F; omit other imports</span><br><span class="line">&#125; from &#39;@reduxjs&#x2F;toolkit&#39;</span><br></pre></td></tr></table></figure>
<p>and will only update that array if items are added / removed or the sorting order changes.</p>
<h4 id="createEntityAdapter"><a href="#createEntityAdapter" class="headerlink" title="createEntityAdapter"></a>createEntityAdapter</h4><h5 id="数据对象创建"><a href="#数据对象创建" class="headerlink" title="数据对象创建"></a>数据对象创建</h5><p><code>createEntityAdapter</code>可以依据内容把ID array排序，它接收an option object that include a <code>sortComparer</code> function，通过比较两个entity的内容，把ID array中的id进行排序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const postsAdapter &#x3D; createEntityAdapter(&#123;</span><br><span class="line">  sortComparer: (a, b) &#x3D;&gt; b.date.localeCompare(a.date)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="数据对象初始化"><a href="#数据对象初始化" class="headerlink" title="数据对象初始化"></a>数据对象初始化</h5><p><code>createEntityAdapter.getInitialState()</code>，这个函数自动返回一个空的<code>&#123; ids: [], entities: &#123;&#125; &#125;</code> 对象。还可以通过给getInitialState传入更多的参数，来给让返回的对象有更多的fields。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const initialState &#x3D; postsAdapter.getInitialState(&#123;</span><br><span class="line">  status: &#39;idle&#39;,</span><br><span class="line">  error: null</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="数据对象选择"><a href="#数据对象选择" class="headerlink" title="数据对象选择"></a>数据对象选择</h4><p><code>createEntityAdapter.getSelector()</code>，把一个用于从redux store中选择某个特定slice的selector function作为参数传入该函数后，该函数能够自动返回名称总为<code>selectAll</code>和<code>selectById</code>这样的selector function。</p>
<p>由于自动生成的selectors function总是固定的两个名字，所以利用ES6 array destructing的语法来为selector function重新命名。</p>
<blockquote>
<p>The generated selector functions are always called <code>selectAll</code> and <code>selectById</code>, so we can use ES6 destructuring syntax to rename them as we export them and match the old selector names. </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Export the customized selectors for this adapter using &#96;getSelectors&#96;</span><br><span class="line">export const &#123;</span><br><span class="line">  selectAll: selectAllPosts,</span><br><span class="line">  selectById: selectPostById,</span><br><span class="line">  selectIds: selectPostIds</span><br><span class="line">  &#x2F;&#x2F; Pass in a selector that returns the posts slice of state</span><br><span class="line">  &#x2F;&#x2F; Since the selectors are called with the root Redux state object, they need to know where to find our posts data in the Redux state, so we pass in a small selector that returns state.posts.</span><br><span class="line">&#125; &#x3D; postsAdapter.getSelectors(state &#x3D;&gt; state.posts)</span><br></pre></td></tr></table></figure>
<h4 id="数据对象更新"><a href="#数据对象更新" class="headerlink" title="数据对象更新"></a>数据对象更新</h4><p>它返回一个包含了许多自动生成的reducer function的对象。这个对象中的reducer functions能够实现”add all these items”, “update one item”, or “remove multiple items”这一类的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extraReducers: &#123;</span><br><span class="line">    &#x2F;&#x2F; omit other reducers</span><br><span class="line"></span><br><span class="line">    [fetchPosts.fulfilled]: (state, action) &#x3D;&gt; &#123;</span><br><span class="line">      state.status &#x3D; &#39;succeeded&#39;</span><br><span class="line">      &#x2F;&#x2F; Add any fetched posts to the array</span><br><span class="line">      &#x2F;&#x2F; Use the &#96;upsertMany&#96; reducer as a mutating update utility</span><br><span class="line">      postsAdapter.upsertMany(state, action.payload)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; Use the &#96;addOne&#96; reducer for the fulfilled case</span><br><span class="line">    [addNewPost.fulfilled]: postsAdapter.addOne</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>redux</tag>
        <tag>slice</tag>
        <tag>store</tag>
        <tag>thunk</tag>
        <tag>normalized data</tag>
      </tags>
  </entry>
  <entry>
    <title>redux数据流基础</title>
    <url>/2020/12/10/redux-fundamentals/</url>
    <content><![CDATA[<h1 id="action"><a href="#action" class="headerlink" title="action"></a>action</h1><p>所有的<strong>Redux Action必须满足两个要求</strong>：第一，是一个朴素的<strong>JavaScript对象</strong>；第二，<strong>有type field</strong>。type field的值用于描述这个action，命名上要与该action的语义一致。</p>
<p>An <strong>action</strong> is a plain JavaScript object that has a <code>type</code> field. <strong>You can think of an action as an event that describes something that happened in the application</strong>.</p>
<p>The <code>type</code> field should be a string that gives this action a descriptive name. We usually write that type string like <code>&quot;domain/eventName&quot;</code>.</p>
<p>An action object can have other fields with additional information about what happened. By convention, we put that information in a field called <code>payload</code>.</p>
<h2 id="action规范化"><a href="#action规范化" class="headerlink" title="action规范化"></a>action规范化</h2><p>Flux standard actions conventions： FSA convention</p>
<ul>
<li>action对象的实体数据本身需要放在action.payload中。</li>
<li>action对象必须拥有用于描述其他描述性信息的action.meta field。</li>
<li>action对象必须拥有用于提供错误信息的action.error field。</li>
</ul>
<hr>
<p>结合Redux action的两个必备条件：JS object以及type field，可以得出一个规范化的action对象必须用一以下三个fields：</p>
<ul>
<li>a payload field</li>
<li>an error field</li>
<li>a meta field</li>
</ul>
<h1 id="action-creators"><a href="#action-creators" class="headerlink" title="action creators"></a>action creators</h1><p>action creators是一个抽象了具体action的形式的一个函数。它接收payload field的值作为参数，返回action对象；该action对象的type对于该action creators应该是一致的。</p>
<p>An <strong>action creator</strong> is a function that creates and returns an action object. We typically use these so we don’t have to write the action object by hand every time.</p>
<p>调用action creator function后，将它返回的action object直接传递给dispatch函数。</p>
<h1 id="reducers"><a href="#reducers" class="headerlink" title="reducers"></a>reducers</h1><p>reducer是一个更新数据/状态的函数，它接收当前状态和action对象作为参数，返回更新后的状态。</p>
<p>A <strong>reducer</strong> is a function that receives the current <code>state</code> and an <code>action</code> object, decides how to update the state if necessary, and returns the new state: <code>(state, action) =&gt; newState</code>. </p>
<h2 id="Reducers的调用逻辑"><a href="#Reducers的调用逻辑" class="headerlink" title="Reducers的调用逻辑"></a>Reducers的调用逻辑</h2><p><strong>You can think of a reducer as an event listener which handles events based on the received action (event) type.</strong>可以把reducer堪称一个监听状态变化的监听函数，action就相当于call backfunction/event handler。</p>
<p>调用逻辑——The logic inside reducer functions typically follows the same series of steps:</p>
<ul>
<li>Check to see if the reducer cares about this action<ul>
<li>If so, make a copy of the state, update the copy with new values, and return it</li>
</ul>
</li>
<li>Otherwise, return the existing state unchanged</li>
</ul>
<p>类比useEffect Hook就相当于传入了第二个参数，有条件地针对某个state的变化去更新状态。</p>
<hr>
<h2 id="手写Reducers返回对象newState"><a href="#手写Reducers返回对象newState" class="headerlink" title="手写Reducers返回对象newState"></a>手写Reducers返回对象newState</h2><p>如果手写newState就面临一个问题，改动的值可能就一两个，返回的却是整个对象，这个对象可能还有很多子对象nested object。为了遵循redux state要求的immutable updates，每一次的返回都要在update之前先copy一份obj，然后再改动，进入下一层子对象还要继续copy再update，十分麻烦。</p>
<blockquote>
<p>wirte immutable updates by hand, by using JavaScript’s <strong>array / object spread operators</strong> and other functions that return copies of the original values.</p>
<p>This becomes harder when the <strong>data is nested</strong>. A critical rule of immutable updates is that you must make a copy of <em>every</em> level of nesting that needs to be updated.</p>
</blockquote>
<hr>
<h2 id="Reducers第一个参数的state初始值"><a href="#Reducers第一个参数的state初始值" class="headerlink" title="Reducers第一个参数的state初始值"></a>Reducers第一个参数的state初始值</h2><p>整个app初始化的时候一般是没有状态的，但是又不能给reducer提供undefined state，所以一般需要手动提供一个initialState value。</p>
<p>A reducer may be called with <code>undefined</code> as the state value when the application is being initialized. If that happens, we need to provide an initial state value so the rest of the reducer code has something to work with. <strong>Reducers normally use ES6 default argument syntax to provide initial state: <code>(state = initialState, action)</code></strong>.</p>
<hr>
<h2 id="Reducers拆分"><a href="#Reducers拆分" class="headerlink" title="Reducers拆分"></a>Reducers拆分</h2><p>如果把一个app中的所有reducer结合起来，就是一个由switch/case组成的函数，传入的参数是action type。但是本身一个app涉及的action type就很多，每个action的内容也很多，所以考虑拆分reducers。</p>
<p><strong>Redux reducers are typically split apart based on the section of the Redux state that they update</strong>. </p>
<h3 id="拆分准则"><a href="#拆分准则" class="headerlink" title="拆分准则"></a>拆分准则</h3><p><strong>We recommend organizing your Redux app folders and files based on “features”</strong> - code that relates to a specific concept or area of your application.</p>
<p>建议基于app的features拆分reducers。</p>
<p><strong>The Redux code for a particular feature is usually written as a single file, known as a “slice” file</strong>, which contains all the reducer logic and all of the action-related code for that part of your app state.</p>
<p>每一个feature的action以及state的相关的内容都被写在slice file中。</p>
<h3 id="拆分的好处"><a href="#拆分的好处" class="headerlink" title="拆分的好处"></a>拆分的好处</h3><p>在基于feature拆分后，对action type的命名也可以写成’feature/actionName’。</p>
<p>在基于feature拆分后，slice file中的action只需要应对feature-related state。也就意味着不再是nested object了。</p>
<hr>
<h2 id="Reducer组合"><a href="#Reducer组合" class="headerlink" title="Reducer组合"></a>Reducer组合</h2><p>因为redux store需要一个root reducer function，所以我们需要把slice文件中的各个feature的reducer组合起来。本质上reducer就是一个function，只需要把它们import到root reducer文件，重新写一个root reducer来调用slice中的reducer。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import todosReducer from &#39;.&#x2F;features&#x2F;todos&#x2F;todosSlice&#39;</span><br><span class="line">import filtersReducer from &#39;.&#x2F;features&#x2F;filters&#x2F;filtersSlice&#39;</span><br><span class="line"></span><br><span class="line">export default function rootReducer(state, action) &#123;</span><br><span class="line">  &#x2F;&#x2F; always return a new object for the root state</span><br><span class="line">  return &#123;</span><br><span class="line">    &#x2F;&#x2F; the value of &#96;state.todos&#96; is whatever the todos reducer returns</span><br><span class="line">    todos: todosReducer(state.todos, action),</span><br><span class="line">    &#x2F;&#x2F; For both reducers, we only pass in their slice of the state</span><br><span class="line">    filters: filtersReducer(state.filters, action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来手写root reducer，每一次调用某一个reducer遵循的模式都是相通的。因此redux core library把这种pattern抽象了出来，写成一个新的utility function名为<code>combineReducers</code>，这样能让代码更简洁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; combineReducers &#125; from &#39;redux&#39;</span><br><span class="line"></span><br><span class="line">import todosReducer from &#39;.&#x2F;features&#x2F;todos&#x2F;todosSlice&#39;</span><br><span class="line">import filtersReducer from &#39;.&#x2F;features&#x2F;filters&#x2F;filtersSlice&#39;</span><br><span class="line"></span><br><span class="line">const rootReducer &#x3D; combineReducers(&#123;</span><br><span class="line">  &#x2F;&#x2F; Define a top-level state field named &#96;todos&#96;, handled by &#96;todosReducer&#96;</span><br><span class="line">  todos: todosReducer,</span><br><span class="line">  filters: filtersReducer</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default rootReducer</span><br></pre></td></tr></table></figure>
<p>combineReducers接受一个对象作为参数，对象的key是root state object的feature（也就是redux store的state.key对象），对象的value是该feature的slice reducers functions。</p>
<h1 id="store"><a href="#store" class="headerlink" title="store"></a>store</h1><p>用于管理整个app的当前状态。整个redux application只能有唯一一个store。</p>
<p>The current Redux application state lives in an object called the <strong>store</strong> .</p>
<p>The store is created by passing in a reducer, and has a method called <code>getState</code> that returns the current state value:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; configureStore &#125; from &#39;@reduxjs&#x2F;toolkit&#39;</span><br><span class="line"></span><br><span class="line">const store &#x3D; configureStore(&#123; reducer: counterReducer &#125;)</span><br><span class="line"></span><br><span class="line">console.log(store.getState())</span><br></pre></td></tr></table></figure>
<h2 id="store功能"><a href="#store功能" class="headerlink" title="store功能"></a>store功能</h2><ul>
<li>储存当前应用的所有state value以及所有的reducer function</li>
<li>允许外部文件通过<code>store.getState()</code>访问当前状态</li>
<li>允许通过<code>store.dispatch(action)</code>更新当前状态</li>
<li>允许通过<code>store.subscribe(listener)</code>将listener callback绑定</li>
<li>允许通过<code>store.unsubscribe(listener)</code>将listener callback的绑定解除</li>
</ul>
<p>这些功能能够组成createStore API的内部逻辑。The store API is an object with {dispatch, subscribe, getState} inside。</p>
<p><code>getState</code> just returns whatever the current <code>state</code> value is. That means that <strong>by default, nothing prevents you from accidentally mutating the current state value!</strong> </p>
<p>store本身并不会在外部调用getState()的时候提前做一个原来state value的copy，store本身不能防止accidential mutatable updates。一种最常见的accidental mutations就是sorting arrays。</p>
<h2 id="创建store及三个参数rootReducer-initialState-enhancer"><a href="#创建store及三个参数rootReducer-initialState-enhancer" class="headerlink" title="创建store及三个参数rootReducer/initialState/enhancer"></a>创建store及三个参数rootReducer/initialState/enhancer</h2><p>Redux core library有一个<code>createStore</code> API用于创建store，只需要把从reducer中rootReducer给import进来就可以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#39;redux&#39;</span><br><span class="line">import rootReducer from &#39;.&#x2F;reducer&#39;</span><br><span class="line"></span><br><span class="line">const store &#x3D; createStore(rootReducer)</span><br><span class="line"></span><br><span class="line">export default store</span><br></pre></td></tr></table></figure>
<p>除了接受rootReducer为第一个argument以外，createStore还接受一个装载了初始状态值的preloadedState value作为第二个参数。</p>
<p>另外createStore还接受一个enhancer作为第三个参数（如果没有initialState就是第二个参数）。enhancer就相当于用enhancer的函数包裹住了原来的redux store，他可以override or replace原来store中的任何方法。</p>
<p>A store enhancer is like a special version of <code>createStore</code> that adds another layer wrapping around the original Redux store.</p>
<p>如果有多个enhancers存在该怎么办？可以用compose API把这些enhancers合并起来。</p>
<hr>
<h2 id="从enhancer到middleware"><a href="#从enhancer到middleware" class="headerlink" title="从enhancer到middleware"></a>从enhancer到middleware</h2><p>但是有时候我们只需要<strong>customize how dispatch behaves</strong>，我们希望在dispatch函数运行的时候有一些特殊的行为，那么就可以使用middleware。</p>
<p>Redux uses a special kind of addon called <strong>middleware</strong> to let us customize the <code>dispatch</code> function.</p>
<h3 id="middleware在redux数据流中的位置"><a href="#middleware在redux数据流中的位置" class="headerlink" title="middleware在redux数据流中的位置"></a>middleware在redux数据流中的位置</h3><p><strong>Middleware form a pipeline around the store’s <code>dispatch</code> method</strong>. 当我们dispatch一个action时，实际上我们是在calling the first middleware in the pipeline。首先，middleware会检查这个action是不是它要去customize的action，如果不是他就传递给流水线中下一个middleware；如果是需要customize的action，那么他就运行一些custom logic。</p>
<p><strong>Redux middleware provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.</strong> </p>
<h3 id="手写middleware"><a href="#手写middleware" class="headerlink" title="手写middleware"></a>手写middleware</h3><p>redux middleware手写的话就是三层嵌套的函数：outer的功能是someCustomMiddleware；middle功能是wrapDispatch；inner的功能是handleAction。</p>
<h4 id="使用ES5手写中间件"><a href="#使用ES5手写中间件" class="headerlink" title="使用ES5手写中间件"></a>使用<strong>ES5手写中间件</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Middleware written as ES5 functions</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Outer function:</span><br><span class="line">function exampleMiddleware(storeAPI) &#123;</span><br><span class="line">  return function wrapDispatch(next) &#123;</span><br><span class="line">    return function handleAction(action) &#123;</span><br><span class="line">      &#x2F;&#x2F; Do anything here: pass the action onwards with next(action),</span><br><span class="line">      &#x2F;&#x2F; or restart the pipeline with storeAPI.dispatch(action)</span><br><span class="line">      &#x2F;&#x2F; Can also use storeAPI.getState() here</span><br><span class="line"></span><br><span class="line">      return next(action)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最外层的outer exampleMiddleware就是我们调用的middleware本身，它接受包含了store’s <code>&#123;dispatch, getState&#125;</code> functions的storeAPI对象作为参。called once。</p>
<p>中间层的inner wrapDispatch接受一个名为next的function作为函数。这个next function本质上就是pipeline中的下一个middleware。如果该middleware已经是最后一个中间件了，那么next function就是original store.dispatch function。Calling <code>next(action)</code> passes the middleware to the <em>next</em> middleware in the pipeline. called once。</p>
<p>最里层的inner handleAction接受当前action作为参数，called everytime an action is dispatched。</p>
<hr>
<p>middleware inner handleAction的逻辑如下：</p>
<p>return内容可以是任何值。the return value from the first middleware in the pipeline is actually returned when you call <code>store.dispatch()</code>。</p>
<p>通常会利用一个if判断去匹配某一个特定的action，然后do something when that action is dispatched。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const delayedMessageMiddleware &#x3D; storeAPI &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;</span><br><span class="line">  if (action.type &#x3D;&#x3D;&#x3D; &#39;todos&#x2F;todoAdded&#39;) &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;Added a new todo: &#39;, action.payload)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line">  return next(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="使用ES6的箭头函数重写middleware"><a href="#使用ES6的箭头函数重写middleware" class="headerlink" title="使用ES6的箭头函数重写middleware"></a>使用<strong>ES6的箭头函数重写</strong>middleware</h4><p>因为是implicit return所以比较难阅读：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const anotherExampleMiddleware &#x3D; storeAPI &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; Do something in here, when each action is dispatched</span><br><span class="line">    </span><br><span class="line">  return next(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用手写middleware"><a href="#调用手写middleware" class="headerlink" title="调用手写middleware"></a>调用手写middleware</h4><p>需要用到<code>applyMiddleware(middleWare)</code>函数作为middlewareEnhancer再次传入createStore API去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const middlewareEnhancer &#x3D; applyMiddleware(alwaysReturnHelloMiddleware)</span><br><span class="line">const store &#x3D; createStore(rootReducer, middlewareEnhancer)</span><br></pre></td></tr></table></figure>
<p>当一个action被dispatch的时候运行逻辑如下：</p>
<ul>
<li>最内层的handleAction会最先运行</li>
<li>接着将action传递到next section，也就是另一个middleware或者real store dispatch。</li>
<li>最后reducer会运行然后状态被更新，next 函数返回</li>
<li>可以通过storeAPI.getState()获取当前状态</li>
</ul>
<h3 id="async-function-middleware"><a href="#async-function-middleware" class="headerlink" title="async function middleware"></a>async function middleware</h3><h4 id="手写async-function-middleware的两种方式"><a href="#手写async-function-middleware的两种方式" class="headerlink" title="手写async function middleware的两种方式"></a>手写async function middleware的两种方式</h4><p>以上涉及的middleware都是同步逻辑下的，能够让我们书写异步逻辑的middleware怎么书写？一种方式就是在middleware内部，用if条件语句匹配特定的action type，并且return async logic（比如在内部调用了定时器）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const delayedActionMiddleware &#x3D; storeAPI &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;</span><br><span class="line">  if (action.type &#x3D;&#x3D;&#x3D; &#39;todos&#x2F;todoAdded&#39;) &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; Delay this action by one second</span><br><span class="line">      next(action)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  return next(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种写法过于specific且only do one thing（因为通过action type来识别异步逻辑）。因为我们传递给middleware的是用action type来识别的action object。</p>
<p>更好的想法就是我们把<strong>异步逻辑从middleware的定义中剥离</strong>(<strong>write async logic ahead of time, without knowing what Redux store is being used</strong>)，但是middleware为异步逻辑代码块提供store的dispatch函数与getState方法的访问许可。</p>
<blockquote>
<p>It would be nice if we had a way to write <em>any</em> async logic ahead of time, separate from the middleware itself, and still have access to <code>dispatch</code> and <code>getState</code> so that we can interact with the store.</p>
</blockquote>
<p>We could have our middleware <strong>check to see if the “action” is actually a function</strong> instead, and if it’s a function, call the function right away. That would let us <strong>write async logic in separate functions, outside of the middleware definition.</strong></p>
<p>为middleware配备识别function的能力：let us pass a function to dispatch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const asyncFunctionMiddleware &#x3D; storeAPI &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; If the &quot;action&quot; is actually a function instead...</span><br><span class="line">  if (typeof action &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F; then call the function and pass &#96;dispatch&#96; and &#96;getState&#96; as arguments</span><br><span class="line">    return action(storeAPI.dispatch, storeAPI.getState)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Otherwise, it&#39;s a normal action - send it onwards</span><br><span class="line">  return next(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在middleware外部定义异步逻辑并调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const middlewareEnhancer &#x3D; applyMiddleware(asyncFunctionMiddleware)</span><br><span class="line">const store &#x3D; createStore(rootReducer, middlewareEnhancer)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Write a function that has &#96;dispatch&#96; and &#96;getState&#96; as arguments</span><br><span class="line">const fetchSomeData &#x3D; (dispatch, getState) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; Make an async HTTP request</span><br><span class="line">  &#x2F;&#x2F; 使用dispatch和getState书写异步逻辑</span><br><span class="line">&#125;</span><br><span class="line">store.dispatch(fetchSomeData)</span><br></pre></td></tr></table></figure>
<h4 id="使用redux-thunk-middleware"><a href="#使用redux-thunk-middleware" class="headerlink" title="使用redux-thunk middleware"></a>使用redux-thunk middleware</h4><p>The thunk middleware allows us to write functions that get <code>dispatch</code> and <code>getState</code> as arguments.</p>
<p>在使用redux-thunk middleware的时候可以简单分两种情况。</p>
<p>第一种是从第三方API获取数据。直接export async function之后disptach该thunk function即可。</p>
<p>第二种是将UI中的数据传到服务器。简单的async function只能接受dispatch和getState作为arguments，但是UI中的数据从何而来？需要先写一个接受UI数据作为参数的函数，然后创建使用该UI数据的thunk function。We need a way to write one function that accepts <code>text</code> as its parameter, but then creates the actual thunk function so that it can use the <code>text</code> value to make the API call. </p>
<p>方法就是先在外层写一个同步逻辑把UI数据做为参数的函数，该函数返回的是一个异步逻辑的thunk function。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Write a synchronous outer function that receives the &#96;text&#96; parameter:</span><br><span class="line">export function saveNewTodo(text) &#123;</span><br><span class="line">  &#x2F;&#x2F; And then creates and returns the async thunk function:</span><br><span class="line">  return async function saveNewTodoThunk(dispatch, getState) &#123;</span><br></pre></td></tr></table></figure>
<p>在UI中调用这个function要先传入UI数据，然后再dispatch。</p>
<h1 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h1><p>dispatch作为更新app当前状态store的唯一媒介，接受一个action obejct作为参数。由于action creator返回一个action object，所以可以把action creators传入dispatch函数。</p>
<p>The Redux store has a method called <code>dispatch</code>. <strong>The only way to update the state is to call <code>store.dispatch()</code> and pass in an action object</strong>. </p>
<p><strong>You can think of dispatching actions as “triggering an event”</strong>.类比事件监听函数，这就像客户端有一个用户去点击了网页，触发了事件监听函数。</p>
<h1 id="selectors"><a href="#selectors" class="headerlink" title="selectors"></a>selectors</h1><p>选择store中的特定状态</p>
<p><strong>Selectors</strong> are functions that know how to extract specific pieces of information from a store state value.</p>
<p>一般作为参数传入useSelector中去。</p>
<h1 id="redux-sync-data-flow"><a href="#redux-sync-data-flow" class="headerlink" title="redux sync data flow"></a>redux sync data flow</h1><p><img src="/2020/12/10/redux-fundamentals/drunk99/machacroissant/source/_posts/2020-12-04-redux-hooks/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif" alt="ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26" style="zoom:50%;"></p>
<ul>
<li><p>首次渲染</p>
<ul>
<li>创建一个redux store。</li>
<li>store调用root reducer，将它返回的值作为initial state。</li>
<li>当UI被渲染的时候，UI中的组件从redux store中读取当前状态，并渲染。</li>
</ul>
</li>
<li><p>重新渲染</p>
<ul>
<li>用户有一些行为，UI组件发现了这些行为的发生，这些行为用action对象来描述。</li>
<li>通过给dispatch函数传递该行为action，获得的返回值就是current state，store将这更新后的值<strong>覆盖原值</strong>地保存起来。（immutable）</li>
</ul>
<blockquote>
<p><strong>In order to update values immutably, your code must make <em>copies</em> of existing objects/arrays, and then modify the copies</strong>.</p>
</blockquote>
<ul>
<li>store会通知所有的UI组件状态值被更新了</li>
<li>那些需要从store中获取状态的UI组件就<strong>检查store</strong>看自己需要的值是否被更新了，<strong>更新了的话就重新渲染</strong>自己的那个部分。</li>
</ul>
</li>
</ul>
<h1 id="UI-and-Redux"><a href="#UI-and-Redux" class="headerlink" title="UI and Redux"></a>UI and Redux</h1><p>最原始的基础的redux and UI integration必须经历一下几个步骤：</p>
<ol>
<li>Create a Redux store</li>
<li>Subscribe to updates(UI中的render)</li>
<li>Inside the subscription callback:(render函数的具体内容)<ol>
<li>Get the current store state</li>
<li>Extract the data needed by this piece of UI</li>
<li>Update the UI with the data</li>
</ol>
</li>
<li>If necessary, render the UI with initial state(初始UI呈现通过调用render函数来实现)</li>
<li>Respond to UI inputs by dispatching Redux actions</li>
</ol>
<p>有许多UI binding libraries协助use Redux with a given UI framework，他们承担subscribing to the store和update UI的工作。其中<strong>react-redux UI binding library</strong>就是redux core的一个独立包。</p>
<h2 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h2><p>connect函数的作用就是connects a React component to a Redux store。使用connect的好处就是：it encapsulates the logic of talking to the Redux store。</p>
<p>从UI component的角度出发，该函数为UI提供了data needed from store，以及提供了functions it can use to dispatch actions to the store。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?)</span><br></pre></td></tr></table></figure>
<p>The <code>mapStateToProps</code> and <code>mapDispatchToProps</code> deals with your Redux store’s <code>state</code> and <code>dispatch</code>, respectively.</p>
<h3 id="Connect-Extracting-Data-with-mapSateToProps"><a href="#Connect-Extracting-Data-with-mapSateToProps" class="headerlink" title="Connect: Extracting Data with mapSateToProps"></a>Connect: Extracting Data with <code>mapSateToProps</code></h3><p><code>mapStateToProps</code>是传递给<code>connect</code>函数的第一个参数。它的作用是从整体store中把所需要的那部分数据传递给connected components，也就是让UI组件订阅保存全体数据的store。</p>
<p>如果不希望该组件订阅全体store，可以直接给connect函数的第一个参数传入<code>null</code>或者<code>undefined</code>。</p>
<hr>
<p>该函数有以下特性：</p>
<ul>
<li>每次store发生变化该函数就会重新调用。</li>
</ul>
<p>如果整个app中有一个action被dispatched了，这就意味着store state有可能改变。那么mapStateToProps的UI component就会调用<code>store.getState()</code> 来检查是否 <code>lastState === currentState</code>，如果两次的state value是identical by reference，那么就不会重新调用 <code>mapStateToProps</code> function</p>
<ul>
<li>它就接受整个的store state作为参数，返回an object of data this component needs。</li>
</ul>
<hr>
<p>定义<code>mapStateToProps</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function mapStateToProps(state, ownProps?)&#123; return &#123;</span><br><span class="line">    a: 42,</span><br><span class="line">    todos: state.todos</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<p>state参数代表了整个app的redux store state。(the same value returned by a call to <code>store.getState()</code>)。这是必须有的一个参数。</p>
<p>ownProps参数(optional)是一个可选参数，如果UI组件需要使用它自己的props去retrieve date from store的话就需要改参数。比如当前UI component中拥有名为id的props，该id可以作为key去查找store，所以要把该id作为ownProps传入mapStateToProps。</p>
<p>返回内容：</p>
<p>mapStateToProps函数返回一个plain object，这个对象中的每一个field都会成为该UI component的props。返回对象中的field的value决定了你的UI component是否需要重新渲染。比如上面的例子就说明该component会接受props.a/props.todos。</p>
<hr>
<p>为什么要使用mapStateToProps？</p>
<p>这个函数拥有re-shaping store data as needed for that component的功能。它可以将整个UI component所需要的数据都集中到一个返回对象中。</p>
<p>一般在mapStateToProps的函数体中会用到useSelector。useSelector用于在mapStateToProps函数内部实现选取数据，每一次useSelector选取的数据都是互相独立，如果单独使用useSelector，这个选取数据的过程会和UI component交织在一起。(useSelector help encapsulate the process of extracting values from specific locations in the state tree)</p>
<h3 id="Connect-Dispatching-Actions-with-mapDispatchToProps"><a href="#Connect-Dispatching-Actions-with-mapDispatchToProps" class="headerlink" title="Connect: Dispatching Actions with mapDispatchToProps"></a>Connect: Dispatching Actions with <code>mapDispatchToProps</code></h3><p><code>mapDispatchToProps</code>是传递给<code>connect</code>函数的第二个参数。它的作用是dispatching action to the store。</p>
<p>如果connect的第二个参数没有传入或者传入的是null，那么默认UI component会接受<code>dispatch</code>函数作为<code>props.dispatch</code>。在UI中调用时依然需要给dispatch函数传递action type。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; UI与store绑定默认dispatch的三种方式</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">connect()(MyComponent)</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">connect(null, null)(MyComponent)</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">connect(mapStateToProps &#x2F;** no second argument *&#x2F;)(MyComponent)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在UI描述中调用时需要传递action type</span><br><span class="line">function Counter(&#123; count, dispatch &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;DECREMENT&#39; &#125;)&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">      </span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于dispatch函数</p>
<p><code>dispatch</code> is a function of the Redux store. You call <code>store.dispatch</code> to dispatch an action. This is the only way to trigger a state change.</p>
</blockquote>
<p>由于当前UI component并不能access the store directly，所以<code>connect</code>就实现了让UI component直接与redux store对接。同样的useDispatch hook也实现了相同的功能。</p>
<hr>
<p>定义mapDispatchToProps能帮我们省去写dispatch函数。<strong>if you define your own <code>mapDispatchToProps</code>, the connected component will no longer receive <code>dispatch</code>.</strong> </p>
<hr>
<p>定义mapDispatchToProps的两种方式：</p>
<h4 id="Function-form"><a href="#Function-form" class="headerlink" title="Function form"></a>Function form</h4><p> Allows more customization, gains access to <code>dispatch</code> and optionally <code>ownProps</code></p>
<p>传入参数说明：</p>
<p>第一个必选参数是dispatch，一般会在mapDispatchToProps函数的返回对象中使用dispatch。给dispatch函数传入一个action object或者是action creator。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mapDispatchToProps &#x3D; dispatch &#x3D;&gt; &#123;</span><br><span class="line">  return &#123;&#x2F;&#x2F; dispatching plain actions</span><br><span class="line">    increment: () &#x3D;&gt; dispatch(&#123; type: &#39;INCREMENT&#39; &#125;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个参数是ownProps(optional)可选参数。在bind on component mount的基础之上，还能bind on props change。当传入的ownProps Change的时候也会dispatch action。</p>
<p>返回对象说明：</p>
<p>返回的应该是a plain object。这个object的每一个field都会被添加为该UI component的prop，也就在在原来UI compoennt的基础之上继续添补进去。（The return of the <code>mapDispatchToProps</code> function will be merged to your connected component as props.）同时the value should normally be a function that dispatches an action when called.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; way1 plain object return</span><br><span class="line">const mapDispatchToProps &#x3D; dispatch &#x3D;&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    &#x2F;&#x2F; dispatching plain actions</span><br><span class="line">    increment: () &#x3D;&gt; dispatch(&#123; type: &#39;INCREMENT&#39; &#125;),</span><br><span class="line">    decrement: () &#x3D;&gt; dispatch(&#123; type: &#39;DECREMENT&#39; &#125;),</span><br><span class="line">    reset: () &#x3D;&gt; dispatch(&#123; type: &#39;RESET&#39; &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果给dipsatch传入的是action creator函数而非plain obejct action，通常的习惯就是把action creator的名字与mapDispatchToProps的return object的field也命名为相同的名字。</p>
<p>如果存在多个action creator要dispatch绑定到props，这个过程很tedious，所以可以使用bindActionCreators函数来实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; way2 action creator return</span><br><span class="line">const increment &#x3D; () &#x3D;&gt; (&#123; type: &#39;INCREMENT&#39; &#125;)</span><br><span class="line">const decrement &#x3D; () &#x3D;&gt; (&#123; type: &#39;DECREMENT&#39; &#125;)</span><br><span class="line">const reset &#x3D; () &#x3D;&gt; (&#123; type: &#39;RESET&#39; &#125;)</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps &#x3D; dispatch &#x3D;&gt; &#123;</span><br><span class="line">  return &#123;&#x2F;&#x2F; dispatching actions returned by action creators</span><br><span class="line">    increment: () &#x3D;&gt; dispatch(increment()),</span><br><span class="line">    decrement: () &#x3D;&gt; dispatch(decrement()),</span><br><span class="line">    reset: () &#x3D;&gt; dispatch(reset())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用bindActionCreator：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; way3 bindActionCreator return</span><br><span class="line">const boundActionCreators &#x3D; bindActionCreators(</span><br><span class="line">  &#123; increment, decrement, reset &#125;,</span><br><span class="line">  dispatch</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="Object-shorthand-form："><a href="#Object-shorthand-form：" class="headerlink" title="Object shorthand form："></a>Object shorthand form：</h4><p>More declarative and easier to use（更推荐使用）</p>
<p>由于在define as function的语法中多次出现了类似another function that looks like <code>(…args) =&gt; dispatch(actionCreator(…args))</code>这样的pattern，这种模式可以抽取出来简化。走在上面我们尝试使用bindActionCreators来简化，但实际上还可以更加简化，这就是Object shorthand form。</p>
<p>在obejct shorthand form当中，我们直接给mapDispatchToProps传递一个对象，对象中的每一个field都是action creators。那么根据内容重新命名mapDispatchToProps可以发现其实这本质上就是actionCreators的集合，作为第二个参数传入connect。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mapDispatchToProps &#x3D; &#123;increment, decrement, reset&#125;</span><br></pre></td></tr></table></figure>
<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>react-redux提供了一系列的hooks让store和UI发生数据双向流动。但是在使用这些hook前，需要让这些hook能够找到正确的redux store。</p>
<p>我们需要告诉react-redux我们希望在compnents中使用哪一个store。因此我们需要rendering a <code>&lt;Provider&gt;</code>  component around our entire <code>&lt;App&gt;</code>, <strong>and passing the Redux store as a prop to <code>&lt;Provider&gt;</code></strong>.</p>
<hr>
<blockquote>
<p><strong>In a React + Redux app, your global state should go in the Redux store, and your local state should stay in React components.</strong></p>
</blockquote>
<h3 id="useSelector"><a href="#useSelector" class="headerlink" title="useSelector"></a>useSelector</h3><p>react中提供类似于useState hook让react function components能够访问react state values。</p>
<p>同样的react-redux提供useSelector hook让react component能够从redux store中读取数据。它接收selector function作为参数。selector function本身只接受一个state参数，这个state时entire redux store state，它的返回值可以是store state的某个slice，也可以是经过一些运算得到的derived value。</p>
<p>那么useSelector本身不能执行select的功能，那么他的功能何在？它主要承担为selector function传递entire redux state object的工作。</p>
<blockquote>
<p><code>useSelector</code> accepts a single function, which we call a <strong>selector</strong> function. <strong>A selector is a function that takes the entire Redux store state as its argument, reads some value from the state, and returns that result</strong>.</p>
</blockquote>
<p>如果store中的state value有了变化该怎么办？useSelector自动帮我们subscribe to the redux store。意思就是只要selector返回的value和上一次的value不一样，useSelector就会force our component to re-render with the new data。</p>
<blockquote>
<p><strong><code>useSelector</code> compares its results using strict <code>===</code> reference comparisons, so the component will re-render any time the selector result is a new reference!</strong> </p>
</blockquote>
<hr>
<h4 id="useSelector总是返回new-reference解决办法"><a href="#useSelector总是返回new-reference解决办法" class="headerlink" title="useSelector总是返回new reference解决办法"></a>useSelector总是返回new reference解决办法</h4><p>如果传递给useSelector的selector函数返回的总是是一个新的reference，那么这就回导致无条件re-render。比如filter函数和map函数总是return a new reference。</p>
<p>在书写传入useSelector的selector function时最好注意以下几点：</p>
<hr>
<h5 id="单次selector选择store中尽可能少的数据量"><a href="#单次selector选择store中尽可能少的数据量" class="headerlink" title="单次selector选择store中尽可能少的数据量"></a>单次selector选择store中尽可能少的数据量</h5><p>建议在一个component中使用useSelector的时候，每一次的调用尽量返回最少的数据smallest amount of state。比如比起一个item本身，我们可能更希望返回指向该item的id。</p>
<hr>
<h5 id="useSelector-with-ShallowEuqal-comparison"><a href="#useSelector-with-ShallowEuqal-comparison" class="headerlink" title="useSelector with ShallowEuqal comparison"></a>useSelector with ShallowEuqal comparison</h5><p>但是方法1中提供的返回少量数据也不能改变返回的id本质上也是array的事实。因此我们需要一个比较前后返回数据的function（返回数据的volume越小这种comparison执行起来就越快）。<strong>将<code>shallowEqual</code> comparison function函数作为第二参传入useSelector函数</strong>。</p>
<blockquote>
<p>React-Redux has a <code>shallowEqual</code> comparison function we can use to check if the items <em>inside</em> the array are still the same.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; useSelector, shallowEqual &#125; from &#39;react-redux&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;selector function</span><br><span class="line">const selectTodoIds &#x3D; state &#x3D;&gt; state.todos.map(todo &#x3D;&gt; todo.id)</span><br><span class="line"></span><br><span class="line">const TodoList &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; useSelector in UI</span><br><span class="line">  const todoIds &#x3D; useSelector(selectTodoIds, shallowEqual)  </span><br><span class="line">  &#x2F;&#x2F; UI rendering</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用memoized-seletors"><a href="#使用memoized-seletors" class="headerlink" title="使用memoized seletors"></a>使用memoized seletors</h5><p>memoized selectors中的memoization的意思就是一种caching机制，储存经过较大运算量后得出的结果，并在后续遇到相同输入的时候重复使用该储存值。</p>
<p>而memoized selector functions就是那些 save the most recent result value的selector。遇到相同的input，reuse the same result value；遇到不同的input，recalculate a new result value。</p>
<p>那么如果创建memoized selector functions呢？<strong>Reselect library提供了<code>createSelector</code> API</strong>供创建memoized selector function。该函数接受一个或多个input selector function作为第一参数，接受一个output selector function作为第二参数，并且返回一个新的selector function。</p>
<p>运行机制如下：</p>
<ul>
<li>All “input selectors” are called with all of the arguments</li>
<li>If any of the input selector return values have changed, the “output selector” will re-run</li>
<li>All of the input selector results become arguments to the output selector</li>
<li>The final result of the output selector is cached for next time</li>
</ul>
<p>这是原来的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const selectTodoIds &#x3D; state &#x3D;&gt; state.todos.map(todo &#x3D;&gt; todo.id)</span><br></pre></td></tr></table></figure>
<p>这是使用createSelector的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const selectTodoIds &#x3D; createSelector(</span><br><span class="line">  &#x2F;&#x2F; First, pass one or more &quot;input selector&quot; functions:</span><br><span class="line">  state &#x3D;&gt; state.todos,</span><br><span class="line">  &#x2F;&#x2F; Then, an &quot;output selector&quot; that receives all the input results as arguments</span><br><span class="line">  &#x2F;&#x2F; and returns a final result value</span><br><span class="line">  todos &#x3D;&gt; todos.map(todo &#x3D;&gt; todo.id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>就相当于把原来的一步到位拆分成了两个步骤。</p>
<p>什么时候建议使用memoized selectors？当你<strong>需要从redux store中获取derived additional values</strong>。换句话说return的值是经过某些逻辑后产生的值，步骤较多。</p>
<h3 id="useDispatch"><a href="#useDispatch" class="headerlink" title="useDispatch"></a>useDispatch</h3><p>useSelector解决了如何从redux store读取数据到UI的问题，但是如何解决从UI component去dispatch action到store的问题呢？当然我们可以调用store.dispatch(action)来完成，但是我们在component file中是无法访问到store的，因此我们需要一个API能让我们在UI component中使用dispatch function。</p>
<p>由此react-redux提供了useDispatch Hook，它的作用是gives us the store’s <code>dispatch</code> method as its result. (In fact, the implementation of the hook really is <code>return store.dispatch</code>.)</p>
<p>在UI component中使用useDispatch的方法一般是：调用<code>const dispatch = useDispatch()</code>，然后在需要时调用<code>dispatch(someAction)</code>。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Vue框架的记录</title>
    <url>/2020/10/17/learn-vue/</url>
    <content><![CDATA[<h1 id="创建Vue应用"><a href="#创建Vue应用" class="headerlink" title="创建Vue应用"></a>创建Vue应用</h1><p>使用<code>const app = Vue.createApp(&#123;&#125;)</code>创建Vue应用，在创建完Vue应用之后，还要利用<code>app.mount(&quot;#vue-app&quot;)</code>把当前Vue应用mount/挂载到对应html节点中去，而html节点用id唯一标识<code>&lt;div id=&quot;vue-app&quot;&gt;&lt;/div&gt;</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;https://unpkg.com/vue@next&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;vue-app&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      <span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">        template: <span class="string">&quot;&lt;div&gt;&lt;h1&gt;HI&lt;/h1&gt;&lt;/div&gt;&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      app.mount(<span class="string">&quot;.vue-app&quot;</span>);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实只要是一个选择器都能实现挂载，利用class对应点选择器也能实现挂载，问题在于一个class可以对应到多个html标签，而使用id是因为id的唯一性。因此约定都适用id选择器和标签的id属性。</p>
<h1 id="template-syntax"><a href="#template-syntax" class="headerlink" title="template syntax"></a>template syntax</h1><p>在创建template的时候，使用引号将html语言包裹起来，能正常加载，但是问题在于必须在一行内全部写完所有html内容，因此使用模版字符串中来实现分栏。</p>
<center class="half">
<img src="/2020/10/17/learn-vue/image-20201225142100746.png" alt="image-20201225142100746" style="zoom:30%;"><img src="/2020/10/17/learn-vue/image-20201225142124760.png" alt="image-20201225142124760" style="zoom:30%;">
</center>

<p>Vue.js使用了基于HTML的模版语法，利用模版字符串可以在Vue实例的template中直接写入合法的HTML。</p>
<p>在HTML文件中，<strong>将想要传递简单值值的属性用双括号(“Mustache” Syntax)包裹</strong>（如果是复杂值参考computed attribute field）。但是<strong>只能在HTML元素两个尖括号之间使用，作为HTML元素内容。</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tag</span>&gt;</span>&#123;&#123; Mustache-Syntax &#125;&#125;<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>双括号既可以用在我们想要mount id特定的原生html中，也可以用在我们创建的Vue实例的template中。</p>
<p>template syntax和v-directive中的<code>v-text</code>很相似，但是v-text的问题在于不管template中父亲元素内部有什么内容，都会被v-text的内容替换/覆盖。</p>
<h1 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h1><p>每个Vue实例被创建时都要经过一系列初始化过程， 而实例生命周期钩子就是在初始化过程中执行的函数，可以在特定的初始化阶段插入我们想要的代码。</p>
<p>beforeCreate(页面载入之前)/created(Vue实例被创建之后)，例子就比如在刚进入页面，或者刷新页面的时候。</p>
<p>breforeMount(挂载之前)/mounted(挂载成功)：如果在html元素内部有内容却没有在vue实例的template定义内容，那么将html元素的outerHTML编译成template；如果有template，将template编译成render function。</p>
<p>mounted和beforeMount的例子就比如在页面间路由，如果从当前页面跑到另外一个页面去，那么当前页面的vue实例就会经历beforeUnmount以及unmounted，而去往的目的页面的vue实例就会经历beforeMount以及mounted。</p>
<p>beforeUpdate(数据改变，更新之前)/updated(更新完毕），例如用户在文本框输入了数据，传递到vue，那么就会重新渲染显示到页面。</p>
<p>注意<strong>不能使用箭头函数来定义一个生命周期方法，因为箭头函数没有指向实例的this。</strong></p>
<p>生命周期函数定义在methods field中，以函数的形式定义。</p>
<p><img src="/2020/10/17/learn-vue/lifecycle.png" alt="lifecycle"></p>
<h1 id="v-directives指定约定"><a href="#v-directives指定约定" class="headerlink" title="v- directives指定约定"></a>v- directives指定约定</h1><p>A directive’s job is to reactively <strong>apply side effects to the DOM</strong> when the value of its expression changes.</p>
<p>指令是带有v-前缀的特殊的由vue来处理的attribute。指令接受单个JavaScript表达式（v-for和v-on除外）。attribute的值都需要从我们定义的vue实例中去寻找，而不是默认的DOM对象。</p>
<blockquote>
<p>Directives are prefixed with <code>v-</code> to indicate that they are <strong>special attributes provided by Vue</strong>, and they apply special reactive behavior to the rendered DOM.</p>
</blockquote>
<p>Vue为最常用的<code>v-bind</code>和<code>v-on</code>提供了缩写指令。v-bind语法中可以直接省去v-bind，直接在html标签中用冒号传参数<code>:url/:[computed]</code>；v-on可以用@符号替代v-on:，直接在html中用at符号和事件名<code>@click/@[event]</code>。</p>
<p><strong>修饰符 (modifier) 是以半角句号<code>.</code>指明的特殊后缀</strong>，用于指出一个指令应该以特殊方式绑定。每个v-directive可用的修饰符见具体的说明模块。</p>
<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind:"></a><code>v-bind:</code></h2><h3 id="实现值的绑定"><a href="#实现值的绑定" class="headerlink" title="实现值的绑定"></a>实现值的绑定</h3><p>在v-指令后面添加一个冒号，让指令接受一个html attribute参数，v-指令会让该html attribute和等号后传入的单个JavaScript表达式的值绑定。（主要任务是绑定当前vue实例中的值）</p>
<p>v-bind让我们把html field中任何一个attribute的值和定义在vuejs中的data联系起来，因为我们把value放在引号中，如果没有v-bind，html中的attribute会直接被理解为字符串值传递过去。比如href=”url”的意思就是href的值是url，而不是url这个变量所指向的具体的url地址。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这里 <code>href</code> 是参数，告知 <code>v-bind</code> 指令将该元素的 <code>href</code> attribute 与表达式 <code>url</code> 的值绑定。</p>
<p>又如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这里<code>click</code>监听事件名称是参数，告知<code>v-on</code>指令将该html元素的<code>click</code>事件与表达式<code>doSomething</code>回调函数绑定。</p>
<h3 id="实现属性的绑定"><a href="#实现属性的绑定" class="headerlink" title="实现属性的绑定"></a>实现属性的绑定</h3><p>既然属性值可以从vuejs的data中传递过来，那么属性是否也可以从vuejs的data中传递过来呢？通过方括号将变量括起来放到v-directive的冒号后面，vue首先会将方括号里的变量当作一个JavaScript表达式在vuejs的代码部分查找到匹配名字的变量后求值后再作为静态的html attribute传递给html（<strong>在vue的data field中定义这个属性一定要是字符串</strong>）与等号后JavaScript表达式值的绑定。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributename</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果<code>[attributename]</code>被求值出来的结果是一个<strong><code>null</code>字符串，表示移除该绑定</strong>。</p>
<p>在DOM中使用模版是（也就是直接在html文件中撰写模版）<strong>避免在方括号中使用大写字符</strong>，因为DOM会把代码转换为小写。如<code>&lt;a v-bind:[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt;</code>就会被自动转换为<code>v-bind:[someattr]</code>，除非js文件的vue实例中确实有return一个someattr，否则代码不会工作。</p>
<p><strong>不要在方括号内书写空格和引号</strong>，因为空格和引号在html的attribute名里都是无效的。</p>
<h3 id="绑定html-class"><a href="#绑定html-class" class="headerlink" title="绑定html class"></a>绑定html class</h3><h4 id="通过对象true-false切换class"><a href="#通过对象true-false切换class" class="headerlink" title="通过对象true/false切换class"></a>通过对象true/false切换class</h4><p>通过给<code>:class</code>一个对象，实现<strong>动态切换class</strong>。</p>
<p>html class在该对象的object field中定义，而<strong>该class是否存在取决于该对象的obejct field value的truthiness</strong>。</p>
<p><code>:class</code>指令可以与html的普通的class共存。</p>
<hr>
<ol>
<li>内联定义方式</li>
</ol>
<p>当然该对象可以直接内联定义在html template中，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<ol>
<li>解耦定义方式</li>
</ol>
<p>也可以在vue实例的data field中return，如html中定义：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>并在JavaScript中定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    classObject: &#123;</span><br><span class="line">      active: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&#x27;text-danger&#x27;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过数组值应用多个class"><a href="#通过数组值应用多个class" class="headerlink" title="通过数组值应用多个class"></a>通过数组值应用多个class</h4><p>可以把一个数组传给 <code>:class</code>，以应用一个 class 列表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    activeClass: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line">    errorClass: <span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个部分组合起来渲染结果就是</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;active text-danger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="绑定html-style"><a href="#绑定html-style" class="headerlink" title="绑定html style"></a>绑定html style</h3><p>和绑定html class遵循相似的方式，对象语法和数组语法都可以。</p>
<h2 id="v-model表单输入双向绑定"><a href="#v-model表单输入双向绑定" class="headerlink" title="v-model表单输入双向绑定"></a><code>v-model</code>表单输入双向绑定</h2><h3 id="v-bind和v-model的区别"><a href="#v-bind和v-model的区别" class="headerlink" title="v-bind和v-model的区别"></a><code>v-bind</code>和<code>v-model</code>的区别</h3><p>v-bind虽然能够实现js中的数据传递向html（也就是视图），但是用开发工具查看当用户在视图上的input框里输入的内容是不会自动同步到js中去的，也就是说这是一个单向绑定。</p>
<p>如果实现双向绑定，直接使用v-model，v-model隐含的语义就是在v-bind实现的单项数据基础上，再把反向增加一个数据流，作用的属性是value。</p>
<h3 id="v-model的具体使用"><a href="#v-model的具体使用" class="headerlink" title="v-model的具体使用"></a><code>v-model</code>的具体使用</h3><p><code>v-model</code>指令用于表单<code>input</code> <code>textarea</code> 以及 <code>select</code>元素上创建和JavaScript的<strong>data对象的双向数据绑定</strong>。</p>
<p><strong><code>v-model</code>会忽略HTML文件中表单元素的各种属性的初始值，只会依据JavaScript文件中的实例数据作为初始数据来源</strong>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Tag</th>
<th>Property</th>
<th>Event</th>
</tr>
</thead>
<tbody>
<tr>
<td>text/textarea</td>
<td>Value</td>
<td>Input</td>
</tr>
<tr>
<td>checkbox/radio</td>
<td>Checked</td>
<td>Change</td>
</tr>
<tr>
<td>select</td>
<td>Value</td>
<td>Change</td>
</tr>
</tbody>
</table>
</div>
<p>选择框单选时需要注意<strong>提供一个值为空的初始禁用选项</strong>，选择框多选时绑定到一个数组。</p>
<h3 id="使用v-model修饰符"><a href="#使用v-model修饰符" class="headerlink" title="使用v-model修饰符"></a>使用<code>v-model</code>修饰符</h3><p><strong>v-model的绑定是默认用户在focus时每次输入都要vue去响应去同步</strong>，这是很不高效的。因此就有了<code>v-model.lazy</code>修饰符，这告诉vue，等用户的focus从当前表单输入离开了之后，你再去更新vue实例反向的数据流。</p>
<p>有时候用户会在输入文本头尾添加无意义的空格，我们不希望接受这些无意义的输入，因此就有了<code>v-model.trim</code>修饰符，这告诉vue，你把用户输入的头尾空格都修剪掉在作为同步到vue实例对应的地方去储存值。</p>
<p>默认接受用户输入是字符串格式，有时候希望把字符串作为number形式储存在vue 实例中，因此就有了<code>v-model.number</code>修饰符。</p>
<h2 id="v-once一次性渲染DOM"><a href="#v-once一次性渲染DOM" class="headerlink" title="v-once一次性渲染DOM"></a><code>v-once</code>一次性渲染DOM</h2><p>v-once 代表只在DOM中渲染一次该组件，但是该组件中涉及的数据仍然由vue组件管控，会在vue devtools的data field中（如果有的话）被更新。但是被v-once标记的元素不会再初始渲染后再次重新渲染。</p>
<h2 id="v-html在template中插入html代码"><a href="#v-html在template中插入html代码" class="headerlink" title="v-html在template中插入html代码"></a><code>v-html</code>在template中插入html代码</h2><p>在template中的元素上使用v-html会告诉vue，父亲标签里面的字标签应当被当作原生html渲染。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 v-html=<span class="string">&quot;title&quot;</span>&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      title: <span class="string">&quot;&lt;h1&gt;Hey Vue3&lt;/h1&gt;&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="v-if-v-else-if-v-else条件渲染"><a href="#v-if-v-else-if-v-else条件渲染" class="headerlink" title="v-if v-else-if v-else条件渲染"></a><code>v-if</code> <code>v-else-if</code> <code>v-else</code>条件渲染</h2><p> <code>v-if option</code>的使用决定了这个标签是否会被销毁或者再造，即<strong>是否存在于DOM树中</strong>。如有必要还可以<strong>和<code>v-else-if</code> <code>v-else</code>紧邻配对使用</strong>。</p>
<p><strong><code>v-if option</code>只能加载一个单独的元素标签上</strong>，如果要对好多个元素标签使用条件渲染，应该把需要条件渲染的所有元素标签都放在<code>&lt;template v-if=&quot;??&quot;&gt; &lt;\template&gt;</code>标签中。</p>
<p><strong>不推荐一起使用<code>v-if</code>和<code>v-for</code>。</strong>因为当二者存在于同一个元素节点上时，<code>v-if</code>有更高的优先级，总是先测试它。因此<code>v-if</code>没有权限访问<code>v-for</code>作用域内的变量。</p>
<h2 id="v-showCSS切换"><a href="#v-showCSS切换" class="headerlink" title="v-showCSS切换"></a><code>v-show</code>CSS切换</h2><p><strong>使用了<code>v-show option</code>的元素总是会被渲染并且留在DOM中</strong>，它的作用仅仅是切换CSS property是否display。给插入的父亲标签添加一个<code>&lt;h1 style=&quot;display: none;&quot;&gt;这里是script中的template的内容&lt;/h1&gt;</code></p>
<h2 id="v-for多选素渲染"><a href="#v-for多选素渲染" class="headerlink" title="v-for多选素渲染"></a><code>v-for</code>多选素渲染</h2><p>使用<code>v-for</code>来循环渲染包含多个元素的内容，可以是遍历数组元素，也可以是遍历对象属性。</p>
<p>Vue使用v-for进行渲染的时候，<strong>默认使用就地更新(in-place patch strategy)</strong>。如果数据项的顺序改变，Vue不会移动DOM元素来匹配数据项的顺序，而是就地更新，并确保它们在每个索引位置正确渲染（因此会造成不必要的渲染）。因此，<strong>为了确保Vue正确识别节点，在使用<code>v-for</code>的时候带上<code>v-bind:key=&quot;&quot;</code>。</strong></p>
<h3 id="修饰符modifiers"><a href="#修饰符modifiers" class="headerlink" title="修饰符modifiers"></a>修饰符modifiers</h3><p><code>.lazy</code>在Change事件之后进行同步，（比如，不是在用户选中对话框且输入时就同步，而是用户光标离开对话框后再同步）</p>
<p><code>.number</code>自动将用户的输入值转为数值类型</p>
<p><code>.trim</code>自动过滤用户输入的收尾空白字符</p>
<h2 id="v-on事件监听"><a href="#v-on事件监听" class="headerlink" title="v-on事件监听"></a><code>v-on</code>事件监听</h2><p>利用<code>v-on: event-listener=&quot;&quot;</code>(short for <code>@event-listener=&quot;&quot;</code> )。</p>
<p>赋值语句后跟一个javascript简单语法（这个语句和在vue实例中执行的语句有相同的效果比如<code>@submit.prevent=&quot;newHero = &#39;Wonder Woman&#39;&quot;</code>就是可以的），或者就是在js文件的methods field中预先定义好的（带参数的）回调函数。</p>
<p>当在HTML的内联语句中需要访问原始的DOM事件时，可以将原始DOM事件利用<code>$event</code>特殊变量传入回调函数中。</p>
<p>对于一个事件的<strong>多个事件处理函数用逗号分开</strong>回调函数。</p>
<h3 id="v-on修饰符"><a href="#v-on修饰符" class="headerlink" title="v-on修饰符"></a><code>v-on</code>修饰符</h3><p>在事件处理函数中经常需要调用 <code>event.preventDefault()</code> 或者 <code>event.stopPropagation()</code>。这属于DOM细节的考虑范畴，因此通过事件修饰符将这个操作框定在html中。虽然可以在Vue的methods中去实现，但<strong>methods更多需要处理的事数据逻辑而非DOM细节</strong>。由此引入事件修饰符，<code>directive.postfix-event-modifiers</code>。</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code>在DOM中如果发生了表单提交行为，是默认会重新刷新当前网页，并且路径会变成<code>http://localhost:8080/?</code>，这意味着表单提交了，我们不希望这样的默认行为发生，因此引入了<code>v-on:submit.prevent</code>这样的修饰符，vue会阻止DOM在发生了submit事件是自动提交表单刷新页面的行为。</li>
<li><code>.capture</code></li>
<li><code>.self</code></li>
<li><code>.once</code> 点击事件只触发一次，也可以被用到component events中</li>
<li><code>.passive</code> 相当于<code>addEventListener</code>的<code>passive</code>选项，执行事件的默认行为</li>
</ul>
<p>监听键盘事件时需要检查详细按键，<code>Vue</code>允许为<code>v-on</code>在监听键盘事件时添加按键修饰符。<strong>将<code>KeyBoardEvent.key</code>中规定的任意有效按键名转换为kebab-case(短横线形式)作为按键修饰符即可。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input v-on:keyup.page-down=<span class="string">&quot;onPageDown&quot;</span>/&gt;</span><br><span class="line"><span class="comment">//处理函数只会在$event.key等于PageDown时才会被调用。</span></span><br></pre></td></tr></table></figure>
<h1 id="vue组件实例全体field约定"><a href="#vue组件实例全体field约定" class="headerlink" title="vue组件实例全体field约定"></a>vue组件实例全体field约定</h1><p>创建组件实例通过调用<code>Vue.createApp(&#123;&#125;)</code>方法来实现，通过给它添加<code>data/computed/watch/methods/lifecycle-hooks</code>这些field来描述他的数据和数据操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;)</span><br><span class="line"><span class="keyword">const</span> vm = app.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在JavaScript文件中定义的组件通过<code>const vm = app.mount(&#39;#app&#39;)</code>的mount方法挂载到对应的html中去。</p>
<p>Vue <strong>使用 <code>$</code> 前缀通过组件实例暴露自己的内置field</strong>。它还为内部 property 保留 <code>_</code> 前缀。</p>
<p>field中的所有return{}的内容都可以在挂载后的html中直接访问到，无需经过该field。</p>
<p>Vue中所有field内，<strong>this都指向当前组件实例</strong>。</p>
<h2 id="data-field约定"><a href="#data-field约定" class="headerlink" title="data field约定"></a>data field约定</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            property1: value1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>实例中的<code>data()</code>是一个function，每当新建一个实例，Vue就会调用这个函数。</p>
<p>我们需要<strong>保证所有需要用到的数据都在<code>data()</code>函数的<code>return&#123;&#125;</code>中，因为这些实例属性(instance properties)只会在instance第一次被创建的时候被Vue的响应式系统记录在<code>$data</code>对象中。</strong>如果存在一些属性你不知道他一开始要取何值，<strong>用<code>null</code> <code>undefined</code>占位</strong>。</p>
<p>访问/修改Vue实例中的data部分，可以通过两种形式的点访问法：<code>vm.$data.property1</code>或着<code>vm.property1</code>。</p>
<p>通过以上两个方式修改的vue实例的data部分都会同步到实例中去。而实例属性的变化会对应的渲染到视图UI中去，这属于响应式更新。</p>
<p>但是，只有Vue实例被创建时已经存在于数据对象中的属性才是响应式的。通过使用<code>Object.freeze(data)</code>会阻止修改data中已有的property，意味着响应系统无法再追踪变化。</p>
<h2 id="methods-field约定"><a href="#methods-field约定" class="headerlink" title="methods field约定"></a>methods field约定</h2><p>在Vue实例的<code>methods</code> field内部可以有多个方法，一般结合@[event]/@click之类的v-指令当作事件监听的回调函数使用。</p>
<p>如果method方法内部有用到任何data field中的响应式数据，那么<strong>method会自动把响应式数据作为渲染依赖项进行跟踪</strong>。</p>
<p>用<code>this</code>指向当前实例，因为Vue自动将<code>this</code>和当前实例绑定在了一起。<strong>注意不要使用箭头函数，默认情况下Vue的自动绑定this执行环境，但在箭头函数中没有指向该vue实例的this，但我们在methods中需要用到vue实例中的data function里面的数据，并且每一次使用vue实例中的数据都要在<code>this.variablename</code>。</strong></p>
<p><strong>method中的方法不应该包含异步操作？或者说不应该调用它？</strong>，异步操作应该出现在生命周期钩子中。</p>
<h2 id="computed-attribute-field约定"><a href="#computed-attribute-field约定" class="headerlink" title="computed attribute field约定"></a>computed attribute field约定</h2><p>我们<strong>使用Mustache Syntax的时候建议在花括号内仅存放简单表达式</strong>，如果花括号内的template syntax不再简明易懂，即复杂到<strong>包含了reactive data的情况下，需要使用计算属性</strong>。 </p>
<p>计算属性是Data和Methods这两个field之间的一个中间量。</p>
<p>把<strong>复杂表达式抽象成一个函数，在in-template expression中只使用这个函数名<code>&#123;&#123;complex-expression&#125;&#125;</code></strong>，在JS中添加如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123; </span><br><span class="line">    computed: &#123;</span><br><span class="line">        <span class="comment">// a computed getter</span></span><br><span class="line">        <span class="comment">// no side effects</span></span><br><span class="line">        complex-expression()&#123;</span><br><span class="line">    	<span class="comment">// `this` points to vm instance</span></span><br><span class="line">    		<span class="keyword">return</span> <span class="built_in">this</span>.????</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="computed与method比较"><a href="#computed与method比较" class="headerlink" title="computed与method比较"></a>computed与method比较</h3><p>为什么这个函数放在<code>computed option</code>中而不是<code>methods option</code>中？</p>
<ul>
<li><p><strong>计算属性的值依赖于表达式中的reactive data。</strong></p>
<p>reactive data的变化会让该计算属性的值自动更新。</p>
<p>一方面，<strong>如果reactive data没有变化，那么计算属性会一直使用上一次计算过的缓存的值。</strong></p>
<p>另一方面，如果依赖的值不是reactive data，那么计算属性的值无论如何都不会改变。</p>
<blockquote>
<p>Computed properties are <strong>cached based on their reactive dependencies.</strong></p>
<p>计算属性的值是通过基本的、简单的属性值计算而来的，这些用于计算的属性值就是这里所说的reactive dependency。</p>
</blockquote>
</li>
<li><p><strong>如果将属性计算通过方法定义，就意味着每一次Vue实例的重新渲染都会导致函数（可能是不必要的）调用。</strong></p>
</li>
</ul>
<h3 id="getter-amp-setter"><a href="#getter-amp-setter" class="headerlink" title="getter &amp; setter"></a>getter &amp; setter</h3><p>在上面的例子中通过简单的计算return一个项目的时候，我们其实是在定义一个getter。在有必要时也可以提供一个setter，修改属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    get() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    set(newValue) &#123;</span><br><span class="line">      <span class="keyword">const</span> names = newValue.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="built_in">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="built_in">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在html中用mustache syntax访问fullName会调用get()，而在javascript中调用vm.fullname=’John Doe’时就会调用set()函数。</p>
<h2 id="watch-field"><a href="#watch-field" class="headerlink" title="watch field"></a>watch field</h2><p><strong>适用于执行数据变化的异步或开销较大的操作</strong>，需要谨慎使用。</p>
<p>对于数据改变所引起的其他数据的改变，选择使用计算属性而非侦听器。</p>
<p>在watch内部定义一个接受依赖数据项作为参数的函数，当这些依赖数据项发生改变的时候，该定义在watch内的函数就会运行。这个函数可以调用methods中定义的异步函数。</p>
<h2 id="emits-field自定义事件"><a href="#emits-field自定义事件" class="headerlink" title="emits field自定义事件"></a>emits field自定义事件</h2><p>详情见组件-emit实现自底向上数据流-利用emits field自定义事件。</p>
<h2 id="refs-field获得元素引用"><a href="#refs-field获得元素引用" class="headerlink" title="refs field获得元素引用"></a>refs field获得元素引用</h2><p>相当于DOM中的getElementByXX中获取html元素的方法。只需要在vue实例的template中为组件添加<code>&lt; ref=&quot;RefName&quot;/&gt;</code>属性，双引号中即为ref名。当我们在当前实例中需要获得这个元素的时候，只需要使用<code>this.$refs.RefName</code>就可以获得元素的引用并在该元素上添加方法。</p>
<p>例如，我们为表单的input添加一个名为InputRef，并且希望在当前页面挂载的时候自动聚焦到当前页面，那么在script的mounted field中需要使用<code>mounted() &#123;this.$refs.InputRef.focus();&#125;</code>让输入文本框自动聚焦。</p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>Since <strong>components are reusable instances</strong>, they <strong>accept the same options as a root instance, such as <code>data</code>, <code>computed</code>, <code>watch</code>, <code>methods</code>, and lifecycle hooks.</strong></p>
<p>在HTML文件中被当做可以被重复利用的用户自定义元素(custom element)。</p>
<h2 id="创建自定义组件的两种方式"><a href="#创建自定义组件的两种方式" class="headerlink" title="创建自定义组件的两种方式"></a>创建自定义组件的两种方式</h2><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;) <span class="comment">//根组件 root instance</span></span><br><span class="line"></span><br><span class="line">app.component(<span class="string">&#x27;component-name&#x27;</span>, &#123;&#125;)<span class="comment">//全局自定义组件，即root instance的custom element</span></span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">&#x27;#components-demo&#x27;</span>) <span class="comment">// 挂载root instance</span></span><br></pre></td></tr></table></figure>
<p>这样子的调用默认是<strong>全局注册的组件</strong>(根实例的子实例)，<strong>可以被根实例中的template和根实例中的所有其他子组件使用。</strong></p>
<p>挂载后的root instance通过id绑定到html中去，在root instance的内部，可以像一个自定义组件custom element一样去使用用<code>.component(&#39;&#39;,&#123;&#125;)</code>定义的全局注册的组件，自定义的html标签就是传入component的第一个字符串。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>全局注册往往是不够有效率的，因为全局注册的组件意味着就算它不再被使用，它仍然会被包含在最终的构建结果中，这会造成用户下载多余的JavaScript代码。</p>
<p>可以通过一个JavaScript对象来定义组件，并在父组件的components field中用绑定使用。任何一个组件想要使用另外一个局部注册的、通过对象定义的组件，都需要把它绑定到components field中后才可以访问。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ComponentA = &#123;&#125;</span><br><span class="line"><span class="comment">// 在根组件中绑定局部注册的组件</span></span><br><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        <span class="string">&#x27;component-a&#x27;</span>: ComponentA</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在其他局部注册的子组件中绑定另一个局部注册的子组件</span></span><br><span class="line"><span class="keyword">const</span> ComponentB = &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        <span class="string">&#x27;component-a&#x27;</span>: ComponentA</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用了ES6-Babel-webpack等模块系统中的局部注册"><a href="#使用了ES6-Babel-webpack等模块系统中的局部注册" class="headerlink" title="使用了ES6/Babel/webpack等模块系统中的局部注册"></a>使用了ES6/Babel/webpack等模块系统中的局部注册</h4><p>建议把所有局部注册的组件都放置在components目录中，如果组件A的定义需要使用到同层级的组件B和组件C，需要在局部注册组件A之前导入同级别文件夹下的组件B和组件C，过程如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// current file is ComponentA.vue or ComponentA.js</span></span><br><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">&#x27;./ComponentB&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ComponentC <span class="keyword">from</span> <span class="string">&#x27;./ComponentC&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentB,</span><br><span class="line">    ComponentC</span><br><span class="line">    <span class="comment">// 注意以上写法其实是ComponentB: ComponentB的缩写</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义组件名的两种方式"><a href="#自定义组件名的两种方式" class="headerlink" title="自定义组件名的两种方式"></a>自定义组件名的两种方式</h2><h3 id="kebab-case"><a href="#kebab-case" class="headerlink" title="kebab-case"></a>kebab-case</h3><p>第一种是kebab-case，遵循W3C规范，即字母全部小写且必须包含连字符，如<code>&lt;my-component-name&gt;</code>。</p>
<h3 id="PascalCase"><a href="#PascalCase" class="headerlink" title="PascalCase"></a>PascalCase</h3><p>第二种是PascalCase，即首字母大写命名组件，如<code>&lt;MyComponentName&gt;</code>。</p>
<p><strong>直接在dom中使用自定义组件时（即非字符串的模版），只有kebab-case有效。</strong></p>
<h2 id="非prop的attribute"><a href="#非prop的attribute" class="headerlink" title="非prop的attribute"></a>非prop的attribute</h2><p>这里所说的非prop的attribute，就是那些在定义vue组件时，没有在props field和emits field中定义的attribute；也可以说是html标签自带的诸如<code>class/style/id</code>之类的属性。</p>
<h3 id="如何访问"><a href="#如何访问" class="headerlink" title="如何访问"></a>如何访问</h3><p>如何访问这些非prop的attribute？在vue组件内部调用<code>this.$attr</code>就可以访问。</p>
<h3 id="root-element的attribute-inheritance"><a href="#root-element的attribute-inheritance" class="headerlink" title="root element的attribute inheritance"></a>root element的attribute inheritance</h3><p>在js文件中定义组件时返回的是<strong>单个根节点</strong>时，在html文件中调用vue组件时定义的<strong>非prop的attribute将在vue的渲染结果中自动添加到根节点去</strong>。</p>
<p>以下是在js文件中定义组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;date-picker&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;date-picker&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;input type=&quot;datetime&quot; /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以下是在html文件中调用组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">date-picker</span> <span class="attr">data-status</span>=<span class="string">&quot;activated&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">date-picker</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以下是vue经过一系列操作的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;date-picker&quot; data-status&#x3D;&quot;activated&quot;&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;datetime&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>如果有单个根节点，绑定的非prop的attribute自动添加到渲染后的html的根节点。</p>
<p>如果有vue组件返回多个根元素，必须在定义vue组件时显式地在某个根元素上<code>v-bind: &quot;$attrs&quot;</code>。否则会有runtime warning。</p>
<h3 id="禁用attribute-inheritance"><a href="#禁用attribute-inheritance" class="headerlink" title="禁用attribute inheritance"></a>禁用attribute inheritance</h3><p>如果不希望根元素自动属性继承，需要在定义vue组件时<code>inheritAttrs：false</code>。</p>
<p>在禁用根元素的元素继承的同时，我们又希望根元素内的其他元素去继承这个非prop的attribute，如何控制？需要使用v-bind方法和当前组件的<code>$attr</code>属性，这个属性会自动包括除了vue组件内部定义的<code>prop</code> field和<code>emits</code> field内的所有属性。</p>
<p>以上两个操作都是在vue组件所在js文件中完成的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;date-picker&#x27;</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;date-picker&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;input type=&quot;datetime&quot; v-bind=&quot;$attrs&quot; /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="props实现自顶向下的数据流"><a href="#props实现自顶向下的数据流" class="headerlink" title="props实现自顶向下的数据流"></a>props实现自顶向下的数据流</h2><blockquote>
<p><strong>Props are custom attributes you can register on a component.</strong> When a value is passed to a prop attribute, it becomes a property on that component instance. </p>
</blockquote>
<p>怎么解释props的出现？就比如html的a标签有src属性，这里自定义的组件使用方式也就是html的某种标签，既然是<strong>用户自定义元素，那么应当也有用户自定义元素属性。</strong>props定义了这个自定义元素有什么属性，通过给这个属性传值，将数据从View/UI/html传递到Model/data/JavaScript。</p>
<h3 id="用字符串数组定义prop"><a href="#用字符串数组定义prop" class="headerlink" title="用字符串数组定义prop"></a>用字符串数组定义prop</h3><p>在定义组件的时候直接引入一个<code>props: []</code>选项即可。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;)</span><br><span class="line">app.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">  template: <span class="string">`&lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line">app.mount(<span class="string">&#x27;#blog-post-demo&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在html中的使用遵循如下形式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;blog-post-demo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--首先要把自定义组件包裹在mount id下的对应根组件中--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;My journey with Vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自定义组件的props可以当作元素标签的attribute使用--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;Blogging with Vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;Why Vue is so fun&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>当然，这些数据最好和View/UI/html分开存放比较好，根组件的data field可以用来存放这些数据。</p>
<p>因此，整个过程就变成了：首先，在JavaScript中定义根组件和子组件的各个field；其次，在HTML中调用JS文件中定义组件，通过已有html tag的id/class属性或者自定义的custom element attribute绑定数据，数据来自于JavaScript文件的根实例。</p>
<hr>
<h3 id="用对象列出prop"><a href="#用对象列出prop" class="headerlink" title="用对象列出prop"></a>用对象列出prop</h3><p>通常会为每个prop都指定取值类型，对象中的每一个名称和值分别时prop各自的名称和类型，如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span>,</span><br><span class="line">  isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">  commentIds: <span class="built_in">Array</span>,</span><br><span class="line">  author: <span class="built_in">Object</span>,</span><br><span class="line">  callback: <span class="built_in">Function</span>,</span><br><span class="line">  contactsPromise: <span class="built_in">Promise</span> <span class="comment">// 或任何其他构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想把一个对象的所有property都当作prop传入，使用不带参数的v-bind取代v-bind:prop-name即可，如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">post: &#123; <span class="comment">//这个对象的所有property都要传入</span></span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  title: <span class="string">&#x27;My Journey with Vue&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在html中调用如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个表达式就等价于：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;post.id&quot;</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;post.title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="prop验证"><a href="#prop验证" class="headerlink" title="prop验证"></a>prop验证</h3><p>为组件的prop指定验证的要求，比如说基础的类型检查（包括String/Number/Boolean/Array/Object/Date/Function/Symbol基本类型，以及自定义的构造函数），是否有必填的字符串，是否带默认值，自定义验证函数等功能。验证内容都是对当前prop的描述，也就是一种元数据的概念（描述数据的数据）。</p>
<p>前面提到的用对象列出prop，提供了最简单的prop类型检查，如果在props field中定义的prop名称后面跟一个花括号包裹的对象，就能实现prop验证。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 </span></span><br><span class="line">    <span class="comment">// (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;success&#x27;</span>, <span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;danger&#x27;</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意prop的验证会在组件实例创建之前进行，因此实例的data/computed等field中涉及的变量在prop验证中不能使用。</p>
<h3 id="prop书写约定"><a href="#prop书写约定" class="headerlink" title="prop书写约定"></a>prop书写约定</h3><p>因为在HTML中attribute名是大小写不敏感的，因此浏览器会把所有大写字符全部解释为小写字符，因此在JavaScript中使用的camelCase应用到HTML中就变成对应的kabab-case。</p>
<h3 id="父子组件prop的单向下行绑定"><a href="#父子组件prop的单向下行绑定" class="headerlink" title="父子组件prop的单向下行绑定"></a>父子组件prop的单向下行绑定</h3><p>这里的单项数据流是从父组件的prop流动到子组件的prop，也就是说：<strong>父级prop的更新会向下流动到子组件中</strong>，每一次父组件发生变更时，子组件的所有prop都会刷新为最新的值；<strong>子组件不应该变更父组件的状态</strong>。</p>
<blockquote>
<p>虽然子组件不应该变更父组件的状态，但也是可以实现改变的，因为JavaScript的对象和数组是通过引用传入的。</p>
<p>如果在子组件上变更对象或数组定义的prop本身，父组件的状态就会被改变，Vue也会在控制台发出警告。</p>
</blockquote>
<p>当尝试在一个子组件内部改变prop时，不要直接对props field中的原始prop进行变更，因为这个prop时从父组件中传递过来的，或者是从View/UI/html中传递过来的。</p>
<p>当需要直接利用prop中的数据时，正确的做法是在当前组件的data field中定义一个新的data property（用react中的说法也就是当前state），并用this.prop作为它的初始值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">&#x27;initialCounter&#x27;</span>],</span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="built_in">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要经过某些计算再利用prop中的数据时，正确的做法是在当前组件的computed field中定义一个新的computed property，并用this.prop经过一系列的运算后返回想要的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">&#x27;size&#x27;</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="emit实现自底向上的数据流"><a href="#emit实现自底向上的数据流" class="headerlink" title="emit实现自底向上的数据流"></a>emit实现自底向上的数据流</h2><h3 id="事件名称约定"><a href="#事件名称约定" class="headerlink" title="事件名称约定"></a>事件名称约定</h3><p>不像components和props会自动在各种书写方式之间自动转换，事件名称在js文件中被emit的时候的名称必须和在html文件中被监听的名称一致。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// my-compoennt.vue</span></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;my-event&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">my-event</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果定义的时候使用camelCase/PascalCase，在监听的时候却又使用kebab-case，是不会有效果的。</p>
<p>所以总是<strong>建议使用kebab-case来定义事件名称</strong>。</p>
<h3 id="emit作用"><a href="#emit作用" class="headerlink" title="emit作用"></a>emit作用</h3><p>emit的作用是什么？</p>
<p>在子组件上通过emit定义一个事件/注册一个事件，如果父组件/父亲页面的.vue文件中的该子组件被点击了，就可以监听该事件，然后调用event handler，并且事件处理函数可以使用父亲页面/父亲组件中的数据去处理子组件上的事件。</p>
<p>比如，html中button这个元素本身就有click事件，我们直接使用了button这个元素和click这个事件。按照vue的思考方式，在button这个组件内部定义好了button本身以及click事件。因此我们才可以在html中使用这个元素并且监听这个事件。</p>
<p>总结：emit能够在组件上自定义事件供父组件监听发生在该组件上的行为并添加回调函数，虽然组件上的自定义事件很有可能也是通过默认事件如click触发，但是emit可以放在method中中供其他method调用，比如用户点击了某个组件就出发一个窗口消失的emit事件，或用户完成登陆之后在method中自动emit一个窗口消失的事件。</p>
<h3 id="实现emit"><a href="#实现emit" class="headerlink" title="实现emit"></a>实现emit</h3><p>某个子组件与用户发生了某种交互，或者说用户给子组件传递了某些值，子组件此时需要emit an event on itself by calling the built-in <code>$emit</code> method, passing the name of the event，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;)&quot;</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然也可以把$emit(‘enlarge-text’)抽象到methods中的某个函数去，当调用这个函数的时候就有这个事件，而不必须发生click。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  close() &#123;</span><br><span class="line">    <span class="built_in">this</span>.$emit(<span class="string">&quot;enlarge-text&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而父组件可以通过v-on或者@标志来监听子组件上的任何事件，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">...</span> @<span class="attr">enlarge-text</span>=<span class="string">&quot;postFontSize += 0.1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">...</span> @<span class="attr">enlarge-text</span>=<span class="string">&quot;onEnlargeText&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>事件发生在子组件上，但是这个事件通过v-on/@标志被传递到了父组件上，且回调函数却是由父组件定义的，或者可以直接用methods field中定义的函数。</p>
<hr>
<p>在定义子组件的时候提供emits选项，方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">  emits: [<span class="string">&#x27;enlarge-text&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="emit-an-event’s-value"><a href="#emit-an-event’s-value" class="headerlink" title="emit an event’s value"></a>emit an event’s value</h3><p>有时候需要在子组件中emit一个定义在父组件上的事件，并向父组件传递一个参数，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;, 0.1)&quot;</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在父组件中，可以通过<code>$event</code>访问到这个event value。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">...</span> @<span class="attr">enlarge-text</span>=<span class="string">&quot;postFontSize += $event&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="利用emits-field自定义事件"><a href="#利用emits-field自定义事件" class="headerlink" title="利用emits field自定义事件"></a>利用emits field自定义事件</h3><p>在定义组件的时候在<code>emits</code> field中用数组或者对象的形式定义custom events，只要出现在emits field中，就是自定义事件。custom event会覆盖native event。</p>
<p>建议所有的emitted event都定义在emits field中。</p>
<h4 id="array-syntax-not-recommended"><a href="#array-syntax-not-recommended" class="headerlink" title="array syntax(not recommended)"></a>array syntax(not recommended)</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;custom-form&#x27;</span>, &#123;</span><br><span class="line">  emits: [<span class="string">&#x27;in-focus&#x27;</span>, <span class="string">&#x27;submit&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="obejct-syntax-to-validate"><a href="#obejct-syntax-to-validate" class="headerlink" title="obejct syntax to validate"></a>obejct syntax to validate</h4><p>通过数组array syntax定义的事件不能被validate，因此建议使用对象object syntax。</p>
<p>event name在object中就变成了key，对应value是一个验证函数，该函数接受传递给$emit call的payload作为参数，对参数进行操作后返回boolean值去验证这个事件是有效还是无效的。如果不希望event有验证，直接讲key对应value取null。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;custom-form&#x27;</span>, &#123;</span><br><span class="line">  emits: &#123;</span><br><span class="line">    <span class="comment">// No validation</span></span><br><span class="line">    click: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate submit event</span></span><br><span class="line">    submit: <span class="function">(<span class="params">&#123; email, password &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (email &amp;&amp; password) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;Invalid submit event payload!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    submitForm() &#123;</span><br><span class="line">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;submit&#x27;</span>, &#123; email, password &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="插槽slots"><a href="#插槽slots" class="headerlink" title="插槽slots"></a>插槽slots</h1><p>插槽就是在js文件中定义vue组件的template field中插入的一个标志元素，形如<code>&lt;slot&gt;&lt;/slot&gt;</code>。当在html文件中调用该vue组件时，直接在vue组件开闭合标签内添加想要插入的内容，该内容就会替代原js template中的插槽。</p>
<blockquote>
<p>注意如果希望不是用插槽，那么调用vue组件的开闭合标签内不能有任何文字，甚至是comment也不行。</p>
</blockquote>
<p>插槽也能够在指定渲染域中访问数据，该渲染域是和它在同一DOM树层级的兄弟节点，也就是说插槽不能访问父亲节点中的数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">todo-button</span> <span class="attr">action</span>=<span class="string">&quot;delete&quot;</span>&gt;</span></span><br><span class="line">  Clicking here will &#123;&#123; action &#125;&#125; an item</span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  The `action` will be undefined, because this content is passed</span></span><br><span class="line"><span class="comment">  _to_ &lt;todo-button&gt;, rather than defined _inside_ the</span></span><br><span class="line"><span class="comment">  &lt;todo-button&gt; component.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">todo-button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之前讨论的插槽标签之间都是空内容的，有时候为一个插槽提供后备内容fallback content也很有用，该内容会在html文件调用该组件没有传入内容时被渲染。<code>&lt;slot&gt;Submit&lt;/slot&gt;</code>这个时候Submit就是后备内容。</p>
<p>当需要多个插槽的时候，需要在js文件中定义组件时给每一个插槽一个name attribute，形如<code>&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</code>，一个不带有name的插槽隐含的名字就是<code>default</code>。</p>
<p>为了在html文件中调用该组件并为特定的插槽提供特定的内容，将想要提供的内容包裹在<code>&lt;template&gt;</code>元素中。给该<code>&lt;template&gt;</code>元素一个<code>v-slot:header</code>指令，冒号后面就是name attribute的取值；或者直接在#hash符号后面跟上插槽的名字。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="teleport"><a href="#teleport" class="headerlink" title="teleport"></a>teleport</h1><p>teleport用于解决逻辑与视图不一致的情况。比如在当前组件中存在一个子组件，虽然该子组件的数据逻辑归属于当前组件，但是UI视图并不从属于当前视图。那么就需要在当前组件的template中将该子组件用<code>&lt;teleport&gt;</code> 标签包裹，并在<code>&lt;teleport to=&quot;&quot;&gt;</code>中选择html元素，指定该子组件在DOM树中的位置。</p>
<p>比如网站首页点击登陆之后会弹出登陆信息框，虽然登陆的信息由首页的导航栏维护，但是在视图层面并不属于导航栏这个vue实例，而是属于body元素的子元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;AppHeader :isLoggedIn&#x3D;&quot;isLoggedIn&quot; @open-login-model&#x3D;&quot;isLoginOpen &#x3D; true&quot; &#x2F;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;w-full flex&quot;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;teleport to&#x3D;&quot;body&quot;&gt;</span><br><span class="line">    &lt;LoginModel v-if&#x3D;&quot;isLoginOpen&quot; @close-login&#x3D;&quot;isLoginOpen &#x3D; false&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;teleport&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h1>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2020/11/21/learn-js/</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量就是一个用来存储数据类型的容器。</p>
<h2 id="声明var-amp-let"><a href="#声明var-amp-let" class="headerlink" title="声明var&amp;let"></a>声明<code>var</code>&amp;<code>let</code></h2><p><code>var</code>会被变量提升，但是<code>let</code>没有。因此使用<code>var</code>时，可以根据需要多次声明相同名称的变量，但是<code>let</code>不能。</p>
<h2 id="声明的意义"><a href="#声明的意义" class="headerlink" title="声明的意义"></a>声明的意义</h2><p>声明但不初始化变量就相当于让容器存在于执行环境中，但里面是“空”的，什么也不放，因而在控制台会返回undefined。</p>
<p>没有声明也没有初始化的变量相当于执行环境中没有该变量，不存在容器，因而控制台直接会返回报错信息。</p>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ul>
<li>Number</li>
</ul>
<p>数值的数据分类有哪些，基本运算符有哪些，变量自增自减在控制台中的表现。</p>
<ul>
<li>String需要单引号或者双引号包围</li>
</ul>
<p>字符串中转义字符的使用：<code>\&#39;</code> </p>
<p>字符串拼接：<code>myString1+myString2</code> </p>
<p>利用字符串长度索引：<code>myString1[0]</code>&amp;<code>string1[string1.length-1]</code> </p>
<p>查找子串： <code>myString1.indexOf(&#39;mySubstring1&#39;)</code></p>
<p>切割子串： <code>myString1.slice(i,j)</code>第二个参数可选，如果没有传入那么一直切割到末尾，不会改变<code>myString1</code></p>
<p>替换子串：<code>myString1.replace(&#39;mySubstring1&#39;, &#39;mySubstring2&#39;)</code>，返回更新后的字符串。</p>
<blockquote>
<p>如果要用新的字符串替换原来的字符串，一定不可以只有<code>newStory.replace(&#39;130&#39;, pound);</code>，这对原字符串并不会有任何影响，一定要<code>newStory = newStory.replace(&#39;130&#39;, pound);</code>才会修改原字符串。</p>
</blockquote>
<p>大小写：<code>myString1.toLowerCase()/toUpperCase()</code></p>
<hr>
<p>Number &amp; String类型互相转换</p>
<p>Number(myString)可以将String类型转换为Number类型</p>
<p>myNum.toString()可以讲Number类型转换为String类型</p>
<hr>
<ul>
<li><p>Boolean可以取值true/false</p>
</li>
<li><p>Array是单个对象，用方括号包含很多元素，元素之间用逗号分隔，元素索引从0开始。</p>
</li>
</ul>
<p>获取长度：<code>sequence.length</code></p>
<p>添加末尾元素：<code>let length = sequence.push(element1)</code>返回新数组的长度</p>
<p>删除末尾元素：<code>let removedItem = sequence.pop()</code>返回已删除的项目</p>
<p>添加头部元素：<code>let length = sequence.unshift(element1)</code></p>
<p>删除头部元素：<code>let removedItem = sequence.shift()</code>返回已删除的项目</p>
<hr>
<p>Array &amp; String类型互相转换</p>
<p>当String中存在重复出现的分隔符时，可以将String分成许多元素放入Array中，如<code>let myArray = myString.split(&#39;,&#39;);</code></p>
<p>当Array中的元素想通过某种方式连接起来变成String时，可以使用<code>let myString = myArray.join(&#39;,&#39;);</code>，也可以使用<code>let myString = myArray.toString();</code>。二者区别是join可以指定分隔符。</p>
<hr>
<ul>
<li>Object</li>
</ul>
<p>JavaScript时一种动态类型语言，不需要人为指定变量包含什么类型的数据。你赋什么类型的值，变量就会是什么类型。可以利用<code>typeof</code>操作符检查传递给改操作符的变量的数据类型。</p>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="for-loop"><a href="#for-loop" class="headerlink" title="for-loop"></a><code>for-loop</code></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (initializer; exit-condition; final-expression) &#123;</span><br><span class="line">  <span class="comment">// code to run</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="while-loop"><a href="#while-loop" class="headerlink" title="while loop"></a><code>while loop</code></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">initializer</span><br><span class="line"><span class="keyword">while</span> (exit-condition) &#123;</span><br><span class="line">  <span class="comment">// code to run</span></span><br><span class="line"></span><br><span class="line">  final-expression</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="do-while-loop"><a href="#do-while-loop" class="headerlink" title="do-while loop"></a><code>do-while loop</code></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">initializer</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// code to run</span></span><br><span class="line"></span><br><span class="line">  final-expression</span><br><span class="line">&#125; <span class="keyword">while</span> (exit-condition)</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是对象方法的一部分。</p>
<p>内置浏览器函数基于浏览器API，并不是核心JavaScript语言的一部分，他们是方法。方法是在对象哪定义的函数，浏览器内置函数（方法）和变量（属性）储存在结构化对象里，使得代码管理更高效，易于处理。</p>
<h2 id="声明与调用"><a href="#声明与调用" class="headerlink" title="声明与调用"></a>声明与调用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="comment">//声明</span></span><br><span class="line">myFunction()<span class="comment">//调用</span></span><br></pre></td></tr></table></figure>
<p>怎么样才算调用一个函数呢？函数名后面的括号叫做函数调用运算符(function invocation operator)。</p>
<p>注意以下两种写法。</p>
<p><code>btn.onclick = displayMessage;</code>的意思是当按钮被点击就运行该名称的函数。</p>
<p><code>btn.onclick = displayMessage();</code>的意思是不需要点击按钮该函数就会被调用。</p>
<p>为了改变第二种结果，最适合的写法应该是将要调用的函数包裹在匿名函数中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  displayMessage();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>一个没有名称的函数就是匿名函数，它本身不会做任何事情，一般将匿名函数和事件处理程序一起使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myButton.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以把匿名函数分配为多个变量值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myGreeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">myGreeting()<span class="comment">//调用</span></span><br></pre></td></tr></table></figure>
<p>匿名函数也叫匿名表达式。函数声明会declaration hoisting，而函数表达式不会。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>参数值放在函数括号内，可以叫做参数arguments，也被叫做属性properties/attributes。</p>
<h2 id="函数作用域scope和冲突"><a href="#函数作用域scope和冲突" class="headerlink" title="函数作用域scope和冲突"></a>函数作用域scope和冲突</h2><p>所有函数的最外层被称为全局作用域。 在全局作用域内定义的值可以在任意地方访问。</p>
<p>当你创建一个函数时，函数内定义的变量和其他东西都在它们自己的单独的范围内, 意味着它们被锁在自己独立的隔间中, 不能被函数外的代码访问。</p>
<p>参数的存在就相当于把属于一个作用域的变量传递另一个作用域。</p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>一些没有返回值的函数调用后在控制台输出就是空值void或未定义值undefined。</p>
<p>通常函数返回值是用作中间步骤的计算结果，该结果可以用于计算的下一阶段。</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>每个可用的事件都会有一个<strong>事件处理器</strong>，也就是事件触发时会运行的代码块。当我们定义了一个用来回应事件被激发的代码块的时候，我们说我们<strong>注册了一个事件处理器</strong>。</p>
<p>监听器留意事件是否发生，然后处理器就是对事件发生做出的回应。</p>
<h2 id="响应网页事件的几种机制"><a href="#响应网页事件的几种机制" class="headerlink" title="响应网页事件的几种机制"></a>响应网页事件的几种机制</h2><h3 id="事件处理器属性"><a href="#事件处理器属性" class="headerlink" title="事件处理器属性"></a>事件处理器属性</h3><p>比如对于几乎所有HTML元素，都有<code>onclick</code>属性，和其他<code>.style,.textContent</code>一样。</p>
<h3 id="行内事件处理器-不要使用"><a href="#行内事件处理器-不要使用" class="headerlink" title="行内事件处理器-不要使用"></a>行内事件处理器-不要使用</h3><p>也叫事件处理程序HTML属性，会混用HTML和JavaScript。</p>
<h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a>addEventListener()</h3><p>定义在DOM Level2 Events中的函数addEventListener()，接受两个参数。第一个参数是我们想要将处理器函数应用上去的时间名称，第二个是用来回应事件的函数，可以是一个匿名函数。</p>
<p>相较于事件处理器属性被覆盖，addEventListener()可以实现一个监听器注册多个处理器。</p>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>有时候在处理函数内部，可一个固定指定名称的参数，如<code>event,evt,e</code>，这是事件对象，它被自动传递给事件处理函数。</p>
<p>事件对象 <code>e</code> 的<code>target</code>属性始终是事件刚刚发生的元素的引用。</p>
<h2 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h2><p>自定义注册表单。，当你填写详细信息并按提交按钮时，自然行为by default是将数据提交到服务器上的指定页面进行处理，并将浏览器重定向到某种“成功消息”页面（或 相同的页面，如果另一个没有指定。）</p>
<p>但是当用户提交的数据并不正确时，开发人员希望停止提交信息到服务器，并给用户错误提示，需要在事件对象上调用<code>preventDefault()</code>函数，这样就停止了表单提交。</p>
<h2 id="事件冒泡及捕获"><a href="#事件冒泡及捕获" class="headerlink" title="事件冒泡及捕获"></a>事件冒泡及捕获</h2><p>事件冒泡和捕捉是两种机制，主要描述当在一个元素上有两个相同类型的事件处理器被激活会发生什么。</p>
<p>当一个事件发生在具有父元素的元素上时，现代浏览器运行两个不同的阶段：捕获阶段和冒泡阶段。</p>
<p>在现代浏览器中，默认情况下，所有事件处理程序都在冒泡阶段进行注册。</p>
<h3 id="捕获阶段："><a href="#捕获阶段：" class="headerlink" title="捕获阶段："></a>捕获阶段：</h3><ul>
<li>浏览器检查元素的最外层祖先<code>&lt;html&gt;</code>，是否在捕获阶段中注册了一个<code>onclick</code>事件处理程序，如果是，则运行它。</li>
<li>然后，它移动到<code>&lt;html&gt;</code>中单击元素的下一个祖先元素，并执行相同的操作，然后是单击元素再下一个祖先元素，依此类推，直到到达实际点击的元素。</li>
</ul>
<h3 id="冒泡阶段："><a href="#冒泡阶段：" class="headerlink" title="冒泡阶段："></a>冒泡阶段：</h3><ul>
<li>浏览器检查实际点击的元素是否在冒泡阶段中注册了一个<code>onclick</code>事件处理程序，如果是，则运行它</li>
<li>然后它移动到下一个直接的祖先元素，并做同样的事情，然后是下一个，等等，直到它到达<code>&lt;html&gt;</code>元素。</li>
</ul>
<h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p>标准事件对象具有可用的名为 <code>stopPropagation()</code>的函数，当在事件对象上调用该函数时，它只会让当前事件处理程序运行，但事件不会在<strong>冒泡</strong>链上进一步扩大，因此将不会有更多事件处理器被运行(不会向上冒泡)。</p>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><blockquote>
<p>Event delegation allows you to avoid adding event listeners to specific nodes;  instead, the event listener is added to one parent.  That event listener analyzes bubbled events to find a match on child elements.</p>
</blockquote>
<p>check the event object’s target property to gain a reference to the actual clicked node.</p>
<p>虽然事件处理函数添加在父元素上，但通过if语句对事件对象进行条件判断，可以访问父元素及其内部子元素，从而实现特定的相应操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(e.target &amp;&amp; e.target.nodeName == <span class="string">&quot;LI&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>Using the <a href="https://davidwalsh.name/element-matches-selector">Element.matches API</a>, we can see if the element matches our desired target.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.target &amp;&amp; e.target.matches(<span class="string">&quot;a.classA&quot;</span>)) </span><br></pre></td></tr></table></figure>
<p><a href="https://davidwalsh.name/event-delegate">参考</a></p>
<h2 id="一些实作的易错点"><a href="#一些实作的易错点" class="headerlink" title="一些实作的易错点"></a>一些实作的易错点</h2><p>关于单引号的双引号的区分。规定自己对于html元素名称或者属性的引用都使用单引号，但对字符串统一使用双引号。如<code>if(btn.getAttribute(&#39;class&#39;) === &quot;dark&quot;)</code>。</p>
<p>对属性赋值都是赋值字符串，如<code>overlay.style.backgroundColor = &quot;rgba(0, 0, 0, 0.5)&quot;;</code>，如果rgba没有加双引号，那最后javascript编译器会把它当作一个函数，从而报错。</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>对象是一个包含相关数据和方法的集合（通常由一些变量和函数组成，我们称之为对象里面的属性和方法）。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>对象包（object package，或者叫命名空间 namespace）存储（官方用语：<strong>封装</strong>）着对象的数据（常常还包括函数），使数据的组织和访问变得更容易了；对象也常用作数据存储体（data stores），用于在网络上运输数据，十分便捷 —— 也就是JSON(JavaScript对象表示法)。</p>
<h2 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h2><p>一个对象由许多的成员组成，每一个成员都拥有一个名字（像上面的name、age），和一个值（如[‘Bob’, ‘Smith’]、32）。每一个名字/值（name/value）对被逗号分隔开，并且名字和值之间由冒号（:）分隔。</p>
<p>对象成员的值可以是任意的，可以是字符串(string)，数字(number)，数组(array)，函数(function)。前三种属于资料项目，被称为对象的属性(property)；最后一个函数，允许对象对资料做一些操作，被称为对象的方法(method)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objectName = &#123;</span><br><span class="line">  member1Name : member1Value,</span><br><span class="line">  member2Name : member2Value,</span><br><span class="line">  member3Name : member3Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个如上所示的对象被称之为对象的字面量(literal)——手动的写出对象的内容来创建一个对象。</p>
<h2 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h2><h3 id="点表示法"><a href="#点表示法" class="headerlink" title="点表示法"></a>点表示法</h3><p>使用点表示法(dot notation)来访问对象的属性和方法。</p>
<p>对象的名字表现为一个命名空间(namespace)，它必须写在第一位。</p>
<blockquote>
<p>子命名空间</p>
<p>可以用一个对象来做另一个对象成员的值。访问对象内的对象成员就相当于要用两次点表示法。</p>
</blockquote>
<p>紧接着是你想要访问的项目，标识可以是简单属性的名字，或者是数组属性的一个子元素，又或者是对象的方法调用。</p>
<h3 id="括号表示法"><a href="#括号表示法" class="headerlink" title="括号表示法"></a>括号表示法</h3><p>另外一种访问属性的方式是使用括号表示法(bracket notation)，例如<code>person[&#39;age&#39;]</code>。</p>
<p>对象有时被称之为关联数组(associative array)了——对象做了字符串到值的映射，而数组做的是数字到值的映射。</p>
<h3 id="括号表示法与点表示法的区别"><a href="#括号表示法与点表示法的区别" class="headerlink" title="括号表示法与点表示法的区别"></a>括号表示法与点表示法的区别</h3><p>括号表示法能接受一个变量作为成员名字；点表示法只能接受字面量的成员的名字，不接受变量作为名字。</p>
<h2 id="设置成员对象"><a href="#设置成员对象" class="headerlink" title="设置成员对象"></a>设置成员对象</h2><p>既可以对已有的成员的值进行改变，也可以创建新的成员并赋值。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a><code>this</code></h2><p>关键字”this”指向了当前代码运行时的对象( 原文：the current object the code is being written inside )，它保证了当代码的上下文(context)改变时变量的值的正确性。</p>
<p>在字面量的对象里this看起来不是很有用，但是当你动态创建一个对象（例如使用构造器）时它是非常有用的。</p>
<h2 id="对象与类的关系"><a href="#对象与类的关系" class="headerlink" title="对象与类的关系"></a>对象与类的关系</h2><p>用类（class）的概念去描述一个对象。</p>
<p>类并不完全是一个对象，它更像是一个定义对象特质的模板。 我们能够基于类创建出一些拥有class中属性及方法的对象。</p>
<p>当一个对象需要从类中创建出来时，类的<strong>构造函数</strong>就会运行来创建这个实例。</p>
<h2 id="创建对象的方式总结"><a href="#创建对象的方式总结" class="headerlink" title="创建对象的方式总结"></a>创建对象的方式总结</h2><h3 id="声明一个对象去创建对象"><a href="#声明一个对象去创建对象" class="headerlink" title="声明一个对象去创建对象"></a>声明一个对象去创建对象</h3><h3 id="使用构造函数创建对象"><a href="#使用构造函数创建对象" class="headerlink" title="使用构造函数创建对象"></a>使用构造函数创建对象</h3><h3 id="使用Object-构造函数创建对象"><a href="#使用Object-构造函数创建对象" class="headerlink" title="使用Object()构造函数创建对象"></a>使用<code>Object()</code>构造函数创建对象</h3><p>首先使用<code>var person1 = new Object();</code>创建一个空的对象。</p>
<p>其次根据需要使用点或括号表示法向此对象添加属性和方法。</p>
<hr>
<p>也可以将对象文本传递给<code>Object()</code>构造函数作为参数。<code>var person1 = new Object(&#123;name: &#39;Chris&#39;, age: 38, greeting: function()&#123;&#125; &#125;);</code>。</p>
<h3 id="基于现有对象创建新对象"><a href="#基于现有对象创建新对象" class="headerlink" title="基于现有对象创建新对象"></a>基于现有对象创建新对象</h3><p>使用<code>Object2.create(Object1)</code>，基于现有对象创建新的对象， 它们具有相同的属性和方法。</p>
<p>结合原谅来看，这个函数做的就是从指定原型对象<code>Object1</code>创建一个新的对象<code>Object2</code>，在控制台输入<code>Object2.__prooto__</code>返回的就是对象<code>Object1</code>。</p>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>JavaScript 常被描述为一种<strong>基于原型的语言 (prototype-based language)</strong>。</p>
<p>每个对象拥有一个<strong>原型对象</strong>，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为<strong>原型链 (prototype chain)</strong>，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p>
<h2 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a><code>prototype</code>属性</h2><p>如果某一对象把属性定义在<code>prototype</code>属性之中，那就意味着这个对象允许其他对象继承这些方法。也就是说该对象可继承的内容都放在了该对象的<code>prototype</code>这个子命名空间中，其实这个子命名空间也是一个对象。</p>
<p>其他不位于<code>prototype</code> 对象内的成员，不会被“对象实例”或“继承自 <code>Object()</code> 的对象类型”所继承。这些方法/属性仅能被 <code>Object()</code> 构造器自身使用。</p>
<h2 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a><code>constructor</code>属性</h2><p>每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。</p>
<p>某个对象的<code>constructor</code>属性可以告诉我们该对象从什么对象继承而来。可以获取作为构造器的对象的属性。</p>
<p>在对象的<code>constructor</code>属性末尾添加一对圆括号（括号中包含所需的参数），并在前面添加 <code>new</code> 关键字，从而用这个构造器创建另一个对象实例。</p>
<h2 id="原型存在的意义"><a href="#原型存在的意义" class="headerlink" title="原型存在的意义"></a>原型存在的意义</h2><p>如果某个对象的原型更新了方法，该对象可以通过上溯圆形链调用原型的方法，而不必把上游对象的方法复制到该对象中。</p>
<h2 id="利用原型定义对象"><a href="#利用原型定义对象" class="headerlink" title="利用原型定义对象"></a>利用原型定义对象</h2><p>一种极其常见的对象定义模式是，在构造器（函数体）中定义属性、在 <code>prototype</code> 属性上定义方法（也就是将方法都放在构造器的<code>prototype</code> 属性中）。如此，构造器只包含属性定义，而方法则分装在不同的代码块，代码更具可读性。</p>
<h2 id="实际操作中的一些问题"><a href="#实际操作中的一些问题" class="headerlink" title="实际操作中的一些问题"></a>实际操作中的一些问题</h2><p>实现继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params">x, y, velX, velY, exist</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 将属性值当作构造函数的参数传入，使用this指向对象</span></span><br><span class="line">    <span class="comment">// 注意对象要大写</span></span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">    <span class="built_in">this</span>.velX = velX;</span><br><span class="line">    <span class="built_in">this</span>.velY = velY;</span><br><span class="line">    <span class="built_in">this</span>.exist = exist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ball</span>(<span class="params">x, y, velX, velY, exist, size, color</span>)</span>&#123;</span><br><span class="line">  Shape.call(<span class="built_in">this</span>, x, y, velX, velY, exist); </span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="comment">// 需要注意的是传入call函数的参数一定也要出现在构造函数的参数中</span></span><br><span class="line">  <span class="built_in">this</span>.size = size;</span><br><span class="line">  <span class="built_in">this</span>.color = color;</span><br><span class="line">  <span class="built_in">this</span>.exist = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数的参数与确定属性值的关系</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EvilCircle</span>(<span class="params"> x, y,exist, color, size</span>)</span>&#123;</span><br><span class="line">  Shape.call(<span class="built_in">this</span>, x, y, exist);</span><br><span class="line">  <span class="built_in">this</span>.color = color;</span><br><span class="line">  <span class="built_in">this</span>.size = size;</span><br><span class="line">  <span class="built_in">this</span>.velX = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">this</span>.velY = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">// 这里确定值的velX和velY就没有作为参数传入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数和原型之间的关系</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是构造函数，需要大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ball</span>(<span class="params">x, y, velX, velY, exist, size, color</span>)</span>&#123;</span><br><span class="line">  Shape.call(<span class="built_in">this</span>, x, y, velX, velY, exist); </span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="comment">// 需要注意的是传入call函数的参数一定也要出现在构造函数的参数中</span></span><br><span class="line">  <span class="built_in">this</span>.size = size;</span><br><span class="line">  <span class="built_in">this</span>.color = color;</span><br><span class="line">  <span class="built_in">this</span>.exist = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是原型对象，用于定义方法，可以通过this访问构造函数的属性</span></span><br><span class="line">Ball.prototype.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.fillStyle = <span class="built_in">this</span>.color;</span><br><span class="line">  ctx.arc(<span class="built_in">this</span>.x, <span class="built_in">this</span>.y, <span class="built_in">this</span>.size, <span class="number">0</span>, <span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line">  ctx.fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><p>一个线程是一个基本的处理过程，程序用它来完成任务。每个线程一次只能执行一个任务。</p>
<p>JavaScript 传统上是单线程的。即使有多个内核，也只能在单一线程上运行多个任务，此线程称为主线程（<strong>main thread</strong>）。</p>
<h2 id="Web-workers"><a href="#Web-workers" class="headerlink" title="Web workers"></a>Web workers</h2><p>借助web workers把一些任务交给一个名为worker的单独的线程。一般来说，用一个worker来运行一个耗时的任务，主线程就可以处理用户的交互（避免了阻塞）。</p>
<h2 id="异步callbacks"><a href="#异步callbacks" class="headerlink" title="异步callbacks"></a>异步callbacks</h2><p><strong>异步callbacks函数</strong>只不过是作为<strong>参数</strong>传递给那些在后台执行的<strong>其他函数</strong>。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>涉及两个函数，他们的关系是函数和参数，回调函数和调用回调函数的函数（包含函数）。</p>
<p>当我们把<strong>回调函数作为一个参数传递给另一个函数</strong>时，仅仅是把<strong>回调函数定义作为参数传递</strong>过去——回调函数并没有立刻执行，回调函数会在包含它的函数的某个地方异步执行，<strong>包含函数负责在合适的时候（例如触发了某个事件）执行回调函数</strong>。</p>
<p><code>addEventListener()</code>的第二个参数就是异步callback函数。第一个参数是侦听的事件类型，第二个就是事件发生时调用的回调函数。</p>
<h3 id="回调函数和异步的关系"><a href="#回调函数和异步的关系" class="headerlink" title="回调函数和异步的关系"></a>回调函数和异步的关系</h3><p>不是所有的回调函数都是异步的。</p>
<p>当遍历数组时使用的<code>Array.prototype.forEach()</code>函数需要的参数就是一个回调函数，它无需等待立刻运行。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>回调地狱与每层嵌套都需要调用一个失败回调。</p>
<h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a><code>Promises</code></h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><h4 id="创建最初的promise"><a href="#创建最初的promise" class="headerlink" title="创建最初的promise"></a>创建最初的promise</h4><p>首先，为<code>fectch()</code>传入网络资源的URL作为参数。该函数返回一个<code>promise</code>对象，代表了异步操作完成或失败的对象。</p>
<hr>
<p>这个最初既不成功也不失败的中间状态下的promise的官方术语叫作<strong>pending</strong>。</p>
<hr>
<h4 id="返回promise"><a href="#返回promise" class="headerlink" title="返回promise"></a>返回promise</h4><p>其次，使用<code>then()</code>块，传入回调函数作为参数。如果前一个操作成功，该函数将运行，并且<strong>每个回调都接收前一个成功操作的结果作为输入</strong>，因此您可以继续对它执行其他操作。</p>
<p>每个<code>.then()</code>块返回另一个promise，这意味着可以将多个<code>.then()</code>块链接到另一个块上，这样就可以依次执行多个异步操作。</p>
<p>如果任何一个<code>.then()</code>块返回失败，就运行末尾的<code>catch()</code>块，也是传入一个回调函数作为参数，提供了一个错误对象，可用来报告发生的错误类型。</p>
<hr>
<p>当promise返回时，称为 <strong>resolved</strong>（已解决）.</p>
<ol>
<li>一个成功<strong>resolved</strong>的promise称为<strong>fullfilled</strong>（<strong>实现</strong>）。它返回一个值，可以通过将<code>.then()</code>块链接到promise链的末尾来访问该值。<code>.then()</code>块中的执行程序函数将包含promise的返回值。</li>
<li>一个不成功<strong>resolved</strong>的promise被称为<strong>rejected</strong>（<strong>拒绝</strong>）了。它返回一个原因（<strong>reason</strong>），一条错误消息，说明为什么拒绝promise。可以通过将<code>.catch()</code>块链接到promise链的末尾来访问此原因。</li>
</ol>
<hr>
<h3 id="promise完成后运行一段代码"><a href="#promise完成后运行一段代码" class="headerlink" title="promise完成后运行一段代码"></a>promise完成后运行一段代码</h3><p>在promise完成后，你可能希望运行最后一段代码，无论它是否已实现（fullfilled）或被拒绝（rejected）。</p>
<h3 id="then-块与AddEventListener"><a href="#then-块与AddEventListener" class="headerlink" title=".then()块与AddEventListener()"></a><code>.then()</code>块与<code>AddEventListener()</code></h3><p><code>.then()</code>块的工作方式类似于使用<code>AddEventListener()</code>向对象添加事件侦听器时的方式。</p>
<blockquote>
<p>最显着的区别是<code>.then()</code>每次使用时只运行一次，而事件监听器可以多次调用。</p>
</blockquote>
<h3 id="流程合并"><a href="#流程合并" class="headerlink" title="流程合并"></a>流程合并</h3><p>请记住，履行的promise所返回的值将成为传递给下一个 <code>.then()</code> 块的executor函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> response.blob())</span><br><span class="line">.then(<span class="function"><span class="params">myBlob</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + e.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="多个promise协同工作"><a href="#多个promise协同工作" class="headerlink" title="多个promise协同工作"></a>多个promise协同工作</h3><p><code>Promise.all()</code>函数将一个promises数组，也就是多个pending，作为输入参数，并返回一个新的Promise对象，只有当数组中的所有promise都满足时才会满足。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([a, b, c]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>只要一个被拒绝了，该函数整体就不会返回promise。需要逐个检查promise返回了什么。</p>
<h3 id="自定义Promise"><a href="#自定义Promise" class="headerlink" title="自定义Promise"></a>自定义Promise</h3><p>使用<code>Promise()</code>构造函数构建自己的promise。</p>
<p><code>resolve()</code>和<code>reject()</code>是用来<strong>实现</strong>和<strong>拒绝</strong>新创建的promise的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timeoutPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve();<span class="comment">//这个函数表明了调用该promise成功后，作为参数传递给后面的then块的值</span></span><br><span class="line">    reject();<span class="comment">//这个函数表明了调用该promise失败后，作为参数传递给最后的catch块的值，一般是要和条件判断一起写的。</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 上面的写法也可以写成一个函数，函数返回的return是new Promise</span></span><br></pre></td></tr></table></figure>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>这两个关键字async/await是基于promises的语法糖，使异步代码更易于编写和阅读。</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>在函数声明前使用<code>async</code>关键字，使该函数称为异步函数。函数声明，函数表达式，箭头函数都可以。</p>
<p>例如，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;; <span class="comment">//异步函数</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;; <span class="comment">// 异步函数表达式</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="keyword">async</span> () =&gt; &#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;; <span class="comment">//箭头函数</span></span><br></pre></td></tr></table></figure>
<p>异步函数是一个知道怎么使用<code>await</code>关键字调用异步代码的函数。调用异步函数会返回一个<code>promise</code>。</p>
<h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>await关键字与异步函数一起使用，且 <strong>await只在异步函数里面才起作用</strong>。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>可以在调用任何返回Promise的函数前使用 <strong>await</strong>，包括Web API函数，然后将这个返回的量赋值到一个变量去。</p>
<h4 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h4><p>await作为 <code>.then()</code> 代码块的替代存在，可以让我们用更少的<code>.then()</code>。这让代码的形式看起来更像同步代码，能够将结果返回到中间变量去，而不是像链条一样把一个输出连到另一个的输入。</p>
<p>await关键字使JavaScript运行时暂停于此行，允许其他代码在此期间执行，直到异步函数调用返回其结果。一旦完成，您的代码将继续从下一行开始执行。</p>
<h2 id="超时和间隔"><a href="#超时和间隔" class="headerlink" title="超时和间隔"></a>超时和间隔</h2><p>以下介绍的三个异步函数都是在主线程上运行的。在给定的时间间隔之前和重复调用之间可以在主线程上运行其他代码。</p>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a><code>setTimeout()</code></h3><p>在指定的时间后执行一段代码。</p>
<h4 id="传入参数"><a href="#传入参数" class="headerlink" title="传入参数"></a>传入参数</h4><ul>
<li>回调函数/函数引用</li>
<li>以毫秒为单位的时间间隔：如果指定为0，函数将尽快运行，而不是立即运行。因为需要主线程的堆栈为空才能运行回调函数</li>
<li>希望传递给回调函数的参数值，在参数列表后面添加即可。</li>
</ul>
<h4 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h4><p><code>setTimeout()</code> 返回一个标志符变量用来引用这个间隔。取消该超时任务使用函数<code>clearTimeout(setTimeout(params))</code>。</p>
<h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a><code>setInterval()</code></h3><p>以固定的时间间隔重复运行一段代码，例如动画。这与<code>setTimeout()</code>的工作方式非常相似。</p>
<h4 id="传入参数-1"><a href="#传入参数-1" class="headerlink" title="传入参数"></a>传入参数</h4><p>作为第一个参数传递给它的函数，<strong>重复</strong>执行的时间不少于第二个参数给出的毫秒数，<strong>而不是一次执行</strong>。</p>
<p>可以将正在执行的函数所需的任何参数作为 <code>setInterval()</code> 调用的后续参数传递。</p>
<h4 id="取消任务-1"><a href="#取消任务-1" class="headerlink" title="取消任务"></a>取消任务</h4><p><code>setInterval()</code> 返回一个确定的值，稍后你可以用它来取消间隔任务。</p>
<p>通过将<code>setInterval</code>()调用返回的标识符传递给<code>clearInterval</code>()函数来取消间隔任务。</p>
<blockquote>
<p>递归调用<code>setTimeout()</code>和调用<code>setInterval()</code>效果类似。</p>
<p>二者微妙区别在于：</p>
<p><code>setInterval()</code>的执行时间包括了我们想要运行的代码所花费的时间。</p>
<p><code>setTimeout()</code>每次都等代码运行完了之后，开始计算等待的时间，时间间隔总是相同。</p>
</blockquote>
<h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame()"></a><code>requestAnimationFrame()</code></h3><p><code>setInterval()</code>的现代版本，在浏览器下一次重新绘制显示之前执行指定的代码块，因此该方法将重新加载页面之前要调用的回调函数作为参数。</p>
<h4 id="WHY-1"><a href="#WHY-1" class="headerlink" title="WHY"></a>WHY</h4><p><strong>动画的平滑度直接取决于动画的帧速率，并以每秒帧数（fps）为单位进行测量。</strong>由于大多数屏幕的刷新率为60Hz，因此在使用web浏览器时，可以达到的最快帧速率是每秒60帧（FPS）。</p>
<p><code>requestAnimationFrame()</code> 总是试图<strong>尽可能接近60帧/秒的值</strong>。</p>
<p>当然有时这是不可能的如果你有一个非常复杂的动画，你是在一个缓慢的计算机上运行它，你的帧速率将更少。<code>requestAnimationFrame()</code> 会<strong>尽其所能利用现有资源提升帧速率。</strong></p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// Drawing code goes here</span></span><br><span class="line">    <span class="keyword">if</span>(!startTime) &#123;</span><br><span class="line">      startTime = timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   currentTime = timestamp - startTime;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do something based on current time</span></span><br><span class="line">    </span><br><span class="line">   requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw();</span><br></pre></td></tr></table></figure>
<p>传递给 <code>requestAnimationFrame()</code> 函数的实际回调也可以被赋予一个参数（一个时间戳值），表示自 <code>requestAnimationFrame()</code> 开始运行以来的时间。</p>
<blockquote>
<p>模版字符串</p>
<p><code>$&#123;var&#125;</code>是变量的占位符，常用语字符串拼接。在实际开发中一般在ajax请求中用<code>不变的html$&#123;变量&#125;html标签</code>代替以前传统复杂的单引号双引号与+的拼接。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">spinner.style.transform = <span class="string">&#x27;rotate(&#x27;</span> + rotateCount +<span class="string">&#x27;deg)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">spinner.style.transform = <span class="string">`rotate(<span class="subst">$&#123;rotateCount&#125;</span>deg)`</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>requestAnimationFrame() 的限制之一是无法选择帧率。他总是尽可能地逼近60fps。</p>
<p>有的时候反而需要限制帧率，比如老式动画。如果需要以较慢的帧速率运行动画，则需要使用<code>setInterval（）</code>或递归的<code>setTimeout（）</code>。</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h2><h3 id="基于对象"><a href="#基于对象" class="headerlink" title="基于对象"></a>基于对象</h3><p>API使用一个或多个对象来与JavaScript的代码交互，这些对象的功能是：API使用的数据容器（包含在对象属性中），API提供的功能（包含在对象方法中）。</p>
<h3 id="可识别的入口点"><a href="#可识别的入口点" class="headerlink" title="可识别的入口点"></a>可识别的入口点</h3><p>文档对象模型 (DOM) API的入口点就是Document对象。</p>
<p>Canvas API需要为要编写的API代码创建特定的上下文。例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="使用事件来处理状态的变化"><a href="#使用事件来处理状态的变化" class="headerlink" title="使用事件来处理状态的变化"></a>使用事件来处理状态的变化</h3><p>一些Web API不包含事件，但有些包含一些事件。当事件触发时，允许我们运行函数的处理程序属性通常在单独的 “Event handlers”(事件处理程序) 部分的参考资料中列出。</p>
<h2 id="文档操作的API"><a href="#文档操作的API" class="headerlink" title="文档操作的API"></a>文档操作的API</h2><h3 id="web页面构成"><a href="#web页面构成" class="headerlink" title="web页面构成"></a>web页面构成</h3><p>window是载入浏览器的标签，用<code>window</code>对象来表示。通过调用该对象的方法，可以返回窗口的大小，操作载入窗口的文档等等。</p>
<p>navigator是浏览器存在于web上的状态和标识（即用户代理），用<code>navigator</code>对象来表示，通过调用该对象的方法，可以获取用户摄像头的地理信息、偏好语言、多媒体流等。</p>
<p>document是载入窗口的实际页面，用<code>document</code>对象表示，可以返回、操作文档中HTML和CSS上的信息。</p>
<h3 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h3><p>元素节点、根节点、子节点、后代节点、父节点、兄弟节点、文本节点等。</p>
<p>主要需要弄清楚子节点和后代节点的关系。子节点是<strong>直接</strong>位于另一个节点内的节点，后代节点是位于另一个节点内<strong>任意</strong>位置的节点。</p>
<blockquote>
<p>依据DOM元素存在的各种事件，考虑的角度应该是在创建这个对象的时候就为它添加对应的事件，而不是说在这个事件要发生的时候去考虑该怎么做。</p>
<p>input输入框的内容是通过value属性获取的，<code>let content = input.value;</code>。对input输入框的操作还涉及了自动对焦，<code>input.focus();</code>。</p>
<p>span这种行内元素的内容是通过innerHTML确定的，<code>span.innerHTML = content;</code>。</p>
</blockquote>
<h3 id="操作DOM元素"><a href="#操作DOM元素" class="headerlink" title="操作DOM元素"></a>操作DOM元素</h3><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p><code>Document.querySelector()</code>允许使用CSS选择器选择元素，它调用会匹配它在文档中遇到的第一个匹配的元素。</p>
<p>如果需要选择多个元素，可以使用<code>Document.querySelectorAll()</code>。会返回一个存放了这些元素的array。</p>
<p>一般来说<strong>对DOM元素的引用全部创建为常量</strong>，因为这些引用在应用程序的生命周期中不需要更改。</p>
<blockquote>
<p>也有其他方法比如，<code>document.getElementById()/getElementByTagName()</code>，分别传入id属性值和html元素标签名。</p>
</blockquote>
<h4 id="新建-放置"><a href="#新建-放置" class="headerlink" title="新建/放置"></a>新建/放置</h4><p>新建元素使用<code>Document.vreateElement()</code>，放置使用<code>Node.appendChild()</code>。</p>
<p>新建文本节点要用<code>Document.createTextNode()</code>，放置使用<code>Node.appendChild()</code>。</p>
<h4 id="移动-删除"><a href="#移动-删除" class="headerlink" title="移动/删除"></a>移动/删除</h4><p>基于现有元素做一个副本，然后把副本移动到其他节点，需要使用<code>Node.cloneNode()</code>。</p>
<p>删除节点需要知道父亲节点的引用和要删除节点的引用，<code>Node.removeChild()</code>；但是不知道父亲节点的引用，需要问询父亲节点<code>linkPara.parentNode.removeChild(linkPara);</code>。</p>
<h3 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a>操作样式</h3><p>有两种方式。</p>
<p>第一种是直接想要动态设置样式的内部元素添加内联样式。通过<code>HTMLElement.style</code>属性来实现，这个属性包含了文档中每一个元素的内联样式的信息。载入页面后会直接看到样式应用到HTML文件对应的元素。</p>
<p>第二种是使用<code>Element.setAttribute(attribute, value)</code>。</p>
<h2 id="从服务器获取数据的API"><a href="#从服务器获取数据的API" class="headerlink" title="从服务器获取数据的API"></a>从服务器获取数据的API</h2><p>主要涉及两个常用API，一个是<code>XMLHttpRequest</code>，另一个是<code>Fetch</code>。这些API允许网页直接对服务器上可用的特定资源进行HTTP请求，并在显示之前根据需要对数据进行格式化。</p>
<blockquote>
<p><strong>在早期，这种通用技术被称为</strong>Asynchronous JavaScript and XML<strong>（Ajax）</strong></p>
</blockquote>
<p>第三方API根植于第三方浏览器，要通过JavaScript获取，首先要连接到它的功能接口上并使其在页面上生效。</p>
<h3 id="使用第三方API"><a href="#使用第三方API" class="headerlink" title="使用第三方API"></a>使用第三方API</h3><p>首先就是要阅读第三方API的官方文档了解应该如何使用。</p>
<p>其次需要向第三方API的提供者申请使用密钥。</p>
<p>浏览器API通常有一个安全性提示，在第三方API中，使用<strong>API KEY</strong>来允许开发人员访问API功能，但是如果开发者恶意使用API来侵犯用户隐私，API的提供者可以根据密钥撤销该开发者的API使用权。</p>
<h4 id="引入第三方库"><a href="#引入第三方库" class="headerlink" title="引入第三方库"></a>引入第三方库</h4><p>需要引入一个<code>&lt;script&gt;&lt;/script&gt;</code>元素连接到第三方服务器所开放的JavaScript库。</p>
<p>谷歌地图的API如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;https://maps.google.com/maps/api/js?key=AIzaSyDDuGt0E5IEGkcE6ZfrKfUtE9Ko_de66pA&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="基于URL请求"><a href="#基于URL请求" class="headerlink" title="基于URL请求"></a>基于URL请求</h4><p>一般此类API都遵循RESTful API的设计指南，遵循域名、API版本、Endpoint、Filtering过滤信息参数、状态码、错误处理等相关规定。</p>
<ul>
<li><p>利用字符串操作等方式创建相应的URL</p>
<ul>
<li><p>首先应当有一个baseURL</p>
</li>
<li><p>建立API和本地应用的链接<code>?api-key=$&#123;key&#125;</code></p>
<p>每次向服务器对应的 URL 发起 get 请求，都需要把 API key 作为 get 请求的参数。</p>
</li>
<li><p>个性化请求参数<code>&amp;page=$&#123;pageNumber&#125;</code></p>
</li>
</ul>
</li>
<li><p>利用URL从API请求数据，结合Fetch方法/XMLHTTPRequest方法。</p>
</li>
<li><p>对接收到的JSON数据进行解析，拆分显示到当前HTML的各个元素。</p>
</li>
</ul>
<h2 id="用于绘制和操作图形的API"><a href="#用于绘制和操作图形的API" class="headerlink" title="用于绘制和操作图形的API"></a>用于绘制和操作图形的API</h2><p>主要基于<code>&lt;canvas&gt;</code>讲解。</p>
<h3 id="基本准备"><a href="#基本准备" class="headerlink" title="基本准备"></a>基本准备</h3><ul>
<li>在<code>body</code>中添加带class的<code>canvas</code>元素并在JS中选择该canvas元素</li>
<li>获取该画布上下文canvas context并完成设置<code>var ctx = canvas.getContext(&#39;2d&#39;);</code>，还可以选择wbgl1和webgl2。这里的<code>ctx</code>是一个<code>CanvasRenderingContext2D</code>对象。</li>
<li>画布原点默认是在<code>(0,0)</code>，如需改变，使用<code>ctx.translate()</code>函数，将画布原点移动到指定坐标。</li>
</ul>
<h3 id="绘制基本形状"><a href="#绘制基本形状" class="headerlink" title="绘制基本形状"></a>绘制基本形状</h3><ul>
<li><p>内容填充与描绘边</p>
<p><code>ctx.fillStyle = &#39;&#39;; ctx.fillRect()</code></p>
<p> <code>ctx.storkeStyle = &#39;&#39;; ctx.lineWidth = ; ctx.strokeRect();</code></p>
</li>
<li><p>路径绘制与画线自定义形状</p>
<p>前期准备确定一下<code>ctx.fillStyle = &#39;&#39;</code>，即要画什么颜色。</p>
<ul>
<li><p>第一步：产生钢笔，并移动钢笔，这个步骤不会绘制任何内容<code>ctx.beginPath(); ctx.moveTo();</code></p>
</li>
<li><p>第二步：移动钢笔到多个计算好坐标的位置，形成闭合路径 <code>ctx.lineTo();</code></p>
</li>
<li><p>第三步：选择填充还是描边这两种行为 <code>ctx.fill(); ctx.stroke();</code></p>
</li>
</ul>
</li>
<li><p>画圆/画弧</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.fillStyle = <span class="string">&#x27;yellow&#x27;</span>;</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.arc(<span class="number">200</span>, <span class="number">106</span>, <span class="number">50</span>, degToRad(<span class="number">-45</span>), degToRad(<span class="number">45</span>), <span class="literal">true</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>, <span class="number">106</span>);</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure>
<ul>
<li>填充文字</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.fillStyle = <span class="string">&#x27;red&#x27;</span>; </span><br><span class="line"><span class="comment">// ctx.strokeStyle = &#x27;white&#x27;; </span></span><br><span class="line"><span class="comment">// ctx.lineWidth = 1;</span></span><br><span class="line"></span><br><span class="line">ctx.font = <span class="string">&#x27;48px georgia&#x27;</span>;</span><br><span class="line">ctx.fillText(<span class="string">&#x27;Canvas text&#x27;</span>, <span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>图片嵌入</li>
</ul>
<p>首先，使用<code>Image()</code>构造器创建一个新的<code>HTMLImageElement</code>对象，返回对象的类型与非空<code>&lt;img&gt;</code>元素的引用一致，设置改图片的src属性</p>
<p>其次使用<code>ctx.drawImage()</code>函数来嵌入图片。由于需要事先确保图片已经载入完毕，要在图片的<code>onload</code>事件处理器中调用嵌入图片的函数。</p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p><code>window.requestAnimationFrame()</code>只接受一个参数，这个参数是<strong>一个每帧都要运行的函数名</strong>，因为请注意每一帧我们都整体清除画布并重新渲染所有内容。</p>
<p>这个函数传入该方法后就会在一秒内被重复运行多次。下一次浏览器准备好更新屏幕时，将会调用你的函数。如果你的函数向动画中绘制了更新内容，则在函数结束前再次调用 <code>requestAnimationFrame()</code>，动画循环得以保留。</p>
<p>只有在停止调用 <code>requestAnimationFrame()</code> 时，或 <code>requestAnimationFrame()</code> 调用后、帧调用前调用了 <code>window.cancelAnimationFrame()</code>时，循环才会停止。</p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>清除画布内容（可用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fillRect"><code>fillRect()</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/clearRect"><code>clearRect()</code></a>）。</li>
<li>（在需要时）用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/save"><code>save()</code></a> 保存状态。（在进行下一步前保存所更新的设置，一般在复杂环境中用到）</li>
<li>绘制动画图形。</li>
<li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/restore"><code>restore()</code></a> 恢复第 2 步中保存的状态。</li>
<li>调用 <code>requestAnimationFrame()</code> 准备下一帧动画</li>
</ol>
<hr>
<p>3D画布内容通过WebGL API实现，WebGL基于Open GL图形编程语言实现，可以直接与GPU通信，更类似C++的底层语言。</p>
<p>常用的第三方API有<code>three.js/PlayCanvas</code>等。</p>
<p>使用three.js的基本步骤如下：</p>
<ul>
<li>构造一个新的3D场景</li>
<li>为该3D场景添加摄影机，代表绘图语境中观察着视角</li>
<li>指定渲染器，并将3D画布与DOM对象关联</li>
<li>创建基于纹理的画布内容</li>
</ul>
<p>首先要创建一个TextureLoader对象，把作为纹理的图片在图片载入成功后（通过事件监听实现）传入一个回调函数。</p>
<p>其次该纹理图可能会经过一系列复制旋转等操作。</p>
<ul>
<li>为场景打光，分柔光和硬光，分别创建对象。</li>
</ul>
<h2 id="视频和音频API"><a href="#视频和音频API" class="headerlink" title="视频和音频API"></a>视频和音频API</h2><h3 id="HTML5中的播放器"><a href="#HTML5中的播放器" class="headerlink" title="HTML5中的播放器"></a>HTML5中的播放器</h3><p>HTML5中<code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>元素允许我们把视频和音频嵌入到网页当中。</p>
<p>构成HTML视频播放器的主要由两个部分，这两个部分都被包裹在名为<code>&lt;div class=&quot;player&quot;&gt;</code>的div块中。</p>
<h4 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h4><hr>
<p>首先是video元素层，包含多个视频source，可以根据浏览器来加载其所支持的不同视频格式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意上面的controls是浏览器默认控件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;video/sintel-short.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;video/sintel-short.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- fallback content here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其次是自定义控件层，涉及多个button以及div。</p>
<p>四个 <code>&lt;button&gt;</code>涉及play/pause, stop, rewind, and fast forward，分别带有属性一个<code>class名</code> ，一个<code>data-icon</code> 属性来决定在每个按钮上显示什么图标 (在下一节讲述它是如何工作的)，和一个<code>aria-label</code> 属性为每一个按钮提供容易理解的描述, 即使我们没有在tags内提供可读的标签。</p>
<p>有一个设定的计时器 <code>&lt;div&gt;</code>用来报告已经播放的时长。由两部分组成， 一个<code>&lt;span&gt;</code> 包含了流逝时间的分钟和秒；一个额外的<code>&lt;div&gt;</code> 用来创建一个水平的随着时间增加而增长的进度条。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;controls&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;play&quot;</span> <span class="attr">data-icon</span>=<span class="string">&quot;P&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;play pause toggle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;stop&quot;</span> <span class="attr">data-icon</span>=<span class="string">&quot;S&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;stop&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;timer&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-label</span>=<span class="string">&quot;timer&quot;</span>&gt;</span>00:00<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;rwd&quot;</span> <span class="attr">data-icon</span>=<span class="string">&quot;B&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;rewind&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;fwd&quot;</span> <span class="attr">data-icon</span>=<span class="string">&quot;F&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;fast forward&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h4><p>关于播放器的CSS设置有如下几个要点。</p>
<ul>
<li>默认情况下，我们将控件的<code>opacity</code>设置为0.5 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/opacity"><code>opacity</code></a>，这样当您尝试观看视频时，它们就不会分散注意力。 只有当您将鼠标悬停/聚焦在播放器上时，控件才会完全不透明。</li>
<li>使用flexbox控制各个按钮</li>
<li>CSS中设置我们的自定义控件的visible属性为hidden；video元素中默认使用浏览器自带的控件。这样的好处是，一旦JavaScript由于某种原因没有加载, 用户依然可以使用原生的控件播放视频。</li>
<li>我们使用 <code>::before</code>状态选择器显示在每个button被点击之前显示内容。</li>
</ul>
<h4 id="使用API"><a href="#使用API" class="headerlink" title="使用API"></a>使用API</h4><p>HTMLMediaElement API允许开发者用编程的方式控制视频和音频播放的相关功能，如例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement/play"><code>HTMLMediaElement.play()</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement/pause"><code>HTMLMediaElement.pause()</code></a>。</p>
<h2 id="客户端储存"><a href="#客户端储存" class="headerlink" title="客户端储存"></a>客户端储存</h2><p>现代web浏览器提供了很多在用户电脑的web客户端存放数据的方法。</p>
<p>它是由 JavaScript APIs 组成的因此允许你在客户端存储数据 (比如在用户的机器上)，而且可以在需要的时候重新取得需要的数据。例如个性化网站偏好，站点行为如是否记住登录状态，本地化数据的静态资源可以加速访问等。</p>
<p>传统上使用cookies，现代浏览器使用Web Storage和Indexed DB这两个API。</p>
<h3 id="Web-Storage-API"><a href="#Web-Storage-API" class="headerlink" title="Web Storage API"></a>Web Storage API</h3><p>只需存储简单的键名/键值对数据 (限制为字符串、数字等类型) 并在需要的时候检索其值。</p>
<h4 id="存储对象sessionStorage和localStorage"><a href="#存储对象sessionStorage和localStorage" class="headerlink" title="存储对象sessionStorage和localStorage"></a>存储对象sessionStorage和localStorage</h4><p>一般所有web storage的数据都包含在浏览器内的两个对象中，他们都属于Storage类的对象。对这两个对象调用方法就能实现客户端数据存储。</p>
<p>第一个是sessionStorage，只要浏览器开着，数据就会一直保存 (关闭浏览器时数据会丢失)。</p>
<p>第二个是localStorage，会一直保存数据，甚至到浏览器关闭又开启后也是这样。</p>
<p>web storage 的一个关键特性是，数据在不同页面加载时都存在（甚至是当浏览器关闭后，对localStorage的而言）。</p>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p><code>Storage.setItem()</code>允许在客户端储存中保存一个数据项，接受两个参数：数据项的名字和其值。</p>
<p>例如<code>localStorage.setItem(&#39;name&#39;,&#39;Chris&#39;);</code></p>
<p><code>Storage.getItem()</code>接受一个参数：想要检索的数据项的名称，返回数据项的值。</p>
<p>例如<code>localStorage.getItem(&#39;name&#39;);</code></p>
<p><code>Storage.removeItem()</code>接受一个参数：想要删除的数据项的名称，并从web stroage中删除该数据项。</p>
<p>例如<code>localStorage.removeItem(&#39;name&#39;);</code> </p>
<h4 id="数据库的使用"><a href="#数据库的使用" class="headerlink" title="数据库的使用"></a>数据库的使用</h4><p>首先，需要<strong>打开数据库并存放在常量</strong>中，第一个参数是名字，第二个参数是版本号。如果不存在该数据库，会自动创建。</p>
<p>我们需要在页面载入成功，也就是<code>window.onload</code>完成之后打开一下数据库并把它放在，而不是在需要用数据库的时候再去调用他，如果数据库很大的话，这个加载需要很久的时间，会导致阻塞。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="built_in">window</span>.indexedDB.open(<span class="string">&#x27;notes&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<hr>
<p>其次，由于数据库操作是异步的，需要给打开后的<strong>数据库添加各种状态监听函数</strong>。</p>
<p>监听函数需要包括<strong>是否成功打开</strong>数据库的后台消息onerror/onsuccess；<strong>设置初始数据库</strong>onupgradeneeded。</p>
<p>如何从监听函数内部获取对现有数据库的引用<code>let db = e.target.result;</code></p>
<p>如何在数据库中建立一个新的table/对象库<code>let objectStore = db.createObjectStore(&#39;notes&#39;, &#123;keyPath:&#39;id&#39;, autoIncrement: true&#125;);</code> </p>
<p>如何在数据库的某个对象库中创建数据项<code>objectStore.createIndex(&#39;title&#39;, &#39;title&#39;, &#123;unique: false&#125;);</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 从事件目标e.target中获取对现有数据库的引用，即request对象</span></span><br><span class="line">        <span class="keyword">let</span> db = e.target.result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个objectStore就像一个table一样存放记录</span></span><br><span class="line">        <span class="comment">// 在我们打开的数据库中新建一个对象库，类似于传统数据库系统中的单个表</span></span><br><span class="line">        <span class="comment">// id用于唯一标志一条记录</span></span><br><span class="line">        <span class="keyword">let</span> objectStore = db.createObjectStore(<span class="string">&#x27;notes&#x27;</span>, &#123;<span class="attr">keyPath</span>:<span class="string">&#x27;id&#x27;</span>, <span class="attr">autoIncrement</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">        <span class="comment">// 定义这个table中会存放什么样的数据项，创建了两个索引</span></span><br><span class="line">        objectStore.createIndex(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, &#123;<span class="attr">unique</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">        objectStore.createIndex(<span class="string">&#x27;body&#x27;</span>, <span class="string">&#x27;body&#x27;</span>, &#123;<span class="attr">unique</span>: <span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Database setup complete&#x27;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>对数据库进行<strong>增加数据项</strong>的操作</p>
<p>首先，明确要增加进去的数据项<code>newItem</code>。</p>
<p>需要引入一个读写数据库的方法的引用<code>let transaction = db.transaction([&#39;notes&#39;], &#39;readwrite&#39;);</code>。</p>
<p>然后，锁定目标到数据库内的某一个table/对象库。</p>
<p>最后，基于该对象库调用<code>obJectStore.add(newItem)</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newItem = &#123;<span class="attr">title</span>: titleInput.value, <span class="attr">body</span>: bodyInput.value&#125;;</span><br><span class="line"><span class="keyword">let</span> transaction = db.transaction([<span class="string">&#x27;notes&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> objectStore = transaction.objectStore(<span class="string">&#x27;notes&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> request = objectStore.add(newItem);</span><br></pre></td></tr></table></figure>
<p>该引用成功完成后应当增加<code>transaction.oncomplete</code>监听函数。该引用失败后应当增加<code>transaction.onerror</code>监听函数。</p>
<hr>
<p>将<strong>数据库更新同步到客户端</strong>网页DOM中</p>
<p>首先，需要明确原网页DOM中所有数据库的原先内容都要被移除，否则会出现叠加。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(list.firstChild)&#123;</span><br><span class="line">    list.removeChild(list.firstChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，获得对数据库中的特定对象库table的引用。<code>let objectStore = db.transaction(&#39;notes&#39;).objectStore(&#39;notes&#39;);</code></p>
<p>最后，最重要的是获得对对象库中的所有条目的引用。条目的各项index都可以通过<code>cursor.value</code>的属性获得，但是需要注意<code>cursor.value.id</code>是连接DOM中的条目和数据库中条目的通道。删除了的DOM中条目如何对应到数据库中去删除？这就需要id来分辨。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">objectStore.openCursor().onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cursor = e.target.result;</span><br><span class="line"><span class="comment">// cursor.value就相当于一个table中的一个条目</span></span><br><span class="line"><span class="comment">// cursor.value.title/bod就相当于一个条目中的一个index</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 当用户操作删除这个的时候，便于我们在数据库中寻找对应的条目删除</span></span><br><span class="line">	listItem.setAttribute(<span class="string">&#x27;data-note-id&#x27;</span>, cursor.value.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>DOM树的数据项删除同步到客户端</strong>数据库</p>
<p>首先，需要获得删除数据项在数据库中的唯一id。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> noteId = <span class="built_in">Number</span>(e.target.parentNode.getAttribute(<span class="string">&#x27;data-note-id&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>其次，打开数据库的特定对象库。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> transaction = db.transaction([<span class="string">&#x27;notes&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> objectStore = transaction.objectStore(<span class="string">&#x27;notes&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>最后，在对象库上传入id参数执行delte操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> request = objectStore.delete(noteId);</span><br></pre></td></tr></table></figure>
<p>对该请求设置一个事件监听操作，一旦在数据库中删除成功，这种变化需要反映到DOM树中去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request.oncomplete = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            e.target.parentNode.parentNode.removeChild(e.target.parentNode);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;Note $&#123;noteId&#125; deleted.&#x27;</span>);</span><br><span class="line">	<span class="comment">// 如是删除到最后都是空列表该怎么做</span></span><br><span class="line">    <span class="comment">// 这是没有listitem的默认显示</span></span><br><span class="line">    <span class="keyword">if</span>(!list.firstChild)&#123;</span><br><span class="line">        <span class="keyword">let</span> listItem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">        listItem.textContent = <span class="string">&#x27;No notes stored.&#x27;</span>;</span><br><span class="line">        list.appendChild(listItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
