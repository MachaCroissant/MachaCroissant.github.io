<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="记录，分享。">
    <meta name="author" content="徐徐">
    
    <title>
        
            如何使用Vue框架的记录 |
        
        来个抹茶可颂
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/favicon-32x32-next.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"drunk99.xyz","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/tuotuo.jpg","favicon":"/images/favicon-32x32-next.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"记录，分享。"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.2"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="来个抹茶可颂" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                来个抹茶可颂
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">如何使用Vue框架的记录</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/tuotuo.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">徐徐</span>
                        
                            <span class="author-label">Lv5</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2020-10-17 20:55:16
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Vue/">Vue</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Vue/">Vue</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>37 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="创建Vue应用"><a href="#创建Vue应用" class="headerlink" title="创建Vue应用"></a>创建Vue应用</h1><p>使用<code>const app = Vue.createApp(&#123;&#125;)</code>创建Vue应用，在创建完Vue应用之后，还要利用<code>app.mount(&quot;#vue-app&quot;)</code>把当前Vue应用mount/挂载到对应html节点中去，而html节点用id唯一标识<code>&lt;div id=&quot;vue-app&quot;&gt;&lt;/div&gt;</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;https://unpkg.com/vue@next&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;vue-app&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      <span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">        template: <span class="string">&quot;&lt;div&gt;&lt;h1&gt;HI&lt;/h1&gt;&lt;/div&gt;&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      app.mount(<span class="string">&quot;.vue-app&quot;</span>);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实只要是一个选择器都能实现挂载，利用class对应点选择器也能实现挂载，问题在于一个class可以对应到多个html标签，而使用id是因为id的唯一性。因此约定都适用id选择器和标签的id属性。</p>
<h1 id="template-syntax"><a href="#template-syntax" class="headerlink" title="template syntax"></a>template syntax</h1><p>在创建template的时候，使用引号将html语言包裹起来，能正常加载，但是问题在于必须在一行内全部写完所有html内容，因此使用模版字符串中来实现分栏。</p>
<center class="half">
<img src="/2020/10/17/learn-vue/image-20201225142100746.png" alt="image-20201225142100746" style="zoom:30%;"><img src="/2020/10/17/learn-vue/image-20201225142124760.png" alt="image-20201225142124760" style="zoom:30%;">
</center>

<p>Vue.js使用了基于HTML的模版语法，利用模版字符串可以在Vue实例的template中直接写入合法的HTML。</p>
<p>在HTML文件中，<strong>将想要传递简单值值的属性用双括号(“Mustache” Syntax)包裹</strong>（如果是复杂值参考computed attribute field）。但是<strong>只能在HTML元素两个尖括号之间使用，作为HTML元素内容。</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tag</span>&gt;</span>&#123;&#123; Mustache-Syntax &#125;&#125;<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>双括号既可以用在我们想要mount id特定的原生html中，也可以用在我们创建的Vue实例的template中。</p>
<p>template syntax和v-directive中的<code>v-text</code>很相似，但是v-text的问题在于不管template中父亲元素内部有什么内容，都会被v-text的内容替换/覆盖。</p>
<h1 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h1><p>每个Vue实例被创建时都要经过一系列初始化过程， 而实例生命周期钩子就是在初始化过程中执行的函数，可以在特定的初始化阶段插入我们想要的代码。</p>
<p>beforeCreate(页面载入之前)/created(Vue实例被创建之后)，例子就比如在刚进入页面，或者刷新页面的时候。</p>
<p>breforeMount(挂载之前)/mounted(挂载成功)：如果在html元素内部有内容却没有在vue实例的template定义内容，那么将html元素的outerHTML编译成template；如果有template，将template编译成render function。</p>
<p>mounted和beforeMount的例子就比如在页面间路由，如果从当前页面跑到另外一个页面去，那么当前页面的vue实例就会经历beforeUnmount以及unmounted，而去往的目的页面的vue实例就会经历beforeMount以及mounted。</p>
<p>beforeUpdate(数据改变，更新之前)/updated(更新完毕），例如用户在文本框输入了数据，传递到vue，那么就会重新渲染显示到页面。</p>
<p>注意<strong>不能使用箭头函数来定义一个生命周期方法，因为箭头函数没有指向实例的this。</strong></p>
<p>生命周期函数定义在methods field中，以函数的形式定义。</p>
<p><img src="/2020/10/17/learn-vue/lifecycle.png" alt="lifecycle"></p>
<h1 id="v-directives指定约定"><a href="#v-directives指定约定" class="headerlink" title="v- directives指定约定"></a>v- directives指定约定</h1><p>A directive’s job is to reactively <strong>apply side effects to the DOM</strong> when the value of its expression changes.</p>
<p>指令是带有v-前缀的特殊的由vue来处理的attribute。指令接受单个JavaScript表达式（v-for和v-on除外）。attribute的值都需要从我们定义的vue实例中去寻找，而不是默认的DOM对象。</p>
<blockquote>
<p>Directives are prefixed with <code>v-</code> to indicate that they are <strong>special attributes provided by Vue</strong>, and they apply special reactive behavior to the rendered DOM.</p>
</blockquote>
<p>Vue为最常用的<code>v-bind</code>和<code>v-on</code>提供了缩写指令。v-bind语法中可以直接省去v-bind，直接在html标签中用冒号传参数<code>:url/:[computed]</code>；v-on可以用@符号替代v-on:，直接在html中用at符号和事件名<code>@click/@[event]</code>。</p>
<p><strong>修饰符 (modifier) 是以半角句号<code>.</code>指明的特殊后缀</strong>，用于指出一个指令应该以特殊方式绑定。每个v-directive可用的修饰符见具体的说明模块。</p>
<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind:"></a><code>v-bind:</code></h2><h3 id="实现值的绑定"><a href="#实现值的绑定" class="headerlink" title="实现值的绑定"></a>实现值的绑定</h3><p>在v-指令后面添加一个冒号，让指令接受一个html attribute参数，v-指令会让该html attribute和等号后传入的单个JavaScript表达式的值绑定。（主要任务是绑定当前vue实例中的值）</p>
<p>v-bind让我们把html field中任何一个attribute的值和定义在vuejs中的data联系起来，因为我们把value放在引号中，如果没有v-bind，html中的attribute会直接被理解为字符串值传递过去。比如href=”url”的意思就是href的值是url，而不是url这个变量所指向的具体的url地址。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这里 <code>href</code> 是参数，告知 <code>v-bind</code> 指令将该元素的 <code>href</code> attribute 与表达式 <code>url</code> 的值绑定。</p>
<p>又如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这里<code>click</code>监听事件名称是参数，告知<code>v-on</code>指令将该html元素的<code>click</code>事件与表达式<code>doSomething</code>回调函数绑定。</p>
<h3 id="实现属性的绑定"><a href="#实现属性的绑定" class="headerlink" title="实现属性的绑定"></a>实现属性的绑定</h3><p>既然属性值可以从vuejs的data中传递过来，那么属性是否也可以从vuejs的data中传递过来呢？通过方括号将变量括起来放到v-directive的冒号后面，vue首先会将方括号里的变量当作一个JavaScript表达式在vuejs的代码部分查找到匹配名字的变量后求值后再作为静态的html attribute传递给html（<strong>在vue的data field中定义这个属性一定要是字符串</strong>）与等号后JavaScript表达式值的绑定。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributename</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果<code>[attributename]</code>被求值出来的结果是一个<strong><code>null</code>字符串，表示移除该绑定</strong>。</p>
<p>在DOM中使用模版是（也就是直接在html文件中撰写模版）<strong>避免在方括号中使用大写字符</strong>，因为DOM会把代码转换为小写。如<code>&lt;a v-bind:[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt;</code>就会被自动转换为<code>v-bind:[someattr]</code>，除非js文件的vue实例中确实有return一个someattr，否则代码不会工作。</p>
<p><strong>不要在方括号内书写空格和引号</strong>，因为空格和引号在html的attribute名里都是无效的。</p>
<h3 id="绑定html-class"><a href="#绑定html-class" class="headerlink" title="绑定html class"></a>绑定html class</h3><h4 id="通过对象true-false切换class"><a href="#通过对象true-false切换class" class="headerlink" title="通过对象true/false切换class"></a>通过对象true/false切换class</h4><p>通过给<code>:class</code>一个对象，实现<strong>动态切换class</strong>。</p>
<p>html class在该对象的object field中定义，而<strong>该class是否存在取决于该对象的obejct field value的truthiness</strong>。</p>
<p><code>:class</code>指令可以与html的普通的class共存。</p>
<hr>
<ol>
<li>内联定义方式</li>
</ol>
<p>当然该对象可以直接内联定义在html template中，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<ol>
<li>解耦定义方式</li>
</ol>
<p>也可以在vue实例的data field中return，如html中定义：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>并在JavaScript中定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    classObject: &#123;</span><br><span class="line">      active: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&#x27;text-danger&#x27;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过数组值应用多个class"><a href="#通过数组值应用多个class" class="headerlink" title="通过数组值应用多个class"></a>通过数组值应用多个class</h4><p>可以把一个数组传给 <code>:class</code>，以应用一个 class 列表。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    activeClass: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line">    errorClass: <span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个部分组合起来渲染结果就是</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;active text-danger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="绑定html-style"><a href="#绑定html-style" class="headerlink" title="绑定html style"></a>绑定html style</h3><p>和绑定html class遵循相似的方式，对象语法和数组语法都可以。</p>
<h2 id="v-model表单输入双向绑定"><a href="#v-model表单输入双向绑定" class="headerlink" title="v-model表单输入双向绑定"></a><code>v-model</code>表单输入双向绑定</h2><h3 id="v-bind和v-model的区别"><a href="#v-bind和v-model的区别" class="headerlink" title="v-bind和v-model的区别"></a><code>v-bind</code>和<code>v-model</code>的区别</h3><p>v-bind虽然能够实现js中的数据传递向html（也就是视图），但是用开发工具查看当用户在视图上的input框里输入的内容是不会自动同步到js中去的，也就是说这是一个单向绑定。</p>
<p>如果实现双向绑定，直接使用v-model，v-model隐含的语义就是在v-bind实现的单项数据基础上，再把反向增加一个数据流，作用的属性是value。</p>
<h3 id="v-model的具体使用"><a href="#v-model的具体使用" class="headerlink" title="v-model的具体使用"></a><code>v-model</code>的具体使用</h3><p><code>v-model</code>指令用于表单<code>input</code> <code>textarea</code> 以及 <code>select</code>元素上创建和JavaScript的<strong>data对象的双向数据绑定</strong>。</p>
<p><strong><code>v-model</code>会忽略HTML文件中表单元素的各种属性的初始值，只会依据JavaScript文件中的实例数据作为初始数据来源</strong>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Tag</th>
<th>Property</th>
<th>Event</th>
</tr>
</thead>
<tbody>
<tr>
<td>text/textarea</td>
<td>Value</td>
<td>Input</td>
</tr>
<tr>
<td>checkbox/radio</td>
<td>Checked</td>
<td>Change</td>
</tr>
<tr>
<td>select</td>
<td>Value</td>
<td>Change</td>
</tr>
</tbody>
</table>
</div>
<p>选择框单选时需要注意<strong>提供一个值为空的初始禁用选项</strong>，选择框多选时绑定到一个数组。</p>
<h3 id="使用v-model修饰符"><a href="#使用v-model修饰符" class="headerlink" title="使用v-model修饰符"></a>使用<code>v-model</code>修饰符</h3><p><strong>v-model的绑定是默认用户在focus时每次输入都要vue去响应去同步</strong>，这是很不高效的。因此就有了<code>v-model.lazy</code>修饰符，这告诉vue，等用户的focus从当前表单输入离开了之后，你再去更新vue实例反向的数据流。</p>
<p>有时候用户会在输入文本头尾添加无意义的空格，我们不希望接受这些无意义的输入，因此就有了<code>v-model.trim</code>修饰符，这告诉vue，你把用户输入的头尾空格都修剪掉在作为同步到vue实例对应的地方去储存值。</p>
<p>默认接受用户输入是字符串格式，有时候希望把字符串作为number形式储存在vue 实例中，因此就有了<code>v-model.number</code>修饰符。</p>
<h2 id="v-once一次性渲染DOM"><a href="#v-once一次性渲染DOM" class="headerlink" title="v-once一次性渲染DOM"></a><code>v-once</code>一次性渲染DOM</h2><p>v-once 代表只在DOM中渲染一次该组件，但是该组件中涉及的数据仍然由vue组件管控，会在vue devtools的data field中（如果有的话）被更新。但是被v-once标记的元素不会再初始渲染后再次重新渲染。</p>
<h2 id="v-html在template中插入html代码"><a href="#v-html在template中插入html代码" class="headerlink" title="v-html在template中插入html代码"></a><code>v-html</code>在template中插入html代码</h2><p>在template中的元素上使用v-html会告诉vue，父亲标签里面的字标签应当被当作原生html渲染。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 v-html=<span class="string">&quot;title&quot;</span>&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      title: <span class="string">&quot;&lt;h1&gt;Hey Vue3&lt;/h1&gt;&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="v-if-v-else-if-v-else条件渲染"><a href="#v-if-v-else-if-v-else条件渲染" class="headerlink" title="v-if v-else-if v-else条件渲染"></a><code>v-if</code> <code>v-else-if</code> <code>v-else</code>条件渲染</h2><p> <code>v-if option</code>的使用决定了这个标签是否会被销毁或者再造，即<strong>是否存在于DOM树中</strong>。如有必要还可以<strong>和<code>v-else-if</code> <code>v-else</code>紧邻配对使用</strong>。</p>
<p><strong><code>v-if option</code>只能加载一个单独的元素标签上</strong>，如果要对好多个元素标签使用条件渲染，应该把需要条件渲染的所有元素标签都放在<code>&lt;template v-if=&quot;??&quot;&gt; &lt;\template&gt;</code>标签中。</p>
<p><strong>不推荐一起使用<code>v-if</code>和<code>v-for</code>。</strong>因为当二者存在于同一个元素节点上时，<code>v-if</code>有更高的优先级，总是先测试它。因此<code>v-if</code>没有权限访问<code>v-for</code>作用域内的变量。</p>
<h2 id="v-showCSS切换"><a href="#v-showCSS切换" class="headerlink" title="v-showCSS切换"></a><code>v-show</code>CSS切换</h2><p><strong>使用了<code>v-show option</code>的元素总是会被渲染并且留在DOM中</strong>，它的作用仅仅是切换CSS property是否display。给插入的父亲标签添加一个<code>&lt;h1 style=&quot;display: none;&quot;&gt;这里是script中的template的内容&lt;/h1&gt;</code></p>
<h2 id="v-for多选素渲染"><a href="#v-for多选素渲染" class="headerlink" title="v-for多选素渲染"></a><code>v-for</code>多选素渲染</h2><p>使用<code>v-for</code>来循环渲染包含多个元素的内容，可以是遍历数组元素，也可以是遍历对象属性。</p>
<p>Vue使用v-for进行渲染的时候，<strong>默认使用就地更新(in-place patch strategy)</strong>。如果数据项的顺序改变，Vue不会移动DOM元素来匹配数据项的顺序，而是就地更新，并确保它们在每个索引位置正确渲染（因此会造成不必要的渲染）。因此，<strong>为了确保Vue正确识别节点，在使用<code>v-for</code>的时候带上<code>v-bind:key=&quot;&quot;</code>。</strong></p>
<h3 id="修饰符modifiers"><a href="#修饰符modifiers" class="headerlink" title="修饰符modifiers"></a>修饰符modifiers</h3><p><code>.lazy</code>在Change事件之后进行同步，（比如，不是在用户选中对话框且输入时就同步，而是用户光标离开对话框后再同步）</p>
<p><code>.number</code>自动将用户的输入值转为数值类型</p>
<p><code>.trim</code>自动过滤用户输入的收尾空白字符</p>
<h2 id="v-on事件监听"><a href="#v-on事件监听" class="headerlink" title="v-on事件监听"></a><code>v-on</code>事件监听</h2><p>利用<code>v-on: event-listener=&quot;&quot;</code>(short for <code>@event-listener=&quot;&quot;</code> )。</p>
<p>赋值语句后跟一个javascript简单语法（这个语句和在vue实例中执行的语句有相同的效果比如<code>@submit.prevent=&quot;newHero = &#39;Wonder Woman&#39;&quot;</code>就是可以的），或者就是在js文件的methods field中预先定义好的（带参数的）回调函数。</p>
<p>当在HTML的内联语句中需要访问原始的DOM事件时，可以将原始DOM事件利用<code>$event</code>特殊变量传入回调函数中。</p>
<p>对于一个事件的<strong>多个事件处理函数用逗号分开</strong>回调函数。</p>
<h3 id="v-on修饰符"><a href="#v-on修饰符" class="headerlink" title="v-on修饰符"></a><code>v-on</code>修饰符</h3><p>在事件处理函数中经常需要调用 <code>event.preventDefault()</code> 或者 <code>event.stopPropagation()</code>。这属于DOM细节的考虑范畴，因此通过事件修饰符将这个操作框定在html中。虽然可以在Vue的methods中去实现，但<strong>methods更多需要处理的事数据逻辑而非DOM细节</strong>。由此引入事件修饰符，<code>directive.postfix-event-modifiers</code>。</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code>在DOM中如果发生了表单提交行为，是默认会重新刷新当前网页，并且路径会变成<code>http://localhost:8080/?</code>，这意味着表单提交了，我们不希望这样的默认行为发生，因此引入了<code>v-on:submit.prevent</code>这样的修饰符，vue会阻止DOM在发生了submit事件是自动提交表单刷新页面的行为。</li>
<li><code>.capture</code></li>
<li><code>.self</code></li>
<li><code>.once</code> 点击事件只触发一次，也可以被用到component events中</li>
<li><code>.passive</code> 相当于<code>addEventListener</code>的<code>passive</code>选项，执行事件的默认行为</li>
</ul>
<p>监听键盘事件时需要检查详细按键，<code>Vue</code>允许为<code>v-on</code>在监听键盘事件时添加按键修饰符。<strong>将<code>KeyBoardEvent.key</code>中规定的任意有效按键名转换为kebab-case(短横线形式)作为按键修饰符即可。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-on:keyup.page-down=<span class="string">&quot;onPageDown&quot;</span>/&gt;</span><br><span class="line"><span class="comment">//处理函数只会在$event.key等于PageDown时才会被调用。</span></span><br></pre></td></tr></table></figure>
<h1 id="vue组件实例全体field约定"><a href="#vue组件实例全体field约定" class="headerlink" title="vue组件实例全体field约定"></a>vue组件实例全体field约定</h1><p>创建组件实例通过调用<code>Vue.createApp(&#123;&#125;)</code>方法来实现，通过给它添加<code>data/computed/watch/methods/lifecycle-hooks</code>这些field来描述他的数据和数据操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;)</span><br><span class="line"><span class="keyword">const</span> vm = app.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在JavaScript文件中定义的组件通过<code>const vm = app.mount(&#39;#app&#39;)</code>的mount方法挂载到对应的html中去。</p>
<p>Vue <strong>使用 <code>$</code> 前缀通过组件实例暴露自己的内置field</strong>。它还为内部 property 保留 <code>_</code> 前缀。</p>
<p>field中的所有return{}的内容都可以在挂载后的html中直接访问到，无需经过该field。</p>
<p>Vue中所有field内，<strong>this都指向当前组件实例</strong>。</p>
<h2 id="data-field约定"><a href="#data-field约定" class="headerlink" title="data field约定"></a>data field约定</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            property1: value1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>实例中的<code>data()</code>是一个function，每当新建一个实例，Vue就会调用这个函数。</p>
<p>我们需要<strong>保证所有需要用到的数据都在<code>data()</code>函数的<code>return&#123;&#125;</code>中，因为这些实例属性(instance properties)只会在instance第一次被创建的时候被Vue的响应式系统记录在<code>$data</code>对象中。</strong>如果存在一些属性你不知道他一开始要取何值，<strong>用<code>null</code> <code>undefined</code>占位</strong>。</p>
<p>访问/修改Vue实例中的data部分，可以通过两种形式的点访问法：<code>vm.$data.property1</code>或着<code>vm.property1</code>。</p>
<p>通过以上两个方式修改的vue实例的data部分都会同步到实例中去。而实例属性的变化会对应的渲染到视图UI中去，这属于响应式更新。</p>
<p>但是，只有Vue实例被创建时已经存在于数据对象中的属性才是响应式的。通过使用<code>Object.freeze(data)</code>会阻止修改data中已有的property，意味着响应系统无法再追踪变化。</p>
<h2 id="methods-field约定"><a href="#methods-field约定" class="headerlink" title="methods field约定"></a>methods field约定</h2><p>在Vue实例的<code>methods</code> field内部可以有多个方法，一般结合@[event]/@click之类的v-指令当作事件监听的回调函数使用。</p>
<p>如果method方法内部有用到任何data field中的响应式数据，那么<strong>method会自动把响应式数据作为渲染依赖项进行跟踪</strong>。</p>
<p>用<code>this</code>指向当前实例，因为Vue自动将<code>this</code>和当前实例绑定在了一起。<strong>注意不要使用箭头函数，默认情况下Vue的自动绑定this执行环境，但在箭头函数中没有指向该vue实例的this，但我们在methods中需要用到vue实例中的data function里面的数据，并且每一次使用vue实例中的数据都要在<code>this.variablename</code>。</strong></p>
<p><strong>method中的方法不应该包含异步操作？或者说不应该调用它？</strong>，异步操作应该出现在生命周期钩子中。</p>
<h2 id="computed-attribute-field约定"><a href="#computed-attribute-field约定" class="headerlink" title="computed attribute field约定"></a>computed attribute field约定</h2><p>我们<strong>使用Mustache Syntax的时候建议在花括号内仅存放简单表达式</strong>，如果花括号内的template syntax不再简明易懂，即复杂到<strong>包含了reactive data的情况下，需要使用计算属性</strong>。 </p>
<p>计算属性是Data和Methods这两个field之间的一个中间量。</p>
<p>把<strong>复杂表达式抽象成一个函数，在in-template expression中只使用这个函数名<code>&#123;&#123;complex-expression&#125;&#125;</code></strong>，在JS中添加如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.createApp(&#123; </span><br><span class="line">    computed: &#123;</span><br><span class="line">        <span class="comment">// a computed getter</span></span><br><span class="line">        <span class="comment">// no side effects</span></span><br><span class="line">        complex-expression()&#123;</span><br><span class="line">    	<span class="comment">// `this` points to vm instance</span></span><br><span class="line">    		<span class="keyword">return</span> <span class="built_in">this</span>.????</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="computed与method比较"><a href="#computed与method比较" class="headerlink" title="computed与method比较"></a>computed与method比较</h3><p>为什么这个函数放在<code>computed option</code>中而不是<code>methods option</code>中？</p>
<ul>
<li><p><strong>计算属性的值依赖于表达式中的reactive data。</strong></p>
<p>reactive data的变化会让该计算属性的值自动更新。</p>
<p>一方面，<strong>如果reactive data没有变化，那么计算属性会一直使用上一次计算过的缓存的值。</strong></p>
<p>另一方面，如果依赖的值不是reactive data，那么计算属性的值无论如何都不会改变。</p>
<blockquote>
<p>Computed properties are <strong>cached based on their reactive dependencies.</strong></p>
<p>计算属性的值是通过基本的、简单的属性值计算而来的，这些用于计算的属性值就是这里所说的reactive dependency。</p>
</blockquote>
</li>
<li><p><strong>如果将属性计算通过方法定义，就意味着每一次Vue实例的重新渲染都会导致函数（可能是不必要的）调用。</strong></p>
</li>
</ul>
<h3 id="getter-amp-setter"><a href="#getter-amp-setter" class="headerlink" title="getter &amp; setter"></a>getter &amp; setter</h3><p>在上面的例子中通过简单的计算return一个项目的时候，我们其实是在定义一个getter。在有必要时也可以提供一个setter，修改属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    get() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    set(newValue) &#123;</span><br><span class="line">      <span class="keyword">const</span> names = newValue.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="built_in">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="built_in">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在html中用mustache syntax访问fullName会调用get()，而在javascript中调用vm.fullname=’John Doe’时就会调用set()函数。</p>
<h2 id="watch-field"><a href="#watch-field" class="headerlink" title="watch field"></a>watch field</h2><p><strong>适用于执行数据变化的异步或开销较大的操作</strong>，需要谨慎使用。</p>
<p>对于数据改变所引起的其他数据的改变，选择使用计算属性而非侦听器。</p>
<p>在watch内部定义一个接受依赖数据项作为参数的函数，当这些依赖数据项发生改变的时候，该定义在watch内的函数就会运行。这个函数可以调用methods中定义的异步函数。</p>
<h2 id="emits-field自定义事件"><a href="#emits-field自定义事件" class="headerlink" title="emits field自定义事件"></a>emits field自定义事件</h2><p>详情见组件-emit实现自底向上数据流-利用emits field自定义事件。</p>
<h2 id="refs-field获得元素引用"><a href="#refs-field获得元素引用" class="headerlink" title="refs field获得元素引用"></a>refs field获得元素引用</h2><p>相当于DOM中的getElementByXX中获取html元素的方法。只需要在vue实例的template中为组件添加<code>&lt; ref=&quot;RefName&quot;/&gt;</code>属性，双引号中即为ref名。当我们在当前实例中需要获得这个元素的时候，只需要使用<code>this.$refs.RefName</code>就可以获得元素的引用并在该元素上添加方法。</p>
<p>例如，我们为表单的input添加一个名为InputRef，并且希望在当前页面挂载的时候自动聚焦到当前页面，那么在script的mounted field中需要使用<code>mounted() &#123;this.$refs.InputRef.focus();&#125;</code>让输入文本框自动聚焦。</p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>Since <strong>components are reusable instances</strong>, they <strong>accept the same options as a root instance, such as <code>data</code>, <code>computed</code>, <code>watch</code>, <code>methods</code>, and lifecycle hooks.</strong></p>
<p>在HTML文件中被当做可以被重复利用的用户自定义元素(custom element)。</p>
<h2 id="创建自定义组件的两种方式"><a href="#创建自定义组件的两种方式" class="headerlink" title="创建自定义组件的两种方式"></a>创建自定义组件的两种方式</h2><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;) <span class="comment">//根组件 root instance</span></span><br><span class="line"></span><br><span class="line">app.component(<span class="string">&#x27;component-name&#x27;</span>, &#123;&#125;)<span class="comment">//全局自定义组件，即root instance的custom element</span></span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">&#x27;#components-demo&#x27;</span>) <span class="comment">// 挂载root instance</span></span><br></pre></td></tr></table></figure>
<p>这样子的调用默认是<strong>全局注册的组件</strong>(根实例的子实例)，<strong>可以被根实例中的template和根实例中的所有其他子组件使用。</strong></p>
<p>挂载后的root instance通过id绑定到html中去，在root instance的内部，可以像一个自定义组件custom element一样去使用用<code>.component(&#39;&#39;,&#123;&#125;)</code>定义的全局注册的组件，自定义的html标签就是传入component的第一个字符串。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>全局注册往往是不够有效率的，因为全局注册的组件意味着就算它不再被使用，它仍然会被包含在最终的构建结果中，这会造成用户下载多余的JavaScript代码。</p>
<p>可以通过一个JavaScript对象来定义组件，并在父组件的components field中用绑定使用。任何一个组件想要使用另外一个局部注册的、通过对象定义的组件，都需要把它绑定到components field中后才可以访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ComponentA = &#123;&#125;</span><br><span class="line"><span class="comment">// 在根组件中绑定局部注册的组件</span></span><br><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        <span class="string">&#x27;component-a&#x27;</span>: ComponentA</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在其他局部注册的子组件中绑定另一个局部注册的子组件</span></span><br><span class="line"><span class="keyword">const</span> ComponentB = &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        <span class="string">&#x27;component-a&#x27;</span>: ComponentA</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用了ES6-Babel-webpack等模块系统中的局部注册"><a href="#使用了ES6-Babel-webpack等模块系统中的局部注册" class="headerlink" title="使用了ES6/Babel/webpack等模块系统中的局部注册"></a>使用了ES6/Babel/webpack等模块系统中的局部注册</h4><p>建议把所有局部注册的组件都放置在components目录中，如果组件A的定义需要使用到同层级的组件B和组件C，需要在局部注册组件A之前导入同级别文件夹下的组件B和组件C，过程如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// current file is ComponentA.vue or ComponentA.js</span></span><br><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">&#x27;./ComponentB&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ComponentC <span class="keyword">from</span> <span class="string">&#x27;./ComponentC&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentB,</span><br><span class="line">    ComponentC</span><br><span class="line">    <span class="comment">// 注意以上写法其实是ComponentB: ComponentB的缩写</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义组件名的两种方式"><a href="#自定义组件名的两种方式" class="headerlink" title="自定义组件名的两种方式"></a>自定义组件名的两种方式</h2><h3 id="kebab-case"><a href="#kebab-case" class="headerlink" title="kebab-case"></a>kebab-case</h3><p>第一种是kebab-case，遵循W3C规范，即字母全部小写且必须包含连字符，如<code>&lt;my-component-name&gt;</code>。</p>
<h3 id="PascalCase"><a href="#PascalCase" class="headerlink" title="PascalCase"></a>PascalCase</h3><p>第二种是PascalCase，即首字母大写命名组件，如<code>&lt;MyComponentName&gt;</code>。</p>
<p><strong>直接在dom中使用自定义组件时（即非字符串的模版），只有kebab-case有效。</strong></p>
<h2 id="非prop的attribute"><a href="#非prop的attribute" class="headerlink" title="非prop的attribute"></a>非prop的attribute</h2><p>这里所说的非prop的attribute，就是那些在定义vue组件时，没有在props field和emits field中定义的attribute；也可以说是html标签自带的诸如<code>class/style/id</code>之类的属性。</p>
<h3 id="如何访问"><a href="#如何访问" class="headerlink" title="如何访问"></a>如何访问</h3><p>如何访问这些非prop的attribute？在vue组件内部调用<code>this.$attr</code>就可以访问。</p>
<h3 id="root-element的attribute-inheritance"><a href="#root-element的attribute-inheritance" class="headerlink" title="root element的attribute inheritance"></a>root element的attribute inheritance</h3><p>在js文件中定义组件时返回的是<strong>单个根节点</strong>时，在html文件中调用vue组件时定义的<strong>非prop的attribute将在vue的渲染结果中自动添加到根节点去</strong>。</p>
<p>以下是在js文件中定义组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;date-picker&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;date-picker&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;input type=&quot;datetime&quot; /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以下是在html文件中调用组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">date-picker</span> <span class="attr">data-status</span>=<span class="string">&quot;activated&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">date-picker</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以下是vue经过一系列操作的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;date-picker&quot; data-status&#x3D;&quot;activated&quot;&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;datetime&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>如果有单个根节点，绑定的非prop的attribute自动添加到渲染后的html的根节点。</p>
<p>如果有vue组件返回多个根元素，必须在定义vue组件时显式地在某个根元素上<code>v-bind: &quot;$attrs&quot;</code>。否则会有runtime warning。</p>
<h3 id="禁用attribute-inheritance"><a href="#禁用attribute-inheritance" class="headerlink" title="禁用attribute inheritance"></a>禁用attribute inheritance</h3><p>如果不希望根元素自动属性继承，需要在定义vue组件时<code>inheritAttrs：false</code>。</p>
<p>在禁用根元素的元素继承的同时，我们又希望根元素内的其他元素去继承这个非prop的attribute，如何控制？需要使用v-bind方法和当前组件的<code>$attr</code>属性，这个属性会自动包括除了vue组件内部定义的<code>prop</code> field和<code>emits</code> field内的所有属性。</p>
<p>以上两个操作都是在vue组件所在js文件中完成的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;date-picker&#x27;</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;date-picker&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;input type=&quot;datetime&quot; v-bind=&quot;$attrs&quot; /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="props实现自顶向下的数据流"><a href="#props实现自顶向下的数据流" class="headerlink" title="props实现自顶向下的数据流"></a>props实现自顶向下的数据流</h2><blockquote>
<p><strong>Props are custom attributes you can register on a component.</strong> When a value is passed to a prop attribute, it becomes a property on that component instance. </p>
</blockquote>
<p>怎么解释props的出现？就比如html的a标签有src属性，这里自定义的组件使用方式也就是html的某种标签，既然是<strong>用户自定义元素，那么应当也有用户自定义元素属性。</strong>props定义了这个自定义元素有什么属性，通过给这个属性传值，将数据从View/UI/html传递到Model/data/JavaScript。</p>
<h3 id="用字符串数组定义prop"><a href="#用字符串数组定义prop" class="headerlink" title="用字符串数组定义prop"></a>用字符串数组定义prop</h3><p>在定义组件的时候直接引入一个<code>props: []</code>选项即可。如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;)</span><br><span class="line">app.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">  template: <span class="string">`&lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line">app.mount(<span class="string">&#x27;#blog-post-demo&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在html中的使用遵循如下形式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;blog-post-demo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--首先要把自定义组件包裹在mount id下的对应根组件中--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;My journey with Vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自定义组件的props可以当作元素标签的attribute使用--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;Blogging with Vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;Why Vue is so fun&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>当然，这些数据最好和View/UI/html分开存放比较好，根组件的data field可以用来存放这些数据。</p>
<p>因此，整个过程就变成了：首先，在JavaScript中定义根组件和子组件的各个field；其次，在HTML中调用JS文件中定义组件，通过已有html tag的id/class属性或者自定义的custom element attribute绑定数据，数据来自于JavaScript文件的根实例。</p>
<hr>
<h3 id="用对象列出prop"><a href="#用对象列出prop" class="headerlink" title="用对象列出prop"></a>用对象列出prop</h3><p>通常会为每个prop都指定取值类型，对象中的每一个名称和值分别时prop各自的名称和类型，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span>,</span><br><span class="line">  isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">  commentIds: <span class="built_in">Array</span>,</span><br><span class="line">  author: <span class="built_in">Object</span>,</span><br><span class="line">  callback: <span class="built_in">Function</span>,</span><br><span class="line">  contactsPromise: <span class="built_in">Promise</span> <span class="comment">// 或任何其他构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想把一个对象的所有property都当作prop传入，使用不带参数的v-bind取代v-bind:prop-name即可，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post: &#123; <span class="comment">//这个对象的所有property都要传入</span></span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  title: <span class="string">&#x27;My Journey with Vue&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在html中调用如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个表达式就等价于：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;post.id&quot;</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;post.title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="prop验证"><a href="#prop验证" class="headerlink" title="prop验证"></a>prop验证</h3><p>为组件的prop指定验证的要求，比如说基础的类型检查（包括String/Number/Boolean/Array/Object/Date/Function/Symbol基本类型，以及自定义的构造函数），是否有必填的字符串，是否带默认值，自定义验证函数等功能。验证内容都是对当前prop的描述，也就是一种元数据的概念（描述数据的数据）。</p>
<p>前面提到的用对象列出prop，提供了最简单的prop类型检查，如果在props field中定义的prop名称后面跟一个花括号包裹的对象，就能实现prop验证。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 </span></span><br><span class="line">    <span class="comment">// (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;success&#x27;</span>, <span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;danger&#x27;</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意prop的验证会在组件实例创建之前进行，因此实例的data/computed等field中涉及的变量在prop验证中不能使用。</p>
<h3 id="prop书写约定"><a href="#prop书写约定" class="headerlink" title="prop书写约定"></a>prop书写约定</h3><p>因为在HTML中attribute名是大小写不敏感的，因此浏览器会把所有大写字符全部解释为小写字符，因此在JavaScript中使用的camelCase应用到HTML中就变成对应的kabab-case。</p>
<h3 id="父子组件prop的单向下行绑定"><a href="#父子组件prop的单向下行绑定" class="headerlink" title="父子组件prop的单向下行绑定"></a>父子组件prop的单向下行绑定</h3><p>这里的单项数据流是从父组件的prop流动到子组件的prop，也就是说：<strong>父级prop的更新会向下流动到子组件中</strong>，每一次父组件发生变更时，子组件的所有prop都会刷新为最新的值；<strong>子组件不应该变更父组件的状态</strong>。</p>
<blockquote>
<p>虽然子组件不应该变更父组件的状态，但也是可以实现改变的，因为JavaScript的对象和数组是通过引用传入的。</p>
<p>如果在子组件上变更对象或数组定义的prop本身，父组件的状态就会被改变，Vue也会在控制台发出警告。</p>
</blockquote>
<p>当尝试在一个子组件内部改变prop时，不要直接对props field中的原始prop进行变更，因为这个prop时从父组件中传递过来的，或者是从View/UI/html中传递过来的。</p>
<p>当需要直接利用prop中的数据时，正确的做法是在当前组件的data field中定义一个新的data property（用react中的说法也就是当前state），并用this.prop作为它的初始值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;initialCounter&#x27;</span>],</span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="built_in">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要经过某些计算再利用prop中的数据时，正确的做法是在当前组件的computed field中定义一个新的computed property，并用this.prop经过一系列的运算后返回想要的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;size&#x27;</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="emit实现自底向上的数据流"><a href="#emit实现自底向上的数据流" class="headerlink" title="emit实现自底向上的数据流"></a>emit实现自底向上的数据流</h2><h3 id="事件名称约定"><a href="#事件名称约定" class="headerlink" title="事件名称约定"></a>事件名称约定</h3><p>不像components和props会自动在各种书写方式之间自动转换，事件名称在js文件中被emit的时候的名称必须和在html文件中被监听的名称一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my-compoennt.vue</span></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;my-event&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">my-event</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果定义的时候使用camelCase/PascalCase，在监听的时候却又使用kebab-case，是不会有效果的。</p>
<p>所以总是<strong>建议使用kebab-case来定义事件名称</strong>。</p>
<h3 id="emit作用"><a href="#emit作用" class="headerlink" title="emit作用"></a>emit作用</h3><p>emit的作用是什么？</p>
<p>在子组件上通过emit定义一个事件/注册一个事件，如果父组件/父亲页面的.vue文件中的该子组件被点击了，就可以监听该事件，然后调用event handler，并且事件处理函数可以使用父亲页面/父亲组件中的数据去处理子组件上的事件。</p>
<p>比如，html中button这个元素本身就有click事件，我们直接使用了button这个元素和click这个事件。按照vue的思考方式，在button这个组件内部定义好了button本身以及click事件。因此我们才可以在html中使用这个元素并且监听这个事件。</p>
<p>总结：emit能够在组件上自定义事件供父组件监听发生在该组件上的行为并添加回调函数，虽然组件上的自定义事件很有可能也是通过默认事件如click触发，但是emit可以放在method中中供其他method调用，比如用户点击了某个组件就出发一个窗口消失的emit事件，或用户完成登陆之后在method中自动emit一个窗口消失的事件。</p>
<h3 id="实现emit"><a href="#实现emit" class="headerlink" title="实现emit"></a>实现emit</h3><p>某个子组件与用户发生了某种交互，或者说用户给子组件传递了某些值，子组件此时需要emit an event on itself by calling the built-in <code>$emit</code> method, passing the name of the event，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;)&quot;</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然也可以把$emit(‘enlarge-text’)抽象到methods中的某个函数去，当调用这个函数的时候就有这个事件，而不必须发生click。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  close() &#123;</span><br><span class="line">    <span class="built_in">this</span>.$emit(<span class="string">&quot;enlarge-text&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而父组件可以通过v-on或者@标志来监听子组件上的任何事件，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">...</span> @<span class="attr">enlarge-text</span>=<span class="string">&quot;postFontSize += 0.1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">...</span> @<span class="attr">enlarge-text</span>=<span class="string">&quot;onEnlargeText&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>事件发生在子组件上，但是这个事件通过v-on/@标志被传递到了父组件上，且回调函数却是由父组件定义的，或者可以直接用methods field中定义的函数。</p>
<hr>
<p>在定义子组件的时候提供emits选项，方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">  emits: [<span class="string">&#x27;enlarge-text&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="emit-an-event’s-value"><a href="#emit-an-event’s-value" class="headerlink" title="emit an event’s value"></a>emit an event’s value</h3><p>有时候需要在子组件中emit一个定义在父组件上的事件，并向父组件传递一个参数，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;, 0.1)&quot;</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在父组件中，可以通过<code>$event</code>访问到这个event value。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">...</span> @<span class="attr">enlarge-text</span>=<span class="string">&quot;postFontSize += $event&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="利用emits-field自定义事件"><a href="#利用emits-field自定义事件" class="headerlink" title="利用emits field自定义事件"></a>利用emits field自定义事件</h3><p>在定义组件的时候在<code>emits</code> field中用数组或者对象的形式定义custom events，只要出现在emits field中，就是自定义事件。custom event会覆盖native event。</p>
<p>建议所有的emitted event都定义在emits field中。</p>
<h4 id="array-syntax-not-recommended"><a href="#array-syntax-not-recommended" class="headerlink" title="array syntax(not recommended)"></a>array syntax(not recommended)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;custom-form&#x27;</span>, &#123;</span><br><span class="line">  emits: [<span class="string">&#x27;in-focus&#x27;</span>, <span class="string">&#x27;submit&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="obejct-syntax-to-validate"><a href="#obejct-syntax-to-validate" class="headerlink" title="obejct syntax to validate"></a>obejct syntax to validate</h4><p>通过数组array syntax定义的事件不能被validate，因此建议使用对象object syntax。</p>
<p>event name在object中就变成了key，对应value是一个验证函数，该函数接受传递给$emit call的payload作为参数，对参数进行操作后返回boolean值去验证这个事件是有效还是无效的。如果不希望event有验证，直接讲key对应value取null。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;custom-form&#x27;</span>, &#123;</span><br><span class="line">  emits: &#123;</span><br><span class="line">    <span class="comment">// No validation</span></span><br><span class="line">    click: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate submit event</span></span><br><span class="line">    submit: <span class="function">(<span class="params">&#123; email, password &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (email &amp;&amp; password) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;Invalid submit event payload!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    submitForm() &#123;</span><br><span class="line">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;submit&#x27;</span>, &#123; email, password &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="插槽slots"><a href="#插槽slots" class="headerlink" title="插槽slots"></a>插槽slots</h1><p>插槽就是在js文件中定义vue组件的template field中插入的一个标志元素，形如<code>&lt;slot&gt;&lt;/slot&gt;</code>。当在html文件中调用该vue组件时，直接在vue组件开闭合标签内添加想要插入的内容，该内容就会替代原js template中的插槽。</p>
<blockquote>
<p>注意如果希望不是用插槽，那么调用vue组件的开闭合标签内不能有任何文字，甚至是comment也不行。</p>
</blockquote>
<p>插槽也能够在指定渲染域中访问数据，该渲染域是和它在同一DOM树层级的兄弟节点，也就是说插槽不能访问父亲节点中的数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">todo-button</span> <span class="attr">action</span>=<span class="string">&quot;delete&quot;</span>&gt;</span></span><br><span class="line">  Clicking here will &#123;&#123; action &#125;&#125; an item</span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  The `action` will be undefined, because this content is passed</span></span><br><span class="line"><span class="comment">  _to_ &lt;todo-button&gt;, rather than defined _inside_ the</span></span><br><span class="line"><span class="comment">  &lt;todo-button&gt; component.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">todo-button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之前讨论的插槽标签之间都是空内容的，有时候为一个插槽提供后备内容fallback content也很有用，该内容会在html文件调用该组件没有传入内容时被渲染。<code>&lt;slot&gt;Submit&lt;/slot&gt;</code>这个时候Submit就是后备内容。</p>
<p>当需要多个插槽的时候，需要在js文件中定义组件时给每一个插槽一个name attribute，形如<code>&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</code>，一个不带有name的插槽隐含的名字就是<code>default</code>。</p>
<p>为了在html文件中调用该组件并为特定的插槽提供特定的内容，将想要提供的内容包裹在<code>&lt;template&gt;</code>元素中。给该<code>&lt;template&gt;</code>元素一个<code>v-slot:header</code>指令，冒号后面就是name attribute的取值；或者直接在#hash符号后面跟上插槽的名字。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="teleport"><a href="#teleport" class="headerlink" title="teleport"></a>teleport</h1><p>teleport用于解决逻辑与视图不一致的情况。比如在当前组件中存在一个子组件，虽然该子组件的数据逻辑归属于当前组件，但是UI视图并不从属于当前视图。那么就需要在当前组件的template中将该子组件用<code>&lt;teleport&gt;</code> 标签包裹，并在<code>&lt;teleport to=&quot;&quot;&gt;</code>中选择html元素，指定该子组件在DOM树中的位置。</p>
<p>比如网站首页点击登陆之后会弹出登陆信息框，虽然登陆的信息由首页的导航栏维护，但是在视图层面并不属于导航栏这个vue实例，而是属于body元素的子元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;AppHeader :isLoggedIn&#x3D;&quot;isLoggedIn&quot; @open-login-model&#x3D;&quot;isLoginOpen &#x3D; true&quot; &#x2F;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;w-full flex&quot;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;teleport to&#x3D;&quot;body&quot;&gt;</span><br><span class="line">    &lt;LoginModel v-if&#x3D;&quot;isLoginOpen&quot; @close-login&#x3D;&quot;isLoginOpen &#x3D; false&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;teleport&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h1>
        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：如何使用Vue框架的记录</li>
        <li>本文作者：徐徐</li>
        <li>创建时间：2020-10-17 20:55:16</li>
        <li>
            本文链接：https://drunk99.xyz/2020/10/17/learn-vue/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2020/10/19/html-revision/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">HTML基础知识</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2020/10/16/css-tips/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">CSS基础知识</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'aqAOPQAx86speqYXI4gPuLWx-gzGzoHsz',
                    appKey: '8fzaXFq8Ikhr5mucbhj3qqUS',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '来一起讨论吧～',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = '徐徐';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020-2021</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">徐徐</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.2</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAVue%E5%BA%94%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">创建Vue应用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#template-syntax"><span class="nav-number">2.</span> <span class="nav-text">template syntax</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="nav-number">3.</span> <span class="nav-text">生命周期钩子</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#v-directives%E6%8C%87%E5%AE%9A%E7%BA%A6%E5%AE%9A"><span class="nav-number">4.</span> <span class="nav-text">v- directives指定约定</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#v-bind"><span class="nav-number">4.1.</span> <span class="nav-text">v-bind:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%80%BC%E7%9A%84%E7%BB%91%E5%AE%9A"><span class="nav-number">4.1.1.</span> <span class="nav-text">实现值的绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%B1%9E%E6%80%A7%E7%9A%84%E7%BB%91%E5%AE%9A"><span class="nav-number">4.1.2.</span> <span class="nav-text">实现属性的绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%91%E5%AE%9Ahtml-class"><span class="nav-number">4.1.3.</span> <span class="nav-text">绑定html class</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1true-false%E5%88%87%E6%8D%A2class"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">通过对象true&#x2F;false切换class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84%E5%80%BC%E5%BA%94%E7%94%A8%E5%A4%9A%E4%B8%AAclass"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">通过数组值应用多个class</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%91%E5%AE%9Ahtml-style"><span class="nav-number">4.1.4.</span> <span class="nav-text">绑定html style</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-model%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="nav-number">4.2.</span> <span class="nav-text">v-model表单输入双向绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#v-bind%E5%92%8Cv-model%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.</span> <span class="nav-text">v-bind和v-model的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-model%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="nav-number">4.2.2.</span> <span class="nav-text">v-model的具体使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8v-model%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">4.2.3.</span> <span class="nav-text">使用v-model修饰符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-once%E4%B8%80%E6%AC%A1%E6%80%A7%E6%B8%B2%E6%9F%93DOM"><span class="nav-number">4.3.</span> <span class="nav-text">v-once一次性渲染DOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-html%E5%9C%A8template%E4%B8%AD%E6%8F%92%E5%85%A5html%E4%BB%A3%E7%A0%81"><span class="nav-number">4.4.</span> <span class="nav-text">v-html在template中插入html代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-if-v-else-if-v-else%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="nav-number">4.5.</span> <span class="nav-text">v-if v-else-if v-else条件渲染</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-showCSS%E5%88%87%E6%8D%A2"><span class="nav-number">4.6.</span> <span class="nav-text">v-showCSS切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-for%E5%A4%9A%E9%80%89%E7%B4%A0%E6%B8%B2%E6%9F%93"><span class="nav-number">4.7.</span> <span class="nav-text">v-for多选素渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6modifiers"><span class="nav-number">4.7.1.</span> <span class="nav-text">修饰符modifiers</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-on%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="nav-number">4.8.</span> <span class="nav-text">v-on事件监听</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#v-on%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">4.8.1.</span> <span class="nav-text">v-on修饰符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vue%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E5%85%A8%E4%BD%93field%E7%BA%A6%E5%AE%9A"><span class="nav-number">5.</span> <span class="nav-text">vue组件实例全体field约定</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#data-field%E7%BA%A6%E5%AE%9A"><span class="nav-number">5.1.</span> <span class="nav-text">data field约定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#methods-field%E7%BA%A6%E5%AE%9A"><span class="nav-number">5.2.</span> <span class="nav-text">methods field约定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#computed-attribute-field%E7%BA%A6%E5%AE%9A"><span class="nav-number">5.3.</span> <span class="nav-text">computed attribute field约定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#computed%E4%B8%8Emethod%E6%AF%94%E8%BE%83"><span class="nav-number">5.3.1.</span> <span class="nav-text">computed与method比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getter-amp-setter"><span class="nav-number">5.3.2.</span> <span class="nav-text">getter &amp; setter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#watch-field"><span class="nav-number">5.4.</span> <span class="nav-text">watch field</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#emits-field%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="nav-number">5.5.</span> <span class="nav-text">emits field自定义事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#refs-field%E8%8E%B7%E5%BE%97%E5%85%83%E7%B4%A0%E5%BC%95%E7%94%A8"><span class="nav-number">5.6.</span> <span class="nav-text">refs field获得元素引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6"><span class="nav-number">6.</span> <span class="nav-text">组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">6.1.</span> <span class="nav-text">创建自定义组件的两种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C"><span class="nav-number">6.1.1.</span> <span class="nav-text">全局注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C"><span class="nav-number">6.1.2.</span> <span class="nav-text">局部注册</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%86ES6-Babel-webpack%E7%AD%89%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">使用了ES6&#x2F;Babel&#x2F;webpack等模块系统中的局部注册</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E5%90%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">自定义组件名的两种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kebab-case"><span class="nav-number">6.2.1.</span> <span class="nav-text">kebab-case</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PascalCase"><span class="nav-number">6.2.2.</span> <span class="nav-text">PascalCase</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9Eprop%E7%9A%84attribute"><span class="nav-number">6.3.</span> <span class="nav-text">非prop的attribute</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE"><span class="nav-number">6.3.1.</span> <span class="nav-text">如何访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#root-element%E7%9A%84attribute-inheritance"><span class="nav-number">6.3.2.</span> <span class="nav-text">root element的attribute inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A6%81%E7%94%A8attribute-inheritance"><span class="nav-number">6.3.3.</span> <span class="nav-text">禁用attribute inheritance</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#props%E5%AE%9E%E7%8E%B0%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">6.4.</span> <span class="nav-text">props实现自顶向下的数据流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89prop"><span class="nav-number">6.4.1.</span> <span class="nav-text">用字符串数组定义prop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%88%97%E5%87%BAprop"><span class="nav-number">6.4.2.</span> <span class="nav-text">用对象列出prop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#prop%E9%AA%8C%E8%AF%81"><span class="nav-number">6.4.3.</span> <span class="nav-text">prop验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#prop%E4%B9%A6%E5%86%99%E7%BA%A6%E5%AE%9A"><span class="nav-number">6.4.4.</span> <span class="nav-text">prop书写约定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6prop%E7%9A%84%E5%8D%95%E5%90%91%E4%B8%8B%E8%A1%8C%E7%BB%91%E5%AE%9A"><span class="nav-number">6.4.5.</span> <span class="nav-text">父子组件prop的单向下行绑定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#emit%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">6.5.</span> <span class="nav-text">emit实现自底向上的数据流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%90%8D%E7%A7%B0%E7%BA%A6%E5%AE%9A"><span class="nav-number">6.5.1.</span> <span class="nav-text">事件名称约定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#emit%E4%BD%9C%E7%94%A8"><span class="nav-number">6.5.2.</span> <span class="nav-text">emit作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0emit"><span class="nav-number">6.5.3.</span> <span class="nav-text">实现emit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#emit-an-event%E2%80%99s-value"><span class="nav-number">6.5.4.</span> <span class="nav-text">emit an event’s value</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8emits-field%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="nav-number">6.5.5.</span> <span class="nav-text">利用emits field自定义事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#array-syntax-not-recommended"><span class="nav-number">6.5.5.1.</span> <span class="nav-text">array syntax(not recommended)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#obejct-syntax-to-validate"><span class="nav-number">6.5.5.2.</span> <span class="nav-text">obejct syntax to validate</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%92%E6%A7%BDslots"><span class="nav-number">7.</span> <span class="nav-text">插槽slots</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#teleport"><span class="nav-number">8.</span> <span class="nav-text">teleport</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Composition-API"><span class="nav-number">9.</span> <span class="nav-text">Composition API</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/code-copy.js"></script>




<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        const pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
